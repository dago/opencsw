To: vim-dev@vim.org
Subject: patch 7.1.001
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.001
Problem:    Still can't build with Gnome libraries.
Solution:   Fix typo in bind_textdomain_codeset. (Mike Kelly)
Files:	    src/gui_gtk.c, src/gui_gtk_x11.c


*** ../vim-7.1.000/src/gui_gtk.c	Thu May 10 20:27:29 2007
--- src/gui_gtk.c	Mon May 14 14:40:54 2007
***************
*** 53,60 ****
  # ifdef bindtextdomain
  #  undef bindtextdomain
  # endif
! # ifdef bindtextdomain_codeset
! #  undef bindtextdomain_codeset
  # endif
  # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
  #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
--- 53,60 ----
  # ifdef bindtextdomain
  #  undef bindtextdomain
  # endif
! # ifdef bind_textdomain_codeset
! #  undef bind_textdomain_codeset
  # endif
  # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
  #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
*** ../vim-7.1.000/src/gui_gtk_x11.c	Thu May 10 21:17:51 2007
--- src/gui_gtk_x11.c	Mon May 14 14:41:06 2007
***************
*** 36,43 ****
  # ifdef bindtextdomain
  #  undef bindtextdomain
  # endif
! # ifdef bindtextdomain_codeset
! #  undef bindtextdomain_codeset
  # endif
  # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
  #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
--- 36,43 ----
  # ifdef bindtextdomain
  #  undef bindtextdomain
  # endif
! # ifdef bind_textdomain_codeset
! #  undef bind_textdomain_codeset
  # endif
  # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
  #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
*** ../vim-7.1.000/src/version.c	Sat May 12 16:34:15 2007
--- src/version.c	Mon May 14 14:42:19 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     1,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
127. You bring your laptop and cellular phone to church.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.002
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.002
Problem:    Oracle Pro*C/C++ files are not detected.
Solution:   Add the missing star. (Micah J. Cowan)
Files:	    runtime/filetype.vim


*** ../vim-7.1.001/runtime/filetype.vim	Thu May 10 20:42:30 2007
--- runtime/filetype.vim	Tue May 15 09:12:06 2007
***************
*** 1,7 ****
  " Vim support file to detect file types
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2007 May 10
  
  " Listen very carefully, I will say this only once
  if exists("did_load_filetypes")
--- 1,7 ----
  " Vim support file to detect file types
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2007 May 15
  
  " Listen very carefully, I will say this only once
  if exists("did_load_filetypes")
***************
*** 1286,1292 ****
  au BufNewFile,BufRead *.it,*.ih			setf ppwiz
  
  " Oracle Pro*C/C++
! au BufNewFile,BufRead .pc			setf proc
  
  " Privoxy actions file
  au BufNewFile,BufRead *.action			setf privoxy
--- 1286,1292 ----
  au BufNewFile,BufRead *.it,*.ih			setf ppwiz
  
  " Oracle Pro*C/C++
! au BufNewFile,BufRead *.pc			setf proc
  
  " Privoxy actions file
  au BufNewFile,BufRead *.action			setf privoxy
*** ../vim-7.1.001/src/version.c	Mon May 14 19:35:51 2007
--- src/version.c	Tue May 15 09:13:11 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     2,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
132. You come back and check this list every half-hour.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.003 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.003 (extra)
Problem:    The "Tear off this menu" message appears in the message history
	    when using a menu. (Yongwei Wu)
Solution:   Disable message history when displaying the menu tip.
Files:	    src/gui_w32.c


*** ../vim-7.1.002/src/gui_w32.c	Thu May 10 22:17:22 2007
--- src/gui_w32.c	Sat Jun  9 13:43:07 2007
***************
*** 1051,1057 ****
--- 1051,1059 ----
  	    if (pMenu != NULL && pMenu->strings[MENU_INDEX_TIP] != 0
  		    && GetMenuState(s_menuBar, pMenu->id, MF_BYCOMMAND) != -1)
  	    {
+ 		++msg_hist_off;
  		msg(pMenu->strings[MENU_INDEX_TIP]);
+ 		--msg_hist_off;
  		setcursor();
  		out_flush();
  		did_menu_tip = TRUE;
*** ../vim-7.1.002/src/version.c	Tue May 15 09:14:33 2007
--- src/version.c	Tue Jun 19 10:08:17 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     3,
  /**/

-- 
In his lifetime van Gogh painted 486 oil paintings. Oddly enough, 8975
of them are to be found in the United States.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.004
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.004
Problem:    Crash when doing ":next directory". (Raphael Finkel)
Solution:   Do not use "buf", it may be invalid after autocommands.
Files:	    src/ex_cmds.c


*** ../vim-7.1.003/src/ex_cmds.c	Thu May 10 21:24:24 2007
--- src/ex_cmds.c	Mon Jun 18 22:03:56 2007
***************
*** 3367,3373 ****
  		 * was in this window (or another window).  If not used
  		 * before, reset the local window options to the global
  		 * values.  Also restores old folding stuff. */
! 		get_winopts(buf);
  #ifdef FEAT_SPELL
  		did_get_winopts = TRUE;
  #endif
--- 3367,3373 ----
  		 * was in this window (or another window).  If not used
  		 * before, reset the local window options to the global
  		 * values.  Also restores old folding stuff. */
! 		get_winopts(curbuf);
  #ifdef FEAT_SPELL
  		did_get_winopts = TRUE;
  #endif
***************
*** 3649,3656 ****
  #ifdef FEAT_SPELL
      /* If the window options were changed may need to set the spell language.
       * Can only do this after the buffer has been properly setup. */
!     if (did_get_winopts && curwin->w_p_spell && *buf->b_p_spl != NUL)
! 	did_set_spelllang(buf);
  #endif
  
      if (command == NULL)
--- 3649,3656 ----
  #ifdef FEAT_SPELL
      /* If the window options were changed may need to set the spell language.
       * Can only do this after the buffer has been properly setup. */
!     if (did_get_winopts && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
! 	did_set_spelllang(curbuf);
  #endif
  
      if (command == NULL)
*** ../vim-7.1.003/src/version.c	Tue Jun 19 10:09:15 2007
--- src/version.c	Tue Jun 19 11:53:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     4,
  /**/

-- 
FIRST HEAD:  Oh! quick! get the sword out I want to cut his head off.
THIRD HEAD:  Oh, cut your own head off.
SECOND HEAD: Yes - do us all a favour.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.005
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.005
Problem:    "cit" used on <foo></foo> deletes <foo>.  Should not delete
	    anything and start insertion, like "ci'" does on "". (Michal
	    Bozon)
Solution:   Handle an empty object specifically.  Made it work consistent for
	    various text objects.
Files:	    src/search.c


*** ../vim-7.1.004/src/search.c	Thu May 10 20:54:46 2007
--- src/search.c	Mon Jun  4 12:31:04 2007
***************
*** 3600,3612 ****
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
  	if (sol)
- 	{
  	    incl(&curwin->w_cursor);
! 	    oap->inclusive = FALSE;
! 	}
! 	else
  	    oap->inclusive = TRUE;
      }
  
      return OK;
--- 3600,3615 ----
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
+ 	oap->inclusive = FALSE;
  	if (sol)
  	    incl(&curwin->w_cursor);
! 	else if (lt(start_pos, curwin->w_cursor))
! 	    /* Include the character under the cursor. */
  	    oap->inclusive = TRUE;
+ 	else
+ 	    /* End is before the start (no text in between <>, [], etc.): don't
+ 	     * operate on any text. */
+ 	    curwin->w_cursor = start_pos;
      }
  
      return OK;
***************
*** 3734,3740 ****
  
  	if (in_html_tag(FALSE))
  	{
! 	    /* cursor on start tag, move to just after it */
  	    while (*ml_get_cursor() != '>')
  		if (inc_cursor() < 0)
  		    break;
--- 3737,3743 ----
  
  	if (in_html_tag(FALSE))
  	{
! 	    /* cursor on start tag, move to its '>' */
  	    while (*ml_get_cursor() != '>')
  		if (inc_cursor() < 0)
  		    break;
***************
*** 3838,3844 ****
  	/* Exclude the start tag. */
  	curwin->w_cursor = start_pos;
  	while (inc_cursor() >= 0)
! 	    if (*ml_get_cursor() == '>' && lt(curwin->w_cursor, end_pos))
  	    {
  		inc_cursor();
  		start_pos = curwin->w_cursor;
--- 3841,3847 ----
  	/* Exclude the start tag. */
  	curwin->w_cursor = start_pos;
  	while (inc_cursor() >= 0)
! 	    if (*ml_get_cursor() == '>')
  	    {
  		inc_cursor();
  		start_pos = curwin->w_cursor;
***************
*** 3860,3866 ****
  #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
! 	if (*p_sel == 'e')
  	    ++curwin->w_cursor.col;
  	VIsual = start_pos;
  	VIsual_mode = 'v';
--- 3863,3873 ----
  #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
! 	/* If the end is before the start there is no text between tags, select
! 	 * the char under the cursor. */
! 	if (lt(end_pos, start_pos))
! 	    curwin->w_cursor = start_pos;
! 	else if (*p_sel == 'e')
  	    ++curwin->w_cursor.col;
  	VIsual = start_pos;
  	VIsual_mode = 'v';
***************
*** 3872,3878 ****
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
! 	oap->inclusive = TRUE;
      }
      retval = OK;
  
--- 3879,3893 ----
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
! 	if (lt(end_pos, start_pos))
! 	{
! 	    /* End is before the start: there is no text between tags; operate
! 	     * on an empty area. */
! 	    curwin->w_cursor = start_pos;
! 	    oap->inclusive = FALSE;
! 	}
! 	else
! 	    oap->inclusive = TRUE;
      }
      retval = OK;
  
*** ../vim-7.1.004/src/version.c	Tue Jun 19 11:54:23 2007
--- src/version.c	Tue Jun 19 12:57:03 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     5,
  /**/

-- 
Life would be so much easier if we could just look at the source code.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.006
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.006
Problem:    Resetting 'modified' in a StdinReadPost autocommand doesn't work.
Solution:   Set 'modified' before the autocommands instead of after it.
Files:	    src/buffer.c


*** ../vim-7.1.005/src/buffer.c	Thu May 10 18:43:46 2007
--- src/buffer.c	Fri Jun  8 20:59:04 2007
***************
*** 171,176 ****
--- 171,183 ----
  	    /* Put the cursor on the first line. */
  	    curwin->w_cursor.lnum = 1;
  	    curwin->w_cursor.col = 0;
+ 
+ 	    /* Set or reset 'modified' before executing autocommands, so that
+ 	     * it can be changed there. */
+ 	    if (!readonlymode && !bufempty())
+ 		changed();
+ 	    else if (retval != FAIL)
+ 		unchanged(curbuf, FALSE);
  #ifdef FEAT_AUTOCMD
  # ifdef FEAT_EVAL
  	    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,
***************
*** 194,209 ****
      /* When reading stdin, the buffer contents always needs writing, so set
       * the changed flag.  Unless in readonly mode: "ls | gview -".
       * When interrupted and 'cpoptions' contains 'i' set changed flag. */
!     if ((read_stdin && !readonlymode && !bufempty())
  #ifdef FEAT_AUTOCMD
  		|| modified_was_set	/* ":set modified" used in autocmd */
  # ifdef FEAT_EVAL
  		|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)
  # endif
  #endif
! 		|| (got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL))
  	changed();
!     else if (retval != FAIL)
  	unchanged(curbuf, FALSE);
      save_file_ff(curbuf);		/* keep this fileformat */
  
--- 201,216 ----
      /* When reading stdin, the buffer contents always needs writing, so set
       * the changed flag.  Unless in readonly mode: "ls | gview -".
       * When interrupted and 'cpoptions' contains 'i' set changed flag. */
!     if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)
  #ifdef FEAT_AUTOCMD
  		|| modified_was_set	/* ":set modified" used in autocmd */
  # ifdef FEAT_EVAL
  		|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)
  # endif
  #endif
!        )
  	changed();
!     else if (retval != FAIL && !read_stdin)
  	unchanged(curbuf, FALSE);
      save_file_ff(curbuf);		/* keep this fileformat */
  
*** ../vim-7.1.005/src/version.c	Tue Jun 19 12:58:55 2007
--- src/version.c	Tue Jun 19 15:37:53 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     6,
  /**/

-- 
If I tell you "you have a beautiful body", would you hold it against me?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.007 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.007 (extra)
Problem:    Mac: Context menu doesn't work on Intel Macs.
            Scrollbars are not dimmed when Vim is not the active application.
Solution:   Remove the test whether context menus are supported.  They are
            always there in OS/X.  Handle the dimming. (Nicolas Weber)
Files:      src/gui_mac.c, src/gui.h


*** ../vim-7.1.006/src/gui_mac.c	Thu May 10 20:07:25 2007
--- src/gui_mac.c	Sat Jun  9 14:19:25 2007
***************
*** 1676,1688 ****
  	/* TODO: NEEDED? */
  	clickIsPopup = FALSE;
  
! 	if ((gui.MacOSHaveCntxMenu) && (mouse_model_popup()))
! 	    if (IsShowContextualMenuClick(theEvent))
! 	    {
! 		vimMouseButton = MOUSE_RIGHT;
! 		vimModifiers &= ~MOUSE_CTRL;
! 		clickIsPopup = TRUE;
! 	    }
  
  	/* Is it a double click ? */
  	dblClick = ((theEvent->when - lastMouseTick) < GetDblTime());
--- 1676,1687 ----
  	/* TODO: NEEDED? */
  	clickIsPopup = FALSE;
  
! 	if (mouse_model_popup() && IsShowContextualMenuClick(theEvent))
! 	{
! 	    vimMouseButton = MOUSE_RIGHT;
! 	    vimModifiers &= ~MOUSE_CTRL;
! 	    clickIsPopup = TRUE;
! 	}
  
  	/* Is it a double click ? */
  	dblClick = ((theEvent->when - lastMouseTick) < GetDblTime());
***************
*** 1920,1943 ****
      WindowPtr	whichWindow;
  
      whichWindow = (WindowPtr) event->message;
!     if ((event->modifiers) & activeFlag)
! 	/* Activate */
! 	gui_focus_change(TRUE);
!     else
      {
! 	/* Deactivate */
! 	gui_focus_change(FALSE);
! /*	DON'T KNOW what the code below was doing
! 	found in the deactivate clause, but the
! 	clause writing TRUE into in_focus (BUG)
!  */
! 
! #if 0	/* Removed by Dany as per above June 2001 */
! 	a_bool = false;
! 	SetPreserveGlyph(a_bool);
! 	SetOutlinePreferred(a_bool);
! #endif
      }
  }
  
  
--- 1919,1937 ----
      WindowPtr	whichWindow;
  
      whichWindow = (WindowPtr) event->message;
!     /* Dim scrollbars */
!     if (whichWindow == gui.VimWindow)
      {
!         ControlRef rootControl;
!         GetRootControl(gui.VimWindow, &rootControl);
!         if ((event->modifiers) & activeFlag)
!             ActivateControl(rootControl);
!         else
!             DeactivateControl(rootControl);
      }
+ 
+     /* Activate */
+     gui_focus_change((event->modifiers) & activeFlag);
  }
  
  
***************
*** 2559,2574 ****
      OSErr	error;
  
      /* Handle contextual menu right now (if needed) */
!     if (gui.MacOSHaveCntxMenu)
! 	if (IsShowContextualMenuClick(event))
! 	{
  # if 0
! 	    gui_mac_handle_contextual_menu(event);
  # else
! 	    gui_mac_doMouseDownEvent(event);
  # endif
! 	    return;
! 	}
  
      /* Handle normal event */
      switch (event->what)
--- 2553,2567 ----
      OSErr	error;
  
      /* Handle contextual menu right now (if needed) */
!     if (IsShowContextualMenuClick(event))
!     {
  # if 0
!         gui_mac_handle_contextual_menu(event);
  # else
!         gui_mac_doMouseDownEvent(event);
  # endif
!         return;
!     }
  
      /* Handle normal event */
      switch (event->what)
***************
*** 2782,2795 ****
      (void) InstallAEHandlers();
  #endif
  
-     if (Gestalt(gestaltContextualMenuAttr, &gestalt_rc) == noErr)
- 	gui.MacOSHaveCntxMenu = BitTst(&gestalt_rc, 31-gestaltContextualMenuTrapAvailable);
-     else
- 	gui.MacOSHaveCntxMenu = false;
- 
-     if (gui.MacOSHaveCntxMenu)
- 	gui.MacOSHaveCntxMenu = (InitContextualMenus()==noErr);
- 
      pomme = NewMenu(256, "\p\024"); /* 0x14= = Apple Menu */
  
      AppendMenu(pomme, "\pAbout VIM");
--- 2775,2780 ----
***************
*** 2941,2946 ****
--- 2926,2932 ----
  #ifdef USE_CARBONKEYHANDLER
      EventHandlerRef keyEventHandlerRef;
  #endif
+     ControlRef rootControl;
  
      if (Gestalt(gestaltSystemVersion, &gMacSystemVersion) != noErr)
  	gMacSystemVersion = 0x1000; /* TODO: Default to minimum sensible value */
***************
*** 2954,2968 ****
      (void) InstallAEHandlers();
  #endif
  
-     /* Ctrl click */
-     if (Gestalt(gestaltContextualMenuAttr, &gestalt_rc) == noErr)
- 	gui.MacOSHaveCntxMenu = BitTst(&gestalt_rc, 31-gestaltContextualMenuTrapAvailable);
-     else
- 	gui.MacOSHaveCntxMenu = false;
- 
-     if (gui.MacOSHaveCntxMenu)
- 	gui.MacOSHaveCntxMenu = (InitContextualMenus()==noErr);
- 
      pomme = NewMenu(256, "\p\024"); /* 0x14= = Apple Menu */
  
      AppendMenu(pomme, "\pAbout VIM");
--- 2940,2945 ----
***************
*** 2981,2986 ****
--- 2958,2964 ----
      gui.VimWindow = NewCWindow(nil, &windRect, "\pgVim on Macintosh", true,
  			zoomDocProc,
  			(WindowPtr)-1L, true, 0);
+     CreateRootControl(gui.VimWindow, &rootControl);
      InstallReceiveHandler((DragReceiveHandlerUPP)receiveHandler,
  	    gui.VimWindow, NULL);
      SetPortWindowPort(gui.VimWindow);
*** ../vim-7.1.006/src/gui.h	Thu May 10 19:18:46 2007
--- src/gui.h	Sat Jun  9 14:10:34 2007
***************
*** 460,466 ****
      WindowPtr	VimWindow;
      MenuHandle	MacOSHelpMenu;	    /* Help menu provided by the MacOS */
      int		MacOSHelpItems;	    /* Nr of help-items supplied by MacOS */
-     int		MacOSHaveCntxMenu;  /* Contextual menu available */
      WindowPtr	wid;		    /* Window id of text area */
      int		visibility;	    /* Is window partially/fully obscured? */
  #endif
--- 460,465 ----
*** ../vim-7.1.006/src/version.c	Tue Jun 19 15:40:51 2007
--- src/version.c	Tue Jun 19 15:44:15 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     7,
  /**/

-- 
       When danger reared its ugly head,
       He bravely turned his tail and fled
       Yes, Brave Sir Robin turned about
       And gallantly he chickened out
       Bravely taking to his feet
       He beat a very brave retreat
       Bravest of the brave Sir Robin
       Petrified of being dead
       Soiled his pants then brave Sir Robin
       Turned away and fled.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.008 (correction
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Oops, forgot the src/version.c change.

Patch 7.1.008
Problem:    getfsize() returns a negative number for very big files.
Solution:   Check for overflow and return -2.
Files:	    runtime/doc/eval.txt, src/eval.c


*** ../vim-7.1.007/runtime/doc/eval.txt	Sat May 12 16:38:23 2007
--- runtime/doc/eval.txt	Sat Jun  9 15:48:40 2007
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2007 May 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Jun 09
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 2824,2829 ****
--- 2824,2831 ----
  		given file {fname}.
  		If {fname} is a directory, 0 is returned.
  		If the file {fname} can't be found, -1 is returned.
+ 		If the size of {fname} is too big to fit in a Number then -2
+ 		is returned.
  
  getfontname([{name}])					*getfontname()*
  		Without an argument returns the name of the normal font being
*** ../vim-7.1.007/src/eval.c	Thu May 10 21:30:00 2007
--- src/eval.c	Sat Jun  9 15:46:46 2007
***************
*** 10136,10142 ****
--- 10136,10148 ----
  	if (mch_isdir(fname))
  	    rettv->vval.v_number = 0;
  	else
+ 	{
  	    rettv->vval.v_number = (varnumber_T)st.st_size;
+ 
+ 	    /* non-perfect check for overflow */
+ 	    if ((off_t)rettv->vval.v_number != (off_t)st.st_size)
+ 		rettv->vval.v_number = -2;
+ 	}
      }
      else
  	  rettv->vval.v_number = -1;
*** ../vim-7.1.007/src/version.c	Tue Jun 19 16:33:53 2007
--- src/version.c	Tue Jun 19 17:30:50 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     8,
  /**/


-- 
ZOOT:  I'm afraid our life must seem very dull and quiet compared to yours.
       We are but eightscore young blondes, all between sixteen and
       nineteen-and-a-half, cut off in this castle, with no one to protect us.
       Oooh.  It is a lonely life ... bathing ...  dressing ... undressing ...
       making exciting underwear....
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.009
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.009
Problem:    In diff mode, displaying the difference between a tab and spaces
	    is not highlighted correctly.
Solution:   Only change highlighting at the end of displaying a tab.
Files:	    src/screen.c


*** ../vim-7.1.008/src/screen.c	Thu May 10 20:15:31 2007
--- src/screen.c	Mon Jun 11 21:49:44 2007
***************
*** 3459,3467 ****
  #ifdef FEAT_DIFF
  	    if (diff_hlf != (hlf_T)0)
  	    {
! 		if (diff_hlf == HLF_CHD && ptr - line >= change_start)
  		    diff_hlf = HLF_TXD;		/* changed text */
! 		if (diff_hlf == HLF_TXD && ptr - line > change_end)
  		    diff_hlf = HLF_CHD;		/* changed line */
  		line_attr = hl_attr(diff_hlf);
  	    }
--- 3459,3469 ----
  #ifdef FEAT_DIFF
  	    if (diff_hlf != (hlf_T)0)
  	    {
! 		if (diff_hlf == HLF_CHD && ptr - line >= change_start
! 							      && n_extra == 0)
  		    diff_hlf = HLF_TXD;		/* changed text */
! 		if (diff_hlf == HLF_TXD && ptr - line > change_end
! 							      && n_extra == 0)
  		    diff_hlf = HLF_CHD;		/* changed line */
  		line_attr = hl_attr(diff_hlf);
  	    }
*** ../vim-7.1.008/src/version.c	Tue Jun 19 17:33:52 2007
--- src/version.c	Tue Jun 19 17:36:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     9,
  /**/

-- 
Linux is just like a wigwam: no Windows, no Gates and an Apache inside.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.010
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.010
Problem:    The Gnome session file doesn't restore tab pages.
Solution:   Add SSOP_TABPAGES to the session flags. (Matias D'Ambrosio)
Files:	    src/gui_gtk_x11.c


*** ../vim-7.1.009/src/gui_gtk_x11.c	Mon May 14 19:35:51 2007
--- src/gui_gtk_x11.c	Sat Jun  9 16:54:13 2007
***************
*** 2188,2195 ****
      escaped_filename = vim_strsave_escaped(filename, escape_chars);
      if (escaped_filename == NULL)
  	return FALSE;
!     mksession_cmdline = g_strconcat("mksession ", (char *)escaped_filename, NULL);
      vim_free(escaped_filename);
      /*
       * Use a reasonable hardcoded set of 'sessionoptions' flags to avoid
       * unpredictable effects when the session is saved automatically.  Also,
--- 2188,2197 ----
      escaped_filename = vim_strsave_escaped(filename, escape_chars);
      if (escaped_filename == NULL)
  	return FALSE;
!     mksession_cmdline = g_strconcat("mksession ", (char *)escaped_filename,
! 									NULL);
      vim_free(escaped_filename);
+ 
      /*
       * Use a reasonable hardcoded set of 'sessionoptions' flags to avoid
       * unpredictable effects when the session is saved automatically.  Also,
***************
*** 2199,2205 ****
       */
      save_ssop_flags = ssop_flags;
      ssop_flags = (SSOP_BLANK|SSOP_CURDIR|SSOP_FOLDS|SSOP_GLOBALS
! 		  |SSOP_HELP|SSOP_OPTIONS|SSOP_WINSIZE);
  
      do_cmdline_cmd((char_u *)"let Save_VV_this_session = v:this_session");
      failed = (do_cmdline_cmd((char_u *)mksession_cmdline) == FAIL);
--- 2201,2207 ----
       */
      save_ssop_flags = ssop_flags;
      ssop_flags = (SSOP_BLANK|SSOP_CURDIR|SSOP_FOLDS|SSOP_GLOBALS
! 		  |SSOP_HELP|SSOP_OPTIONS|SSOP_WINSIZE|SSOP_TABPAGES);
  
      do_cmdline_cmd((char_u *)"let Save_VV_this_session = v:this_session");
      failed = (do_cmdline_cmd((char_u *)mksession_cmdline) == FAIL);
*** ../vim-7.1.009/src/version.c	Tue Jun 19 17:49:12 2007
--- src/version.c	Tue Jun 19 18:07:09 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     10,
  /**/

-- 
GALAHAD: No look, really, this isn't nescess ...
PIGLET:  We must examine you.
GALAHAD: There's nothing wrong with ... that.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.011
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.011
Problem:    Possible buffer overflow when $VIMRUNTIME is very long. (Victor
	    Stinner)
Solution:   Use vim_snprintf().
Files:	    src/main.c


*** ../vim-7.1.010/src/main.c	Thu May 10 21:12:25 2007
--- src/main.c	Sat Jun  9 22:37:46 2007
***************
*** 1360,1367 ****
  	p = vim_getenv((char_u *)"VIMRUNTIME", &mustfree);
  	if (p != NULL && *p != NUL)
  	{
! 	    STRCPY(NameBuff, p);
! 	    STRCAT(NameBuff, "/lang");
  	    bindtextdomain(VIMPACKAGE, (char *)NameBuff);
  	}
  	if (mustfree)
--- 1360,1366 ----
  	p = vim_getenv((char_u *)"VIMRUNTIME", &mustfree);
  	if (p != NULL && *p != NUL)
  	{
! 	    vim_snprintf((char *)NameBuff, MAXPATHL, "%s/lang", p);
  	    bindtextdomain(VIMPACKAGE, (char *)NameBuff);
  	}
  	if (mustfree)
*** ../vim-7.1.010/src/version.c	Tue Jun 19 18:07:52 2007
--- src/version.c	Tue Jun 19 20:29:44 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     11,
  /**/

-- 
   GALAHAD hurries to the door and pushes through it.  As he leaves the room
   we CUT TO the reverse to show that he is now in a room full of bathing
   and romping GIRLIES, all innocent, wide-eyed and beautiful.  They smile
   enchantingly at him as he tries to keep walking without being diverted by
   the lovely sights assaulting his eyeballs.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.012
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.012
Problem:    ":let &shiftwidth = 'asdf'" doesn't produce an error message.
Solution:   Check for a string argument. (Chris Lubinski)
Files:	    src/option.c


*** ../vim-7.1.011/src/option.c	Sun May  6 15:37:32 2007
--- src/option.c	Tue Jun 19 20:56:36 2007
***************
*** 8219,8224 ****
--- 8219,8243 ----
  	    varp = get_varp(&options[opt_idx]);
  	    if (varp != NULL)	/* hidden option is not changed */
  	    {
+ 		if (number == 0 && string != NULL)
+ 		{
+ 		    int index;
+ 
+ 		    /* Either we are given a string or we are setting option
+ 		     * to zero. */
+ 		    for (index = 0; string[index] == '0'; ++index)
+ 			;
+ 		    if (string[index] != NUL || index == 0)
+ 		    {
+ 			/* There's another character after zeros or the string
+ 			 * is empty.  In both cases, we are trying to set a
+ 			 * num option using a string. */
+ 			EMSG3(_("E521: Number required: &%s = '%s'"),
+ 								name, string);
+ 			return;     /* do nothing as we hit an error */
+ 
+ 		    }
+ 		}
  		if (flags & P_NUM)
  		    (void)set_num_option(opt_idx, varp, number,
  							  NULL, 0, opt_flags);
*** ../vim-7.1.011/src/version.c	Tue Jun 19 20:30:46 2007
--- src/version.c	Tue Jun 19 20:53:15 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     12,
  /**/

-- 
Ten million Linux users can't be wrong!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.013
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.013
Problem:    ":syn include" only loads the first file, while it is documented
	    as doing the equivalent of ":runtime!".
Solution:   Change the argument to source_runtime(). (James Vega)
Files:	    src/syntax.c


*** ../vim-7.1.012/src/syntax.c	Thu May 10 20:54:33 2007
--- src/syntax.c	Sun Jun 17 22:03:30 2007
***************
*** 4460,4467 ****
      current_syn_inc_tag = ++running_syn_inc_tag;
      prev_toplvl_grp = curbuf->b_syn_topgrp;
      curbuf->b_syn_topgrp = sgl_id;
!     if (source ? do_source(eap->arg, FALSE, FALSE) == FAIL
! 				: source_runtime(eap->arg, DOSO_NONE) == FAIL)
  	EMSG2(_(e_notopen), eap->arg);
      curbuf->b_syn_topgrp = prev_toplvl_grp;
      current_syn_inc_tag = prev_syn_inc_tag;
--- 4460,4467 ----
      current_syn_inc_tag = ++running_syn_inc_tag;
      prev_toplvl_grp = curbuf->b_syn_topgrp;
      curbuf->b_syn_topgrp = sgl_id;
!     if (source ? do_source(eap->arg, FALSE, DOSO_NONE) == FAIL
! 				: source_runtime(eap->arg, TRUE) == FAIL)
  	EMSG2(_(e_notopen), eap->arg);
      curbuf->b_syn_topgrp = prev_toplvl_grp;
      current_syn_inc_tag = prev_syn_inc_tag;
*** ../vim-7.1.012/src/version.c	Tue Jun 19 20:56:52 2007
--- src/version.c	Thu Jun 28 11:58:25 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     13,
  /**/

-- 
MORTICIAN:    What?
CUSTOMER:     Nothing -- here's your nine pence.
DEAD PERSON:  I'm not dead!
MORTICIAN:    Here -- he says he's not dead!
CUSTOMER:     Yes, he is.
DEAD PERSON:  I'm not!
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.014
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.014
Problem:    Crash when doing C indenting. (Chris Monson)
Solution:   Obtain the current line again after invoking cin_islabel().
Files:	    src/edit.c


*** ../vim-7.1.013/src/edit.c	Thu May 10 20:44:18 2007
--- src/edit.c	Wed Jun 20 18:25:54 2007
***************
*** 7215,7220 ****
--- 7215,7222 ----
  		p = ml_get_curline();
  		if (cin_iscase(p) || cin_isscopedecl(p) || cin_islabel(30))
  		    return TRUE;
+ 		/* Need to get the line again after cin_islabel(). */
+ 		p = ml_get_curline();
  		if (curwin->w_cursor.col > 2
  			&& p[curwin->w_cursor.col - 1] == ':'
  			&& p[curwin->w_cursor.col - 2] == ':')
*** ../vim-7.1.013/src/version.c	Thu Jun 28 11:59:13 2007
--- src/version.c	Thu Jun 28 12:26:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     14,
  /**/

-- 
Have you heard about the new Barbie doll?  It's called Divorce
Barbie.  It comes with all of Ken's stuff.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.016
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.016 (after patch 7.1.012)
Problem:    Error message about setting 'diff' to a string.
Solution:   Don't pass an empty string to set_option_value() when setting
	    'diff'.
Files:	    src/quickfix.c, src/popupmnu.c


*** ../vim-7.1.015/src/quickfix.c	Sun Feb  4 02:58:00 2007
--- src/quickfix.c	Thu Jun 28 18:56:16 2007
***************
*** 2331,2337 ****
  	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
  								   OPT_LOCAL);
  	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
! 	    set_option_value((char_u *)"diff", 0L, (char_u *)"", OPT_LOCAL);
  	}
  
  	/* Only set the height when still in the same tab page and there is no
--- 2331,2337 ----
  	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
  								   OPT_LOCAL);
  	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
! 	    set_option_value((char_u *)"diff", 0L, NULL, OPT_LOCAL);
  	}
  
  	/* Only set the height when still in the same tab page and there is no
*** ../vim-7.1.015/src/popupmnu.c	Tue Mar 27 12:42:05 2007
--- src/popupmnu.c	Thu Jun 28 19:00:51 2007
***************
*** 466,472 ****
  			set_option_value((char_u *)"bh", 0L,
  						 (char_u *)"wipe", OPT_LOCAL);
  			set_option_value((char_u *)"diff", 0L,
! 						     (char_u *)"", OPT_LOCAL);
  		    }
  		}
  		if (res == OK)
--- 466,472 ----
  			set_option_value((char_u *)"bh", 0L,
  						 (char_u *)"wipe", OPT_LOCAL);
  			set_option_value((char_u *)"diff", 0L,
! 							     NULL, OPT_LOCAL);
  		    }
  		}
  		if (res == OK)
*** ../vim-7.1.015/src/version.c	Thu Jun 28 13:02:22 2007
--- src/version.c	Thu Jun 28 21:20:20 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     16,
  /**/

-- 
We do not stumble over mountains, but over molehills.
				Confucius

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.017
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.017
Problem:    ":confirm w" does give a prompt when 'readonly' is set, but not
	    when the file permissions are read-only.  (Michael Schaap)
Solution:   Provide a dialog in both situations.  (Chris Lubinski)
Files:	    src/ex_cmds.c, src/fileio.c, src/proto/fileio.pro


*** ../vim-7.1.016/src/ex_cmds.c	Tue Jun 19 11:54:23 2007
--- src/ex_cmds.c	Tue Jun 19 22:37:25 2007
***************
*** 2912,2933 ****
  }
  
  /*
!  * Check if a buffer is read-only.  Ask for overruling in a dialog.
!  * Return TRUE and give an error message when the buffer is readonly.
   */
      static int
  check_readonly(forceit, buf)
      int		*forceit;
      buf_T	*buf;
  {
!     if (!*forceit && buf->b_p_ro)
      {
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  	if ((p_confirm || cmdmod.confirm) && buf->b_fname != NULL)
  	{
  	    char_u	buff[IOSIZE];
  
! 	    dialog_msg(buff, _("'readonly' option is set for \"%s\".\nDo you wish to write anyway?"),
  		    buf->b_fname);
  
  	    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)
--- 2912,2946 ----
  }
  
  /*
!  * Check if a buffer is read-only (either 'readonly' option is set or file is
!  * read-only). Ask for overruling in a dialog. Return TRUE and give an error
!  * message when the buffer is readonly.
   */
      static int
  check_readonly(forceit, buf)
      int		*forceit;
      buf_T	*buf;
  {
!     struct stat	st;
! 
!     /* Handle a file being readonly when the 'readonly' option is set or when
!      * the file exists and permissions are read-only.
!      * We will send 0777 to check_file_readonly(), as the "perm" variable is
!      * important for device checks but not here. */
!     if (!*forceit && (buf->b_p_ro
! 		|| (mch_stat((char *)buf->b_ffname, &st) >= 0
! 		    && check_file_readonly(buf->b_ffname, 0777))))
      {
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  	if ((p_confirm || cmdmod.confirm) && buf->b_fname != NULL)
  	{
  	    char_u	buff[IOSIZE];
  
! 	    if (buf->b_p_ro)
! 		dialog_msg(buff, _("'readonly' option is set for \"%s\".\nDo you wish to write anyway?"),
! 		    buf->b_fname);
! 	    else
! 		dialog_msg(buff, _("File permissions of \"%s\" are read-only.\nIt may still be possible to write it.\nDo you wish to try?"),
  		    buf->b_fname);
  
  	    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)
***************
*** 2941,2949 ****
--- 2954,2967 ----
  	}
  	else
  #endif
+ 	if (buf->b_p_ro)
  	    EMSG(_(e_readonly));
+ 	else
+ 	    EMSG2(_("E505: \"%s\" is read-only (add ! to override)"),
+ 		    buf->b_fname);
  	return TRUE;
      }
+ 
      return FALSE;
  }
  
*** ../vim-7.1.016/src/fileio.c	Thu May 10 19:32:17 2007
--- src/fileio.c	Thu Jun 28 21:54:18 2007
***************
*** 424,430 ****
  	 */
  	if (!p_odev && mch_nodetype(fname) == NODE_WRITABLE)
  	{
! 	    filemess(curbuf, fname, (char_u *)_("is a device (disabled with 'opendevice' option"), 0);
  	    msg_end();
  	    msg_scroll = msg_save;
  	    return FAIL;
--- 424,430 ----
  	 */
  	if (!p_odev && mch_nodetype(fname) == NODE_WRITABLE)
  	{
! 	    filemess(curbuf, fname, (char_u *)_("is a device (disabled with 'opendevice' option)"), 0);
  	    msg_end();
  	    msg_scroll = msg_save;
  	    return FAIL;
***************
*** 2734,2739 ****
--- 2734,2765 ----
  #endif
  
  /*
+  * Return TRUE if a file appears to be read-only from the file permissions.
+  */
+     int
+ check_file_readonly(fname, perm)
+     char_u	*fname;		/* full path to file */
+     int		perm;		/* known permissions on file */
+ {
+ #ifndef USE_MCH_ACCESS
+     int	    fd = 0;
+ #endif
+ 
+     return (
+ #ifdef USE_MCH_ACCESS
+ # ifdef UNIX
+ 	(perm & 0222) == 0 ||
+ # endif
+ 	mch_access((char *)fname, W_OK)
+ #else
+ 	(fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0
+ 					? TRUE : (close(fd), FALSE)
+ #endif
+ 	);
+ }
+ 
+ 
+ /*
   * buf_write() - write to file "fname" lines "start" through "end"
   *
   * We do our own buffering here because fwrite() is so slow.
***************
*** 3219,3235 ****
  	 * Check if the file is really writable (when renaming the file to
  	 * make a backup we won't discover it later).
  	 */
! 	file_readonly = (
! # ifdef USE_MCH_ACCESS
! #  ifdef UNIX
! 		    (perm & 0222) == 0 ||
! #  endif
! 		    mch_access((char *)fname, W_OK)
! # else
! 		    (fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0
! 						   ? TRUE : (close(fd), FALSE)
! # endif
! 		    );
  	if (!forceit && file_readonly)
  	{
  	    if (vim_strchr(p_cpo, CPO_FWRITE) != NULL)
--- 3245,3252 ----
  	 * Check if the file is really writable (when renaming the file to
  	 * make a backup we won't discover it later).
  	 */
! 	file_readonly = check_file_readonly(fname, (int)perm);
! 
  	if (!forceit && file_readonly)
  	{
  	    if (vim_strchr(p_cpo, CPO_FWRITE) != NULL)
*** ../vim-7.1.016/src/proto/fileio.pro	Sat May  5 19:59:00 2007
--- src/proto/fileio.pro	Thu Jun 28 21:09:59 2007
***************
*** 2,7 ****
--- 2,8 ----
  void filemess __ARGS((buf_T *buf, char_u *name, char_u *s, int attr));
  int readfile __ARGS((char_u *fname, char_u *sfname, linenr_T from, linenr_T lines_to_skip, linenr_T lines_to_read, exarg_T *eap, int flags));
  int prep_exarg __ARGS((exarg_T *eap, buf_T *buf));
+ int check_file_readonly __ARGS((char_u *fname, int perm));
  int buf_write __ARGS((buf_T *buf, char_u *fname, char_u *sfname, linenr_T start, linenr_T end, exarg_T *eap, int append, int forceit, int reset_changed, int filtering));
  void msg_add_fname __ARGS((buf_T *buf, char_u *fname));
  void msg_add_lines __ARGS((int insert_space, long lnum, long nchars));
*** ../vim-7.1.016/src/version.c	Thu Jun 28 21:23:52 2007
--- src/version.c	Thu Jun 28 21:49:29 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     17,
  /**/

-- 
CUSTOMER:     Well, can you hang around a couple of minutes?  He won't be
              long.
MORTICIAN:    Naaah, I got to go on to Robinson's -- they've lost nine today.
CUSTOMER:     Well, when is your next round?
MORTICIAN:    Thursday.
DEAD PERSON:  I think I'll go for a walk.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.018
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.018
Problem:    When 'virtualedit' is set a "p" of a block just past the end of
	    the line inserts before the cursor. (Engelke)
Solution:   Check for the cursor being just after the line (Chris Lubinski)
Files:	    src/ops.c


*** ../vim-7.1.017/src/ops.c	Thu May 10 20:34:55 2007
--- src/ops.c	Tue Jun 19 22:40:45 2007
***************
*** 3404,3410 ****
  
  #ifdef FEAT_VIRTUALEDIT
  	col += curwin->w_cursor.coladd;
! 	if (ve_flags == VE_ALL && curwin->w_cursor.coladd > 0)
  	{
  	    if (dir == FORWARD && c == NUL)
  		++col;
--- 3404,3412 ----
  
  #ifdef FEAT_VIRTUALEDIT
  	col += curwin->w_cursor.coladd;
! 	if (ve_flags == VE_ALL
! 		&& (curwin->w_cursor.coladd > 0
! 		    || endcol2 == curwin->w_cursor.col))
  	{
  	    if (dir == FORWARD && c == NUL)
  		++col;
*** ../vim-7.1.017/src/version.c	Thu Jun 28 21:57:08 2007
--- src/version.c	Thu Jun 28 22:12:49 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     18,
  /**/

-- 
    [clop clop]
MORTICIAN:  Who's that then?
CUSTOMER:   I don't know.
MORTICIAN:  Must be a king.
CUSTOMER:   Why?
MORTICIAN:  He hasn't got shit all over him.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.019
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.019
Problem:    ":py" asks for an argument, ":py asd" then gives the error that
	    ":py" isn't implemented.  Should already happen for ":py".
Solution:   Compare with ex_script_ni. (Chris Lubinski)
Files:	    src/ex_docmd.c


*** ../vim-7.1.018/src/ex_docmd.c	Thu May 10 18:53:03 2007
--- src/ex_docmd.c	Sat Jun 23 13:36:37 2007
***************
*** 2118,2124 ****
  #ifdef FEAT_USR_CMDS
  	    !USER_CMDIDX(ea.cmdidx) &&
  #endif
! 	    cmdnames[ea.cmdidx].cmd_func == ex_ni);
  
  #ifndef FEAT_EVAL
      /*
--- 2118,2125 ----
  #ifdef FEAT_USR_CMDS
  	    !USER_CMDIDX(ea.cmdidx) &&
  #endif
! 	    (cmdnames[ea.cmdidx].cmd_func == ex_ni
! 	     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni));
  
  #ifndef FEAT_EVAL
      /*
*** ../vim-7.1.018/src/version.c	Thu Jun 28 22:14:28 2007
--- src/version.c	Thu Jul  5 09:48:11 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     19,
  /**/

-- 
MARTHA'S WAY: Don't throw out all that leftover wine. Freeze into ice cubes
              for future use in casseroles and sauces.
MY WAY:       What leftover wine?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.020
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.020
Problem:    Reading from uninitialized memory when using a dialog. (Dominique
	    Pelle)
Solution:   In msg_show_console_dialog() append a NUL after every appended
	    character.
Files:	    src/message.c


*** ../vim-7.1.019/src/message.c	Thu May 10 18:49:39 2007
--- src/message.c	Sun Jul  1 12:06:52 2007
***************
*** 3456,3466 ****
  		    /* advance to next hotkey and set default hotkey */
  #ifdef FEAT_MBYTE
  		    if (has_mbyte)
! 			hotkp += (*mb_ptr2len)(hotkp);
  		    else
  #endif
  			++hotkp;
! 		    (void)copy_char(r + 1, hotkp, TRUE);
  		    if (dfltbutton)
  			--dfltbutton;
  
--- 3456,3466 ----
  		    /* advance to next hotkey and set default hotkey */
  #ifdef FEAT_MBYTE
  		    if (has_mbyte)
! 			hotkp += STRLEN(hotkp);
  		    else
  #endif
  			++hotkp;
! 		    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;
  		    if (dfltbutton)
  			--dfltbutton;
  
***************
*** 3493,3499 ****
  			*msgp++ = (dfltbutton == 1) ? ']' : ')';
  
  			/* redefine hotkey */
! 			(void)copy_char(r, hotkp, TRUE);
  		    }
  		}
  		else
--- 3493,3499 ----
  			*msgp++ = (dfltbutton == 1) ? ']' : ')';
  
  			/* redefine hotkey */
! 			hotkp[copy_char(r, hotkp, TRUE)] = NUL;
  		    }
  		}
  		else
***************
*** 3519,3526 ****
  	    *msgp++ = ':';
  	    *msgp++ = ' ';
  	    *msgp = NUL;
- 	    mb_ptr_adv(hotkp);
- 	    *hotkp = NUL;
  	}
  	else
  	{
--- 3519,3524 ----
***************
*** 3555,3562 ****
  	    msgp = confirm_msg + 1 + STRLEN(message);
  	    hotkp = hotk;
  
! 	    /* define first default hotkey */
! 	    (void)copy_char(buttons, hotkp, TRUE);
  
  	    /* Remember where the choices start, displaying starts here when
  	     * "hotkp" typed at the more prompt. */
--- 3553,3561 ----
  	    msgp = confirm_msg + 1 + STRLEN(message);
  	    hotkp = hotk;
  
! 	    /* Define first default hotkey.  Keep the hotkey string NUL
! 	     * terminated to avoid reading past the end. */
! 	    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;
  
  	    /* Remember where the choices start, displaying starts here when
  	     * "hotkp" typed at the more prompt. */
*** ../vim-7.1.019/src/version.c	Thu Jul  5 09:53:20 2007
--- src/version.c	Thu Jul  5 10:09:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     20,
  /**/

-- 
BLACK KNIGHT:  Come on you pansy!
    [hah] [parry thrust]
    [ARTHUR chops the BLACK KNIGHT's right arm off]
ARTHUR:        Victory is mine!  [kneeling]
               We thank thee Lord, that in thy merc-
    [Black Knight kicks Arthur in the head while he is praying]
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.022
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.022
Problem:    When setting 'keymap' twice the b:keymap_name variable isn't set.
            (Milan Berta)
Solution:   Don't unlet b:keymap_name for ":loadkeymap". (Martin Toft)
Files:      src/digraph.c


*** ../vim-7.1.021/src/digraph.c	Wed May  3 00:07:11 2006
--- src/digraph.c	Mon Jul  2 21:24:30 2007
***************
*** 2349,2356 ****
  
      if (*curbuf->b_p_keymap == NUL)
      {
! 	/* Stop any active keymap and clear the table. */
  	keymap_unload();
      }
      else
      {
--- 2349,2358 ----
  
      if (*curbuf->b_p_keymap == NUL)
      {
! 	/* Stop any active keymap and clear the table.  Also remove
! 	 * b:keymap_unload, as no keymap is active now. */
  	keymap_unload();
+ 	do_cmdline_cmd((char_u *)"unlet! b:keymap_name");
      }
      else
      {
***************
*** 2500,2506 ****
  
      ga_clear(&curbuf->b_kmap_ga);
      curbuf->b_kmap_state &= ~KEYMAP_LOADED;
-     do_cmdline_cmd((char_u *)"unlet! b:keymap_name");
  #ifdef FEAT_WINDOWS
      status_redraw_curbuf();
  #endif
--- 2502,2507 ----
*** ../vim-7.1.021/src/version.c	Fri Jul  6 19:42:09 2007
--- src/version.c	Sat Jul  7 13:56:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     22,
  /**/

-- 
If your life is a hard drive,
Christ can be your backup.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.023
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.023
Problem:    "dw" in a line with one character deletes the line.  Vi and nvi
	    don't do this.  (Kjell Arne Rekaa)
Solution:   Check for one-character words especially.
Files:	    src/search.c


*** ../vim-7.1.022/src/search.c	Tue Jun 19 12:58:55 2007
--- src/search.c	Thu Jul  5 21:18:55 2007
***************
*** 2795,2801 ****
  	i = inc_cursor();
  	if (i == -1 || (i >= 1 && last_line)) /* started at last char in file */
  	    return FAIL;
! 	if (i == 1 && eol && count == 0)      /* started at last char in line */
  	    return OK;
  
  	/*
--- 2802,2808 ----
  	i = inc_cursor();
  	if (i == -1 || (i >= 1 && last_line)) /* started at last char in file */
  	    return FAIL;
! 	if (i >= 1 && eol && count == 0)      /* started at last char in line */
  	    return OK;
  
  	/*
*** ../vim-7.1.022/src/version.c	Sat Jul  7 13:57:39 2007
--- src/version.c	Tue Jul 10 12:35:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     23,
  /**/

-- 
BRIDGEKEEPER: What is your favorite editor?
GAWAIN:       Emacs ...  No, Viiiiiiiiiiimmmmmmm!
           "Monty Python and the Holy editor wars" PYTHON (MONTY) SOFTWARE LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.024
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.024
Problem:    Using a pointer that has become invalid. (Chris Monson)
Solution:   Obtain the line pointer again after we looked at another line.
Files:	    src/search.c


*** ../vim-7.1.023/src/search.c	Tue Jul 10 12:36:51 2007
--- src/search.c	Thu Jul  5 21:18:55 2007
***************
*** 2124,2129 ****
--- 2128,2136 ----
  			else if (!backwards)
  			    inquote = TRUE;
  		    }
+ 
+ 		    /* ml_get() only keeps one line, need to get linep again */
+ 		    linep = ml_get(pos.lnum);
  		}
  	    }
  	}
*** ../vim-7.1.023/src/version.c	Tue Jul 10 12:36:51 2007
--- src/version.c	Tue Jul 10 13:06:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     24,
  /**/

-- 
Q: Why does /dev/null accept only integers?
A: You can't sink a float.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.025
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.025
Problem:    search() and searchpos() don't use match under cursor at start of
	    line when using 'bc' flags. (Viktor Kojouharov)
Solution:   Don't go to the previous line when the 'c' flag is present.
	    Also fix that "j" doesn't move the cursor to the right column.
Files:	    src/eval.c, src/search.c


*** ../vim-7.1.024/src/eval.c	Tue Jun 19 17:23:46 2007
--- src/eval.c	Thu Jul  5 21:16:31 2007
***************
*** 13925,13930 ****
--- 13925,13932 ----
      /* If 'n' flag is used: restore cursor position. */
      if (flags & SP_NOMOVE)
  	curwin->w_cursor = save_cursor;
+     else
+ 	curwin->w_set_curswant = TRUE;
  theend:
      p_ws = save_p_ws;
  
*** ../vim-7.1.024/src/search.c	Tue Jul 10 13:07:08 2007
--- src/search.c	Thu Jul  5 21:18:55 2007
***************
*** 573,580 ****
  	/*
  	 * Start searching in current line, unless searching backwards and
  	 * we're in column 0.
  	 */
! 	if (dir == BACKWARD && start_pos.col == 0)
  	{
  	    lnum = pos->lnum - 1;
  	    at_first_line = FALSE;
--- 573,584 ----
  	/*
  	 * Start searching in current line, unless searching backwards and
  	 * we're in column 0.
+ 	 * If we are searching backwards, in column 0, and not including the
+ 	 * current position, gain some efficiency by skipping back a line.
+ 	 * Otherwise begin the search in the current line.
  	 */
! 	if (dir == BACKWARD && start_pos.col == 0
! 					     && (options & SEARCH_START) == 0)
  	{
  	    lnum = pos->lnum - 1;
  	    at_first_line = FALSE;
*** ../vim-7.1.024/src/version.c	Tue Jul 10 13:07:08 2007
--- src/version.c	Tue Jul 10 13:26:13 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     25,
  /**/

-- 
SIGFUN -- signature too funny (core dumped)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.026
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.026
Problem:    "[p" doesn't work in Visual mode. (David Brown)
Solution:   Use checkclearop() instead of checkclearopq().
Files:	    src/normal.c


*** ../vim-7.1.025/src/normal.c	Thu May 10 18:45:26 2007
--- src/normal.c	Wed Jul  4 21:16:36 2007
***************
*** 6379,6385 ****
       */
      else if (cap->nchar == 'p' || cap->nchar == 'P')
      {
! 	if (!checkclearopq(cap->oap))
  	{
  	    prep_redo_cmd(cap);
  	    do_put(cap->oap->regname,
--- 6379,6385 ----
       */
      else if (cap->nchar == 'p' || cap->nchar == 'P')
      {
! 	if (!checkclearop(cap->oap))
  	{
  	    prep_redo_cmd(cap);
  	    do_put(cap->oap->regname,
*** ../vim-7.1.025/src/version.c	Tue Jul 10 13:27:46 2007
--- src/version.c	Tue Jul 10 14:01:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     26,
  /**/

-- 
BRIDGEKEEPER: What is the air-speed velocity of an unladen swallow?
ARTHUR:       What do you mean?  An African or European swallow?
BRIDGEKEEPER: Er ...  I don't know that ... Aaaaarrrrrrggghhh!
   BRIDGEKEEPER is cast into the gorge.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.027
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.027
Problem:    On Sun systems opening /dev/fd/N doesn't work, and they are used
	    by process substitutions.
Solution:   Allow opening specific character special files for Sun systems.
	    (Gary Johnson)
Files:	    src/fileio.c, src/os_unix.h


*** ../vim-7.1.026/src/fileio.c	Thu Jun 28 21:57:08 2007
--- src/fileio.c	Mon Jul  9 11:19:50 2007
***************
*** 44,49 ****
--- 44,53 ----
  /* Is there any system that doesn't have access()? */
  #define USE_MCH_ACCESS
  
+ #if defined(sun) && defined(S_ISCHR)
+ # define OPEN_CHR_FILES
+ static int is_dev_fd_file(char_u *fname);
+ #endif
  #ifdef FEAT_MBYTE
  static char_u *next_fenc __ARGS((char_u **pp));
  # ifdef FEAT_EVAL
***************
*** 406,411 ****
--- 410,419 ----
  # ifdef S_ISSOCK
  		      && !S_ISSOCK(perm)	    /* ... or socket */
  # endif
+ # ifdef OPEN_CHR_FILES
+ 		      && !(S_ISCHR(perm) && is_dev_fd_file(fname))
+ 			/* ... or a character special file named /dev/fd/<n> */
+ # endif
  						)
  	{
  	    if (S_ISDIR(perm))
***************
*** 2265,2270 ****
--- 2273,2285 ----
  	    }
  #  endif
  # endif
+ # ifdef OPEN_CHR_FILES
+ 	    if (S_ISCHR(perm))			    /* or character special */
+ 	    {
+ 		STRCAT(IObuff, _("[character special]"));
+ 		c = TRUE;
+ 	    }
+ # endif
  #endif
  	    if (curbuf->b_p_ro)
  	    {
***************
*** 2463,2468 ****
--- 2478,2502 ----
  	return FAIL;
      return OK;
  }
+ 
+ #ifdef OPEN_CHR_FILES
+ /*
+  * Returns TRUE if the file name argument is of the form "/dev/fd/\d\+",
+  * which is the name of files used for process substitution output by
+  * some shells on some operating systems, e.g., bash on SunOS.
+  * Do not accept "/dev/fd/[012]", opening these may hang Vim.
+  */
+     static int
+ is_dev_fd_file(fname)
+     char_u	*fname;
+ {
+     return (STRNCMP(fname, "/dev/fd/", 8) == 0
+ 	    && VIM_ISDIGIT(fname[8])
+ 	    && *skipdigits(fname + 9) == NUL
+ 	    && (fname[9] != NUL
+ 		|| (fname[8] != '0' && fname[8] != '1' && fname[8] != '2')));
+ }
+ #endif
  
  #ifdef FEAT_MBYTE
  
*** ../vim-7.1.026/src/os_unix.h	Thu May 10 19:43:10 2007
--- src/os_unix.h	Sat Jul  7 13:08:56 2007
***************
*** 508,513 ****
--- 508,516 ----
  #if !defined(S_ISFIFO) && defined(S_IFIFO)
  # define	S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
  #endif
+ #if !defined(S_ISCHR) && defined(S_IFCHR)
+ # define	S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+ #endif
  
  /* Note: Some systems need both string.h and strings.h (Savage).  However,
   * some systems can't handle both, only use string.h in that case. */
*** ../vim-7.1.026/src/version.c	Tue Jul 10 14:02:51 2007
--- src/version.c	Tue Jul 10 17:00:43 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     27,
  /**/

-- 
Every exit is an entrance into something else.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.028
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.028
Problem:    Can't use last search pattern for ":sort". (Brian McKee)
Solution:   When the pattern is emtpy use the last search pattern. (Martin
	    Toft)
Files:	    runtime/doc/change.txt, src/ex_cmds.c


*** ../vim-7.1.027/runtime/doc/change.txt	Sat May 12 16:10:12 2007
--- runtime/doc/change.txt	Tue Jul 10 11:30:56 2007
***************
*** 1571,1576 ****
--- 1571,1580 ----
  			in their original order, right before the sorted
  			lines.
  
+ 			If {pattern} is empty (e.g. // is specified), the
+ 			last search pattern is used.  This allows trying out
+ 			a pattern first.
+ 
  Note that using ":sort" with ":global" doesn't sort the matching lines, it's
  quite useless.
  
*** ../vim-7.1.027/src/ex_cmds.c	Thu Jun 28 21:57:08 2007
--- src/ex_cmds.c	Tue Jul 10 17:25:10 2007
***************
*** 408,414 ****
  		goto sortend;
  	    }
  	    *s = NUL;
! 	    regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);
  	    if (regmatch.regprog == NULL)
  		goto sortend;
  	    p = s;		/* continue after the regexp */
--- 408,418 ----
  		goto sortend;
  	    }
  	    *s = NUL;
! 	    /* Use last search pattern if sort pattern is empty. */
! 	    if (s == p + 1 && last_search_pat() != NULL)
! 		regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);
! 	    else
! 		regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);
  	    if (regmatch.regprog == NULL)
  		goto sortend;
  	    p = s;		/* continue after the regexp */
*** ../vim-7.1.027/src/version.c	Tue Jul 10 17:09:51 2007
--- src/version.c	Tue Jul 10 17:20:01 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     28,
  /**/

-- 
Every person is responsible for the choices he makes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.029
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.029 (after 7.1.019)
Problem:    Can't compile when all interfaces are used. (Taylor Venable)
Solution:   Only check for ex_script_ni when it's defined.
Files:	    src/ex_docmd.c


*** ../vim-7.1.028/src/ex_docmd.c	Thu Jul  5 09:53:20 2007
--- src/ex_docmd.c	Sun Jul 15 17:20:09 2007
***************
*** 133,138 ****
--- 133,139 ----
  static void	get_flags __ARGS((exarg_T *eap));
  #if !defined(FEAT_PERL) || !defined(FEAT_PYTHON) || !defined(FEAT_TCL) \
  	|| !defined(FEAT_RUBY) || !defined(FEAT_MZSCHEME)
+ # define HAVE_EX_SCRIPT_NI
  static void	ex_script_ni __ARGS((exarg_T *eap));
  #endif
  static char_u	*invalid_range __ARGS((exarg_T *eap));
***************
*** 2119,2125 ****
  	    !USER_CMDIDX(ea.cmdidx) &&
  #endif
  	    (cmdnames[ea.cmdidx].cmd_func == ex_ni
! 	     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni));
  
  #ifndef FEAT_EVAL
      /*
--- 2120,2129 ----
  	    !USER_CMDIDX(ea.cmdidx) &&
  #endif
  	    (cmdnames[ea.cmdidx].cmd_func == ex_ni
! #ifdef HAVE_EX_SCRIPT_NI
! 	     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni
! #endif
! 	     ));
  
  #ifndef FEAT_EVAL
      /*
***************
*** 3998,4005 ****
  	eap->errmsg = (char_u *)N_("E319: Sorry, the command is not available in this version");
  }
  
! #if !defined(FEAT_PERL) || !defined(FEAT_PYTHON) || !defined(FEAT_TCL) \
! 	|| !defined(FEAT_RUBY) || !defined(FEAT_MZSCHEME)
  /*
   * Function called for script command which is Not Implemented.  NI!
   * Skips over ":perl <<EOF" constructs.
--- 3999,4005 ----
  	eap->errmsg = (char_u *)N_("E319: Sorry, the command is not available in this version");
  }
  
! #ifdef HAVE_EX_SCRIPT_NI
  /*
   * Function called for script command which is Not Implemented.  NI!
   * Skips over ":perl <<EOF" constructs.
*** ../vim-7.1.028/src/version.c	Tue Jul 10 17:25:20 2007
--- src/version.c	Mon Jul 16 20:37:48 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     29,
  /**/

-- 
I used to wonder about the meaning of life.  But I looked it
up in the dictionary under "L" and there it was - the meaning
of life.  It was less than I expected.              - Dogbert

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.030
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.030
Problem:    The "vimtutor" shell script checks for "vim6" but not for "vim7".
	    (Christian Robinson)
Solution:   Check for more versions, but prefer using "vim".
Files:	    src/vimtutor


*** ../vim-7.1.029/src/vimtutor	Sun Jun 13 20:37:33 2004
--- src/vimtutor	Sun Jul  8 17:16:29 2007
***************
*** 39,56 ****
  # remove the copy of the tutor on exit
  trap "rm -rf $TODELETE" 0 1 2 3 9 11 13 15
  
! # Vim could be called "vim" or "vi".  Also check for "vim6", for people who
! # have Vim 5.x installed as "vim" and Vim 6.0 as "vim6".
! testvim=`which vim6 2>/dev/null`
! if test -f "$testvim"; then
! 	VIM=vim6
! else
! 	testvim=`which vim`
  	if test -f "$testvim"; then
! 		VIM=vim
! 	else
! 		VIM=vi
  	fi
  fi
  
  # Use Vim to copy the tutor, it knows the value of $VIMRUNTIME
--- 39,60 ----
  # remove the copy of the tutor on exit
  trap "rm -rf $TODELETE" 0 1 2 3 9 11 13 15
  
! # Vim could be called "vim" or "vi".  Also check for "vimN", for people who
! # have Vim installed with its version number.
! # We anticipate up to a future Vim 8 version :-).
! seq="vim vim8 vim75 vim74 vim73 vim72 vim71 vim70 vim7 vim6 vi"
! for i in $seq; do
! 	testvim=`which $i 2>/dev/null`
  	if test -f "$testvim"; then
! 		VIM=$i
! 		break
  	fi
+ done
+ 
+ # When no Vim version was found fall back to "vim", you'll get an error message
+ # below.
+ if test -z "$VIM"; then
+ 	VIM=vim
  fi
  
  # Use Vim to copy the tutor, it knows the value of $VIMRUNTIME
*** ../vim-7.1.029/src/version.c	Mon Jul 16 20:38:56 2007
--- src/version.c	Tue Jul 17 14:30:51 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     30,
  /**/

-- 
BLACK KNIGHT: I'm invincible!
ARTHUR:       You're a looney.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.031
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.031
Problem:    virtcol([123, '$']) doesn't work. (Michael Schaap)
Solution:   When '$' is used for the column number get the last column.
Files:	    runtime/doc/eval.txt, src/eval.c


*** ../vim-7.1.030/runtime/doc/eval.txt	Tue Jun 19 17:23:46 2007
--- runtime/doc/eval.txt	Wed Jul 11 21:21:28 2007
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Jun 09
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Jul 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 2020,2025 ****
--- 2020,2029 ----
  			    number of characters in the cursor line plus one)
  		    'x	    position of mark x (if the mark is not set, 0 is
  			    returned)
+ 		Additionally {expr} can be [lnum, col]: a |List| with the line
+ 		and column number. Most useful when the column is "$", to get
+ 		the las column of a specific line.  When "lnum" or "col" is
+ 		out of range then col() returns zero.
  		To get the line number use |line()|.  To get both use
  		|getpos()|.
  		For the screen column position use |virtcol()|.
***************
*** 5024,5037 ****
  		position, the returned Number will be the column at the end of
  		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
  		set to 8, it returns 8.
! 		For the use of {expr} see |col()|.  Additionally you can use
! 		[lnum, col]: a |List| with the line and column number.  When
! 		"lnum" or "col" is out of range then virtcol() returns zero.
! 		When 'virtualedit' is used it can be [lnum, col, off], where
  		"off" is the offset in screen columns from the start of the
  		character.  E.g., a position within a <Tab> or after the last
  		character.
- 		For the byte position use |col()|.
  		When Virtual editing is active in the current mode, a position
  		beyond the end of the line can be returned. |'virtualedit'|
  		The accepted positions are:
--- 5029,5040 ----
  		position, the returned Number will be the column at the end of
  		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
  		set to 8, it returns 8.
! 		For the byte position use |col()|.
! 		For the use of {expr} see |col()|.
! 		When 'virtualedit' is used {expr} can be [lnum, col, off], where
  		"off" is the offset in screen columns from the start of the
  		character.  E.g., a position within a <Tab> or after the last
  		character.
  		When Virtual editing is active in the current mode, a position
  		beyond the end of the line can be returned. |'virtualedit'|
  		The accepted positions are:
*** ../vim-7.1.030/src/eval.c	Tue Jul 10 13:27:46 2007
--- src/eval.c	Wed Jul 11 19:50:27 2007
***************
*** 672,678 ****
  static void f_writefile __ARGS((typval_T *argvars, typval_T *rettv));
  
  static int list2fpos __ARGS((typval_T *arg, pos_T *posp, int *fnump));
! static pos_T *var2fpos __ARGS((typval_T *varp, int lnum, int *fnum));
  static int get_env_len __ARGS((char_u **arg));
  static int get_id_len __ARGS((char_u **arg));
  static int get_name_len __ARGS((char_u **arg, char_u **alias, int evaluate, int verbose));
--- 672,678 ----
  static void f_writefile __ARGS((typval_T *argvars, typval_T *rettv));
  
  static int list2fpos __ARGS((typval_T *arg, pos_T *posp, int *fnump));
! static pos_T *var2fpos __ARGS((typval_T *varp, int dollar_lnum, int *fnum));
  static int get_env_len __ARGS((char_u **arg));
  static int get_id_len __ARGS((char_u **arg));
  static int get_name_len __ARGS((char_u **arg, char_u **alias, int evaluate, int verbose));
***************
*** 16505,16513 ****
   * Returns NULL when there is an error.
   */
      static pos_T *
! var2fpos(varp, lnum, fnum)
      typval_T	*varp;
!     int		lnum;		/* TRUE when $ is last line */
      int		*fnum;		/* set to fnum for '0, 'A, etc. */
  {
      char_u		*name;
--- 16508,16516 ----
   * Returns NULL when there is an error.
   */
      static pos_T *
! var2fpos(varp, dollar_lnum, fnum)
      typval_T	*varp;
!     int		dollar_lnum;	/* TRUE when $ is last line */
      int		*fnum;		/* set to fnum for '0, 'A, etc. */
  {
      char_u		*name;
***************
*** 16520,16525 ****
--- 16523,16529 ----
  	list_T		*l;
  	int		len;
  	int		error = FALSE;
+ 	listitem_T	*li;
  
  	l = varp->vval.v_list;
  	if (l == NULL)
***************
*** 16535,16540 ****
--- 16539,16552 ----
  	if (error)
  	    return NULL;
  	len = (long)STRLEN(ml_get(pos.lnum));
+ 
+ 	/* We accept "$" for the column number: last column. */
+ 	li = list_find(l, 1L);
+ 	if (li != NULL && li->li_tv.v_type == VAR_STRING
+ 		&& li->li_tv.vval.v_string != NULL
+ 		&& STRCMP(li->li_tv.vval.v_string, "$") == 0)
+ 	    pos.col = len + 1;
+ 
  	/* Accept a position up to the NUL after the line. */
  	if (pos.col == 0 || (int)pos.col > len + 1)
  	    return NULL;	/* invalid column number */
***************
*** 16567,16573 ****
      pos.coladd = 0;
  #endif
  
!     if (name[0] == 'w' && lnum)
      {
  	pos.col = 0;
  	if (name[1] == '0')		/* "w0": first visible line */
--- 16579,16585 ----
      pos.coladd = 0;
  #endif
  
!     if (name[0] == 'w' && dollar_lnum)
      {
  	pos.col = 0;
  	if (name[1] == '0')		/* "w0": first visible line */
***************
*** 16585,16591 ****
      }
      else if (name[0] == '$')		/* last column or line */
      {
! 	if (lnum)
  	{
  	    pos.lnum = curbuf->b_ml.ml_line_count;
  	    pos.col = 0;
--- 16597,16603 ----
      }
      else if (name[0] == '$')		/* last column or line */
      {
! 	if (dollar_lnum)
  	{
  	    pos.lnum = curbuf->b_ml.ml_line_count;
  	    pos.col = 0;
*** ../vim-7.1.030/src/version.c	Tue Jul 17 14:32:07 2007
--- src/version.c	Tue Jul 17 16:24:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     31,
  /**/

-- 
CRONE:  Who sent you?
ARTHUR: The Knights Who Say GNU!
CRONE:  Aaaagh!  (she looks around in rear) No!  We have no licenses here.
           "Monty Python and the Holy editor wars" PYTHON (MONTY) SOFTWARE LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.032
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.032
Problem:    Potential crash when editing a command line. (Chris Monson)
Solution:   Check the position to avoid access before the start of an array.
Files:	    src/ex_getln.c


*** ../vim-7.1.031/src/ex_getln.c	Thu May 10 20:22:29 2007
--- src/ex_getln.c	Tue Jul 17 18:05:49 2007
***************
*** 484,490 ****
  	if (xpc.xp_context == EXPAND_MENUNAMES && p_wmnu)
  	{
  	    /* Hitting <Down> after "emenu Name.": complete submenu */
! 	    if (ccline.cmdbuff[ccline.cmdpos - 1] == '.' && c == K_DOWN)
  		c = p_wc;
  	    else if (c == K_UP)
  	    {
--- 486,493 ----
  	if (xpc.xp_context == EXPAND_MENUNAMES && p_wmnu)
  	{
  	    /* Hitting <Down> after "emenu Name.": complete submenu */
! 	    if (c == K_DOWN && ccline.cmdpos > 0
! 				  && ccline.cmdbuff[ccline.cmdpos - 1] == '.')
  		c = p_wc;
  	    else if (c == K_UP)
  	    {
***************
*** 533,541 ****
  	    upseg[3] = PATHSEP;
  	    upseg[4] = NUL;
  
! 	    if (ccline.cmdbuff[ccline.cmdpos - 1] == PATHSEP
! 		    && c == K_DOWN
! 		    && (ccline.cmdbuff[ccline.cmdpos - 2] != '.'
  			|| ccline.cmdbuff[ccline.cmdpos - 3] != '.'))
  	    {
  		/* go down a directory */
--- 536,546 ----
  	    upseg[3] = PATHSEP;
  	    upseg[4] = NUL;
  
! 	    if (c == K_DOWN
! 		    && ccline.cmdpos > 0
! 		    && ccline.cmdbuff[ccline.cmdpos - 1] == PATHSEP
! 		    && (ccline.cmdpos < 3
! 			|| ccline.cmdbuff[ccline.cmdpos - 2] != '.'
  			|| ccline.cmdbuff[ccline.cmdpos - 3] != '.'))
  	    {
  		/* go down a directory */
***************
*** 730,737 ****
  	    /* In Ex mode a backslash escapes a newline. */
  	    if (exmode_active
  		    && c != ESC
- 		    && ccline.cmdpos > 0
  		    && ccline.cmdpos == ccline.cmdlen
  		    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\')
  	    {
  		if (c == K_KENTER)
--- 735,742 ----
  	    /* In Ex mode a backslash escapes a newline. */
  	    if (exmode_active
  		    && c != ESC
  		    && ccline.cmdpos == ccline.cmdlen
+ 		    && ccline.cmdpos > 0
  		    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\')
  	    {
  		if (c == K_KENTER)
*** ../vim-7.1.031/src/version.c	Tue Jul 17 16:31:15 2007
--- src/version.c	Tue Jul 17 18:10:37 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     32,
  /**/

-- 
ALL:   A witch!  A witch!
WITCH: It's a fair cop.
ALL:   Burn her!  Burn her!  Let's make her into a ladder.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.033
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.033
Problem:    A buffer is marked modified when it was first deleted and then
	    added again using a ":next" command. (John Mullin)
Solution:   When checking if a buffer is modified use the BF_NEVERLOADED flag.
Files:	    src/option.c


*** ../vim-7.1.032/src/option.c	Tue Jun 19 20:56:52 2007
--- src/option.c	Sun Jul 22 16:42:47 2007
***************
*** 10624,10629 ****
--- 10624,10632 ----
  file_ff_differs(buf)
      buf_T	*buf;
  {
+     /* In a buffer that was never loaded the options are not valid. */
+     if (buf->b_flags & BF_NEVERLOADED)
+ 	return FALSE;
      if ((buf->b_flags & BF_NEW)
  	    && buf->b_ml.ml_line_count == 1
  	    && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)
*** ../vim-7.1.032/src/version.c	Tue Jul 17 18:14:14 2007
--- src/version.c	Mon Jul 23 09:45:44 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     33,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
8. Don't use any punctuation marks.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.034
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.034
Problem:    Win64: A few compiler warnings.  Problems with optimizer.
Solution:   Use int instead of size_t.  Disable the optimizer in one function.
	    (George V.  Reilly)
Files:	    src/eval.c, src/spell.c


*** ../vim-7.1.033/src/eval.c	Tue Jul 17 16:31:15 2007
--- src/eval.c	Wed Jul 11 19:50:27 2007
***************
*** 992,1011 ****
      char_u	*value;
      int		value_len;
  {
!     size_t	len;
  
      if (redir_lval == NULL)
  	return;
  
      if (value_len == -1)
! 	len = STRLEN(value);	/* Append the entire string */
      else
! 	len = value_len;	/* Append only "value_len" characters */
  
!     if (ga_grow(&redir_ga, (int)len) == OK)
      {
  	mch_memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, len);
! 	redir_ga.ga_len += (int)len;
      }
      else
  	var_redir_stop();
--- 992,1011 ----
      char_u	*value;
      int		value_len;
  {
!     int		len;
  
      if (redir_lval == NULL)
  	return;
  
      if (value_len == -1)
! 	len = (int)STRLEN(value);	/* Append the entire string */
      else
! 	len = value_len;		/* Append only "value_len" characters */
  
!     if (ga_grow(&redir_ga, len) == OK)
      {
  	mch_memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, len);
! 	redir_ga.ga_len += len;
      }
      else
  	var_redir_stop();
*** ../vim-7.1.033/src/spell.c	Thu May 10 18:45:53 2007
--- src/spell.c	Sat Jul 14 17:17:52 2007
***************
*** 7829,7835 ****
  # if (_MSC_VER <= 1200)
  /* This line is required for VC6 without the service pack.  Also see the
   * matching #pragma below. */
! /* # pragma optimize("", off) */
  # endif
  #endif
  
--- 7829,7835 ----
  # if (_MSC_VER <= 1200)
  /* This line is required for VC6 without the service pack.  Also see the
   * matching #pragma below. */
!  #  pragma optimize("", off)
  # endif
  #endif
  
***************
*** 7859,7865 ****
  
  #ifdef _MSC_VER
  # if (_MSC_VER <= 1200)
! /* # pragma optimize("", on) */
  # endif
  #endif
  
--- 7859,7865 ----
  
  #ifdef _MSC_VER
  # if (_MSC_VER <= 1200)
!  #  pragma optimize("", on)
  # endif
  #endif
  
*** ../vim-7.1.033/src/version.c	Tue Jul 24 09:50:22 2007
--- src/version.c	Tue Jul 24 09:47:17 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     34,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
17. When the money comes out the ATM, scream "I won!, I won! 3rd
    time this week!!!!!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.035
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.035
Problem:    After ":s/./&/#" all listed lines have a line number. (Yakov
	    Lerner)
Solution:   Reset the line number flag when not using the "&" flag.
Files:	    src/ex_cmds.c


*** ../vim-7.1.034/src/ex_cmds.c	Tue Jul 10 17:25:20 2007
--- src/ex_cmds.c	Sat Jul 14 14:39:38 2007
***************
*** 4316,4321 ****
--- 4316,4322 ----
  	do_error = TRUE;
  	do_print = FALSE;
  	do_count = FALSE;
+ 	do_number = FALSE;
  	do_ic = 0;
      }
      while (*cmd)
*** ../vim-7.1.034/src/version.c	Tue Jul 24 10:44:10 2007
--- src/version.c	Tue Jul 24 11:15:09 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     35,
  /**/

-- 
The startling truth finally became apparent, and it was this: Numbers
written on restaurant checks within the confines of restaurants do not follow
the same mathematical laws as numbers written on any other pieces of paper in
any other parts of the Universe.  This single statement took the scientific
world by storm.  So many mathematical conferences got held in such good
restaurants that many of the finest minds of a generation died of obesity and
heart failure, and the science of mathematics was put back by years.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.036
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.036
Problem:    Completing ":echohl" argument should include "None". (Ori
	    Avtalion)  ":match" should have "none" too.
Solution:   Add flags to use expand_highlight().  Also fix that when disabling
	    FEAT_CMDL_COMPL compilation fails.  (Chris Lubinski)
Files:	    src/eval.c, src/ex_docmd.c, src/ex_getln.c, src/proto/syntax.pro
	    src/syntax.c


*** ../vim-7.1.035/src/eval.c	Tue Jul 24 10:44:10 2007
--- src/eval.c	Wed Jul 11 19:50:27 2007
***************
*** 1411,1417 ****
  }
  
  
! #if (defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)) || defined(PROTO)
  /*
   * Call some vimL function and return the result in "*rettv".
   * Uses argv[argc] for the function arguments.
--- 1411,1418 ----
  }
  
  
! #if (defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)) \
! 	|| defined(FEAT_COMPL_FUNC) || defined(PROTO)
  /*
   * Call some vimL function and return the result in "*rettv".
   * Uses argv[argc] for the function arguments.
***************
*** 1484,1489 ****
--- 1485,1491 ----
      return ret;
  }
  
+ # if (defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)) || defined(PROTO)
  /*
   * Call vimL function "func" and return the result as a string.
   * Returns NULL when calling the function fails.
***************
*** 1506,1513 ****
      clear_tv(&rettv);
      return retval;
  }
  
! #if defined(FEAT_COMPL_FUNC) || defined(PROTO)
  /*
   * Call vimL function "func" and return the result as a number.
   * Returns -1 when calling the function fails.
--- 1508,1516 ----
      clear_tv(&rettv);
      return retval;
  }
+ # endif
  
! # if defined(FEAT_COMPL_FUNC) || defined(PROTO)
  /*
   * Call vimL function "func" and return the result as a number.
   * Returns -1 when calling the function fails.
***************
*** 1530,1536 ****
      clear_tv(&rettv);
      return retval;
  }
! #endif
  
  /*
   * Call vimL function "func" and return the result as a list
--- 1533,1539 ----
      clear_tv(&rettv);
      return retval;
  }
! # endif
  
  /*
   * Call vimL function "func" and return the result as a list
***************
*** 1556,1563 ****
  
      return rettv.vval.v_list;
  }
- 
  #endif
  
  /*
   * Save the current function call pointer, and set it to NULL.
--- 1559,1566 ----
  
      return rettv.vval.v_list;
  }
  #endif
+ 
  
  /*
   * Save the current function call pointer, and set it to NULL.
*** ../vim-7.1.035/src/ex_docmd.c	Mon Jul 16 20:38:56 2007
--- src/ex_docmd.c	Sun Jul 15 17:20:09 2007
***************
*** 3406,3419 ****
  	case CMD_windo:
  	    return arg;
  
! #ifdef FEAT_SEARCH_EXTRA
  	case CMD_match:
  	    if (*arg == NUL || !ends_excmd(*arg))
  	    {
! 		/* Dummy call to clear variables. */
! 		set_context_in_highlight_cmd(xp, (char_u *)"link n");
! 		xp->xp_context = EXPAND_HIGHLIGHT;
! 		xp->xp_pattern = arg;
  		arg = skipwhite(skiptowhite(arg));
  		if (*arg != NUL)
  		{
--- 3406,3418 ----
  	case CMD_windo:
  	    return arg;
  
! #ifdef FEAT_CMDL_COMPL
! # ifdef FEAT_SEARCH_EXTRA
  	case CMD_match:
  	    if (*arg == NUL || !ends_excmd(*arg))
  	    {
! 		/* also complete "None" */
! 		set_context_in_echohl_cmd(xp, arg);
  		arg = skipwhite(skiptowhite(arg));
  		if (*arg != NUL)
  		{
***************
*** 3422,3430 ****
  		}
  	    }
  	    return find_nextcmd(arg);
! #endif
  
- #ifdef FEAT_CMDL_COMPL
  /*
   * All completion for the +cmdline_compl feature goes here.
   */
--- 3421,3428 ----
  		}
  	    }
  	    return find_nextcmd(arg);
! # endif
  
  /*
   * All completion for the +cmdline_compl feature goes here.
   */
***************
*** 3622,3629 ****
  	    break;
  
  	case CMD_echohl:
! 	    xp->xp_context = EXPAND_HIGHLIGHT;
! 	    xp->xp_pattern = arg;
  	    break;
  #endif
  	case CMD_highlight:
--- 3620,3626 ----
  	    break;
  
  	case CMD_echohl:
! 	    set_context_in_echohl_cmd(xp, arg);
  	    break;
  #endif
  	case CMD_highlight:
*** ../vim-7.1.035/src/ex_getln.c	Tue Jul 17 18:14:14 2007
--- src/ex_getln.c	Tue Jul 17 18:05:49 2007
***************
*** 268,274 ****
--- 268,276 ----
      {
  	xpc.xp_context = ccline.xp_context;
  	xpc.xp_pattern = ccline.cmdbuff;
+ # if defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)
  	xpc.xp_arg = ccline.xp_arg;
+ # endif
      }
  #endif
  
***************
*** 4151,4163 ****
--- 4153,4171 ----
  
  #ifdef FEAT_EVAL
      if (ccline.cmdfirstc == '=')
+     {
+ # ifdef FEAT_CMDL_COMPL
  	/* pass CMD_SIZE because there is no real command */
  	set_context_for_expression(xp, str, CMD_SIZE);
+ # endif
+     }
      else if (ccline.input_fn)
      {
  	xp->xp_context = ccline.xp_context;
  	xp->xp_pattern = ccline.cmdbuff;
+ # if defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)
  	xp->xp_arg = ccline.xp_arg;
+ # endif
      }
      else
  #endif
***************
*** 4504,4509 ****
--- 4512,4523 ----
      /* Sort the results.  Keep menu's in the specified order. */
      if (xp->xp_context != EXPAND_MENUNAMES && xp->xp_context != EXPAND_MENUS)
  	sort_strings(*file, *num_file);
+ 
+ #ifdef FEAT_CMDL_COMPL
+     /* Reset the variables used for special highlight names expansion, so that
+      * they don't show up when getting normal highlight names by ID. */
+     reset_expand_highlight();
+ #endif
  
      return OK;
  }
*** ../vim-7.1.035/src/proto/syntax.pro	Sat May  5 19:23:52 2007
--- src/proto/syntax.pro	Fri Jul 13 19:51:43 2007
***************
*** 8,13 ****
--- 8,15 ----
  void syntax_clear __ARGS((buf_T *buf));
  void ex_syntax __ARGS((exarg_T *eap));
  int syntax_present __ARGS((buf_T *buf));
+ void reset_expand_highlight __ARGS((void));
+ void set_context_in_echohl_cmd __ARGS((expand_T *xp, char_u *arg));
  void set_context_in_syntax_cmd __ARGS((expand_T *xp, char_u *arg));
  char_u *get_syntax_name __ARGS((expand_T *xp, int idx));
  int syn_get_id __ARGS((win_T *wp, long lnum, colnr_T col, int trans, int *spellp));
*** ../vim-7.1.035/src/syntax.c	Thu Jun 28 11:59:13 2007
--- src/syntax.c	Fri Jul 13 19:51:39 2007
***************
*** 66,73 ****
  #define HL_TABLE() ((struct hl_group *)((highlight_ga.ga_data)))
  
  #ifdef FEAT_CMDL_COMPL
! static int include_default = FALSE;	/* include "default" for expansion */
! static int include_link = FALSE;	/* include "link" for expansion */
  #endif
  
  /*
--- 66,75 ----
  #define HL_TABLE() ((struct hl_group *)((highlight_ga.ga_data)))
  
  #ifdef FEAT_CMDL_COMPL
! /* Flags to indicate an additional string for highlight name completion. */
! static int include_none = 0;	/* when 1 include "None" */
! static int include_default = 0;	/* when 1 include "default" */
! static int include_link = 0;	/* when 2 include "link" and "clear" */
  #endif
  
  /*
***************
*** 5968,5973 ****
--- 5970,5998 ----
      EXP_CASE	    /* expand ":syn case" arguments */
  } expand_what;
  
+ /*
+  * Reset include_link, include_default, include_none to 0.
+  * Called when we are done expanding.
+  */
+     void
+ reset_expand_highlight()
+ {
+     include_link = include_default = include_none = 0;
+ }
+ 
+ /*
+  * Handle command line completion for :match and :echohl command: Add "None"
+  * as highlight group.
+  */
+     void
+ set_context_in_echohl_cmd(xp, arg)
+     expand_T	*xp;
+     char_u	*arg;
+ {
+     xp->xp_context = EXPAND_HIGHLIGHT;
+     xp->xp_pattern = arg;
+     include_none = 1;
+ }
  
  /*
   * Handle command line completion for :syntax command.
***************
*** 5983,5990 ****
      xp->xp_context = EXPAND_SYNTAX;
      expand_what = EXP_SUBCMD;
      xp->xp_pattern = arg;
!     include_link = FALSE;
!     include_default = FALSE;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
--- 6008,6015 ----
      xp->xp_context = EXPAND_SYNTAX;
      expand_what = EXP_SUBCMD;
      xp->xp_pattern = arg;
!     include_link = 0;
!     include_default = 0;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
***************
*** 8949,8955 ****
      return OK;
  }
  
! #ifdef FEAT_CMDL_COMPL
  
  static void highlight_list __ARGS((void));
  static void highlight_list_two __ARGS((int cnt, int attr));
--- 8974,8980 ----
      return OK;
  }
  
! #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
  
  static void highlight_list __ARGS((void));
  static void highlight_list_two __ARGS((int cnt, int attr));
***************
*** 8967,8974 ****
      /* Default: expand group names */
      xp->xp_context = EXPAND_HIGHLIGHT;
      xp->xp_pattern = arg;
!     include_link = TRUE;
!     include_default = TRUE;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
--- 8992,8999 ----
      /* Default: expand group names */
      xp->xp_context = EXPAND_HIGHLIGHT;
      xp->xp_pattern = arg;
!     include_link = 2;
!     include_default = 1;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
***************
*** 8976,8982 ****
  	p = skiptowhite(arg);
  	if (*p != NUL)			/* past "default" or group name */
  	{
! 	    include_default = FALSE;
  	    if (STRNCMP("default", arg, p - arg) == 0)
  	    {
  		arg = skipwhite(p);
--- 9001,9007 ----
  	p = skiptowhite(arg);
  	if (*p != NUL)			/* past "default" or group name */
  	{
! 	    include_default = 0;
  	    if (STRNCMP("default", arg, p - arg) == 0)
  	    {
  		arg = skipwhite(p);
***************
*** 8985,8991 ****
  	    }
  	    if (*p != NUL)			/* past group name */
  	    {
! 		include_link = FALSE;
  		if (arg[1] == 'i' && arg[0] == 'N')
  		    highlight_list();
  		if (STRNCMP("link", arg, p - arg) == 0
--- 9010,9016 ----
  	    }
  	    if (*p != NUL)			/* past group name */
  	    {
! 		include_link = 0;
  		if (arg[1] == 'i' && arg[0] == 'N')
  		    highlight_list();
  		if (STRNCMP("link", arg, p - arg) == 0
***************
*** 9045,9075 ****
      expand_T	*xp;
      int		idx;
  {
-     if (idx == highlight_ga.ga_len
  #ifdef FEAT_CMDL_COMPL
! 	    && include_link
! #endif
! 	    )
  	return (char_u *)"link";
!     if (idx == highlight_ga.ga_len + 1
! #ifdef FEAT_CMDL_COMPL
! 	    && include_link
! #endif
! 	    )
  	return (char_u *)"clear";
-     if (idx == highlight_ga.ga_len + 2
- #ifdef FEAT_CMDL_COMPL
- 	    && include_default
  #endif
- 	    )
- 	return (char_u *)"default";
      if (idx < 0 || idx >= highlight_ga.ga_len)
  	return NULL;
      return HL_TABLE()[idx].sg_name;
  }
  #endif
  
! #ifdef FEAT_GUI
  /*
   * Free all the highlight group fonts.
   * Used when quitting for systems which need it.
--- 9070,9094 ----
      expand_T	*xp;
      int		idx;
  {
  #ifdef FEAT_CMDL_COMPL
!     if (idx == highlight_ga.ga_len && include_none != 0)
! 	return (char_u *)"none";
!     if (idx == highlight_ga.ga_len + include_none && include_default != 0)
! 	return (char_u *)"default";
!     if (idx == highlight_ga.ga_len + include_none + include_default
! 							 && include_link != 0)
  	return (char_u *)"link";
!     if (idx == highlight_ga.ga_len + include_none + include_default + 1
! 							 && include_link != 0)
  	return (char_u *)"clear";
  #endif
      if (idx < 0 || idx >= highlight_ga.ga_len)
  	return NULL;
      return HL_TABLE()[idx].sg_name;
  }
  #endif
  
! #if defined(FEAT_GUI) || defined(PROTO)
  /*
   * Free all the highlight group fonts.
   * Used when quitting for systems which need it.
*** ../vim-7.1.035/src/version.c	Tue Jul 24 11:15:46 2007
--- src/version.c	Tue Jul 24 14:30:18 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     36,
  /**/

-- 
Apparently, 1 in 5 people in the world are Chinese.  And there are 5
people in my family, so it must be one of them.  It's either my mum
or my dad.  Or my older brother Colin.  Or my younger brother
Ho-Cha-Chu.  But I think it's Colin.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.037
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.037
Problem:    strcpy() used for overlapping strings. (Chris Monson)
Solution:   Use mch_memmove() instead.
Files:	    src/option.c


*** ../vim-7.1.036/src/option.c	Tue Jul 24 09:50:22 2007
--- src/option.c	Sun Jul 22 16:42:47 2007
***************
*** 4628,4634 ****
  				    if ((!(flags & P_COMMA) || *s != ',')
  					    && vim_strchr(s + 1, *s) != NULL)
  				    {
! 					STRCPY(s, s + 1);
  					--s;
  				    }
  			    }
--- 4628,4634 ----
  				    if ((!(flags & P_COMMA) || *s != ',')
  					    && vim_strchr(s + 1, *s) != NULL)
  				    {
! 					mch_memmove(s, s + 1, STRLEN(s));
  					--s;
  				    }
  			    }
*** ../vim-7.1.036/src/version.c	Tue Jul 24 14:32:44 2007
--- src/version.c	Tue Jul 24 14:56:03 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     37,
  /**/

-- 
This planet has -- or rather had -- a problem, which was this: most
of the people living on it were unhappy for pretty much of the time.
Many solutions were suggested for this problem, but most of these
were largely concerned with the movements of small green pieces of
paper, which is odd because on the whole it wasn't the small green
pieces of paper that were unhappy.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.038
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.038
Problem:    When 'expandtab' is set then a Tab copied for 'copyindent' is
	    expanded to spaces, even when 'preserveindent' is set. (Alexei
	    Alexandrov)
Solution:   Remove the check for 'expandtab'.  Also fix that ">>" doesn't obey
	    'preserveindent'. (Chris Lubinski)
Files:	    src/misc1.c


*** ../vim-7.1.037/src/misc1.c	Thu May 10 21:03:33 2007
--- src/misc1.c	Tue Jul 24 15:24:50 2007
***************
*** 90,96 ****
   */
      int
  set_indent(size, flags)
!     int		size;
      int		flags;
  {
      char_u	*p;
--- 90,96 ----
   */
      int
  set_indent(size, flags)
!     int		size;		    /* measured in spaces */
      int		flags;
  {
      char_u	*p;
***************
*** 98,109 ****
      char_u	*oldline;
      char_u	*s;
      int		todo;
!     int		ind_len;
      int		line_len;
      int		doit = FALSE;
!     int		ind_done;
      int		tab_pad;
      int		retval = FALSE;
  
      /*
       * First check if there is anything to do and compute the number of
--- 98,111 ----
      char_u	*oldline;
      char_u	*s;
      int		todo;
!     int		ind_len;	    /* measured in characters */
      int		line_len;
      int		doit = FALSE;
!     int		ind_done = 0;	    /* measured in spaces */
      int		tab_pad;
      int		retval = FALSE;
+     int		orig_char_len = 0;  /* number of initial whitespace chars when
+ 				       'et' and 'pi' are both set */
  
      /*
       * First check if there is anything to do and compute the number of
***************
*** 116,123 ****
      /* Calculate the buffer size for the new indent, and check to see if it
       * isn't already set */
  
!     /* if 'expandtab' isn't set: use TABs */
!     if (!curbuf->b_p_et)
      {
  	/* If 'preserveindent' is set then reuse as much as possible of
  	 * the existing indent structure for the new indent */
--- 118,127 ----
      /* Calculate the buffer size for the new indent, and check to see if it
       * isn't already set */
  
!     /* if 'expandtab' isn't set: use TABs; if both 'expandtab' and
!      * 'preserveindent' are set count the number of characters at the
!      * beginning of the line to be copied */
!     if (!curbuf->b_p_et || (!(flags & SIN_INSERT) && curbuf->b_p_pi))
      {
  	/* If 'preserveindent' is set then reuse as much as possible of
  	 * the existing indent structure for the new indent */
***************
*** 148,156 ****
  		++p;
  	    }
  
  	    /* Fill to next tabstop with a tab, if possible */
  	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
! 	    if (todo >= tab_pad)
  	    {
  		doit = TRUE;
  		todo -= tab_pad;
--- 152,165 ----
  		++p;
  	    }
  
+ 	    /* Set initial number of whitespace chars to copy if we are
+ 	     * preserving indent but expandtab is set */
+ 	    if (curbuf->b_p_et)
+ 		orig_char_len = ind_len;
+ 
  	    /* Fill to next tabstop with a tab, if possible */
  	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
! 	    if (todo >= tab_pad && orig_char_len == 0)
  	    {
  		doit = TRUE;
  		todo -= tab_pad;
***************
*** 193,205 ****
      else
  	p = skipwhite(p);
      line_len = (int)STRLEN(p) + 1;
!     newline = alloc(ind_len + line_len);
!     if (newline == NULL)
! 	return FALSE;
  
      /* Put the characters in the new line. */
-     s = newline;
-     todo = size;
      /* if 'expandtab' isn't set: use TABs */
      if (!curbuf->b_p_et)
      {
--- 202,239 ----
      else
  	p = skipwhite(p);
      line_len = (int)STRLEN(p) + 1;
! 
!     /* If 'preserveindent' and 'expandtab' are both set keep the original
!      * characters and allocate accordingly.  We will fill the rest with spaces
!      * after the if (!curbuf->b_p_et) below. */
!     if (orig_char_len != 0)
!     {
! 	newline = alloc(orig_char_len + size - ind_done + line_len);
! 	if (newline == NULL)
! 	    return FALSE;
! 	p = oldline;
! 	s = newline;
! 	while (orig_char_len > 0)
! 	{
! 	    *s++ = *p++;
! 	    orig_char_len--;
! 	}
! 	/* Skip over any additional white space (useful when newindent is less
! 	 * than old) */
! 	while (vim_iswhite(*p))
! 	    (void)*p++;
! 	todo = size-ind_done;
!     }
!     else
!     {
! 	todo = size;
! 	newline = alloc(ind_len + line_len);
! 	if (newline == NULL)
! 	    return FALSE;
! 	s = newline;
!     }
  
      /* Put the characters in the new line. */
      /* if 'expandtab' isn't set: use TABs */
      if (!curbuf->b_p_et)
      {
***************
*** 1320,1327 ****
  	    newindent += (int)curbuf->b_p_sw;
  	}
  #endif
! 	/* Copy the indent only if expand tab is disabled */
! 	if (curbuf->b_p_ci && !curbuf->b_p_et)
  	{
  	    (void)copy_indent(newindent, saved_line);
  
--- 1354,1361 ----
  	    newindent += (int)curbuf->b_p_sw;
  	}
  #endif
! 	/* Copy the indent */
! 	if (curbuf->b_p_ci)
  	{
  	    (void)copy_indent(newindent, saved_line);
  
*** ../vim-7.1.037/src/version.c	Tue Jul 24 14:57:16 2007
--- src/version.c	Tue Jul 24 15:22:44 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     38,
  /**/

-- 
Time is an illusion.  Lunchtime doubly so.
		-- Ford Prefect, in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.039
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.039
Problem:    A tag in a help file that starts with "help-tags" and contains a
	    percent sign may make Vim crash. (Ulf Harnhammar)
Solution:   Use puts() instead of fprintf().
Files:	    src/ex_cmds.c


*** ../vim-7.1.038/src/ex_cmds.c	Tue Jul 24 11:15:46 2007
--- src/ex_cmds.c	Wed Jul 25 20:06:20 2007
***************
*** 6374,6382 ****
  	for (i = 0; i < ga.ga_len; ++i)
  	{
  	    s = ((char_u **)ga.ga_data)[i];
! 	    if (STRNCMP(s, "help-tags", 9) == 0)
  		/* help-tags entry was added in formatted form */
! 		fprintf(fd_tags, (char *)s);
  	    else
  	    {
  		fprintf(fd_tags, "%s\t/*", s);
--- 6374,6382 ----
  	for (i = 0; i < ga.ga_len; ++i)
  	{
  	    s = ((char_u **)ga.ga_data)[i];
! 	    if (STRNCMP(s, "help-tags\t", 10) == 0)
  		/* help-tags entry was added in formatted form */
! 		fputs((char *)s, fd_tags);
  	    else
  	    {
  		fprintf(fd_tags, "%s\t/*", s);
*** ../vim-7.1.038/src/version.c	Tue Jul 24 15:25:27 2007
--- src/version.c	Wed Jul 25 22:41:18 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     39,
  /**/

-- 
On the other hand, you have different fingers.
                                      -- Steven Wright

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.041 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.041 (extra, after 7.1.040)
Problem:    Some changes for patch 7.1.0 are in extra files.
Solution:   Update the extra files.
Files:	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_os2.mak, src/testdir/Make_vms.mms


*** ../vim-7.1.040/src/testdir/Make_amiga.mak	Sun Apr 30 20:42:49 2006
--- src/testdir/Make_amiga.mak	Tue Jul 24 15:36:00 2007
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out
  
  .SUFFIXES: .in .out
  
--- 25,31 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out
  
  .SUFFIXES: .in .out
  
***************
*** 107,109 ****
--- 107,110 ----
  test60.out: test60.in
  test61.out: test61.in
  test62.out: test62.in
+ test63.out: test63.in
*** ../vim-7.1.040/src/testdir/Make_dos.mak	Sun Apr 30 20:41:13 2006
--- src/testdir/Make_dos.mak	Tue Jul 24 15:37:47 2007
***************
*** 19,25 ****
  		test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out \
  		test55.out test56.out test57.out test58.out test59.out \
! 		test60.out test61.out test62.out
  
  SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
  		test8.out test9.out test11.out test13.out test14.out \
--- 19,25 ----
  		test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out \
  		test55.out test56.out test57.out test58.out test59.out \
! 		test60.out test61.out test62.out test63.out
  
  SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
  		test8.out test9.out test11.out test13.out test14.out \
*** ../vim-7.1.040/src/testdir/Make_os2.mak	Sun Apr 30 20:29:29 2006
--- src/testdir/Make_os2.mak	Tue Jul 24 15:39:15 2007
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out
  
  .SUFFIXES: .in .out
  
--- 25,31 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out
  
  .SUFFIXES: .in .out
  
*** ../vim-7.1.040/src/testdir/Make_vms.mms	Sun Apr 30 20:51:12 2006
--- src/testdir/Make_vms.mms	Tue Jul 24 15:39:23 2007
***************
*** 4,10 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2006 Apr 30
  #
  # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
--- 4,10 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2007 Jul 24
  #
  # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
***************
*** 59,65 ****
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test58.out test59.out test60.out \
! 	 test61.out test62.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
--- 59,65 ----
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test58.out test59.out test60.out \
! 	 test61.out test62.out test63.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
*** ../vim-7.1.040/src/version.c	Thu Jul 26 22:55:11 2007
--- src/version.c	Thu Jul 26 22:58:57 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     41,
  /**/

-- 
Just remember...if the world didn't suck, we'd all fall off.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.043
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.043
Problem:    In Ex mode using CTRL-D twice may cause a crash.  Cursor isn't
	    positioned properly after CTRL-D.
Solution:   Set prev_char properly.  Position the cursor correctly. (Antony
	    Scriven)
Files:	    src/ex_getln.c


*** ../vim-7.1.042/src/ex_getln.c	Tue Jul 24 14:32:44 2007
--- src/ex_getln.c	Wed Jul 25 20:57:05 2007
***************
*** 2095,2105 ****
      garray_T	line_ga;
      char_u	*pend;
      int		startcol = 0;
!     int		c1;
      int		escaped = FALSE;	/* CTRL-V typed */
      int		vcol = 0;
      char_u	*p;
!     int		prev_char = 0;
  
      /* Switch cursor on now.  This avoids that it happens after the "\n", which
       * confuses the system function that computes tabstops. */
--- 2095,2105 ----
      garray_T	line_ga;
      char_u	*pend;
      int		startcol = 0;
!     int		c1 = 0;
      int		escaped = FALSE;	/* CTRL-V typed */
      int		vcol = 0;
      char_u	*p;
!     int		prev_char;
  
      /* Switch cursor on now.  This avoids that it happens after the "\n", which
       * confuses the system function that computes tabstops. */
***************
*** 2152,2157 ****
--- 2152,2158 ----
  
  	/* Get one character at a time.  Don't use inchar(), it can't handle
  	 * special characters. */
+ 	prev_char = c1;
  	c1 = vgetc();
  
  	/*
***************
*** 2209,2215 ****
  redraw:
  		/* redraw the line */
  		msg_col = startcol;
- 		windgoto(msg_row, msg_col);
  		vcol = 0;
  		for (p = (char_u *)line_ga.ga_data;
  			  p < (char_u *)line_ga.ga_data + line_ga.ga_len; ++p)
--- 2210,2215 ----
***************
*** 2228,2233 ****
--- 2228,2234 ----
  		    }
  		}
  		msg_clr_eos();
+ 		windgoto(msg_row, msg_col);
  		continue;
  	    }
  
***************
*** 2273,2279 ****
  	if (IS_SPECIAL(c1))
  	    c1 = '?';
  	((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;
- 	prev_char = c1;
  	if (c1 == '\n')
  	    msg_putchar('\n');
  	else if (c1 == TAB)
--- 2274,2279 ----
*** ../vim-7.1.042/src/version.c	Fri Jul 27 21:32:13 2007
--- src/version.c	Sat Jul 28 14:19:37 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     43,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
48. You get a tatoo that says "This body best viewed with Netscape 3.1 or
    higher."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.044
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.044
Problem:    In Insert mode 0 CTRL-T deletes all indent, it should add indent.
	    (Gautam Iyer)
Solution:   Check for CTRL-D typed.
Files:	    src/edit.c


*** ../vim-7.1.043/src/edit.c	Thu Jun 28 12:44:56 2007
--- src/edit.c	Wed Jul 25 22:50:28 2007
***************
*** 8000,8006 ****
      /*
       * 0^D and ^^D: remove all indent.
       */
!     if ((lastc == '0' || lastc == '^') && curwin->w_cursor.col)
      {
  	--curwin->w_cursor.col;
  	(void)del_char(FALSE);		/* delete the '^' or '0' */
--- 8000,8007 ----
      /*
       * 0^D and ^^D: remove all indent.
       */
!     if (c == Ctrl_D && (lastc == '0' || lastc == '^')
! 						  && curwin->w_cursor.col > 0)
      {
  	--curwin->w_cursor.col;
  	(void)del_char(FALSE);		/* delete the '^' or '0' */
*** ../vim-7.1.043/src/version.c	Sat Jul 28 14:21:04 2007
--- src/version.c	Sun Jul 29 14:14:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     44,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
54. You start tilting your head sideways to smile. :-)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.045
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.045
Problem:    Unnecessary screen redrawing. (Jjgod Jiang)
Solution:   Reset "must_redraw" after clearing the screen.
Files:	    src/screen.c


*** ../vim-7.1.044/src/screen.c	Thu Jul 26 22:55:11 2007
--- src/screen.c	Mon Jul 30 21:39:32 2007
***************
*** 331,336 ****
--- 331,341 ----
      {
  	if (type < must_redraw)	    /* use maximal type */
  	    type = must_redraw;
+ 
+ 	/* must_redraw is reset here, so that when we run into some weird
+ 	 * reason to redraw while busy redrawing (e.g., asynchronous
+ 	 * scrolling), or update_topline() in win_update() will cause a
+ 	 * scroll, the screen will be redrawn later or in win_update(). */
  	must_redraw = 0;
      }
  
***************
*** 1019,1024 ****
--- 1024,1036 ----
  	    type = VALID;
      }
  
+     /* Trick: we want to avoid clearning the screen twice.  screenclear() will
+      * set "screen_cleared" to TRUE.  The special value MAYBE (which is still
+      * non-zero and thus not FALSE) will indicate that screenclear() was not
+      * called. */
+     if (screen_cleared)
+ 	screen_cleared = MAYBE;
+ 
      /*
       * If there are no changes on the screen that require a complete redraw,
       * handle three cases:
***************
*** 1220,1226 ****
  	    mid_end = wp->w_height;
  	    if (lastwin == firstwin)
  	    {
! 		screenclear();
  #ifdef FEAT_WINDOWS
  		/* The screen was cleared, redraw the tab pages line. */
  		if (redraw_tabline)
--- 1232,1242 ----
  	    mid_end = wp->w_height;
  	    if (lastwin == firstwin)
  	    {
! 		/* Clear the screen when it was not done by win_del_lines() or
! 		 * win_ins_lines() above, "screen_cleared" is FALSE or MAYBE
! 		 * then. */
! 		if (screen_cleared != TRUE)
! 		    screenclear();
  #ifdef FEAT_WINDOWS
  		/* The screen was cleared, redraw the tab pages line. */
  		if (redraw_tabline)
***************
*** 1228,1233 ****
--- 1244,1256 ----
  #endif
  	    }
  	}
+ 
+ 	/* When win_del_lines() or win_ins_lines() caused the screen to be
+ 	 * cleared (only happens for the first window) or when screenclear()
+ 	 * was called directly above, "must_redraw" will have been set to
+ 	 * NOT_VALID, need to reset it here to avoid redrawing twice. */
+ 	if (screen_cleared == TRUE)
+ 	    must_redraw = 0;
      }
      else
      {
*** ../vim-7.1.044/src/version.c	Sun Jul 29 15:02:34 2007
--- src/version.c	Mon Jul 30 21:58:06 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     45,
  /**/

-- 
Be thankful to be in a traffic jam, because it means you own a car.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.046
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.046
Problem:    ":s" command removes combining characters. (Ron Aaron)
Solution:   Copy composing characters individually. (Chris Lubinski)
Files:	    src/regexp.c


*** ../vim-7.1.045/src/regexp.c	Thu May 10 19:58:01 2007
--- src/regexp.c	Fri Jul 27 21:17:47 2007
***************
*** 7014,7020 ****
  #ifdef FEAT_MBYTE
  			    if (has_mbyte)
  			    {
! 				int l = mb_ptr2len(s) - 1;
  
  				s += l;
  				len -= l;
--- 7014,7027 ----
  #ifdef FEAT_MBYTE
  			    if (has_mbyte)
  			    {
! 				int l;
! 
! 				/* Copy composing characters separately, one
! 				 * at a time. */
! 				if (enc_utf8)
! 				    l = utf_ptr2len(s) - 1;
! 				else
! 				    l = mb_ptr2len(s) - 1;
  
  				s += l;
  				len -= l;
*** ../vim-7.1.045/src/version.c	Mon Jul 30 21:59:50 2007
--- src/version.c	Mon Jul 30 22:30:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     46,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
57. You begin to wonder how on earth your service provider is allowed to call
    200 hours per month "unlimited."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.047
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.047
Problem:    vim_regcomp() called with invalid argument. (Xiaozhou Liu)
Solution:   Change TRUE to RE_MAGIC + RE_STRING.
Files:	    src/ex_eval.c


*** ../vim-7.1.046/src/ex_eval.c	Thu May 10 20:23:50 2007
--- src/ex_eval.c	Sat Jul 28 13:09:00 2007
***************
*** 1551,1557 ****
  		}
  		save_cpo  = p_cpo;
  		p_cpo = (char_u *)"";
! 		regmatch.regprog = vim_regcomp(pat, TRUE);
  		regmatch.rm_ic = FALSE;
  		if (end != NULL)
  		    *end = save_char;
--- 1551,1557 ----
  		}
  		save_cpo  = p_cpo;
  		p_cpo = (char_u *)"";
! 		regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);
  		regmatch.rm_ic = FALSE;
  		if (end != NULL)
  		    *end = save_char;
*** ../vim-7.1.046/src/version.c	Mon Jul 30 22:32:11 2007
--- src/version.c	Wed Aug  1 15:46:28 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     47,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
80. At parties, you introduce your spouse as your "service provider."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.048
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.048
Problem:    The matchparen plugin doesn't update the match when scrolling with
	    the mouse wheel. (Ilya Bobir)
Solution:   Set the match highlighting for text that can be scrolled into the
	    viewable area without moving the cursor. (Chris Lubinski)
Files:	    runtime/plugin/matchparen.vim


*** ../vim-7.1.047/runtime/plugin/matchparen.vim	Sun May  6 14:26:16 2007
--- runtime/plugin/matchparen.vim	Mon Jul 30 21:14:06 2007
***************
*** 1,6 ****
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2006 Oct 12
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
--- 1,6 ----
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2007 Jul 30
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
***************
*** 62,86 ****
    " Figure out the arguments for searchpairpos().
    " Restrict the search to visible lines with "stopline".
    " And avoid searching very far (e.g., for closed folds and long lines)
    if i % 2 == 0
      let s_flags = 'nW'
      let c2 = plist[i + 1]
      if has("byte_offset") && has("syntax_items") && &smc > 0
        let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
!       let stopline = min([line('w$'), byte2line(stopbyte)])
      else
!       let stopline = min([line('w$'), c_lnum + 100])
      endif
    else
      let s_flags = 'nbW'
      let c2 = c
      let c = plist[i - 1]
      if has("byte_offset") && has("syntax_items") && &smc > 0
        let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
!       let stopline = max([line('w0'), byte2line(stopbyte)])
      else
!       let stopline = max([line('w0'), c_lnum - 100])
      endif
    endif
    if c == '['
      let c = '\['
--- 62,98 ----
    " Figure out the arguments for searchpairpos().
    " Restrict the search to visible lines with "stopline".
    " And avoid searching very far (e.g., for closed folds and long lines)
+   " The "viewable" variables give a range in which we can scroll while keeping
+   " the cursor at the same position
+   " adjustedScrolloff accounts for very large numbers of scrolloff
+   let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
+   let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
+   let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
+   " one of these stoplines will be adjusted below, but the current values are
+   " minimal boundaries within the current window
+   let stoplinebottom = line('w$')
+   let stoplinetop = line('w0')
    if i % 2 == 0
      let s_flags = 'nW'
      let c2 = plist[i + 1]
      if has("byte_offset") && has("syntax_items") && &smc > 0
        let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
!       let stopline = min([bottom_viewable, byte2line(stopbyte)])
      else
!       let stopline = min([bottom_viewable, c_lnum + 100])
      endif
+     let stoplinebottom = stopline
    else
      let s_flags = 'nbW'
      let c2 = c
      let c = plist[i - 1]
      if has("byte_offset") && has("syntax_items") && &smc > 0
        let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
!       let stopline = max([top_viewable, byte2line(stopbyte)])
      else
!       let stopline = max([top_viewable, c_lnum - 100])
      endif
+     let stoplinetop = stopline
    endif
    if c == '['
      let c = '\['
***************
*** 106,112 ****
    endif
  
    " If a match is found setup match highlighting.
!   if m_lnum > 0 && m_lnum >= line('w0') && m_lnum <= line('w$')
      exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
  	  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
      let w:paren_hl_on = 1
--- 118,124 ----
    endif
  
    " If a match is found setup match highlighting.
!   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
      exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
  	  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
      let w:paren_hl_on = 1
*** ../vim-7.1.047/src/version.c	Wed Aug  1 15:47:06 2007
--- src/version.c	Thu Aug  2 22:59:07 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     48,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
91. It's Saturday afternoon in the middle of May and you
    are on computer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.049
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.049
Problem:    Cannot compile GTK2 version with Hangul input feature.
Solution:   Don't define FEAT_XFONTSET when using GTK2.
Files:	    src/feature.h


*** ../vim-7.1.048/src/feature.h	Thu May 10 19:43:24 2007
--- src/feature.h	Fri Aug  3 19:32:56 2007
***************
*** 673,679 ****
  # define ESC_CHG_TO_ENG_MODE		/* if defined, when ESC pressed,
  					 * turn to english mode
  					 */
! # if !defined(FEAT_XFONTSET) && defined(HAVE_X11)
  #  define FEAT_XFONTSET			/* Hangul input requires xfontset */
  # endif
  # if defined(FEAT_XIM) && !defined(LINT)
--- 673,679 ----
  # define ESC_CHG_TO_ENG_MODE		/* if defined, when ESC pressed,
  					 * turn to english mode
  					 */
! # if !defined(FEAT_XFONTSET) && defined(HAVE_X11) && !defined(HAVE_GTK2)
  #  define FEAT_XFONTSET			/* Hangul input requires xfontset */
  # endif
  # if defined(FEAT_XIM) && !defined(LINT)
*** ../vim-7.1.048/src/version.c	Thu Aug  2 23:00:06 2007
--- src/version.c	Fri Aug  3 21:58:23 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     49,
  /**/

-- 
From "know your smileys":
 :-O>-o   Smiley American tourist (note big mouth and camera)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.050
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.050
Problem:    Possible crash when using C++ indenting. (Chris Monson)
Solution:   Keep the line pointer to the line to compare with.  Avoid going
	    past the end of line.
Files:	    src/misc1.c


*** ../vim-7.1.049/src/misc1.c	Tue Jul 24 15:25:27 2007
--- src/misc1.c	Fri Aug  3 21:07:17 2007
***************
*** 4820,4826 ****
  static int	cin_iswhileofdo __ARGS((char_u *, linenr_T, int));
  static int	cin_iswhileofdo_end __ARGS((int terminated, int	ind_maxparen, int ind_maxcomment));
  static int	cin_isbreak __ARGS((char_u *));
! static int	cin_is_cpp_baseclass __ARGS((char_u *line, colnr_T *col));
  static int	get_baseclass_amount __ARGS((int col, int ind_maxparen, int ind_maxcomment, int ind_cpp_baseclass));
  static int	cin_ends_in __ARGS((char_u *, char_u *, char_u *));
  static int	cin_skip2pos __ARGS((pos_T *trypos));
--- 4820,4826 ----
  static int	cin_iswhileofdo __ARGS((char_u *, linenr_T, int));
  static int	cin_iswhileofdo_end __ARGS((int terminated, int	ind_maxparen, int ind_maxcomment));
  static int	cin_isbreak __ARGS((char_u *));
! static int	cin_is_cpp_baseclass __ARGS((colnr_T *col));
  static int	get_baseclass_amount __ARGS((int col, int ind_maxparen, int ind_maxcomment, int ind_cpp_baseclass));
  static int	cin_ends_in __ARGS((char_u *, char_u *, char_u *));
  static int	cin_skip2pos __ARGS((pos_T *trypos));
***************
*** 5585,5597 ****
   * This is a lot of guessing.  Watch out for "cond ? func() : foo".
   */
      static int
! cin_is_cpp_baseclass(line, col)
!     char_u	*line;
      colnr_T	*col;	    /* return: column to align with */
  {
      char_u	*s;
      int		class_or_struct, lookfor_ctor_init, cpp_base_class;
      linenr_T	lnum = curwin->w_cursor.lnum;
  
      *col = 0;
  
--- 5585,5597 ----
   * This is a lot of guessing.  Watch out for "cond ? func() : foo".
   */
      static int
! cin_is_cpp_baseclass(col)
      colnr_T	*col;	    /* return: column to align with */
  {
      char_u	*s;
      int		class_or_struct, lookfor_ctor_init, cpp_base_class;
      linenr_T	lnum = curwin->w_cursor.lnum;
+     char_u	*line = ml_get_curline();
  
      *col = 0;
  
***************
*** 5619,5625 ****
       */
      while (lnum > 1)
      {
! 	s = skipwhite(ml_get(lnum - 1));
  	if (*s == '#' || *s == NUL)
  	    break;
  	while (*s != NUL)
--- 5619,5626 ----
       */
      while (lnum > 1)
      {
! 	line = ml_get(lnum - 1);
! 	s = skipwhite(line);
  	if (*s == '#' || *s == NUL)
  	    break;
  	while (*s != NUL)
***************
*** 5636,5642 ****
  	--lnum;
      }
  
!     s = cin_skipcomment(ml_get(lnum));
      for (;;)
      {
  	if (*s == NUL)
--- 5637,5644 ----
  	--lnum;
      }
  
!     line = ml_get(lnum);
!     s = cin_skipcomment(line);
      for (;;)
      {
  	if (*s == NUL)
***************
*** 5644,5650 ****
  	    if (lnum == curwin->w_cursor.lnum)
  		break;
  	    /* Continue in the cursor line. */
! 	    s = cin_skipcomment(ml_get(++lnum));
  	}
  
  	if (s[0] == ':')
--- 5646,5655 ----
  	    if (lnum == curwin->w_cursor.lnum)
  		break;
  	    /* Continue in the cursor line. */
! 	    line = ml_get(++lnum);
! 	    s = cin_skipcomment(line);
! 	    if (*s == NUL)
! 		continue;
  	}
  
  	if (s[0] == ':')
***************
*** 7113,7119 ****
  		n = FALSE;
  		if (lookfor != LOOKFOR_TERM && ind_cpp_baseclass > 0)
  		{
! 		    n = cin_is_cpp_baseclass(l, &col);
  		    l = ml_get_curline();
  		}
  		if (n)
--- 7118,7124 ----
  		n = FALSE;
  		if (lookfor != LOOKFOR_TERM && ind_cpp_baseclass > 0)
  		{
! 		    n = cin_is_cpp_baseclass(&col);
  		    l = ml_get_curline();
  		}
  		if (n)
***************
*** 7704,7710 ****
  		n = FALSE;
  		if (ind_cpp_baseclass != 0 && theline[0] != '{')
  		{
! 		    n = cin_is_cpp_baseclass(l, &col);
  		    l = ml_get_curline();
  		}
  		if (n)
--- 7709,7715 ----
  		n = FALSE;
  		if (ind_cpp_baseclass != 0 && theline[0] != '{')
  		{
! 		    n = cin_is_cpp_baseclass(&col);
  		    l = ml_get_curline();
  		}
  		if (n)
*** ../vim-7.1.049/src/version.c	Fri Aug  3 22:01:35 2007
--- src/version.c	Sat Aug  4 12:11:51 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     50,
  /**/

-- 
From "know your smileys":
 |-P	Reaction to unusually ugly C code

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.051
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.051
Problem:    Accessing uninitialized memory when finding spell suggestions.
Solution:   Don't try swapping characters at the end of a word.
Files:	    src/spell.c


*** ../vim-7.1.050/src/spell.c	Tue Jul 24 10:44:10 2007
--- src/spell.c	Sun Aug  5 16:59:48 2007
***************
*** 12182,12188 ****
  	    {
  		n = mb_cptr2len(p);
  		c = mb_ptr2char(p);
! 		if (!soundfold && !spell_iswordp(p + n, curbuf))
  		    c2 = c; /* don't swap non-word char */
  		else
  		    c2 = mb_ptr2char(p + n);
--- 12182,12190 ----
  	    {
  		n = mb_cptr2len(p);
  		c = mb_ptr2char(p);
! 		if (p[n] == NUL)
! 		    c2 = NUL;
! 		else if (!soundfold && !spell_iswordp(p + n, curbuf))
  		    c2 = c; /* don't swap non-word char */
  		else
  		    c2 = mb_ptr2char(p + n);
***************
*** 12190,12199 ****
  	    else
  #endif
  	    {
! 		if (!soundfold && !spell_iswordp(p + 1, curbuf))
  		    c2 = c; /* don't swap non-word char */
  		else
  		    c2 = p[1];
  	    }
  
  	    /* When characters are identical, swap won't do anything.
--- 12192,12210 ----
  	    else
  #endif
  	    {
! 		if (p[1] == NUL)
! 		    c2 = NUL;
! 		else if (!soundfold && !spell_iswordp(p + 1, curbuf))
  		    c2 = c; /* don't swap non-word char */
  		else
  		    c2 = p[1];
+ 	    }
+ 
+ 	    /* When the second character is NUL we can't swap. */
+ 	    if (c2 == NUL)
+ 	    {
+ 		sp->ts_state = STATE_REP_INI;
+ 		break;
  	    }
  
  	    /* When characters are identical, swap won't do anything.
*** ../vim-7.1.050/src/version.c	Sat Aug  4 12:14:04 2007
--- src/version.c	Sun Aug  5 18:31:09 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     51,
  /**/

-- 
From "know your smileys":
 8<}}	Glasses, big nose, beard

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.053
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.053
Problem:    Accessing uninitialized memory when giving a message.
Solution:   Check going the length before checking for a NUL byte.
Files:	    src/message.c


*** ../vim-7.1.052/src/message.c	Thu Jul  5 10:10:29 2007
--- src/message.c	Sat Aug  4 23:13:58 2007
***************
*** 1842,1848 ****
      int		wrap;
  
      did_wait_return = FALSE;
!     while (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))
      {
  	/*
  	 * We are at the end of the screen line when:
--- 1842,1848 ----
      int		wrap;
  
      did_wait_return = FALSE;
!     while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)
      {
  	/*
  	 * We are at the end of the screen line when:
*** ../vim-7.1.052/src/version.c	Sun Aug  5 18:49:07 2007
--- src/version.c	Sun Aug  5 19:18:46 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     53,
  /**/

-- 
From "know your smileys":
 <>:-)	Bishop

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.054
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.054
Problem:    Accessing uninitialized memory when displaying the fold column.
Solution:   Add a NUL to the extra array. (Dominique Pelle).  Also do this in
	    a couple of other situations.
Files:	    src/screen.c


*** ../vim-7.1.053/src/screen.c	Mon Jul 30 21:59:50 2007
--- src/screen.c	Sun Aug  5 16:10:53 2007
***************
*** 2555,2561 ****
  
      char_u	extra[18];		/* "%ld" and 'fdc' must fit in here */
      int		n_extra = 0;		/* number of extra chars */
!     char_u	*p_extra = NULL;	/* string of extra chars */
      int		c_extra = NUL;		/* extra chars, all the same */
      int		extra_attr = 0;		/* attributes when n_extra != 0 */
      static char_u *at_end_str = (char_u *)""; /* used for p_extra when
--- 2555,2561 ----
  
      char_u	extra[18];		/* "%ld" and 'fdc' must fit in here */
      int		n_extra = 0;		/* number of extra chars */
!     char_u	*p_extra = NULL;	/* string of extra chars, plus NUL */
      int		c_extra = NUL;		/* extra chars, all the same */
      int		extra_attr = 0;		/* attributes when n_extra != 0 */
      static char_u *at_end_str = (char_u *)""; /* used for p_extra when
***************
*** 3189,3198 ****
  		if (cmdwin_type != 0 && wp == curwin)
  		{
  		    /* Draw the cmdline character. */
- 		    *extra = cmdwin_type;
  		    n_extra = 1;
! 		    p_extra = extra;
! 		    c_extra = NUL;
  		    char_attr = hl_attr(HLF_AT);
  		}
  	    }
--- 3189,3196 ----
  		if (cmdwin_type != 0 && wp == curwin)
  		{
  		    /* Draw the cmdline character. */
  		    n_extra = 1;
! 		    c_extra = cmdwin_type;
  		    char_attr = hl_attr(HLF_AT);
  		}
  	    }
***************
*** 3208,3213 ****
--- 3206,3212 ----
  		    fill_foldcolumn(extra, wp, FALSE, lnum);
  		    n_extra = wp->w_p_fdc;
  		    p_extra = extra;
+ 		    p_extra[n_extra] = NUL;
  		    c_extra = NUL;
  		    char_attr = hl_attr(HLF_FC);
  		}
***************
*** 3550,3558 ****
  	 * Get the next character to put on the screen.
  	 */
  	/*
! 	 * The 'extra' array contains the extra stuff that is inserted to
! 	 * represent special characters (non-printable stuff).  When all
! 	 * characters are the same, c_extra is used.
  	 * For the '$' of the 'list' option, n_extra == 1, p_extra == "".
  	 */
  	if (n_extra > 0)
--- 3549,3559 ----
  	 * Get the next character to put on the screen.
  	 */
  	/*
! 	 * The "p_extra" points to the extra stuff that is inserted to
! 	 * represent special characters (non-printable stuff) and other
! 	 * things.  When all characters are the same, c_extra is used.
! 	 * "p_extra" must end in a NUL to avoid mb_ptr2len() reads past
! 	 * "p_extra[n_extra]".
  	 * For the '$' of the 'list' option, n_extra == 1, p_extra == "".
  	 */
  	if (n_extra > 0)
***************
*** 3808,3817 ****
  		 * a '<' in the first column. */
  		if (n_skip > 0 && mb_l > 1)
  		{
- 		    extra[0] = '<';
- 		    p_extra = extra;
  		    n_extra = 1;
! 		    c_extra = NUL;
  		    c = ' ';
  		    if (area_attr == 0 && search_attr == 0)
  		    {
--- 3809,3816 ----
  		 * a '<' in the first column. */
  		if (n_skip > 0 && mb_l > 1)
  		{
  		    n_extra = 1;
! 		    c_extra = '<';
  		    c = ' ';
  		    if (area_attr == 0 && search_attr == 0)
  		    {
***************
*** 6204,6211 ****
  	return;
  
      off = LineOffset[row] + col;
!     while (*ptr != NUL && col < screen_Columns
! 				      && (len < 0 || (int)(ptr - text) < len))
      {
  	c = *ptr;
  #ifdef FEAT_MBYTE
--- 6203,6211 ----
  	return;
  
      off = LineOffset[row] + col;
!     while (col < screen_Columns
! 	    && (len < 0 || (int)(ptr - text) < len)
! 	    && *ptr != NUL)
      {
  	c = *ptr;
  #ifdef FEAT_MBYTE
*** ../vim-7.1.053/src/version.c	Sun Aug  5 19:20:04 2007
--- src/version.c	Sun Aug  5 20:07:47 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     54,
  /**/

-- 
From "know your smileys":
 +<(:-) The Pope

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.055
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.055
Problem:    Using strcpy() with arguments that overlap.
Solution:   Use mch_memmove() instead.
Files:	    src/buffer.c, src/charset.c, src/eval.c, src/ex_getln.c,
	    src/misc1.c, src/regexp.c, src/termlib.c


*** ../vim-7.1.054/src/buffer.c	Tue Jun 19 15:40:51 2007
--- src/buffer.c	Sun Aug  5 16:14:03 2007
***************
*** 4860,4866 ****
  	     */
  	    for (e = s; *e != ':' && *e != NUL; ++e)
  		if (e[0] == '\\' && e[1] == ':')
! 		    STRCPY(e, e + 1);
  	    if (*e == NUL)
  		end = TRUE;
  
--- 4860,4866 ----
  	     */
  	    for (e = s; *e != ':' && *e != NUL; ++e)
  		if (e[0] == '\\' && e[1] == ':')
! 		    mch_memmove(e, e + 1, STRLEN(e));
  	    if (*e == NUL)
  		end = TRUE;
  
*** ../vim-7.1.054/src/charset.c	Tue Mar 27 12:41:45 2007
--- src/charset.c	Sun Aug  5 21:53:44 2007
***************
*** 1898,1904 ****
  {
      for ( ; *p; ++p)
  	if (rem_backslash(p))
! 	    STRCPY(p, p + 1);
  }
  
  /*
--- 1898,1904 ----
  {
      for ( ; *p; ++p)
  	if (rem_backslash(p))
! 	    mch_memmove(p, p + 1, STRLEN(p));
  }
  
  /*
*** ../vim-7.1.054/src/eval.c	Fri Jul 27 21:32:13 2007
--- src/eval.c	Sun Aug  5 16:25:03 2007
***************
*** 13807,13813 ****
  	    }
  	    /* Shorten "remain". */
  	    if (*q != NUL)
! 		STRCPY(remain, q - 1);
  	    else
  	    {
  		vim_free(remain);
--- 13807,13813 ----
  	    }
  	    /* Shorten "remain". */
  	    if (*q != NUL)
! 		mch_memmove(remain, q - 1, STRLEN(q - 1) + 1);
  	    else
  	    {
  		vim_free(remain);
*** ../vim-7.1.054/src/ex_getln.c	Sat Jul 28 14:21:04 2007
--- src/ex_getln.c	Sun Aug  5 21:55:56 2007
***************
*** 4306,4315 ****
  			    && pat[i + 1] == '\\'
  			    && pat[i + 2] == '\\'
  			    && pat[i + 3] == ' ')
! 			STRCPY(pat + i, pat + i + 3);
  		    if (xp->xp_backslash == XP_BS_ONE
  			    && pat[i + 1] == ' ')
! 			STRCPY(pat + i, pat + i + 1);
  		}
  	}
  
--- 4306,4316 ----
  			    && pat[i + 1] == '\\'
  			    && pat[i + 2] == '\\'
  			    && pat[i + 3] == ' ')
! 			mch_memmove(pat + i, pat + i + 3,
! 						     STRLEN(pat + i + 3) + 1);
  		    if (xp->xp_backslash == XP_BS_ONE
  			    && pat[i + 1] == ' ')
! 			mch_memmove(pat + i, pat + i + 1, STRLEN(pat + i));
  		}
  	}
  
***************
*** 4552,4558 ****
      pat = vim_strsave(filepat);
      for (i = 0; pat[i]; ++i)
  	if (pat[i] == '\\' && pat[i + 1] == ' ')
! 	    STRCPY(pat + i, pat + i + 1);
  
      flags |= EW_FILE | EW_EXEC;
  
--- 4553,4559 ----
      pat = vim_strsave(filepat);
      for (i = 0; pat[i]; ++i)
  	if (pat[i] == '\\' && pat[i + 1] == ' ')
! 	    mch_memmove(pat + i, pat + i + 1, STRLEN(pat + i));
  
      flags |= EW_FILE | EW_EXEC;
  
*** ../vim-7.1.054/src/misc1.c	Sat Aug  4 12:14:04 2007
--- src/misc1.c	Sun Aug  5 21:57:15 2007
***************
*** 8635,8641 ****
      for (p = buf + wildoff; p < s; ++p)
  	if (rem_backslash(p))
  	{
! 	    STRCPY(p, p + 1);
  	    --e;
  	    --s;
  	}
--- 8635,8641 ----
      for (p = buf + wildoff; p < s; ++p)
  	if (rem_backslash(p))
  	{
! 	    mch_memmove(p, p + 1, STRLEN(p));
  	    --e;
  	    --s;
  	}
***************
*** 8936,8942 ****
      for (p = buf + wildoff; p < s; ++p)
  	if (rem_backslash(p))
  	{
! 	    STRCPY(p, p + 1);
  	    --e;
  	    --s;
  	}
--- 8936,8942 ----
      for (p = buf + wildoff; p < s; ++p)
  	if (rem_backslash(p))
  	{
! 	    mch_memmove(p, p + 1, STRLEN(p));
  	    --e;
  	    --s;
  	}
*** ../vim-7.1.054/src/regexp.c	Mon Jul 30 22:32:11 2007
--- src/regexp.c	Sun Aug  5 15:43:27 2007
***************
*** 6637,6645 ****
  		}
  	    }
  	    else if (magic)
! 		STRCPY(p, p + 1);		/* remove '~' */
  	    else
! 		STRCPY(p, p + 2);		/* remove '\~' */
  	    --p;
  	}
  	else
--- 6638,6646 ----
  		}
  	    }
  	    else if (magic)
! 		mch_memmove(p, p + 1, STRLEN(p));	/* remove '~' */
  	    else
! 		mch_memmove(p, p + 2, STRLEN(p) - 1);	/* remove '\~' */
  	    --p;
  	}
  	else
*** ../vim-7.1.054/src/termlib.c	Thu May 10 20:20:59 2007
--- src/termlib.c	Sun Aug  5 21:52:41 2007
***************
*** 191,197 ****
  	    lbuf[0] == '\t' &&
  	    lbuf[1] == ':')
  	{
! 	    strcpy(lbuf, lbuf+2);
  	    llen -= 2;
  	}
  	if (lbuf[llen-2] == '\\')		/* and continuations */
--- 191,197 ----
  	    lbuf[0] == '\t' &&
  	    lbuf[1] == ':')
  	{
! 	    mch_memmove(lbuf, lbuf + 2, strlen(lbuf + 2) + 1);
  	    llen -= 2;
  	}
  	if (lbuf[llen-2] == '\\')		/* and continuations */
*** ../vim-7.1.054/src/version.c	Sun Aug  5 20:10:16 2007
--- src/version.c	Mon Aug  6 21:34:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     55,
  /**/

-- 
From "know your smileys":
 %	Bike accident.  A bit far-fetched, I suppose; although...
             o      _     _         _
     _o     /\_   _ \\o  (_)\__/o  (_)
   _< \_   _>(_) (_)/<_    \_| \   _|/' \/
  (_)>(_) (_)        (_)   (_)    (_)'  _\o_

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.056
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.056
Problem:    More prompt does not behave correctly after scrolling back.
	    (Randall W. Morris)
Solution:   Avoid lines_left becomes negative. (Chris Lubinski)  Don't check
	    mp_last when deciding to show the more prompt. (Martin Toft)
Files:	    src/message.c


*** ../vim-7.1.055/src/message.c	Sun Aug  5 19:20:04 2007
--- src/message.c	Tue Aug  7 21:52:10 2007
***************
*** 1878,1884 ****
  		/* output postponed text */
  		t_puts(&t_col, t_s, s, attr);
  
! 	    /* When no more prompt an no more room, truncate here */
  	    if (msg_no_more && lines_left == 0)
  		break;
  
--- 1878,1884 ----
  		/* output postponed text */
  		t_puts(&t_col, t_s, s, attr);
  
! 	    /* When no more prompt and no more room, truncate here */
  	    if (msg_no_more && lines_left == 0)
  		break;
  
***************
*** 1927,1933 ****
  	     * If screen is completely filled and 'more' is set then wait
  	     * for a character.
  	     */
! 	    --lines_left;
  	    if (p_more && lines_left == 0 && State != HITRETURN
  					    && !msg_no_more && !exmode_active)
  	    {
--- 1927,1934 ----
  	     * If screen is completely filled and 'more' is set then wait
  	     * for a character.
  	     */
! 	    if (lines_left > 0)
! 		--lines_left;
  	    if (p_more && lines_left == 0 && State != HITRETURN
  					    && !msg_no_more && !exmode_active)
  	    {
***************
*** 2234,2240 ****
  {
      msgchunk_T	*mp;
  
!     /* Only show somethign if there is more than one line, otherwise it looks
       * weird, typing a command without output results in one line. */
      mp = msg_sb_start(last_msgchunk);
      if (mp == NULL || mp->sb_prev == NULL)
--- 2235,2241 ----
  {
      msgchunk_T	*mp;
  
!     /* Only show something if there is more than one line, otherwise it looks
       * weird, typing a command without output results in one line. */
      mp = msg_sb_start(last_msgchunk);
      if (mp == NULL || mp->sb_prev == NULL)
***************
*** 2622,2628 ****
  		}
  	    }
  
! 	    if (scroll < 0 || (scroll == 0 && mp_last != NULL))
  	    {
  		/* displayed the requested text, more prompt again */
  		screen_fill((int)Rows - 1, (int)Rows, 0,
--- 2623,2629 ----
  		}
  	    }
  
! 	    if (scroll <= 0)
  	    {
  		/* displayed the requested text, more prompt again */
  		screen_fill((int)Rows - 1, (int)Rows, 0,
*** ../vim-7.1.055/src/version.c	Mon Aug  6 22:27:13 2007
--- src/version.c	Tue Aug  7 21:57:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     56,
  /**/

-- 
From "know your smileys":
 :-| :-|   Deja' vu!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.057
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.057
Problem:    Problem with CursorHoldI when using "r" in Visual mode (Max
            Dyckhoff)
Solution:   Ignore CursorHold(I) when getting a second character for a Normal
            mode command.  Also abort the "r" command in Visual when a special
            key is typed.
Files:      src/normal.c


*** ../vim-7.1.056/src/normal.c	Tue Jul 10 14:02:51 2007
--- src/normal.c	Sun Aug  5 21:57:43 2007
***************
*** 889,894 ****
--- 889,899 ----
  
  	++no_mapping;
  	++allow_keys;		/* no mapping for nchar, but allow key codes */
+ #ifdef FEAT_AUTOCMD
+ 	/* Don't generate a CursorHold event here, most commands can't handle
+ 	 * it, e.g., nv_replace(), nv_csearch(). */
+ 	did_cursorhold = TRUE;
+ #endif
  	if (ca.cmdchar == 'g')
  	{
  	    /*
***************
*** 6662,6667 ****
--- 6668,6680 ----
      else
  	had_ctrl_v = NUL;
  
+     /* Abort if the character is a special key. */
+     if (IS_SPECIAL(cap->nchar))
+     {
+ 	clearopbeep(cap->oap);
+ 	return;
+     }
+ 
  #ifdef FEAT_VISUAL
      /* Visual mode "r" */
      if (VIsual_active)
***************
*** 6688,6698 ****
      }
  #endif
  
!     /*
!      * Check for a special key or not enough characters to replace.
!      */
      ptr = ml_get_cursor();
!     if (IS_SPECIAL(cap->nchar) || STRLEN(ptr) < (unsigned)cap->count1
  #ifdef FEAT_MBYTE
  	    || (has_mbyte && mb_charlen(ptr) < cap->count1)
  #endif
--- 6701,6709 ----
      }
  #endif
  
!     /* Abort if not enough characters to replace. */
      ptr = ml_get_cursor();
!     if (STRLEN(ptr) < (unsigned)cap->count1
  #ifdef FEAT_MBYTE
  	    || (has_mbyte && mb_charlen(ptr) < cap->count1)
  #endif
*** ../vim-7.1.056/src/version.c	Tue Aug  7 21:59:26 2007
--- src/version.c	Wed Aug  8 21:39:43 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     57,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
95. Only communication in your household is through email.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.058
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.058
Problem:    When 'rightleft' is set the completion menu is positioned wrong.
	    (Baha-Eddine MOKADEM)
Solution:   Fix the completion menu. (Martin Toft)
Files:	    src/popupmnu.c, src/proto/search.pro, src/search.c


*** ../vim-7.1.057/src/popupmnu.c	Thu Jun 28 21:23:52 2007
--- src/popupmnu.c	Wed Aug  1 15:43:06 2007
***************
*** 75,81 ****
  
      row = curwin->w_cline_row + W_WINROW(curwin);
      height = curwin->w_cline_height;
-     col = curwin->w_wcol + W_WINCOL(curwin) - curwin->w_leftcol;
  
      if (firstwin->w_p_pvw)
  	top_clear = firstwin->w_height;
--- 75,80 ----
***************
*** 167,172 ****
--- 166,180 ----
      pum_base_width = max_width;
      pum_kind_width = kind_width;
  
+     /* Calculate column */
+ #ifdef FEAT_RIGHTLEFT
+     if (curwin->w_p_rl)
+ 	col = W_WINCOL(curwin) + W_WIDTH(curwin) - curwin->w_wcol -
+ 							curwin->w_leftcol - 1;
+     else
+ #endif
+ 	col = W_WINCOL(curwin) + curwin->w_wcol - curwin->w_leftcol;
+ 
      /* if there are more items than room we need a scrollbar */
      if (pum_height < size)
      {
***************
*** 179,189 ****
      if (def_width < max_width)
  	def_width = max_width;
  
!     if (col < Columns - PUM_DEF_WIDTH || col < Columns - max_width)
      {
  	/* align pum column with "col" */
  	pum_col = col;
! 	pum_width = Columns - pum_col - pum_scrollbar;
  	if (pum_width > max_width + kind_width + extra_width + 1
  						 && pum_width > PUM_DEF_WIDTH)
  	{
--- 187,209 ----
      if (def_width < max_width)
  	def_width = max_width;
  
!     if (((col < Columns - PUM_DEF_WIDTH || col < Columns - max_width)
! #ifdef FEAT_RIGHTLEFT
! 		&& !curwin->w_p_rl)
! 	    || (curwin->w_p_rl && (col > PUM_DEF_WIDTH || col > max_width)
! #endif
!        ))
      {
  	/* align pum column with "col" */
  	pum_col = col;
! 
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	    pum_width = pum_col - pum_scrollbar + 1;
! 	else
! #endif
! 	    pum_width = Columns - pum_col - pum_scrollbar;
! 
  	if (pum_width > max_width + kind_width + extra_width + 1
  						 && pum_width > PUM_DEF_WIDTH)
  	{
***************
*** 195,208 ****
      else if (Columns < def_width)
      {
  	/* not enough room, will use what we have */
! 	pum_col = 0;
  	pum_width = Columns - 1;
      }
      else
      {
  	if (max_width > PUM_DEF_WIDTH)
  	    max_width = PUM_DEF_WIDTH;	/* truncate */
! 	pum_col = Columns - max_width;
  	pum_width = max_width - pum_scrollbar;
      }
  
--- 215,238 ----
      else if (Columns < def_width)
      {
  	/* not enough room, will use what we have */
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	    pum_col = Columns - 1;
! 	else
! #endif
! 	    pum_col = 0;
  	pum_width = Columns - 1;
      }
      else
      {
  	if (max_width > PUM_DEF_WIDTH)
  	    max_width = PUM_DEF_WIDTH;	/* truncate */
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	    pum_col = max_width - 1;
! 	else
! #endif
! 	    pum_col = Columns - max_width;
  	pum_width = max_width - pum_scrollbar;
      }
  
***************
*** 255,262 ****
  	attr = (idx == pum_selected) ? attr_select : attr_norm;
  
  	/* prepend a space if there is room */
! 	if (pum_col > 0)
! 	    screen_putchar(' ', row, pum_col - 1, attr);
  
  	/* Display each entry, use two spaces for a Tab.
  	 * Do this 3 times: For the main text, kind and extra info */
--- 285,300 ----
  	attr = (idx == pum_selected) ? attr_select : attr_norm;
  
  	/* prepend a space if there is room */
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	{
! 	    if (pum_col < W_WINCOL(curwin) + W_WIDTH(curwin) - 1)
! 		screen_putchar(' ', row, pum_col + 1, attr);
! 	}
! 	else
! #endif
! 	    if (pum_col > 0)
! 		screen_putchar(' ', row, pum_col - 1, attr);
  
  	/* Display each entry, use two spaces for a Tab.
  	 * Do this 3 times: For the main text, kind and extra info */
***************
*** 282,307 ****
  		    {
  			/* Display the text that fits or comes before a Tab.
  			 * First convert it to printable characters. */
! 			char_u *st;
! 			int  saved = *p;
  
  			*p = NUL;
  			st = transstr(s);
  			*p = saved;
! 			if (st != NULL)
  			{
! 			    screen_puts_len(st, (int)STRLEN(st), row, col,
  									attr);
! 			    vim_free(st);
  			}
- 			col += width;
  
  			if (*p != TAB)
  			    break;
  
  			/* Display two spaces for a Tab. */
! 			screen_puts_len((char_u *)"  ", 2, row, col, attr);
! 			col += 2;
  			totwidth += 2;
  			s = NULL;	    /* start text at next char */
  			width = 0;
--- 320,386 ----
  		    {
  			/* Display the text that fits or comes before a Tab.
  			 * First convert it to printable characters. */
! 			char_u	*st;
! 			int	saved = *p;
  
  			*p = NUL;
  			st = transstr(s);
  			*p = saved;
! #ifdef FEAT_RIGHTLEFT
! 			if (curwin->w_p_rl)
  			{
! 			    if (st != NULL)
! 			    {
! 				char_u	*rt = reverse_text(st);
! 				char_u	*rt_saved = rt;
! 				int	len, j;
! 
! 				if (rt != NULL)
! 				{
! 				    len = STRLEN(rt);
! 				    if (len > pum_width)
! 				    {
! 					for (j = pum_width; j < len; ++j)
! 					    mb_ptr_adv(rt);
! 					len = pum_width;
! 				    }
! 				    screen_puts_len(rt, len, row,
! 							col - len + 1, attr);
! 				    vim_free(rt_saved);
! 				}
! 				vim_free(st);
! 			    }
! 			    col -= width;
! 			}
! 			else
! #endif
! 			{
! 			    if (st != NULL)
! 			    {
! 				screen_puts_len(st, (int)STRLEN(st), row, col,
  									attr);
! 				vim_free(st);
! 			    }
! 			    col += width;
  			}
  
  			if (*p != TAB)
  			    break;
  
  			/* Display two spaces for a Tab. */
! #ifdef FEAT_RIGHTLEFT
! 			if (curwin->w_p_rl)
! 			{
! 			    screen_puts_len((char_u *)"  ", 2, row, col - 1,
! 									attr);
! 			    col -= 2;
! 			}
! 			else
! #endif
! 			{
! 			    screen_puts_len((char_u *)"  ", 2, row, col, attr);
! 			    col += 2;
! 			}
  			totwidth += 2;
  			s = NULL;	    /* start text at next char */
  			width = 0;
***************
*** 322,338 ****
  					  && pum_array[idx].pum_extra == NULL)
  		    || pum_base_width + n >= pum_width)
  		break;
! 	    screen_fill(row, row + 1, col, pum_col + pum_base_width + n,
  							      ' ', ' ', attr);
! 	    col = pum_col + pum_base_width + n;
  	    totwidth = pum_base_width + n;
  	}
  
! 	screen_fill(row, row + 1, col, pum_col + pum_width, ' ', ' ', attr);
  	if (pum_scrollbar > 0)
! 	    screen_putchar(' ', row, pum_col + pum_width,
! 		    i >= thumb_pos && i < thumb_pos + thumb_heigth
  						  ? attr_thumb : attr_scroll);
  
  	++row;
      }
--- 401,444 ----
  					  && pum_array[idx].pum_extra == NULL)
  		    || pum_base_width + n >= pum_width)
  		break;
! #ifdef FEAT_RIGHTLEFT
! 	    if (curwin->w_p_rl)
! 	    {
! 		screen_fill(row, row + 1, pum_col - pum_base_width - n + 1,
! 						    col + 1, ' ', ' ', attr);
! 		col = pum_col - pum_base_width - n + 1;
! 	    }
! 	    else
! #endif
! 	    {
! 		screen_fill(row, row + 1, col, pum_col + pum_base_width + n,
  							      ' ', ' ', attr);
! 		col = pum_col + pum_base_width + n;
! 	    }
  	    totwidth = pum_base_width + n;
  	}
  
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	    screen_fill(row, row + 1, pum_col - pum_width + 1, col + 1, ' ',
! 								    ' ', attr);
! 	else
! #endif
! 	    screen_fill(row, row + 1, col, pum_col + pum_width, ' ', ' ',
! 									attr);
  	if (pum_scrollbar > 0)
! 	{
! #ifdef FEAT_RIGHTLEFT
! 	    if (curwin->w_p_rl)
! 		screen_putchar(' ', row, pum_col - pum_width,
! 			i >= thumb_pos && i < thumb_pos + thumb_heigth
  						  ? attr_thumb : attr_scroll);
+ 	    else
+ #endif
+ 		screen_putchar(' ', row, pum_col + pum_width,
+ 			i >= thumb_pos && i < thumb_pos + thumb_heigth
+ 						  ? attr_thumb : attr_scroll);
+ 	}
  
  	++row;
      }
*** ../vim-7.1.057/src/proto/search.pro	Sat May  5 20:20:36 2007
--- src/proto/search.pro	Wed Aug  1 12:41:25 2007
***************
*** 1,6 ****
--- 1,7 ----
  /* search.c */
  int search_regcomp __ARGS((char_u *pat, int pat_save, int pat_use, int options, regmmatch_T *regmatch));
  char_u *get_search_pat __ARGS((void));
+ char_u *reverse_text __ARGS((char_u *s));
  void save_search_patterns __ARGS((void));
  void restore_search_patterns __ARGS((void));
  void free_search_patterns __ARGS((void));
*** ../vim-7.1.057/src/search.c	Tue Jul 10 13:27:46 2007
--- src/search.c	Wed Aug  1 12:39:22 2007
***************
*** 101,107 ****
  static char_u	    *mr_pattern = NULL;	/* pattern used by search_regcomp() */
  #ifdef FEAT_RIGHTLEFT
  static int	    mr_pattern_alloced = FALSE; /* mr_pattern was allocated */
- static char_u	    *reverse_text __ARGS((char_u *s));
  #endif
  
  #ifdef FEAT_FIND_ID
--- 101,106 ----
***************
*** 228,239 ****
      return mr_pattern;
  }
  
! #ifdef FEAT_RIGHTLEFT
  /*
   * Reverse text into allocated memory.
   * Returns the allocated string, NULL when out of memory.
   */
!     static char_u *
  reverse_text(s)
      char_u *s;
  {
--- 227,238 ----
      return mr_pattern;
  }
  
! #if defined(FEAT_RIGHTLEFT) || defined(PROTO)
  /*
   * Reverse text into allocated memory.
   * Returns the allocated string, NULL when out of memory.
   */
!     char_u *
  reverse_text(s)
      char_u *s;
  {
***************
*** 1898,1904 ****
      }
  
  #ifdef FEAT_RIGHTLEFT
!     /* This is just guessing: when 'rightleft' is set, search for a maching
       * paren/brace in the other direction. */
      if (curwin->w_p_rl && vim_strchr((char_u *)"()[]{}<>", initc) != NULL)
  	backwards = !backwards;
--- 1897,1903 ----
      }
  
  #ifdef FEAT_RIGHTLEFT
!     /* This is just guessing: when 'rightleft' is set, search for a matching
       * paren/brace in the other direction. */
      if (curwin->w_p_rl && vim_strchr((char_u *)"()[]{}<>", initc) != NULL)
  	backwards = !backwards;
*** ../vim-7.1.057/src/version.c	Wed Aug  8 21:41:19 2007
--- src/version.c	Wed Aug  8 22:44:49 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     58,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
99. The hum of a cooling fan and the click of keys is comforting to you.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.059
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.059
Problem:    When in Ex mode and doing "g/^/vi" and then pressing CTRL-C Vim
	    hangs and beeps. (Antony Scriven)
Solution:   Clear "got_int" in the main loop to avoid the hang.  When typing
	    CTRL-C twice in a row abort the ":g" command.  This is Vi
	    compatible.
Files:	    src/main.c


*** ../vim-7.1.058/src/main.c	Tue Jun 19 20:30:46 2007
--- src/main.c	Tue Aug  7 22:40:35 2007
***************
*** 954,960 ****
      int		cmdwin;	    /* TRUE when working in the command-line window */
      int		noexmode;   /* TRUE when return on entering Ex mode */
  {
!     oparg_T	oa;	/* operator arguments */
  
  #if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)
      /* Setup to catch a terminating error from the X server.  Just ignore
--- 954,961 ----
      int		cmdwin;	    /* TRUE when working in the command-line window */
      int		noexmode;   /* TRUE when return on entering Ex mode */
  {
!     oparg_T	oa;				/* operator arguments */
!     int		previous_got_int = FALSE;	/* "got_int" was TRUE */
  
  #if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)
      /* Setup to catch a terminating error from the X server.  Just ignore
***************
*** 1015,1026 ****
  		need_fileinfo = FALSE;
  	    }
  	}
! 	if (got_int && !global_busy)
  	{
! 	    if (!quit_more)
! 		(void)vgetc();		/* flush all buffers */
! 	    got_int = FALSE;
  	}
  	if (!exmode_active)
  	    msg_scroll = FALSE;
  	quit_more = FALSE;
--- 1016,1047 ----
  		need_fileinfo = FALSE;
  	    }
  	}
! 
! 	/* Reset "got_int" now that we got back to the main loop.  Except when
! 	 * inside a ":g/pat/cmd" command, then the "got_int" needs to abort
! 	 * the ":g" command.
! 	 * For ":g/pat/vi" we reset "got_int" when used once.  When used
! 	 * a second time we go back to Ex mode and abort the ":g" command. */
! 	if (got_int)
  	{
! 	    if (noexmode && global_busy && !exmode_active && previous_got_int)
! 	    {
! 		/* Typed two CTRL-C in a row: go back to ex mode as if "Q" was
! 		 * used and keep "got_int" set, so that it aborts ":g". */
! 		exmode_active = EXMODE_NORMAL;
! 		State = NORMAL;
! 	    }
! 	    else if (!global_busy || !exmode_active)
! 	    {
! 		if (!quit_more)
! 		    (void)vgetc();		/* flush all buffers */
! 		got_int = FALSE;
! 	    }
! 	    previous_got_int = TRUE;
  	}
+ 	else
+ 	    previous_got_int = FALSE;
+ 
  	if (!exmode_active)
  	    msg_scroll = FALSE;
  	quit_more = FALSE;
*** ../vim-7.1.058/src/version.c	Wed Aug  8 22:48:16 2007
--- src/version.c	Fri Aug 10 21:30:39 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     59,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
116. You are living with your boyfriend who networks your respective
     computers so you can sit in separate rooms and email each other

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.060
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.060
Problem:    Splitting quickfix window messes up window layout. (Marius
	    Gedminas)
Solution:   Compute the window size in a smarter way. (Martin Toft)
Files:	    src/window.c


*** ../vim-7.1.059/src/window.c	Sun Aug  5 18:49:07 2007
--- src/window.c	Sun Aug  5 17:17:51 2007
***************
*** 2121,2127 ****
  	if (wp->w_p_pvw || bt_quickfix(wp->w_buffer))
  	{
  	    /*
! 	     * The cursor goes to the preview or the quickfix window, try
  	     * finding another window to go to.
  	     */
  	    for (;;)
--- 2121,2127 ----
  	if (wp->w_p_pvw || bt_quickfix(wp->w_buffer))
  	{
  	    /*
! 	     * If the cursor goes to the preview or the quickfix window, try
  	     * finding another window to go to.
  	     */
  	    for (;;)
***************
*** 2308,2314 ****
      frame_T	*frp, *frp2, *frp3;
      frame_T	*frp_close = win->w_frame;
      win_T	*wp;
-     int		old_size = 0;
  
      /*
       * If there is only one window there is nothing to remove.
--- 2308,2313 ----
***************
*** 2329,2361 ****
      if (frp_close->fr_parent->fr_layout == FR_COL)
      {
  #endif
! 	/* When 'winfixheight' is set, remember its old size and restore
! 	 * it later (it's a simplistic solution...).  Don't do this if the
! 	 * window will occupy the full height of the screen. */
! 	if (frp2->fr_win != NULL
! 		&& (frp2->fr_next != NULL || frp2->fr_prev != NULL)
! 		&& frp2->fr_win->w_p_wfh)
! 	    old_size = frp2->fr_win->w_height;
  	frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
- 	if (old_size != 0)
- 	    win_setheight_win(old_size, frp2->fr_win);
  #ifdef FEAT_VERTSPLIT
  	*dirp = 'v';
      }
      else
      {
! 	/* When 'winfixwidth' is set, remember its old size and restore
! 	 * it later (it's a simplistic solution...).  Don't do this if the
! 	 * window will occupy the full width of the screen. */
! 	if (frp2->fr_win != NULL
! 		&& (frp2->fr_next != NULL || frp2->fr_prev != NULL)
! 		&& frp2->fr_win->w_p_wfw)
! 	    old_size = frp2->fr_win->w_width;
  	frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
- 	if (old_size != 0)
- 	    win_setwidth_win(old_size, frp2->fr_win);
  	*dirp = 'h';
      }
  #endif
--- 2328,2404 ----
      if (frp_close->fr_parent->fr_layout == FR_COL)
      {
  #endif
! 	/* When 'winfixheight' is set, try to find another frame in the column
! 	 * (as close to the closed frame as possible) to distribute the height
! 	 * to. */
! 	if (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)
! 	{
! 	    frp = frp_close->fr_prev;
! 	    frp3 = frp_close->fr_next;
! 	    while (frp != NULL || frp3 != NULL)
! 	    {
! 		if (frp != NULL)
! 		{
! 		    if (frp->fr_win != NULL && !frp->fr_win->w_p_wfh)
! 		    {
! 			frp2 = frp;
! 			wp = frp->fr_win;
! 			break;
! 		    }
! 		    frp = frp->fr_prev;
! 		}
! 		if (frp3 != NULL)
! 		{
! 		    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)
! 		    {
! 			frp2 = frp3;
! 			wp = frp3->fr_win;
! 			break;
! 		    }
! 		    frp3 = frp3->fr_next;
! 		}
! 	    }
! 	}
  	frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
  #ifdef FEAT_VERTSPLIT
  	*dirp = 'v';
      }
      else
      {
! 	/* When 'winfixwidth' is set, try to find another frame in the column
! 	 * (as close to the closed frame as possible) to distribute the width
! 	 * to. */
! 	if (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)
! 	{
! 	    frp = frp_close->fr_prev;
! 	    frp3 = frp_close->fr_next;
! 	    while (frp != NULL || frp3 != NULL)
! 	    {
! 		if (frp != NULL)
! 		{
! 		    if (frp->fr_win != NULL && !frp->fr_win->w_p_wfw)
! 		    {
! 			frp2 = frp;
! 			wp = frp->fr_win;
! 			break;
! 		    }
! 		    frp = frp->fr_prev;
! 		}
! 		if (frp3 != NULL)
! 		{
! 		    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)
! 		    {
! 			frp2 = frp3;
! 			wp = frp3->fr_win;
! 			break;
! 		    }
! 		    frp3 = frp3->fr_next;
! 		}
! 	    }
! 	}
  	frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
  	*dirp = 'h';
      }
  #endif
*** ../vim-7.1.059/src/version.c	Fri Aug 10 21:32:41 2007
--- src/version.c	Sat Aug 11 13:34:42 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     60,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
117. You are more comfortable typing in html.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.061
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.061
Problem:    Win32: When 'encoding' is "latin1" 'ignorecase' doesn't work for
	    characters with umlaut. (Joachim Hofmann)
Solution:   Do not use islower()/isupper()/tolower()/toupper() but our own
	    functions. (Chris Lubinski)
Files:	    src/mbyte.c, src/regexp.c, src/vim.h


*** ../vim-7.1.060/src/mbyte.c	Thu May 10 19:45:20 2007
--- src/mbyte.c	Sat Aug  4 13:44:36 2007
***************
*** 2320,2326 ****
  		/* Single byte: first check normally, then with ignore case. */
  		if (s1[i] != s2[i])
  		{
! 		    cdiff = TOLOWER_LOC(s1[i]) - TOLOWER_LOC(s2[i]);
  		    if (cdiff != 0)
  			return cdiff;
  		}
--- 2320,2326 ----
  		/* Single byte: first check normally, then with ignore case. */
  		if (s1[i] != s2[i])
  		{
! 		    cdiff = MB_TOLOWER(s1[i]) - MB_TOLOWER(s2[i]);
  		    if (cdiff != 0)
  			return cdiff;
  		}
*** ../vim-7.1.060/src/regexp.c	Mon Aug  6 22:27:13 2007
--- src/regexp.c	Sun Aug  5 15:43:27 2007
***************
*** 2220,2226 ****
  				break;
  			    case CLASS_LOWER:
  				for (cu = 1; cu <= 255; cu++)
! 				    if (islower(cu))
  					regc(cu);
  				break;
  			    case CLASS_PRINT:
--- 2220,2226 ----
  				break;
  			    case CLASS_LOWER:
  				for (cu = 1; cu <= 255; cu++)
! 				    if (MB_ISLOWER(cu))
  					regc(cu);
  				break;
  			    case CLASS_PRINT:
***************
*** 2240,2246 ****
  				break;
  			    case CLASS_UPPER:
  				for (cu = 1; cu <= 255; cu++)
! 				    if (isupper(cu))
  					regc(cu);
  				break;
  			    case CLASS_XDIGIT:
--- 2240,2246 ----
  				break;
  			    case CLASS_UPPER:
  				for (cu = 1; cu <= 255; cu++)
! 				    if (MB_ISUPPER(cu))
  					regc(cu);
  				break;
  			    case CLASS_XDIGIT:
***************
*** 3465,3471 ****
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
  #endif
! 			    TOLOWER_LOC(prog->regstart) == TOLOWER_LOC(c)))))
  	    retval = regtry(prog, col);
  	else
  	    retval = 0;
--- 3465,3471 ----
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
  #endif
! 			    MB_TOLOWER(prog->regstart) == MB_TOLOWER(c)))))
  	    retval = regtry(prog, col);
  	else
  	    retval = 0;
***************
*** 4200,4206 ****
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
! 			    TOLOWER_LOC(*opnd) != TOLOWER_LOC(*reginput))))
  		    status = RA_NOMATCH;
  		else if (*opnd == NUL)
  		{
--- 4200,4206 ----
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
! 			    MB_TOLOWER(*opnd) != MB_TOLOWER(*reginput))))
  		    status = RA_NOMATCH;
  		else if (*opnd == NUL)
  		{
***************
*** 4733,4742 ****
  		    rst.nextb = *OPERAND(next);
  		    if (ireg_ic)
  		    {
! 			if (isupper(rst.nextb))
! 			    rst.nextb_ic = TOLOWER_LOC(rst.nextb);
  			else
! 			    rst.nextb_ic = TOUPPER_LOC(rst.nextb);
  		    }
  		    else
  			rst.nextb_ic = rst.nextb;
--- 4733,4742 ----
  		    rst.nextb = *OPERAND(next);
  		    if (ireg_ic)
  		    {
! 			if (MB_ISUPPER(rst.nextb))
! 			    rst.nextb_ic = MB_TOLOWER(rst.nextb);
  			else
! 			    rst.nextb_ic = MB_TOUPPER(rst.nextb);
  		    }
  		    else
  			rst.nextb_ic = rst.nextb;
***************
*** 5558,5568 ****
  	    int	    cu, cl;
  
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
! 	     * would have been used for it. */
  	    if (ireg_ic)
  	    {
! 		cu = TOUPPER_LOC(*opnd);
! 		cl = TOLOWER_LOC(*opnd);
  		while (count < maxcount && (*scan == cu || *scan == cl))
  		{
  		    count++;
--- 5558,5569 ----
  	    int	    cu, cl;
  
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
! 	     * would have been used for it.  It does handle single-byte
! 	     * characters, such as latin1. */
  	    if (ireg_ic)
  	    {
! 		cu = MB_TOUPPER(*opnd);
! 		cl = MB_TOLOWER(*opnd);
  		while (count < maxcount && (*scan == cu || *scan == cl))
  		{
  		    count++;
***************
*** 6490,6499 ****
  	cc = utf_fold(c);
      else
  #endif
! 	 if (isupper(c))
! 	cc = TOLOWER_LOC(c);
!     else if (islower(c))
! 	cc = TOUPPER_LOC(c);
      else
  	return vim_strchr(s, c);
  
--- 6491,6500 ----
  	cc = utf_fold(c);
      else
  #endif
! 	 if (MB_ISUPPER(c))
! 	cc = MB_TOLOWER(c);
!     else if (MB_ISLOWER(c))
! 	cc = MB_TOUPPER(c);
      else
  	return vim_strchr(s, c);
  
*** ../vim-7.1.060/src/vim.h	Sat May 12 15:08:22 2007
--- src/vim.h	Sat Aug  4 13:57:36 2007
***************
*** 1380,1387 ****
  #endif
  
  #ifdef FEAT_MBYTE
! # define MB_STRICMP(d, s)	(has_mbyte ? mb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL) : STRICMP((d), (s)))
! # define MB_STRNICMP(d, s, n)	(has_mbyte ? mb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n)) : STRNICMP((d), (s), (n)))
  #else
  # define MB_STRICMP(d, s)	STRICMP((d), (s))
  # define MB_STRNICMP(d, s, n)	STRNICMP((d), (s), (n))
--- 1380,1393 ----
  #endif
  
  #ifdef FEAT_MBYTE
! /* We need to call mb_stricmp() even when we aren't dealing with a multi-byte
!  * encoding because mb_stricmp() takes care of all ascii and non-ascii
!  * encodings, including characters with umluats in latin1, etc., while
!  * STRICMP() only handles the system locale version, which often does not
!  * handle non-ascii properly. */
! 
! # define MB_STRICMP(d, s)	mb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL)
! # define MB_STRNICMP(d, s, n)	mb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n))
  #else
  # define MB_STRICMP(d, s)	STRICMP((d), (s))
  # define MB_STRNICMP(d, s, n)	STRNICMP((d), (s), (n))
*** ../vim-7.1.060/src/version.c	Sat Aug 11 13:37:36 2007
--- src/version.c	Sat Aug 11 13:55:24 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     61,
  /**/

-- 
Support your right to bare arms!  Wear short sleeves!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.062
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.062 (after 7.1.038)
Problem:    Indents of C comments can be wrong. (John Mullin)
Solution:   Adjust ind_len. (Chris Lubinski)
Files:	    src/misc1.c


*** ../vim-7.1.061/src/misc1.c	Mon Aug  6 22:27:13 2007
--- src/misc1.c	Fri Aug 10 19:41:42 2007
***************
*** 222,228 ****
  	 * than old) */
  	while (vim_iswhite(*p))
  	    (void)*p++;
! 	todo = size-ind_done;
      }
      else
      {
--- 222,231 ----
  	 * than old) */
  	while (vim_iswhite(*p))
  	    (void)*p++;
! 	todo = size - ind_done;
! 	ind_len += todo;    /* Set total length of indent in characters,
! 			     * which may have been undercounted until now  */
! 
      }
      else
      {
*** ../vim-7.1.061/src/version.c	Sat Aug 11 13:57:31 2007
--- src/version.c	Sat Aug 11 14:30:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     62,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
120. You ask a friend, "What's that big shiny thing?" He says, "It's the sun."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.064
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.064
Problem:    On Interix some files appear not to exist.
Solution:   Remove the top bit from st_mode. (Ligesh)
Files:	    src/os_unix.c


*** ../vim-7.1.063/src/os_unix.c	Thu May 10 19:42:47 2007
--- src/os_unix.c	Fri Aug 10 19:32:20 2007
***************
*** 2499,2505 ****
--- 2499,2511 ----
      if (stat((char *)name, &statb))
  #endif
  	return -1;
+ #ifdef __INTERIX
+     /* The top bit makes the value negative, which means the file doesn't
+      * exist.  Remove the bit, we don't use it. */
+     return statb.st_mode & ~S_ADDACE;
+ #else
      return statb.st_mode;
+ #endif
  }
  
  /*
*** ../vim-7.1.063/src/version.c	Sat Aug 11 15:59:44 2007
--- src/version.c	Sat Aug 11 22:21:35 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     64,
  /**/

-- 
I have a watch cat! Just break in and she'll watch.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.065 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.065 (extra)
Problem:    Win32: Compilation problem for newer version of w32api.
Solution:   Only define __IID_DEFINED__ when needed. (Chris Sutcliffe)
Files:	    src/Make_ming.mak, src/iid_ole.c


*** ../vim-7.1.064/src/Make_ming.mak	Thu May 10 19:35:54 2007
--- src/Make_ming.mak	Sat Aug 11 14:52:11 2007
***************
*** 572,579 ****
  $(OUTDIR)/if_cscope.o:	if_cscope.c $(INCL) if_cscope.h
  	$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o
  
  $(OUTDIR)/if_ole.o: if_ole.cpp $(INCL)
! 	$(CC) $(CFLAGS) -D__IID_DEFINED__ -c -o $(OUTDIR)/if_ole.o if_ole.cpp
  
  $(OUTDIR)/if_ruby.o: if_ruby.c $(INCL)
  ifeq (16, $(RUBY))
--- 572,580 ----
  $(OUTDIR)/if_cscope.o:	if_cscope.c $(INCL) if_cscope.h
  	$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o
  
+ # Remove -D__IID_DEFINED__ for newer versions of the w32api
  $(OUTDIR)/if_ole.o: if_ole.cpp $(INCL)
! 	$(CC) $(CFLAGS) -c -o $(OUTDIR)/if_ole.o if_ole.cpp
  
  $(OUTDIR)/if_ruby.o: if_ruby.c $(INCL)
  ifeq (16, $(RUBY))
*** ../vim-7.1.064/src/iid_ole.c	Sun Jun 13 18:45:30 2004
--- src/iid_ole.c	Sat Aug 11 14:57:58 2007
***************
*** 16,24 ****
  extern "C"{
  #endif
  
  
  #ifndef __IID_DEFINED__
! #define __IID_DEFINED__
  
  typedef struct _IID
  {
--- 16,33 ----
  extern "C"{
  #endif
  
+ #ifdef __MINGW32__
+ # include <w32api.h>
+ 
+ # if __W32API_MAJOR_VERSION == 3 && __W32API_MINOR_VERSION < 10
+    /* This define is missing from older MingW versions of w32api, even though
+     * IID is defined. */
+ #  define __IID_DEFINED__
+ # endif
+ #endif
  
  #ifndef __IID_DEFINED__
! # define __IID_DEFINED__
  
  typedef struct _IID
  {
***************
*** 28,39 ****
      unsigned char  c[8];
  } IID;
  
! #endif // __IID_DEFINED__
  
  #ifndef CLSID_DEFINED
! #define CLSID_DEFINED
  typedef IID CLSID;
! #endif // CLSID_DEFINED
  
  const IID IID_IVim = {0x0F0BFAE2,0x4C90,0x11d1,{0x82,0xD7,0x00,0x04,0xAC,0x36,0x85,0x19}};
  
--- 37,48 ----
      unsigned char  c[8];
  } IID;
  
! #endif
  
  #ifndef CLSID_DEFINED
! # define CLSID_DEFINED
  typedef IID CLSID;
! #endif
  
  const IID IID_IVim = {0x0F0BFAE2,0x4C90,0x11d1,{0x82,0xD7,0x00,0x04,0xAC,0x36,0x85,0x19}};
  
*** ../vim-7.1.064/src/version.c	Sat Aug 11 22:22:56 2007
--- src/version.c	Sun Aug 12 15:21:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     65,
  /**/

-- 
I'm writing a book.  I've got the page numbers done.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.066
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.066
Problem:    When 'bomb' is set or reset the file should be considered
	    modified.  (Tony Mechelynck)
Solution:   Handle like 'endofline'. (Martin Toft)
Files:	    src/buffer.c, src/fileio.c, src/option.c, src/structs.h


*** ../vim-7.1.065/src/buffer.c	Mon Aug  6 22:27:12 2007
--- src/buffer.c	Sat Aug 11 16:56:57 2007
***************
*** 502,507 ****
--- 502,508 ----
      buf->b_start_eol = TRUE;
  #ifdef FEAT_MBYTE
      buf->b_p_bomb = FALSE;
+     buf->b_start_bomb = FALSE;
  #endif
      buf->b_ml.ml_mfp = NULL;
      buf->b_ml.ml_flags = ML_EMPTY;		/* empty buffer */
*** ../vim-7.1.065/src/fileio.c	Tue Jul 10 17:09:51 2007
--- src/fileio.c	Sat Aug 11 16:56:57 2007
***************
*** 654,659 ****
--- 654,660 ----
  	curbuf->b_start_eol = TRUE;
  #ifdef FEAT_MBYTE
  	curbuf->b_p_bomb = FALSE;
+ 	curbuf->b_start_bomb = FALSE;
  #endif
      }
  
***************
*** 912,918 ****
--- 913,922 ----
  	file_rewind = FALSE;
  #ifdef FEAT_MBYTE
  	if (set_options)
+ 	{
  	    curbuf->b_p_bomb = FALSE;
+ 	    curbuf->b_start_bomb = FALSE;
+ 	}
  	conv_error = 0;
  #endif
      }
***************
*** 1361,1367 ****
--- 1365,1374 ----
  		    size -= blen;
  		    mch_memmove(ptr, ptr + blen, (size_t)size);
  		    if (set_options)
+ 		    {
  			curbuf->b_p_bomb = TRUE;
+ 			curbuf->b_start_bomb = TRUE;
+ 		    }
  		}
  
  		if (fio_flags == FIO_UCSBOM)
*** ../vim-7.1.065/src/option.c	Tue Jul 24 14:57:16 2007
--- src/option.c	Sat Aug 11 16:56:57 2007
***************
*** 7118,7123 ****
--- 7118,7128 ----
      /* when 'endofline' is changed, redraw the window title */
      else if ((int *)varp == &curbuf->b_p_eol)
  	need_maketitle = TRUE;
+ #ifdef FEAT_MBYTE
+     /* when 'bomb' is changed, redraw the window title */
+     else if ((int *)varp == &curbuf->b_p_bomb)
+ 	need_maketitle = TRUE;
+ #endif
  #endif
  
      /* when 'bin' is set also set some other options */
***************
*** 10604,10609 ****
--- 10609,10616 ----
      buf->b_start_ffc = *buf->b_p_ff;
      buf->b_start_eol = buf->b_p_eol;
  #ifdef FEAT_MBYTE
+     buf->b_start_bomb = buf->b_p_bomb;
+ 
      /* Only use free/alloc when necessary, they take time. */
      if (buf->b_start_fenc == NULL
  			     || STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0)
***************
*** 10617,10623 ****
  /*
   * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value
   * from when editing started (save_file_ff() called).
!  * Also when 'endofline' was changed and 'binary' is set.
   * Don't consider a new, empty buffer to be changed.
   */
      int
--- 10624,10631 ----
  /*
   * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value
   * from when editing started (save_file_ff() called).
!  * Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was
!  * changed and 'binary' is not set.
   * Don't consider a new, empty buffer to be changed.
   */
      int
***************
*** 10636,10641 ****
--- 10644,10651 ----
      if (buf->b_p_bin && buf->b_start_eol != buf->b_p_eol)
  	return TRUE;
  #ifdef FEAT_MBYTE
+     if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)
+ 	return TRUE;
      if (buf->b_start_fenc == NULL)
  	return (*buf->b_p_fenc != NUL);
      return (STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0);
*** ../vim-7.1.065/src/structs.h	Thu Jul 26 22:55:11 2007
--- src/structs.h	Sat Aug 11 16:56:57 2007
***************
*** 1453,1458 ****
--- 1453,1459 ----
  #ifdef FEAT_MBYTE
      char_u	*b_start_fenc;	/* 'fileencoding' when edit started or NULL */
      int		b_bad_char;	/* "++bad=" argument when edit started or 0 */
+     int		b_start_bomb;	/* 'bomb' when it was read */
  #endif
  
  #ifdef FEAT_EVAL
*** ../vim-7.1.065/src/version.c	Sun Aug 12 15:24:05 2007
--- src/version.c	Sun Aug 12 15:48:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     66,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
127. You bring your laptop and cellular phone to church.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.067
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.067
Problem:    'thesaurus' doesn't work when 'infercase' is set. (Mohsin)
Solution:   Don't copy the characters being completed but check the case and
	    apply it to the suggested word.  Also fix that the first word in
	    the thesaurus line is not used.  (Martin Toft)
Files:	    src/edit.c


*** ../vim-7.1.066/src/edit.c	Sun Jul 29 15:02:34 2007
--- src/edit.c	Sat Aug 11 17:16:51 2007
***************
*** 2057,2063 ****
   * case of the originally typed text is used, and the case of the completed
   * text is inferred, ie this tries to work out what case you probably wanted
   * the rest of the word to be in -- webb
-  * TODO: make this work for multi-byte characters.
   */
      int
  ins_compl_add_infercase(str, len, icase, fname, dir, flags)
--- 2057,2062 ----
***************
*** 2068,2121 ****
      int		dir;
      int		flags;
  {
      int		has_lower = FALSE;
      int		was_letter = FALSE;
-     int		idx;
  
!     if (p_ic && curbuf->b_p_inf && len < IOSIZE)
      {
! 	/* Infer case of completed part -- webb */
! 	/* Use IObuff, str would change text in buffer! */
! 	vim_strncpy(IObuff, str, len);
  
! 	/* Rule 1: Were any chars converted to lower? */
! 	for (idx = 0; idx < compl_length; ++idx)
  	{
! 	    if (islower(compl_orig_text[idx]))
  	    {
! 		has_lower = TRUE;
! 		if (isupper(IObuff[idx]))
! 		{
! 		    /* Rule 1 is satisfied */
! 		    for (idx = compl_length; idx < len; ++idx)
! 			IObuff[idx] = TOLOWER_LOC(IObuff[idx]);
! 		    break;
! 		}
  	    }
  	}
  
! 	/*
! 	 * Rule 2: No lower case, 2nd consecutive letter converted to
! 	 * upper case.
! 	 */
! 	if (!has_lower)
  	{
! 	    for (idx = 0; idx < compl_length; ++idx)
  	    {
! 		if (was_letter && isupper(compl_orig_text[idx])
! 						      && islower(IObuff[idx]))
  		{
! 		    /* Rule 2 is satisfied */
! 		    for (idx = compl_length; idx < len; ++idx)
! 			IObuff[idx] = TOUPPER_LOC(IObuff[idx]);
! 		    break;
  		}
- 		was_letter = isalpha(compl_orig_text[idx]);
  	    }
- 	}
  
! 	/* Copy the original case of the part we typed */
! 	STRNCPY(IObuff, compl_orig_text, compl_length);
  
  	return ins_compl_add(IObuff, len, icase, fname, NULL, dir,
  								flags, FALSE);
--- 2067,2213 ----
      int		dir;
      int		flags;
  {
+     char_u	*p;
+     int		i, c;
+     int		actual_len;		/* Take multi-byte characters */
+     int		actual_compl_length;	/* into account. */
+     int		*wca;		        /* Wide character array. */
      int		has_lower = FALSE;
      int		was_letter = FALSE;
  
!     if (p_ic && curbuf->b_p_inf)
      {
! 	/* Infer case of completed part. */
  
! 	/* Find actual length of completion. */
! #ifdef FEAT_MBYTE
! 	if (has_mbyte)
  	{
! 	    p = str;
! 	    actual_len = 0;
! 	    while (*p != NUL)
  	    {
! 		mb_ptr_adv(p);
! 		++actual_len;
  	    }
  	}
+ 	else
+ #endif
+ 	    actual_len = len;
  
! 	/* Find actual length of original text. */
! #ifdef FEAT_MBYTE
! 	if (has_mbyte)
  	{
! 	    p = compl_orig_text;
! 	    actual_compl_length = 0;
! 	    while (*p != NUL)
  	    {
! 		mb_ptr_adv(p);
! 		++actual_compl_length;
! 	    }
! 	}
! 	else
! #endif
! 	    actual_compl_length = compl_length;
! 
! 	/* Allocate wide character array for the completion and fill it. */
! 	wca = (int *)alloc(actual_len * sizeof(int));
! 	if (wca != NULL)
! 	{
! 	    p = str;
! 	    for (i = 0; i < actual_len; ++i)
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    wca[i] = mb_ptr2char_adv(&p);
! 		else
! #endif
! 		    wca[i] = *(p++);
! 
! 	    /* Rule 1: Were any chars converted to lower? */
! 	    p = compl_orig_text;
! 	    for (i = 0; i < actual_compl_length; ++i)
! 	    {
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    c = mb_ptr2char_adv(&p);
! 		else
! #endif
! 		    c = *(p++);
! 		if (MB_ISLOWER(c))
  		{
! 		    has_lower = TRUE;
! 		    if (MB_ISUPPER(wca[i]))
! 		    {
! 			/* Rule 1 is satisfied. */
! 			for (i = actual_compl_length; i < actual_len; ++i)
! 			    wca[i] = MB_TOLOWER(wca[i]);
! 			break;
! 		    }
  		}
  	    }
  
! 	    /*
! 	     * Rule 2: No lower case, 2nd consecutive letter converted to
! 	     * upper case.
! 	     */
! 	    if (!has_lower)
! 	    {
! 		p = compl_orig_text;
! 		for (i = 0; i < actual_compl_length; ++i)
! 		{
! #ifdef FEAT_MBYTE
! 		    if (has_mbyte)
! 			c = mb_ptr2char_adv(&p);
! 		    else
! #endif
! 			c = *(p++);
! 		    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))
! 		    {
! 			/* Rule 2 is satisfied. */
! 			for (i = actual_compl_length; i < actual_len; ++i)
! 			    wca[i] = MB_TOUPPER(wca[i]);
! 			break;
! 		    }
! 		    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);
! 		}
! 	    }
! 
! 	    /* Copy the original case of the part we typed. */
! 	    p = compl_orig_text;
! 	    for (i = 0; i < actual_compl_length; ++i)
! 	    {
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    c = mb_ptr2char_adv(&p);
! 		else
! #endif
! 		    c = *(p++);
! 		if (MB_ISLOWER(c))
! 		    wca[i] = MB_TOLOWER(wca[i]);
! 		else if (MB_ISUPPER(c))
! 		    wca[i] = MB_TOUPPER(wca[i]);
! 	    }
! 
! 	    /* 
! 	     * Generate encoding specific output from wide character array.
! 	     * Multi-byte characters can occupy up to five bytes more than
! 	     * ASCII characters, and we also need one byte for NUL, so stay
! 	     * six bytes away from the edge of IObuff.
! 	     */
! 	    p = IObuff;
! 	    i = 0;
! 	    while (i < actual_len && (p - IObuff + 6) < IOSIZE)
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    p += mb_char2bytes(wca[i++], p);
! 		else
! #endif
! 		    *(p++) = wca[i++];
! 	    *p = NUL;
! 
! 	    vim_free(wca);
! 	}
  
  	return ins_compl_add(IObuff, len, icase, fname, NULL, dir,
  								flags, FALSE);
***************
*** 2842,2847 ****
--- 2934,2940 ----
  			/*
  			 * Add the other matches on the line
  			 */
+ 			ptr = buf;
  			while (!got_int)
  			{
  			    /* Find start of the next word.  Skip white
***************
*** 2851,2857 ****
  				break;
  			    wstart = ptr;
  
! 			    /* Find end of the word and add it. */
  #ifdef FEAT_MBYTE
  			    if (has_mbyte)
  				/* Japanese words may have characters in
--- 2944,2950 ----
  				break;
  			    wstart = ptr;
  
! 			    /* Find end of the word. */
  #ifdef FEAT_MBYTE
  			    if (has_mbyte)
  				/* Japanese words may have characters in
***************
*** 2868,2876 ****
  			    else
  #endif
  				ptr = find_word_end(ptr);
! 			    add_r = ins_compl_add_infercase(wstart,
! 				    (int)(ptr - wstart),
! 				    p_ic, files[i], *dir, 0);
  			}
  		    }
  		    if (add_r == OK)
--- 2961,2972 ----
  			    else
  #endif
  				ptr = find_word_end(ptr);
! 
! 			    /* Add the word. Skip the regexp match. */
! 			    if (wstart != regmatch->startp[0])
! 				add_r = ins_compl_add_infercase(wstart,
! 					(int)(ptr - wstart),
! 					p_ic, files[i], *dir, 0);
  			}
  		    }
  		    if (add_r == OK)
*** ../vim-7.1.066/src/version.c	Sun Aug 12 15:50:26 2007
--- src/version.c	Sun Aug 12 16:36:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     67,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
128. You can access the Net -- via your portable and cellular phone.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.068
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.068
Problem:    When 'equalalways' is set and splitting a window, it's possible
	    that another small window gets bigger.
Solution:   Only equalize window sizes when after a split the windows are
	    smaller than another window. (Martin Toft)
Files:	    runtime/doc/options.txt, runtime/doc/windows.txt, src/window.c


*** ../vim-7.1.067/runtime/doc/options.txt	Sat May 12 16:27:04 2007
--- runtime/doc/options.txt	Sat Aug 11 17:25:38 2007
***************
*** 1,4 ****
! *options.txt*	For Vim version 7.1.  Last change: 2007 May 11
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *options.txt*	For Vim version 7.1.  Last change: 2007 Aug 10
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 2415,2422 ****
  	When mixing vertically and horizontally split windows, a minimal size
  	is computed and some windows may be larger if there is room.  The
  	'eadirection' option tells in which direction the size is affected.
! 	Changing the height of a window can be avoided by setting
! 	'winfixheight'.
  
  						*'equalprg'* *'ep'*
  'equalprg' 'ep'		string	(default "")
--- 2418,2425 ----
  	When mixing vertically and horizontally split windows, a minimal size
  	is computed and some windows may be larger if there is room.  The
  	'eadirection' option tells in which direction the size is affected.
! 	Changing the height and width of a window can be avoided by setting
! 	'winfixheight' and 'winfixwidth', respectively.
  
  						*'equalprg'* *'ep'*
  'equalprg' 'ep'		string	(default "")
*** ../vim-7.1.067/runtime/doc/windows.txt	Sat May 12 16:42:48 2007
--- runtime/doc/windows.txt	Sat Aug 11 17:25:38 2007
***************
*** 132,138 ****
  		the same file.  Make new window N high (default is to use half
  		the height of the current window).  Reduces the current window
  		height to create room (and others, if the 'equalalways' option
! 		is set and 'eadirection' isn't "hor").
  		Note: CTRL-S does not work on all terminals and might block
  		further input, use CTRL-Q to get going again.
  		Also see |++opt| and |+cmd|.
--- 132,139 ----
  		the same file.  Make new window N high (default is to use half
  		the height of the current window).  Reduces the current window
  		height to create room (and others, if the 'equalalways' option
! 		is set, 'eadirection' isn't "hor", and one of them is higher
! 		than the current or the new window).
  		Note: CTRL-S does not work on all terminals and might block
  		further input, use CTRL-Q to get going again.
  		Also see |++opt| and |+cmd|.
***************
*** 140,148 ****
  CTRL-W CTRL-V						*CTRL-W_CTRL-V*
  CTRL-W v						*CTRL-W_v*
  :[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
! 		Like |:split|, but split vertically.  If 'equalalways' is set
! 		and 'eadirection' isn't "ver" the windows will be spread out
! 		horizontally, unless a width was specified.
  		Note: In other places CTRL-Q does the same as CTRL-V, but here
  		it doesn't!
  
--- 141,153 ----
  CTRL-W CTRL-V						*CTRL-W_CTRL-V*
  CTRL-W v						*CTRL-W_v*
  :[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
! 		Like |:split|, but split vertically.  The windows will be
! 		spread out horizontally if
! 		1. a width was not specified,
! 		2. 'equalalways' is set,
! 		3. 'eadirection' isn't "ver", and
! 		4. one of the other windows are wider than the current or new
! 		   window.
  		Note: In other places CTRL-Q does the same as CTRL-V, but here
  		it doesn't!
  
*** ../vim-7.1.067/src/window.c	Sat Aug 11 13:37:36 2007
--- src/window.c	Sat Aug 11 17:25:38 2007
***************
*** 733,739 ****
      if (flags & WSP_VERT)
      {
  	layout = FR_ROW;
- 	do_equal = (p_ea && new_size == 0 && *p_ead != 'v');
  
  	/*
  	 * Check if we are able to split the current window and compute its
--- 733,738 ----
***************
*** 770,785 ****
  	 * instead, if possible. */
  	if (oldwin->w_p_wfw)
  	    win_setwidth_win(oldwin->w_width + new_size, oldwin);
      }
      else
  #endif
      {
  	layout = FR_COL;
- 	do_equal = (p_ea && new_size == 0
- #ifdef FEAT_VERTSPLIT
- 		&& *p_ead != 'h'
- #endif
- 		);
  
  	/*
  	 * Check if we are able to split the current window and compute its
--- 769,799 ----
  	 * instead, if possible. */
  	if (oldwin->w_p_wfw)
  	    win_setwidth_win(oldwin->w_width + new_size, oldwin);
+ 
+ 	/* Only make all windows the same width if one of them (except oldwin)
+ 	 * is wider than one of the split windows. */
+ 	if (!do_equal && p_ea && size == 0 && *p_ead != 'v'
+ 	   && oldwin->w_frame->fr_parent != NULL)
+ 	{
+ 	    frp = oldwin->w_frame->fr_parent->fr_child;
+ 	    while (frp != NULL)
+ 	    {
+ 		if (frp->fr_win != oldwin && frp->fr_win != NULL
+ 			&& (frp->fr_win->w_width > new_size
+ 			    || frp->fr_win->w_width > oldwin->w_width
+ 						   - new_size - STATUS_HEIGHT))
+ 		{
+ 		    do_equal = TRUE;
+ 		    break;
+ 		}
+ 		frp = frp->fr_next;
+ 	    }
+ 	}
      }
      else
  #endif
      {
  	layout = FR_COL;
  
  	/*
  	 * Check if we are able to split the current window and compute its
***************
*** 831,836 ****
--- 845,873 ----
  	    oldwin_height = oldwin->w_height;
  	    if (need_status)
  		oldwin_height -= STATUS_HEIGHT;
+ 	}
+ 
+ 	/* Only make all windows the same height if one of them (except oldwin)
+ 	 * is higher than one of the split windows. */
+ 	if (!do_equal && p_ea && size == 0
+ #ifdef FEAT_VERTSPLIT
+ 		&& *p_ead != 'h'
+ #endif
+ 	   && oldwin->w_frame->fr_parent != NULL)
+ 	{
+ 	    frp = oldwin->w_frame->fr_parent->fr_child;
+ 	    while (frp != NULL)
+ 	    {
+ 		if (frp->fr_win != oldwin && frp->fr_win != NULL
+ 			&& (frp->fr_win->w_height > new_size
+ 			    || frp->fr_win->w_height > oldwin_height - new_size
+ 							      - STATUS_HEIGHT))
+ 		{
+ 		    do_equal = TRUE;
+ 		    break;
+ 		}
+ 		frp = frp->fr_next;
+ 	    }
  	}
      }
  
*** ../vim-7.1.067/src/version.c	Sun Aug 12 16:38:03 2007
--- src/version.c	Sun Aug 12 16:51:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     68,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
129. You cancel your newspaper subscription.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.069
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.069
Problem:    GTK GUI: When using confirm() without a default button there still
	    is a default choice.
Solution:   Ignore Enter and Space when there is no default button. (Chris
	    Lubinski)
Files:	    src/gui_gtk.c


*** ../vim-7.1.068/src/gui_gtk.c	Mon May 14 19:35:51 2007
--- src/gui_gtk.c	Sat Aug 11 17:38:03 2007
***************
*** 1630,1640 ****
   */
  /*ARGSUSED*/
      static int
! dlg_key_press_event(GtkWidget * widget, GdkEventKey * event, CancelData *data)
  {
!     /* Ignore hitting Enter when there is no default button. */
!     if (data->ignore_enter && event->keyval == GDK_Return)
  	return TRUE;
  
      if (event->keyval != GDK_Escape && event->keyval != GDK_Return)
  	return FALSE;
--- 1630,1643 ----
   */
  /*ARGSUSED*/
      static int
! dlg_key_press_event(GtkWidget *widget, GdkEventKey *event, CancelData *data)
  {
!     /* Ignore hitting Enter (or Space) when there is no default button. */
!     if (data->ignore_enter && (event->keyval == GDK_Return
! 						     || event->keyval == ' '))
  	return TRUE;
+     else    /* A different key was pressed, return to normal behavior */
+ 	data->ignore_enter = FALSE;
  
      if (event->keyval != GDK_Escape && event->keyval != GDK_Return)
  	return FALSE;
***************
*** 2223,2228 ****
--- 2226,2238 ----
  dialog_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)
  {
      DialogInfo *di = (DialogInfo *)data;
+ 
+     /* Ignore hitting Enter (or Space) when there is no default button. */
+     if (di->ignore_enter && (event->keyval == GDK_Return
+ 						     || event->keyval == ' '))
+ 	return TRUE;
+     else    /* A different key was pressed, return to normal behavior */
+ 	di->ignore_enter = FALSE;
  
      /* Close the dialog when hitting "Esc". */
      if (event->keyval == GDK_Escape)
*** ../vim-7.1.068/src/version.c	Sun Aug 12 16:55:01 2007
--- src/version.c	Tue Aug 14 14:58:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     69,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
148. You find it easier to dial-up the National Weather Service
     Weather/your_town/now.html than to simply look out the window.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.070 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.070 (extra)
Problem:    Win32 GUI: When using confirm() without a default button there
	    still is a default choice.
Solution:   Set focus on something else than a button. (Chris Lubinski)
Files:	    src/gui_w32.c


*** ../vim-7.1.069/src/gui_w32.c	Tue Jun 19 10:09:15 2007
--- src/gui_w32.c	Sat Aug 11 17:39:50 2007
***************
*** 2894,2899 ****
--- 2894,2903 ----
  	(void)SetFocus(hwnd);
  	if (dialog_default_button > IDCANCEL)
  	    (void)SetFocus(GetDlgItem(hwnd, dialog_default_button));
+ 	else
+ 	    /* We don't have a default, set focus on another element of the
+ 	     * dialog window, probably the icon */
+ 	    (void)SetFocus(GetDlgItem(hwnd, DLG_NONBUTTON_CONTROL));
  	return FALSE;
      }
  
*** ../vim-7.1.069/src/version.c	Tue Aug 14 14:59:41 2007
--- src/version.c	Tue Aug 14 16:55:41 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     70,
  /**/

-- 
You are not really successful until someone claims he sat
beside you in school.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.072 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.072 (extra, after 7.1.041 and 7.1.071)
Problem:    Some changes for patch 7.1.071 are in extra files.
Solution:   Update the extra files.  Also fix a few warnings from the DOS test
	    makefile.
Files:	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_os2.mak, src/testdir/Make_vms.mms


*** ../vim-7.1.071/src/testdir/Make_amiga.mak	Thu Jul 26 23:10:50 2007
--- src/testdir/Make_amiga.mak	Tue Aug 14 15:14:03 2007
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out
  
  .SUFFIXES: .in .out
  
--- 25,31 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out test64.out
  
  .SUFFIXES: .in .out
  
***************
*** 108,110 ****
--- 108,111 ----
  test61.out: test61.in
  test62.out: test62.in
  test63.out: test63.in
+ test64.out: test64.in
*** ../vim-7.1.071/src/testdir/Make_dos.mak	Thu Jul 26 23:10:50 2007
--- src/testdir/Make_dos.mak	Tue Aug 14 15:14:25 2007
***************
*** 19,25 ****
  		test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out \
  		test55.out test56.out test57.out test58.out test59.out \
! 		test60.out test61.out test62.out test63.out
  
  SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
  		test8.out test9.out test11.out test13.out test14.out \
--- 19,25 ----
  		test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out \
  		test55.out test56.out test57.out test58.out test59.out \
! 		test60.out test61.out test62.out test63.out test64.out
  
  SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
  		test8.out test9.out test11.out test13.out test14.out \
***************
*** 51,69 ****
  
  clean:
  	-del *.out
! 	-del test.ok
! 	-del small.vim
! 	-del tiny.vim
! 	-del mbyte.vim
  	-del X*
! 	-del viminfo
  
  .in.out:
  	copy $*.ok test.ok
  	$(VIMPROG) -u dos.vim -U NONE --noplugin -s dotest.in $*.in
  	diff test.out $*.ok
! 	-del $*.out
  	rename test.out $*.out
  	-del X*
  	-del test.ok
! 	-del viminfo
--- 51,69 ----
  
  clean:
  	-del *.out
! 	-if exist test.ok del test.ok
! 	-if exist small.vim del small.vim
! 	-if exist tiny.vim del tiny.vim
! 	-if exist mbyte.vim del mbyte.vim
  	-del X*
! 	-if exist viminfo del viminfo
  
  .in.out:
  	copy $*.ok test.ok
  	$(VIMPROG) -u dos.vim -U NONE --noplugin -s dotest.in $*.in
  	diff test.out $*.ok
! 	-if exist $*.out del $*.out
  	rename test.out $*.out
  	-del X*
  	-del test.ok
! 	-if exist viminfo del viminfo
*** ../vim-7.1.071/src/testdir/Make_os2.mak	Thu Jul 26 23:10:50 2007
--- src/testdir/Make_os2.mak	Tue Aug 14 15:14:44 2007
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out
  
  .SUFFIXES: .in .out
  
--- 25,31 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out test64.out
  
  .SUFFIXES: .in .out
  
*** ../vim-7.1.071/src/testdir/Make_vms.mms	Thu Jul 26 23:10:50 2007
--- src/testdir/Make_vms.mms	Tue Aug 14 15:15:56 2007
***************
*** 4,10 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2007 Jul 24
  #
  # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
--- 4,10 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2007 Aug 14
  #
  # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
***************
*** 59,65 ****
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test58.out test59.out test60.out \
! 	 test61.out test62.out test63.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
--- 59,65 ----
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test58.out test59.out test60.out \
! 	 test61.out test62.out test63.out test64.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
*** ../vim-7.1.071/src/version.c	Tue Aug 14 17:28:14 2007
--- src/version.c	Tue Aug 14 17:51:21 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     72,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
152. You find yourself falling for someone you've never seen or hardly
     know, but, boy can he/she TYPE!!!!!!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.073
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.073 (after 7.1.062)
Problem:    Wrong cursor position and crash when 'preserveindent' is set.
	    (Charles Campbell)
Solution:   Handle the situation that we start without indent. (Chris
	    Lubinski)
Files:	    src/misc1.c


*** ../vim-7.1.072/src/misc1.c	Sat Aug 11 14:32:10 2007
--- src/misc1.c	Tue Aug 14 21:21:49 2007
***************
*** 104,110 ****
      int		ind_done = 0;	    /* measured in spaces */
      int		tab_pad;
      int		retval = FALSE;
!     int		orig_char_len = 0;  /* number of initial whitespace chars when
  				       'et' and 'pi' are both set */
  
      /*
--- 104,110 ----
      int		ind_done = 0;	    /* measured in spaces */
      int		tab_pad;
      int		retval = FALSE;
!     int		orig_char_len = -1; /* number of initial whitespace chars when
  				       'et' and 'pi' are both set */
  
      /*
***************
*** 159,165 ****
  
  	    /* Fill to next tabstop with a tab, if possible */
  	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
! 	    if (todo >= tab_pad && orig_char_len == 0)
  	    {
  		doit = TRUE;
  		todo -= tab_pad;
--- 159,165 ----
  
  	    /* Fill to next tabstop with a tab, if possible */
  	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
! 	    if (todo >= tab_pad && orig_char_len == -1)
  	    {
  		doit = TRUE;
  		todo -= tab_pad;
***************
*** 206,216 ****
      /* If 'preserveindent' and 'expandtab' are both set keep the original
       * characters and allocate accordingly.  We will fill the rest with spaces
       * after the if (!curbuf->b_p_et) below. */
!     if (orig_char_len != 0)
      {
  	newline = alloc(orig_char_len + size - ind_done + line_len);
  	if (newline == NULL)
  	    return FALSE;
  	p = oldline;
  	s = newline;
  	while (orig_char_len > 0)
--- 206,220 ----
      /* If 'preserveindent' and 'expandtab' are both set keep the original
       * characters and allocate accordingly.  We will fill the rest with spaces
       * after the if (!curbuf->b_p_et) below. */
!     if (orig_char_len != -1)
      {
  	newline = alloc(orig_char_len + size - ind_done + line_len);
  	if (newline == NULL)
  	    return FALSE;
+ 	todo = size - ind_done;
+ 	ind_len = orig_char_len + todo;    /* Set total length of indent in
+ 					    * characters, which may have been
+ 					    * undercounted until now  */
  	p = oldline;
  	s = newline;
  	while (orig_char_len > 0)
***************
*** 222,230 ****
  	 * than old) */
  	while (vim_iswhite(*p))
  	    (void)*p++;
- 	todo = size - ind_done;
- 	ind_len += todo;    /* Set total length of indent in characters,
- 			     * which may have been undercounted until now  */
  
      }
      else
--- 226,231 ----
*** ../vim-7.1.072/src/version.c	Tue Aug 14 17:54:37 2007
--- src/version.c	Tue Aug 14 22:14:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     73,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
157. You fum through a magazine, you first check to see if it has a web
     address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.074
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.074
Problem:    Crash when calling string() on a recurively nested List.
Solution:   Check result value for being NULL. (Yukihiro Nakadaira)
Files:	    src/eval.c


*** ../vim-7.1.073/src/eval.c	Mon Aug  6 22:27:12 2007
--- src/eval.c	Tue Aug 14 22:01:12 2007
***************
*** 6802,6808 ****
   * "numbuf" is used for a number.
   * Does not put quotes around strings, as ":echo" displays values.
   * When "copyID" is not NULL replace recursive lists and dicts with "...".
!  * May return NULL;
   */
      static char_u *
  echo_string(tv, tofree, numbuf, copyID)
--- 6802,6808 ----
   * "numbuf" is used for a number.
   * Does not put quotes around strings, as ":echo" displays values.
   * When "copyID" is not NULL replace recursive lists and dicts with "...".
!  * May return NULL.
   */
      static char_u *
  echo_string(tv, tofree, numbuf, copyID)
***************
*** 6887,6893 ****
   * If the memory is allocated "tofree" is set to it, otherwise NULL.
   * "numbuf" is used for a number.
   * Puts quotes around strings, so that they can be parsed back by eval().
!  * May return NULL;
   */
      static char_u *
  tv2string(tv, tofree, numbuf, copyID)
--- 6887,6893 ----
   * If the memory is allocated "tofree" is set to it, otherwise NULL.
   * "numbuf" is used for a number.
   * Puts quotes around strings, so that they can be parsed back by eval().
!  * May return NULL.
   */
      static char_u *
  tv2string(tv, tofree, numbuf, copyID)
***************
*** 14974,14979 ****
--- 14974,14983 ----
  
      p1 = tv2string(&(*(listitem_T **)s1)->li_tv, &tofree1, numbuf1, 0);
      p2 = tv2string(&(*(listitem_T **)s2)->li_tv, &tofree2, numbuf2, 0);
+     if (p1 == NULL)
+ 	p1 = (char_u *)"";
+     if (p2 == NULL)
+ 	p2 = (char_u *)"";
      if (item_compare_ic)
  	res = STRICMP(p1, p2);
      else
***************
*** 15463,15469 ****
  
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = tv2string(&argvars[0], &tofree, numbuf, 0);
!     if (tofree == NULL)
  	rettv->vval.v_string = vim_strsave(rettv->vval.v_string);
  }
  
--- 15467,15474 ----
  
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = tv2string(&argvars[0], &tofree, numbuf, 0);
!     /* Make a copy if we have a value but it's not in allocate memory. */
!     if (rettv->vval.v_string != NULL && tofree == NULL)
  	rettv->vval.v_string = vim_strsave(rettv->vval.v_string);
  }
  
***************
*** 20167,20172 ****
--- 20174,20180 ----
  		char_u	buf[MSG_BUF_LEN];
  		char_u	numbuf2[NUMBUFLEN];
  		char_u	*tofree;
+ 		char_u	*s;
  
  		msg_puts((char_u *)"(");
  		for (i = 0; i < argcount; ++i)
***************
*** 20177,20186 ****
  			msg_outnum((long)argvars[i].vval.v_number);
  		    else
  		    {
! 			trunc_string(tv2string(&argvars[i], &tofree,
! 					      numbuf2, 0), buf, MSG_BUF_CLEN);
! 			msg_puts(buf);
! 			vim_free(tofree);
  		    }
  		}
  		msg_puts((char_u *)")");
--- 20185,20197 ----
  			msg_outnum((long)argvars[i].vval.v_number);
  		    else
  		    {
! 			s = tv2string(&argvars[i], &tofree, numbuf2, 0);
! 			if (s != NULL)
! 			{
! 			    trunc_string(s, buf, MSG_BUF_CLEN);
! 			    msg_puts(buf);
! 			    vim_free(tofree);
! 			}
  		    }
  		}
  		msg_puts((char_u *)")");
***************
*** 20258,20271 ****
  	    char_u	buf[MSG_BUF_LEN];
  	    char_u	numbuf2[NUMBUFLEN];
  	    char_u	*tofree;
  
  	    /* The value may be very long.  Skip the middle part, so that we
  	     * have some idea how it starts and ends. smsg() would always
  	     * truncate it at the end. */
! 	    trunc_string(tv2string(fc.rettv, &tofree, numbuf2, 0),
! 							   buf, MSG_BUF_CLEN);
! 	    smsg((char_u *)_("%s returning %s"), sourcing_name, buf);
! 	    vim_free(tofree);
  	}
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
--- 20269,20286 ----
  	    char_u	buf[MSG_BUF_LEN];
  	    char_u	numbuf2[NUMBUFLEN];
  	    char_u	*tofree;
+ 	    char_u	*s;
  
  	    /* The value may be very long.  Skip the middle part, so that we
  	     * have some idea how it starts and ends. smsg() would always
  	     * truncate it at the end. */
! 	    s = tv2string(fc.rettv, &tofree, numbuf2, 0);
! 	    if (s != NULL)
! 	    {
! 		trunc_string(s, buf, MSG_BUF_CLEN);
! 		smsg((char_u *)_("%s returning %s"), sourcing_name, buf);
! 		vim_free(tofree);
! 	    }
  	}
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
*** ../vim-7.1.073/src/version.c	Tue Aug 14 22:15:53 2007
--- src/version.c	Tue Aug 14 22:27:24 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     74,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
159. You get excited whenever discussing your hard drive.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.075
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.075
Problem:    ":let v:statusmsg" reads memory already freed.
Solution:   Don't set v:statusmsg when listing it.
Files:	    src/eval.c


*** ../vim-7.1.074/src/eval.c	Tue Aug 14 22:28:35 2007
--- src/eval.c	Tue Aug 14 22:01:12 2007
***************
*** 18022,18028 ****
      int		type;
      char_u	*string;
  {
!     msg_attr(prefix, 0);    /* don't use msg(), it overwrites "v:statusmsg" */
      if (name != NULL)	/* "a:" vars don't have a name stored */
  	msg_puts(name);
      msg_putchar(' ');
--- 18022,18030 ----
      int		type;
      char_u	*string;
  {
!     /* don't use msg() or msg_attr() to avoid overwriting "v:statusmsg" */
!     msg_start();
!     msg_puts(prefix);
      if (name != NULL)	/* "a:" vars don't have a name stored */
  	msg_puts(name);
      msg_putchar(' ');
*** ../vim-7.1.074/src/version.c	Tue Aug 14 22:28:35 2007
--- src/version.c	Tue Aug 14 22:39:49 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     75,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
160. You get in the elevator and double-click the button for the floor
     you want.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.076
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.076
Problem:    Another strcpy() with overlapping arguments.
Solution:   Use mch_memmove(). (Dominique Pelle)  And another one.
Files:	    src/ex_docmd.c, src/normal.c


*** ../vim-7.1.075/src/ex_docmd.c	Sat Aug 11 15:59:44 2007
--- src/ex_docmd.c	Wed Aug  8 22:28:33 2007
***************
*** 4493,4499 ****
  	    if (eap->argt & (USECTRLV | XFILE))
  		++p;		/* skip CTRL-V and next char */
  	    else
! 		STRCPY(p, p + 1);	/* remove CTRL-V and skip next char */
  	    if (*p == NUL)		/* stop at NUL after CTRL-V */
  		break;
  	}
--- 4493,4500 ----
  	    if (eap->argt & (USECTRLV | XFILE))
  		++p;		/* skip CTRL-V and next char */
  	    else
! 				/* remove CTRL-V and skip next char */
! 		mch_memmove(p, p + 1, STRLEN(p));
  	    if (*p == NUL)		/* stop at NUL after CTRL-V */
  		break;
  	}
*** ../vim-7.1.075/src/normal.c	Wed Aug  8 21:41:19 2007
--- src/normal.c	Sun Aug 12 17:35:20 2007
***************
*** 3760,3766 ****
      extra_len = (int)STRLEN(p);
      overflow = old_len + extra_len - SHOWCMD_COLS;
      if (overflow > 0)
! 	STRCPY(showcmd_buf, showcmd_buf + overflow);
      STRCAT(showcmd_buf, p);
  
      if (char_avail())
--- 3760,3767 ----
      extra_len = (int)STRLEN(p);
      overflow = old_len + extra_len - SHOWCMD_COLS;
      if (overflow > 0)
! 	mch_memmove(showcmd_buf, showcmd_buf + overflow,
! 						      old_len - overflow + 1);
      STRCAT(showcmd_buf, p);
  
      if (char_avail())
*** ../vim-7.1.075/src/version.c	Tue Aug 14 22:40:13 2007
--- src/version.c	Tue Aug 14 22:53:13 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     76,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
161. You get up before the sun rises to check your e-mail, and you
     find yourself in the very same chair long after the sun has set.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.077
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.077
Problem:    Using "can_spell" without initializing it. (Dominique Pelle)
Solution:   Set a default for get_syntax_attr().
Files:	    src/syntax.c


*** ../vim-7.1.076/src/syntax.c	Thu Jul 26 22:55:11 2007
--- src/syntax.c	Sun Aug 12 19:49:07 2007
***************
*** 1727,1732 ****
--- 1727,1739 ----
  {
      int	    attr = 0;
  
+     if (can_spell != NULL)
+ 	/* Default: Only do spelling when there is no @Spell cluster or when
+ 	 * ":syn spell toplevel" was used. */
+ 	*can_spell = syn_buf->b_syn_spell == SYNSPL_DEFAULT
+ 		    ? (syn_buf->b_spell_cluster_id == 0)
+ 		    : (syn_buf->b_syn_spell == SYNSPL_TOP);
+ 
      /* check for out of memory situation */
      if (syn_buf->b_sst_array == NULL)
  	return 0;
*** ../vim-7.1.076/src/version.c	Tue Aug 14 22:54:00 2007
--- src/version.c	Tue Aug 14 23:06:26 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     77,
  /**/

-- 
Send $25.00 for handy leaflet on how to make money by selling leaflets

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.078
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.078
Problem:    Dropping a file name on gvim that contains a CSI byte doesn't work
	    when editing the command line.
Solution:   Escape the CSI byte when inserting in the input buffer. (Yukihiro
	    Nakadaira)
Files:	    src/gui.c, src/ui.c


*** ../vim-7.1.077/src/gui.c	Thu May 10 19:19:15 2007
--- src/gui.c	Tue Aug 14 12:41:43 2007
***************
*** 5117,5123 ****
  		p = vim_strsave_escaped(fnames[i], (char_u *)"\\ \t\"|");
  # endif
  		if (p != NULL)
! 		    add_to_input_buf(p, (int)STRLEN(p));
  		vim_free(p);
  		vim_free(fnames[i]);
  	    }
--- 5117,5123 ----
  		p = vim_strsave_escaped(fnames[i], (char_u *)"\\ \t\"|");
  # endif
  		if (p != NULL)
! 		    add_to_input_buf_csi(p, (int)STRLEN(p));
  		vim_free(p);
  		vim_free(fnames[i]);
  	    }
*** ../vim-7.1.077/src/ui.c	Thu May 10 21:14:11 2007
--- src/ui.c	Tue Aug 14 12:41:42 2007
***************
*** 1603,1610 ****
  #if defined(FEAT_GUI) || defined(FEAT_MOUSE_GPM) \
  	|| defined(FEAT_XCLIPBOARD) || defined(VMS) \
  	|| defined(FEAT_SNIFF) || defined(FEAT_CLIENTSERVER) \
- 	|| (defined(FEAT_GUI) && (!defined(USE_ON_FLY_SCROLL) \
- 		|| defined(FEAT_MENU))) \
  	|| defined(PROTO)
  /*
   * Add the given bytes to the input buffer
--- 1603,1608 ----
***************
*** 1630,1636 ****
  }
  #endif
  
! #if (defined(FEAT_XIM) && defined(FEAT_GUI_GTK)) \
  	|| (defined(FEAT_MBYTE) && defined(FEAT_MBYTE_IME)) \
  	|| (defined(FEAT_GUI) && (!defined(USE_ON_FLY_SCROLL) \
  		|| defined(FEAT_MENU))) \
--- 1628,1636 ----
  }
  #endif
  
! #if ((defined(FEAT_XIM) || defined(FEAT_DND)) && defined(FEAT_GUI_GTK)) \
! 	|| defined(FEAT_GUI_MSWIN) \
! 	|| defined(FEAT_GUI_MAC) \
  	|| (defined(FEAT_MBYTE) && defined(FEAT_MBYTE_IME)) \
  	|| (defined(FEAT_GUI) && (!defined(USE_ON_FLY_SCROLL) \
  		|| defined(FEAT_MENU))) \
*** ../vim-7.1.077/src/version.c	Tue Aug 14 23:06:51 2007
--- src/version.c	Wed Aug 15 20:07:06 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     78,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
164. You got out to buy software, instead of going out for a beer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.079
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.079
Problem:    When the locale is "C" and 'encoding' is "latin1" then the "@"
	    character in 'isfname', 'isprint', etc. doesn't pick up accented
	    characters.
Solution:   Instead of isalpha() use MB_ISLOWER() and MB_ISUPPER().
Files:	    src/charset.c, src/macros.h


*** ../vim-7.1.078/src/charset.c	Mon Aug  6 22:27:12 2007
--- src/charset.c	Tue Aug 14 13:43:30 2007
***************
*** 207,213 ****
  	    }
  	    while (c <= c2)
  	    {
! 		if (!do_isalpha || isalpha(c)
  #ifdef FEAT_FKMAP
  			|| (p_altkeymap && (F_isalpha(c) || F_isdigit(c)))
  #endif
--- 207,216 ----
  	    }
  	    while (c <= c2)
  	    {
! 		/* Use the MB_ functions here, because isalpha() doesn't
! 		 * work properly when 'encoding' is "latin1" and the locale is
! 		 * "C".  */
! 		if (!do_isalpha || MB_ISLOWER(c) || MB_ISUPPER(c)
  #ifdef FEAT_FKMAP
  			|| (p_altkeymap && (F_isalpha(c) || F_isdigit(c)))
  #endif
*** ../vim-7.1.078/src/macros.h	Thu May 10 19:21:00 2007
--- src/macros.h	Sat Aug  4 13:44:18 2007
***************
*** 54,63 ****
  
  /*
   * toupper() and tolower() that use the current locale.
!  * On some systems toupper()/tolower() only work on lower/uppercase characters
   * Careful: Only call TOUPPER_LOC() and TOLOWER_LOC() with a character in the
   * range 0 - 255.  toupper()/tolower() on some systems can't handle others.
!  * Note: for UTF-8 use utf_toupper() and utf_tolower().
   */
  #ifdef MSWIN
  #  define TOUPPER_LOC(c)	toupper_tab[(c) & 255]
--- 54,65 ----
  
  /*
   * toupper() and tolower() that use the current locale.
!  * On some systems toupper()/tolower() only work on lower/uppercase
!  * characters, first use islower() or isupper() then.
   * Careful: Only call TOUPPER_LOC() and TOLOWER_LOC() with a character in the
   * range 0 - 255.  toupper()/tolower() on some systems can't handle others.
!  * Note: It is often better to use MB_TOLOWER() and MB_TOUPPER(), because many
!  * toupper() and tolower() implementations only work for ASCII.
   */
  #ifdef MSWIN
  #  define TOUPPER_LOC(c)	toupper_tab[(c) & 255]
*** ../vim-7.1.078/src/version.c	Wed Aug 15 20:07:53 2007
--- src/version.c	Wed Aug 15 20:39:18 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     79,
  /**/

-- 
You're as much use as a condom machine at the Vatican.
                  -- Rimmer to Holly in Red Dwarf 'Queeg'

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.080 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.080 (extra)
Problem:    Compiler warnings for using "const char *" for "char *".
Solution:   Add type casts. (Chris Sutcliffe)
Files:	    src/GvimExt/gvimext.cpp


*** ../vim-7.1.079/src/GvimExt/gvimext.cpp	Thu May 10 21:09:38 2007
--- src/GvimExt/gvimext.cpp	Thu Aug 16 21:25:56 2007
***************
*** 69,82 ****
  
      // Registry didn't work, use the search path.
      if (name[0] == 0)
! 	strcpy(name, searchpath("gvim.exe"));
  
      if (!runtime)
      {
  	// Only when looking for the executable, not the runtime dir, we can
  	// search for the batch file or a name without a path.
  	if (name[0] == 0)
! 	    strcpy(name, searchpath("gvim.bat"));
  	if (name[0] == 0)
  	    strcpy(name, "gvim");	// finds gvim.bat or gvim.exe
  
--- 69,82 ----
  
      // Registry didn't work, use the search path.
      if (name[0] == 0)
! 	strcpy(name, searchpath((char *)"gvim.exe"));
  
      if (!runtime)
      {
  	// Only when looking for the executable, not the runtime dir, we can
  	// search for the batch file or a name without a path.
  	if (name[0] == 0)
! 	    strcpy(name, searchpath((char *)"gvim.bat"));
  	if (name[0] == 0)
  	    strcpy(name, "gvim");	// finds gvim.bat or gvim.exe
  
***************
*** 152,160 ****
  	FARPROC	    *ptr;
      } libintl_entry[] =
      {
! 	{"gettext",		(FARPROC*)&dyn_libintl_gettext},
! 	{"textdomain",		(FARPROC*)&dyn_libintl_textdomain},
! 	{"bindtextdomain",	(FARPROC*)&dyn_libintl_bindtextdomain},
  	{NULL, NULL}
      };
  
--- 152,160 ----
  	FARPROC	    *ptr;
      } libintl_entry[] =
      {
! 	{(char *)"gettext",		(FARPROC*)&dyn_libintl_gettext},
! 	{(char *)"textdomain",		(FARPROC*)&dyn_libintl_textdomain},
! 	{(char *)"bindtextdomain",	(FARPROC*)&dyn_libintl_bindtextdomain},
  	{NULL, NULL}
      };
  
***************
*** 835,841 ****
  		    (LPTSTR)location) > (HINSTANCE)32)
  	    return location;
      }
!     return "";
  }
  # endif
  #endif
--- 835,841 ----
  		    (LPTSTR)location) > (HINSTANCE)32)
  	    return location;
      }
!     return (char *)"";
  }
  # endif
  #endif
*** ../vim-7.1.079/src/version.c	Wed Aug 15 20:40:45 2007
--- src/version.c	Sat Aug 18 16:58:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     80,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
192. Your boss asks you to "go fer" coffee and you come up with 235 FTP sites.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.081
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.081
Problem:    Command line completion for a shell command: "cat </tmp/file<Tab>"
	    doesn't work.
Solution:   Start the file name at any character that can't be in a file name.
	    (Martin Toft)
Files:	    src/ex_docmd.c


*** ../vim-7.1.080/src/ex_docmd.c	Tue Aug 14 22:54:00 2007
--- src/ex_docmd.c	Sat Aug 18 14:58:53 2007
***************
*** 3281,3319 ****
  
      if (ea.argt & XFILE)
      {
! 	int in_quote = FALSE;
! 	char_u *bow = NULL;	/* Beginning of word */
  
  	/*
  	 * Allow spaces within back-quotes to count as part of the argument
  	 * being expanded.
  	 */
  	xp->xp_pattern = skipwhite(arg);
! 	for (p = xp->xp_pattern; *p; )
  	{
! 	    if (*p == '\\' && p[1] != NUL)
  		++p;
  #ifdef SPACE_IN_FILENAME
! 	    else if (vim_iswhite(*p) && (!(ea.argt & NOSPC) || usefilter))
  #else
! 	    else if (vim_iswhite(*p))
  #endif
  	    {
! 		p = skipwhite(p);
  		if (in_quote)
  		    bow = p;
  		else
  		    xp->xp_pattern = p;
! 		--p;
! 	    }
! 	    else if (*p == '`')
! 	    {
! 		if (!in_quote)
! 		{
! 		    xp->xp_pattern = p;
! 		    bow = p + 1;
! 		}
! 		in_quote = !in_quote;
  	    }
  	    mb_ptr_adv(p);
  	}
--- 3281,3344 ----
  
      if (ea.argt & XFILE)
      {
! 	int	c;
! 	int	in_quote = FALSE;
! 	char_u	*bow = NULL;	/* Beginning of word */
  
  	/*
  	 * Allow spaces within back-quotes to count as part of the argument
  	 * being expanded.
  	 */
  	xp->xp_pattern = skipwhite(arg);
! 	p = xp->xp_pattern;
! 	while (*p != NUL)
  	{
! #ifdef FEAT_MBYTE
! 	    if (has_mbyte)
! 		c = mb_ptr2char(p);
! 	    else
! #endif
! 		c = *p;
! 	    if (c == '\\' && p[1] != NUL)
  		++p;
+ 	    else if (c == '`')
+ 	    {
+ 		if (!in_quote)
+ 		{
+ 		    xp->xp_pattern = p;
+ 		    bow = p + 1;
+ 		}
+ 		in_quote = !in_quote;
+ 	    }
  #ifdef SPACE_IN_FILENAME
! 	    else if (!vim_isfilec(c) && (!(ea.argt & NOSPC) || usefilter))
  #else
! 	    else if (!vim_isfilec(c))
  #endif
  	    {
! 		while (*p != NUL)
! 		{
! #ifdef FEAT_MBYTE
! 		    if (has_mbyte)
! 			c = mb_ptr2char(p);
! 		    else
! #endif
! 			c = *p;
! 		    if (c == '`' || vim_isfilec(c))
! 			break;
! #ifdef FEAT_MBYTE
! 		    if (has_mbyte)
! 			len = (*mb_ptr2len)(p);
! 		    else
! #endif
! 			len = 1;
! 		    mb_ptr_adv(p);
! 		}
  		if (in_quote)
  		    bow = p;
  		else
  		    xp->xp_pattern = p;
! 		p -= len;
  	    }
  	    mb_ptr_adv(p);
  	}
*** ../vim-7.1.080/src/version.c	Sat Aug 18 16:59:43 2007
--- src/version.c	Sat Aug 18 17:45:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     81,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
194. Your business cards contain your e-mail and home page address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.082
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.082
Problem:    After a ":split" the matchparen highlighting isn't there.
Solution:   Install a WinEnter autocommand.  Also fixes that after
	    ":NoMatchParen" only the current window is updated. (Martin Toft)
Files:	    runtime/doc/pi_paren.txt, runtime/plugin/matchparen.vim


*** ../vim-7.1.081/runtime/doc/pi_paren.txt	Sat May 12 16:23:41 2007
--- runtime/doc/pi_paren.txt	Sat Aug 18 15:08:32 2007
***************
*** 12,19 ****
  You can avoid loading this plugin by setting the "loaded_matchparen" variable: >
  	:let loaded_matchparen = 1
  
! The plugin installs CursorMoved autocommands to redefine the match
! highlighting.
  
  To disable the plugin after it was loaded use this command: >
  
--- 12,19 ----
  You can avoid loading this plugin by setting the "loaded_matchparen" variable: >
  	:let loaded_matchparen = 1
  
! The plugin installs CursorMoved, CursorMovedI and WinEnter autocommands to
! redefine the match highlighting.
  
  To disable the plugin after it was loaded use this command: >
  
*** ../vim-7.1.081/runtime/plugin/matchparen.vim	Thu Aug  2 23:00:06 2007
--- runtime/plugin/matchparen.vim	Sat Aug 18 15:08:32 2007
***************
*** 1,6 ****
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2007 Jul 30
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
--- 1,6 ----
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2007 Aug 8
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
***************
*** 13,19 ****
  
  augroup matchparen
    " Replace all matchparen autocommands
!   autocmd! CursorMoved,CursorMovedI * call s:Highlight_Matching_Pair()
  augroup END
  
  " Skip the rest if it was already done.
--- 13,19 ----
  
  augroup matchparen
    " Replace all matchparen autocommands
!   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
  augroup END
  
  " Skip the rest if it was already done.
***************
*** 126,132 ****
  endfunction
  
  " Define commands that will disable and enable the plugin.
! command! NoMatchParen 3match none | unlet! g:loaded_matchparen | au! matchparen
! command! DoMatchParen runtime plugin/matchparen.vim | doau CursorMoved
  
  let &cpo = cpo_save
--- 126,133 ----
  endfunction
  
  " Define commands that will disable and enable the plugin.
! command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen |
! 	  \ au! matchparen
! command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
  
  let &cpo = cpo_save
*** ../vim-7.1.081/src/version.c	Sat Aug 18 17:46:50 2007
--- src/version.c	Sat Aug 18 18:19:20 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     82,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
195. Your cat has its own home page.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.083
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.083 (after 7.1.081)
Problem:    Command line completion doesn't work with wildcards.
Solution:   Add vim_isfilec_or_wc() and use it. (Martin Toft)
Files:	    src/charset.c, src/proto/charset.pro, src/ex_docmd.c


*** ../vim-7.1.082/src/charset.c	Wed Aug 15 20:40:45 2007
--- src/charset.c	Sun Aug 19 22:30:25 2007
***************
*** 932,937 ****
--- 932,954 ----
  }
  
  /*
+  * return TRUE if 'c' is a valid file-name character or a wildcard character
+  * Assume characters above 0x100 are valid (multi-byte).
+  * Explicitly interpret ']' as a wildcard character as mch_has_wildcard("]")
+  * returns false.
+  */
+     int
+ vim_isfilec_or_wc(c)
+     int c;
+ {
+     char_u buf[2];
+ 
+     buf[0] = (char_u)c;
+     buf[1] = NUL;
+     return vim_isfilec(c) || c == ']' || mch_has_wildcard(buf);
+ }
+ 
+ /*
   * return TRUE if 'c' is a printable character
   * Assume characters above 0x100 are printable (multi-byte), except for
   * Unicode.
*** ../vim-7.1.082/src/proto/charset.pro	Sat May  5 19:21:32 2007
--- src/proto/charset.pro	Sun Aug 19 22:30:28 2007
***************
*** 21,26 ****
--- 21,27 ----
  int vim_iswordp __ARGS((char_u *p));
  int vim_iswordc_buf __ARGS((char_u *p, buf_T *buf));
  int vim_isfilec __ARGS((int c));
+ int vim_isfilec_or_wc __ARGS((int c));
  int vim_isprintc __ARGS((int c));
  int vim_isprintc_strict __ARGS((int c));
  int lbr_chartabsize __ARGS((unsigned char *s, colnr_T col));
*** ../vim-7.1.082/src/ex_docmd.c	Sat Aug 18 17:46:50 2007
--- src/ex_docmd.c	Sun Aug 19 22:29:17 2007
***************
*** 3311,3319 ****
  		in_quote = !in_quote;
  	    }
  #ifdef SPACE_IN_FILENAME
! 	    else if (!vim_isfilec(c) && (!(ea.argt & NOSPC) || usefilter))
  #else
! 	    else if (!vim_isfilec(c))
  #endif
  	    {
  		while (*p != NUL)
--- 3311,3320 ----
  		in_quote = !in_quote;
  	    }
  #ifdef SPACE_IN_FILENAME
! 	    else if (!vim_isfilec_or_wc(c)
! 					 && (!(ea.argt & NOSPC) || usefilter))
  #else
! 	    else if (!vim_isfilec_or_wc(c))
  #endif
  	    {
  		while (*p != NUL)
***************
*** 3324,3330 ****
  		    else
  #endif
  			c = *p;
! 		    if (c == '`' || vim_isfilec(c))
  			break;
  #ifdef FEAT_MBYTE
  		    if (has_mbyte)
--- 3325,3331 ----
  		    else
  #endif
  			c = *p;
! 		    if (c == '`' || vim_isfilec_or_wc(c))
  			break;
  #ifdef FEAT_MBYTE
  		    if (has_mbyte)
*** ../vim-7.1.082/src/version.c	Sat Aug 18 18:20:57 2007
--- src/version.c	Sun Aug 19 22:31:43 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     83,
  /**/

-- 
    "You mean there really is an answer?"
    "Yes! But you're not going to like it!"
    "Oh do please tell us!"
    "You're really not going to like it!"
    "but we MUST know - tell us"
    "Alright, the answer is...."
    "yes..."
    "... is ..."
    "yes... come on!"
    "is 42!"
		(Douglas Adams - The Hitchhiker's Guide to the Galaxy)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.084
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.084
Problem:    Using the "-nb" argument twice causes netbeans not to get
	    fileOpened events.
Solution:   Change "&" to "&&". (Xavier de Gaye)
Files:	    src/ex_cmds.c


*** ../vim-7.1.083/src/ex_cmds.c	Wed Jul 25 22:55:22 2007
--- src/ex_cmds.c	Tue Aug 21 15:02:43 2007
***************
*** 3776,3782 ****
  	    workshop_file_opened((char *)curbuf->b_ffname, curbuf->b_p_ro);
  # endif
  # ifdef FEAT_NETBEANS_INTG
! 	if (usingNetbeans & ((flags & ECMD_SET_HELP) != ECMD_SET_HELP))
  	    netbeans_file_opened(curbuf);
  # endif
      }
--- 3787,3793 ----
  	    workshop_file_opened((char *)curbuf->b_ffname, curbuf->b_p_ro);
  # endif
  # ifdef FEAT_NETBEANS_INTG
! 	if (usingNetbeans && ((flags & ECMD_SET_HELP) != ECMD_SET_HELP))
  	    netbeans_file_opened(curbuf);
  # endif
      }
*** ../vim-7.1.083/src/version.c	Sun Aug 19 22:42:27 2007
--- src/version.c	Tue Aug 21 15:04:03 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     84,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
220. Your wife asks for sex and you tell her where to find you on IRC.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.085
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.085
Problem:    ":e fold.c" then ":sp fold.c" results in folds of original window
	    to disappear. (Akita Noek)
Solution:   Invoke foldUpdateAll() for all windows of the changed buffer.
	    (Martin Toft)
Files:	    src/ex_cmds.c


*** ../vim-7.1.084/src/ex_cmds.c	Tue Aug 21 15:05:54 2007
--- src/ex_cmds.c	Tue Aug 21 15:02:43 2007
***************
*** 2974,2980 ****
   * 'fnum' is the number of the file, if zero use ffname/sfname.
   *
   * Return 1 for "normal" error, 2 for "not written" error, 0 for success
!  * -1 for succesfully opening another file.
   * 'lnum' is the line number for the cursor in the new file (if non-zero).
   */
      int
--- 2974,2980 ----
   * 'fnum' is the number of the file, if zero use ffname/sfname.
   *
   * Return 1 for "normal" error, 2 for "not written" error, 0 for success
!  * -1 for successfully opening another file.
   * 'lnum' is the line number for the cursor in the new file (if non-zero).
   */
      int
***************
*** 3584,3592 ****
  	curwin_init();
  
  #ifdef FEAT_FOLDING
! 	/* It's like all lines in the buffer changed.  Need to update
! 	 * automatic folding. */
  	foldUpdateAll(curwin);
  #endif
  
  	/* Change directories when the 'acd' option is set. */
--- 3584,3603 ----
  	curwin_init();
  
  #ifdef FEAT_FOLDING
! 	/* It's possible that all lines in the buffer changed.  Need to update
! 	 * automatic folding for all windows where it's used. */
! # ifdef FEAT_WINDOWS
! 	{
! 	    win_T	    *win;
! 	    tabpage_T	    *tp;
! 
! 	    FOR_ALL_TAB_WINDOWS(tp, win)
! 		if (win->w_buffer == curbuf)
! 		    foldUpdateAll(win);
! 	}
! # else
  	foldUpdateAll(curwin);
+ # endif
  #endif
  
  	/* Change directories when the 'acd' option is set. */
*** ../vim-7.1.084/src/version.c	Tue Aug 21 15:05:54 2007
--- src/version.c	Tue Aug 21 15:26:43 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     85,
  /**/

-- 
Your fault: core dumped

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.086
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.086
Problem:    Crash when using specific Python syntax highlighting.  (Quirk)
Solution:   Check for a negative index, coming from a keyword match at the
	    start of a line from a saved state.
Files:	    src/syntax.c


*** ../vim-7.1.085/src/syntax.c	Tue Aug 14 23:06:51 2007
--- src/syntax.c	Tue Aug 21 17:13:51 2007
***************
*** 279,285 ****
   */
  typedef struct state_item
  {
!     int		si_idx;			/* index of syntax pattern */
      int		si_id;			/* highlight group ID for keywords */
      int		si_trans_id;		/* idem, transparancy removed */
      int		si_m_lnum;		/* lnum of the match */
--- 279,286 ----
   */
  typedef struct state_item
  {
!     int		si_idx;			/* index of syntax pattern or
! 					   KEYWORD_IDX */
      int		si_id;			/* highlight group ID for keywords */
      int		si_trans_id;		/* idem, transparancy removed */
      int		si_m_lnum;		/* lnum of the match */
***************
*** 837,845 ****
  			    current_lnum = end_lnum;
  			    break;
  			}
! 			spp = &(SYN_ITEMS(syn_buf)[cur_si->si_idx]);
! 			found_flags = spp->sp_flags;
! 			found_match_idx = spp->sp_sync_idx;
  			found_current_lnum = current_lnum;
  			found_current_col = current_col;
  			found_m_endpos = cur_si->si_m_endpos;
--- 838,855 ----
  			    current_lnum = end_lnum;
  			    break;
  			}
! 			if (cur_si->si_idx < 0)
! 			{
! 			    /* Cannot happen? */
! 			    found_flags = 0;
! 			    found_match_idx = KEYWORD_IDX;
! 			}
! 			else
! 			{
! 			    spp = &(SYN_ITEMS(syn_buf)[cur_si->si_idx]);
! 			    found_flags = spp->sp_flags;
! 			    found_match_idx = spp->sp_sync_idx;
! 			}
  			found_current_lnum = current_lnum;
  			found_current_col = current_col;
  			found_m_endpos = cur_si->si_m_endpos;
***************
*** 2533,2538 ****
--- 2543,2552 ----
      stateitem_T	*sip = &CUR_STATE(idx);
      synpat_T	*spp;
  
+     /* This should not happen... */
+     if (sip->si_idx < 0)
+ 	return;
+ 
      spp = &(SYN_ITEMS(syn_buf)[sip->si_idx]);
      if (sip->si_flags & HL_MATCH)
  	sip->si_id = spp->sp_syn_match_id;
***************
*** 2648,2653 ****
--- 2662,2671 ----
      lpos_T	end_endpos;
      int		end_idx;
  
+     /* return quickly for a keyword */
+     if (sip->si_idx < 0)
+ 	return;
+ 
      /* Don't update when it's already done.  Can be a match of an end pattern
       * that started in a previous line.  Watch out: can also be a "keepend"
       * from a containing item. */
***************
*** 2759,2764 ****
--- 2777,2786 ----
      lpos_T	pos;
      char_u	*line;
      int		had_match = FALSE;
+ 
+     /* just in case we are invoked for a keyword */
+     if (idx < 0)
+ 	return;
  
      /*
       * Check for being called with a START pattern.
*** ../vim-7.1.085/src/version.c	Tue Aug 21 15:28:32 2007
--- src/version.c	Tue Aug 21 17:21:06 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     86,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
222. You send more than 20 personal e-mails a day.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.087
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.087
Problem:    Reading past ":cscope find" command.  Writing past end of a buffer.
Solution:   Check length of the argument before using the pattern.  Use
	    vim_strncpy().  (Dominique Pelle)
Files:	    if_cscope.c


*** ../vim-7.1.086/src/if_cscope.c	Sun Mar 11 15:48:29 2007
--- src/if_cscope.c	Sun Aug 19 22:17:09 2007
***************
*** 73,78 ****
--- 73,80 ----
  
  
  static csinfo_T	    csinfo[CSCOPE_MAX_CONNECTIONS];
+ static int	    eap_arg_len;    /* length of eap->arg, set in
+ 				       cs_lookup_cmd() */
  static cscmd_T	    cs_cmds[] =
  {
      { "add",	cs_add,
***************
*** 260,273 ****
  
      if ((p = cs_manage_matches(NULL, NULL, -1, Get)) == NULL)
  	return TRUE;
! 
!     if ((int)strlen(p) > size)
!     {
! 	strncpy((char *)buf, p, size - 1);
! 	buf[size] = '\0';
!     }
!     else
! 	(void)strcpy((char *)buf, p);
  
      return FALSE;
  } /* cs_fgets */
--- 262,268 ----
  
      if ((p = cs_manage_matches(NULL, NULL, -1, Get)) == NULL)
  	return TRUE;
!     vim_strncpy(buf, (char_u *)p, size - 1);
  
      return FALSE;
  } /* cs_fgets */
***************
*** 386,392 ****
   * PRIVATE: cs_add
   *
   * add cscope database or a directory name (to look for cscope.out)
!  * the the cscope connection list
   *
   * MAXPATHL 256
   */
--- 381,387 ----
   * PRIVATE: cs_add
   *
   * add cscope database or a directory name (to look for cscope.out)
!  * to the cscope connection list
   *
   * MAXPATHL 256
   */
***************
*** 966,972 ****
      }
  
      pat = opt + strlen(opt) + 1;
!     if (pat == NULL || (pat != NULL && pat[0] == '\0'))
      {
  	cs_usage_msg(Find);
  	return FALSE;
--- 961,967 ----
      }
  
      pat = opt + strlen(opt) + 1;
!     if (pat >= (char *)eap->arg + eap_arg_len)
      {
  	cs_usage_msg(Find);
  	return FALSE;
***************
*** 1317,1323 ****
  #else
  	    /* compare pathnames first */
  	    && ((fullpathcmp(csinfo[j].fname, fname, FALSE) & FPC_SAME)
! 		/* if not Windows 9x, test index file atributes too */
  		|| (!mch_windows95()
  		    && csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
--- 1312,1318 ----
  #else
  	    /* compare pathnames first */
  	    && ((fullpathcmp(csinfo[j].fname, fname, FALSE) & FPC_SAME)
! 		/* if not Windows 9x, test index file attributes too */
  		|| (!mch_windows95()
  		    && csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
***************
*** 1401,1406 ****
--- 1396,1404 ----
      if (eap->arg == NULL)
  	return NULL;
  
+     /* Store length of eap->arg before it gets modified by strtok(). */
+     eap_arg_len = STRLEN(eap->arg);
+ 
      if ((stok = strtok((char *)(eap->arg), (const char *)" ")) == NULL)
  	return NULL;
  
***************
*** 2195,2201 ****
  	    cs_add_common(dblist[i], pplist[i], fllist[i]);
  	    if (p_csverbose)
  	    {
! 		/* dont' use smsg_attr because want to display
  		 * connection number in the same line as
  		 * "Added cscope database..."
  		 */
--- 2193,2199 ----
  	    cs_add_common(dblist[i], pplist[i], fllist[i]);
  	    if (p_csverbose)
  	    {
! 		/* don't use smsg_attr() because we want to display the
  		 * connection number in the same line as
  		 * "Added cscope database..."
  		 */
*** ../vim-7.1.086/src/version.c	Tue Aug 21 17:29:04 2007
--- src/version.c	Tue Aug 21 17:59:42 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     87,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
223. You set up a web-cam as your home's security system.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.088 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.088 (extra)
Problem:    The coordinates used by ":winpos" differ from what getwinposx()
	    and getwinposy() return.
Solution:   Use MoveWindowStructure() instead of MoveWindow(). (Michael Henry)
Files:	    src/gui_mac.c


*** ../vim-7.1.087/src/gui_mac.c	Tue Jun 19 16:33:53 2007
--- src/gui_mac.c	Wed Aug 29 20:33:34 2007
***************
*** 3149,3155 ****
      /* TODO:  Should make sure the window is move within range
       *	      e.g.: y > ~16 [Menu bar], x > 0, x < screen width
       */
!     MoveWindow(gui.VimWindow, x, y, TRUE);
  }
  
      void
--- 3149,3155 ----
      /* TODO:  Should make sure the window is move within range
       *	      e.g.: y > ~16 [Menu bar], x > 0, x < screen width
       */
!     MoveWindowStructure(gui.VimWindow, x, y, TRUE);
  }
  
      void
***************
*** 5556,5562 ****
   * SetDialogTracksCursor() : Get the I-beam cursor over input box
   * MoveDialogItem():	    Probably better than SetDialogItem
   * SizeDialogItem():		(but is it Carbon Only?)
!  * AutoSizeDialog():	    Magic resize of dialog based on text lenght
   */
  }
  #endif /* FEAT_DIALOG_GUI */
--- 5556,5562 ----
   * SetDialogTracksCursor() : Get the I-beam cursor over input box
   * MoveDialogItem():	    Probably better than SetDialogItem
   * SizeDialogItem():		(but is it Carbon Only?)
!  * AutoSizeDialog():	    Magic resize of dialog based on text length
   */
  }
  #endif /* FEAT_DIALOG_GUI */
*** ../vim-7.1.087/src/version.c	Tue Aug 21 18:02:58 2007
--- src/version.c	Thu Aug 30 10:32:28 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     88,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
10E. You start counting in hex.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.089
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.089
Problem:    ":let loaded_getscriptPlugin" doesn't clear to eol, result is
	    "#1in".
Solution:   Clear to the end of the screen after displaying the first variable
	    value.
Files:	    src/eval.c


*** ../vim-7.1.088/src/eval.c	Tue Aug 14 22:40:13 2007
--- src/eval.c	Wed Aug 29 22:40:15 2007
***************
*** 369,385 ****
  static int ex_let_vars __ARGS((char_u *arg, typval_T *tv, int copy, int semicolon, int var_count, char_u *nextchars));
  static char_u *skip_var_list __ARGS((char_u *arg, int *var_count, int *semicolon));
  static char_u *skip_var_one __ARGS((char_u *arg));
! static void list_hashtable_vars __ARGS((hashtab_T *ht, char_u *prefix, int empty));
! static void list_glob_vars __ARGS((void));
! static void list_buf_vars __ARGS((void));
! static void list_win_vars __ARGS((void));
  #ifdef FEAT_WINDOWS
! static void list_tab_vars __ARGS((void));
  #endif
! static void list_vim_vars __ARGS((void));
! static void list_script_vars __ARGS((void));
! static void list_func_vars __ARGS((void));
! static char_u *list_arg_vars __ARGS((exarg_T *eap, char_u *arg));
  static char_u *ex_let_one __ARGS((char_u *arg, typval_T *tv, int copy, char_u *endchars, char_u *op));
  static int check_changedtick __ARGS((char_u *arg));
  static char_u *get_lval __ARGS((char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int quiet, int fne_flags));
--- 369,385 ----
  static int ex_let_vars __ARGS((char_u *arg, typval_T *tv, int copy, int semicolon, int var_count, char_u *nextchars));
  static char_u *skip_var_list __ARGS((char_u *arg, int *var_count, int *semicolon));
  static char_u *skip_var_one __ARGS((char_u *arg));
! static void list_hashtable_vars __ARGS((hashtab_T *ht, char_u *prefix, int empty, int *first));
! static void list_glob_vars __ARGS((int *first));
! static void list_buf_vars __ARGS((int *first));
! static void list_win_vars __ARGS((int *first));
  #ifdef FEAT_WINDOWS
! static void list_tab_vars __ARGS((int *first));
  #endif
! static void list_vim_vars __ARGS((int *first));
! static void list_script_vars __ARGS((int *first));
! static void list_func_vars __ARGS((int *first));
! static char_u *list_arg_vars __ARGS((exarg_T *eap, char_u *arg, int *first));
  static char_u *ex_let_one __ARGS((char_u *arg, typval_T *tv, int copy, char_u *endchars, char_u *op));
  static int check_changedtick __ARGS((char_u *arg));
  static char_u *get_lval __ARGS((char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int quiet, int fne_flags));
***************
*** 704,711 ****
  static hashtab_T *find_var_ht __ARGS((char_u *name, char_u **varname));
  static void vars_clear_ext __ARGS((hashtab_T *ht, int free_val));
  static void delete_var __ARGS((hashtab_T *ht, hashitem_T *hi));
! static void list_one_var __ARGS((dictitem_T *v, char_u *prefix));
! static void list_one_var_a __ARGS((char_u *prefix, char_u *name, int type, char_u *string));
  static void set_var __ARGS((char_u *name, typval_T *varp, int copy));
  static int var_check_ro __ARGS((int flags, char_u *name));
  static int var_check_fixed __ARGS((int flags, char_u *name));
--- 704,711 ----
  static hashtab_T *find_var_ht __ARGS((char_u *name, char_u **varname));
  static void vars_clear_ext __ARGS((hashtab_T *ht, int free_val));
  static void delete_var __ARGS((hashtab_T *ht, hashitem_T *hi));
! static void list_one_var __ARGS((dictitem_T *v, char_u *prefix, int *first));
! static void list_one_var_a __ARGS((char_u *prefix, char_u *name, int type, char_u *string, int *first));
  static void set_var __ARGS((char_u *name, typval_T *varp, int copy));
  static int var_check_ro __ARGS((int flags, char_u *name));
  static int var_check_fixed __ARGS((int flags, char_u *name));
***************
*** 1699,1704 ****
--- 1699,1705 ----
      int		semicolon = 0;
      char_u	op[2];
      char_u	*argend;
+     int		first = TRUE;
  
      argend = skip_var_list(arg, &var_count, &semicolon);
      if (argend == NULL)
***************
*** 1715,1733 ****
  	    EMSG(_(e_invarg));
  	else if (!ends_excmd(*arg))
  	    /* ":let var1 var2" */
! 	    arg = list_arg_vars(eap, arg);
  	else if (!eap->skip)
  	{
  	    /* ":let" */
! 	    list_glob_vars();
! 	    list_buf_vars();
! 	    list_win_vars();
  #ifdef FEAT_WINDOWS
! 	    list_tab_vars();
  #endif
! 	    list_script_vars();
! 	    list_func_vars();
! 	    list_vim_vars();
  	}
  	eap->nextcmd = check_nextcmd(arg);
      }
--- 1716,1734 ----
  	    EMSG(_(e_invarg));
  	else if (!ends_excmd(*arg))
  	    /* ":let var1 var2" */
! 	    arg = list_arg_vars(eap, arg, &first);
  	else if (!eap->skip)
  	{
  	    /* ":let" */
! 	    list_glob_vars(&first);
! 	    list_buf_vars(&first);
! 	    list_win_vars(&first);
  #ifdef FEAT_WINDOWS
! 	    list_tab_vars(&first);
  #endif
! 	    list_script_vars(&first);
! 	    list_func_vars(&first);
! 	    list_vim_vars(&first);
  	}
  	eap->nextcmd = check_nextcmd(arg);
      }
***************
*** 1932,1941 ****
   * If "empty" is TRUE also list NULL strings as empty strings.
   */
      static void
! list_hashtable_vars(ht, prefix, empty)
      hashtab_T	*ht;
      char_u	*prefix;
      int		empty;
  {
      hashitem_T	*hi;
      dictitem_T	*di;
--- 1933,1943 ----
   * If "empty" is TRUE also list NULL strings as empty strings.
   */
      static void
! list_hashtable_vars(ht, prefix, empty, first)
      hashtab_T	*ht;
      char_u	*prefix;
      int		empty;
+     int		*first;
  {
      hashitem_T	*hi;
      dictitem_T	*di;
***************
*** 1950,1956 ****
  	    di = HI2DI(hi);
  	    if (empty || di->di_tv.v_type != VAR_STRING
  					   || di->di_tv.vval.v_string != NULL)
! 		list_one_var(di, prefix);
  	}
      }
  }
--- 1952,1958 ----
  	    di = HI2DI(hi);
  	    if (empty || di->di_tv.v_type != VAR_STRING
  					   || di->di_tv.vval.v_string != NULL)
! 		list_one_var(di, prefix, first);
  	}
      }
  }
***************
*** 1959,1990 ****
   * List global variables.
   */
      static void
! list_glob_vars()
  {
!     list_hashtable_vars(&globvarht, (char_u *)"", TRUE);
  }
  
  /*
   * List buffer variables.
   */
      static void
! list_buf_vars()
  {
      char_u	numbuf[NUMBUFLEN];
  
!     list_hashtable_vars(&curbuf->b_vars.dv_hashtab, (char_u *)"b:", TRUE);
  
      sprintf((char *)numbuf, "%ld", (long)curbuf->b_changedtick);
!     list_one_var_a((char_u *)"b:", (char_u *)"changedtick", VAR_NUMBER, numbuf);
  }
  
  /*
   * List window variables.
   */
      static void
! list_win_vars()
  {
!     list_hashtable_vars(&curwin->w_vars.dv_hashtab, (char_u *)"w:", TRUE);
  }
  
  #ifdef FEAT_WINDOWS
--- 1961,1998 ----
   * List global variables.
   */
      static void
! list_glob_vars(first)
!     int *first;
  {
!     list_hashtable_vars(&globvarht, (char_u *)"", TRUE, first);
  }
  
  /*
   * List buffer variables.
   */
      static void
! list_buf_vars(first)
!     int *first;
  {
      char_u	numbuf[NUMBUFLEN];
  
!     list_hashtable_vars(&curbuf->b_vars.dv_hashtab, (char_u *)"b:",
! 								 TRUE, first);
  
      sprintf((char *)numbuf, "%ld", (long)curbuf->b_changedtick);
!     list_one_var_a((char_u *)"b:", (char_u *)"changedtick", VAR_NUMBER,
! 							       numbuf, first);
  }
  
  /*
   * List window variables.
   */
      static void
! list_win_vars(first)
!     int *first;
  {
!     list_hashtable_vars(&curwin->w_vars.dv_hashtab,
! 						 (char_u *)"w:", TRUE, first);
  }
  
  #ifdef FEAT_WINDOWS
***************
*** 1992,2000 ****
   * List tab page variables.
   */
      static void
! list_tab_vars()
  {
!     list_hashtable_vars(&curtab->tp_vars.dv_hashtab, (char_u *)"t:", TRUE);
  }
  #endif
  
--- 2000,2010 ----
   * List tab page variables.
   */
      static void
! list_tab_vars(first)
!     int *first;
  {
!     list_hashtable_vars(&curtab->tp_vars.dv_hashtab,
! 						 (char_u *)"t:", TRUE, first);
  }
  #endif
  
***************
*** 2002,2040 ****
   * List Vim variables.
   */
      static void
! list_vim_vars()
  {
!     list_hashtable_vars(&vimvarht, (char_u *)"v:", FALSE);
  }
  
  /*
   * List script-local variables, if there is a script.
   */
      static void
! list_script_vars()
  {
      if (current_SID > 0 && current_SID <= ga_scripts.ga_len)
! 	list_hashtable_vars(&SCRIPT_VARS(current_SID), (char_u *)"s:", FALSE);
  }
  
  /*
   * List function variables, if there is a function.
   */
      static void
! list_func_vars()
  {
      if (current_funccal != NULL)
  	list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,
! 						       (char_u *)"l:", FALSE);
  }
  
  /*
   * List variables in "arg".
   */
      static char_u *
! list_arg_vars(eap, arg)
      exarg_T	*eap;
      char_u	*arg;
  {
      int		error = FALSE;
      int		len;
--- 2012,2055 ----
   * List Vim variables.
   */
      static void
! list_vim_vars(first)
!     int *first;
  {
!     list_hashtable_vars(&vimvarht, (char_u *)"v:", FALSE, first);
  }
  
  /*
   * List script-local variables, if there is a script.
   */
      static void
! list_script_vars(first)
!     int *first;
  {
      if (current_SID > 0 && current_SID <= ga_scripts.ga_len)
! 	list_hashtable_vars(&SCRIPT_VARS(current_SID),
! 						(char_u *)"s:", FALSE, first);
  }
  
  /*
   * List function variables, if there is a function.
   */
      static void
! list_func_vars(first)
!     int *first;
  {
      if (current_funccal != NULL)
  	list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,
! 						(char_u *)"l:", FALSE, first);
  }
  
  /*
   * List variables in "arg".
   */
      static char_u *
! list_arg_vars(eap, arg, first)
      exarg_T	*eap;
      char_u	*arg;
+     int		*first;
  {
      int		error = FALSE;
      int		len;
***************
*** 2091,2105 ****
  			{
  			    switch (*name)
  			    {
! 				case 'g': list_glob_vars(); break;
! 				case 'b': list_buf_vars(); break;
! 				case 'w': list_win_vars(); break;
  #ifdef FEAT_WINDOWS
! 				case 't': list_tab_vars(); break;
  #endif
! 				case 'v': list_vim_vars(); break;
! 				case 's': list_script_vars(); break;
! 				case 'l': list_func_vars(); break;
  				default:
  					  EMSG2(_("E738: Can't list variables for %s"), name);
  			    }
--- 2106,2120 ----
  			{
  			    switch (*name)
  			    {
! 				case 'g': list_glob_vars(first); break;
! 				case 'b': list_buf_vars(first); break;
! 				case 'w': list_win_vars(first); break;
  #ifdef FEAT_WINDOWS
! 				case 't': list_tab_vars(first); break;
  #endif
! 				case 'v': list_vim_vars(first); break;
! 				case 's': list_script_vars(first); break;
! 				case 'l': list_func_vars(first); break;
  				default:
  					  EMSG2(_("E738: Can't list variables for %s"), name);
  			    }
***************
*** 2116,2122 ****
  			    *arg = NUL;
  			    list_one_var_a((char_u *)"",
  				    arg == arg_subsc ? name : name_start,
! 				    tv.v_type, s == NULL ? (char_u *)"" : s);
  			    *arg = c;
  			    vim_free(tf);
  			}
--- 2131,2139 ----
  			    *arg = NUL;
  			    list_one_var_a((char_u *)"",
  				    arg == arg_subsc ? name : name_start,
! 				    tv.v_type,
! 				    s == NULL ? (char_u *)"" : s,
! 				    first);
  			    *arg = c;
  			    vim_free(tf);
  			}
***************
*** 18001,18009 ****
   * List the value of one internal variable.
   */
      static void
! list_one_var(v, prefix)
      dictitem_T	*v;
      char_u	*prefix;
  {
      char_u	*tofree;
      char_u	*s;
--- 18024,18033 ----
   * List the value of one internal variable.
   */
      static void
! list_one_var(v, prefix, first)
      dictitem_T	*v;
      char_u	*prefix;
+     int		*first;
  {
      char_u	*tofree;
      char_u	*s;
***************
*** 18011,18026 ****
  
      s = echo_string(&v->di_tv, &tofree, numbuf, ++current_copyID);
      list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
! 						s == NULL ? (char_u *)"" : s);
      vim_free(tofree);
  }
  
      static void
! list_one_var_a(prefix, name, type, string)
      char_u	*prefix;
      char_u	*name;
      int		type;
      char_u	*string;
  {
      /* don't use msg() or msg_attr() to avoid overwriting "v:statusmsg" */
      msg_start();
--- 18035,18051 ----
  
      s = echo_string(&v->di_tv, &tofree, numbuf, ++current_copyID);
      list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
! 					 s == NULL ? (char_u *)"" : s, first);
      vim_free(tofree);
  }
  
      static void
! list_one_var_a(prefix, name, type, string, first)
      char_u	*prefix;
      char_u	*name;
      int		type;
      char_u	*string;
+     int		*first;  /* when TRUE clear rest of screen and set to FALSE */
  {
      /* don't use msg() or msg_attr() to avoid overwriting "v:statusmsg" */
      msg_start();
***************
*** 18052,18057 ****
--- 18077,18087 ----
  
      if (type == VAR_FUNC)
  	msg_puts((char_u *)"()");
+     if (*first)
+     {
+ 	msg_clr_eos();
+ 	*first = FALSE;
+     }
  }
  
  /*
*** ../vim-7.1.088/src/version.c	Thu Aug 30 10:34:19 2007
--- src/version.c	Thu Aug 30 11:06:32 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     89,
  /**/

-- 
Edison's greatest achievement came in 1879, when he invented the
electric company.  Edison's design was a brilliant adaptation of the
simple electrical circuit: the electric company sends electricity
through a wire to a customer, then immediately gets the electricity
back through another wire

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.090
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.090
Problem:    Compiler warning on Mac OS X 10.5.
Solution:   Don't redeclare sigaltstack(). (Hisashi T Fujinaka)
Files:	    src/os_unix.c


*** ../vim-7.1.089/src/os_unix.c	Sat Aug 11 22:22:56 2007
--- src/os_unix.c	Wed Aug 22 22:28:48 2007
***************
*** 753,759 ****
      if (signal_stack != NULL)
      {
  # ifdef HAVE_SIGALTSTACK
! #  ifdef __APPLE__
  	/* missing prototype.  Adding it to osdef?.h.in doesn't work, because
  	 * "struct sigaltstack" needs to be declared. */
  	extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));
--- 753,760 ----
      if (signal_stack != NULL)
      {
  # ifdef HAVE_SIGALTSTACK
! #  if defined(__APPLE__) && (!defined(MAC_OS_X_VERSION_MAX_ALLOWED) \
! 		|| MAC_OS_X_VERSION_MAX_ALLOWED <= 1040)
  	/* missing prototype.  Adding it to osdef?.h.in doesn't work, because
  	 * "struct sigaltstack" needs to be declared. */
  	extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));
***************
*** 5688,5694 ****
  
  /*
   * Closes connection to gpm
!  * returns non-zero if connection succesfully closed
   */
      static void
  gpm_close()
--- 5689,5695 ----
  
  /*
   * Closes connection to gpm
!  * returns non-zero if connection successfully closed
   */
      static void
  gpm_close()
*** ../vim-7.1.089/src/version.c	Thu Aug 30 11:10:38 2007
--- src/version.c	Thu Aug 30 11:46:07 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     90,
  /**/

-- 
       We're knights of the round table
       We dance whene'er we're able
       We do routines and chorus scenes
       With footwork impeccable.
       We dine well here in Camelot
       We eat ham and jam and spam a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.091 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.091 (extra)
Problem:    Win32: Can't embed Vim inside another application.
Solution:   Add the --windowid argument. (Nageshwar)
Files:	    runtime/doc/gui_w32.txt, runtime/doc/starting.txt,
	    runtime/doc/vi_diff.txt, src/globals.h, src/gui_w32.c, src/main.c


*** ../vim-7.1.090/runtime/doc/gui_w32.txt	Sat May 12 15:35:53 2007
--- runtime/doc/gui_w32.txt	Tue Aug 14 17:32:27 2007
***************
*** 1,4 ****
! *gui_w32.txt*   For Vim version 7.1.  Last change: 2007 May 03
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *gui_w32.txt*   For Vim version 7.1.  Last change: 2007 Aug 14
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 52,57 ****
--- 52,67 ----
  								*gui-w32s*
  There is a specific version of gvim.exe that runs under the Win32s subsystem
  of Windows 3.1 or 3.11.  See |win32s|.
+ 
+ 
+ Using Vim as a plugin					*gui-w32-windowid*
+ 
+ When gvim starts up normally, it creates its own top level window.  If you
+ pass Vim the command-line option |--windowid| with a decimal or hexadecimal
+ value, Vim will create a window that is a child of the window with the given
+ ID.  This enables Vim to act as a plugin in another application.  This really
+ is a programmer's interface, and is of no use without a supporting application
+ to spawn Vim correctly.
  
  ==============================================================================
  2. Vim as default editor				*vim-default-editor*
*** ../vim-7.1.090/runtime/doc/starting.txt	Sat May 12 16:56:17 2007
--- runtime/doc/starting.txt	Tue Aug 14 17:34:22 2007
***************
*** 1,4 ****
! *starting.txt*  For Vim version 7.1.  Last change: 2007 May 12
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *starting.txt*  For Vim version 7.1.  Last change: 2007 Aug 14
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 547,552 ****
--- 547,557 ----
  		GTK+ GUI Vim only.  Make gvim try to use GtkPlug mechanism, so
  		that it runs inside another window.  See |gui-gtk-socketid|
  		for details. {not in Vi}
+ 
+ --windowid {id}						*--windowid*
+ 		Win32 GUI Vim only.  Make gvim try to use the window {id} as a
+ 		parent, so that it runs inside that window.  See
+ 		|gui-w32-windowid| for details. {not in Vi}
  
  --echo-wid						*--echo-wid*
  		GTK+ GUI Vim only.  Make gvim echo the Window ID on stdout,
*** ../vim-7.1.090/runtime/doc/vi_diff.txt	Sat May 12 14:54:28 2007
--- runtime/doc/vi_diff.txt	Tue Aug 14 17:35:10 2007
***************
*** 1,4 ****
! *vi_diff.txt*   For Vim version 7.1.  Last change: 2007 May 07
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *vi_diff.txt*   For Vim version 7.1.  Last change: 2007 Aug 14
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 826,831 ****
--- 826,833 ----
  --servername {name}	Vim: Specify Vim server name
  
  --socketid {id}		Vim: GTK window socket to run Vim in
+ 
+ --windowid {id}		Vim: Win32 window ID to run Vim in
  
  --version	Vim: show version message and exit.
  
*** ../vim-7.1.090/src/globals.h	Thu May 10 19:26:02 2007
--- src/globals.h	Wed Aug 29 22:27:45 2007
***************
*** 876,882 ****
  EXTERN int no_mapping INIT(= FALSE);	/* currently no mapping allowed */
  EXTERN int no_zero_mapping INIT(= 0);	/* mapping zero not allowed */
  EXTERN int allow_keys INIT(= FALSE);	/* allow key codes when no_mapping
! 					     * is set */
  EXTERN int no_u_sync INIT(= 0);		/* Don't call u_sync() */
  
  EXTERN int restart_edit INIT(= 0);	/* call edit when next cmd finished */
--- 876,882 ----
  EXTERN int no_mapping INIT(= FALSE);	/* currently no mapping allowed */
  EXTERN int no_zero_mapping INIT(= 0);	/* mapping zero not allowed */
  EXTERN int allow_keys INIT(= FALSE);	/* allow key codes when no_mapping
! 					 * is set */
  EXTERN int no_u_sync INIT(= 0);		/* Don't call u_sync() */
  
  EXTERN int restart_edit INIT(= 0);	/* call edit when next cmd finished */
***************
*** 1250,1255 ****
--- 1250,1263 ----
  #ifdef FEAT_GUI_GTK
  EXTERN guint32	gtk_socket_id INIT(= 0);
  EXTERN int	echo_wid_arg INIT(= FALSE);	/* --echo-wid argument */
+ #endif
+ 
+ #ifdef FEAT_GUI_W32
+ /*
+  * The value of the --windowid argument.
+  * For embedding gvim inside another application.
+  */
+ EXTERN int	win_socket_id INIT(= 0);
  #endif
  
  #if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
*** ../vim-7.1.090/src/gui_w32.c	Tue Aug 14 16:57:04 2007
--- src/gui_w32.c	Tue Aug 14 17:13:41 2007
***************
*** 23,28 ****
--- 23,30 ----
   * e.g., replace LONG with LONG_PTR, etc.
   */
  
+ #include "vim.h"
+ 
  /*
   * These are new in Windows ME/XP, only defined in recent compilers.
   */
***************
*** 1432,1447 ****
  	}
      }
      else
! 	/* Open toplevel window. */
  	s_hwnd = CreateWindow(
! 	    szVimWndClass, "Vim MSWindows GUI",
! 	    WS_OVERLAPPEDWINDOW,
! 	    gui_win_x == -1 ? CW_USEDEFAULT : gui_win_x,
! 	    gui_win_y == -1 ? CW_USEDEFAULT : gui_win_y,
! 	    100,				/* Any value will do */
! 	    100,				/* Any value will do */
! 	    NULL, NULL,
! 	    s_hinst, NULL);
  
      if (s_hwnd == NULL)
  	return FAIL;
--- 1434,1462 ----
  	}
      }
      else
!     {
! 	/* If the provided windowid is not valid reset it to zero, so that it
! 	 * is ignored and we open our own window. */
! 	if (IsWindow((HWND)win_socket_id) <= 0)
! 	    win_socket_id = 0;
! 
! 	/* Create a window.  If win_socket_id is not zero without border and
! 	 * titlebar, it will be reparented below. */
  	s_hwnd = CreateWindow(
! 		szVimWndClass, "Vim MSWindows GUI",
! 		win_socket_id == 0 ? WS_OVERLAPPEDWINDOW : WS_POPUP,
! 		gui_win_x == -1 ? CW_USEDEFAULT : gui_win_x,
! 		gui_win_y == -1 ? CW_USEDEFAULT : gui_win_y,
! 		100,				/* Any value will do */
! 		100,				/* Any value will do */
! 		NULL, NULL,
! 		s_hinst, NULL);
! 	if (s_hwnd != NULL && win_socket_id != 0)
! 	{
! 	    SetParent(s_hwnd, (HWND)win_socket_id);
! 	    ShowWindow(s_hwnd, SW_SHOWMAXIMIZED);
! 	}
!     }
  
      if (s_hwnd == NULL)
  	return FAIL;
*** ../vim-7.1.090/src/main.c	Fri Aug 10 21:32:41 2007
--- src/main.c	Tue Aug 14 17:22:52 2007
***************
*** 275,280 ****
--- 275,281 ----
       *   -display or --display
       *   --server...
       *   --socketid
+      *   --windowid
       */
      early_arg_scan(&params);
  
***************
*** 1489,1495 ****
   * Get the name of the display, before gui_prepare() removes it from
   * argv[].  Used for the xterm-clipboard display.
   *
!  * Also find the --server... arguments and --socketid
   */
  /*ARGSUSED*/
      static void
--- 1490,1496 ----
   * Get the name of the display, before gui_prepare() removes it from
   * argv[].  Used for the xterm-clipboard display.
   *
!  * Also find the --server... arguments and --socketid and --windowid
   */
  /*ARGSUSED*/
      static void
***************
*** 1536,1559 ****
  #  endif
  	}
  # endif
! # ifdef FEAT_GUI_GTK
  	else if (STRICMP(argv[i], "--socketid") == 0)
  	{
! 	    unsigned int    socket_id;
  	    int		    count;
  
  	    if (i == argc - 1)
  		mainerr_arg_missing((char_u *)argv[i]);
  	    if (STRNICMP(argv[i+1], "0x", 2) == 0)
! 		count = sscanf(&(argv[i + 1][2]), "%x", &socket_id);
  	    else
! 		count = sscanf(argv[i+1], "%u", &socket_id);
  	    if (count != 1)
  		mainerr(ME_INVALID_ARG, (char_u *)argv[i]);
  	    else
! 		gtk_socket_id = socket_id;
  	    i++;
  	}
  	else if (STRICMP(argv[i], "--echo-wid") == 0)
  	    echo_wid_arg = TRUE;
  # endif
--- 1537,1571 ----
  #  endif
  	}
  # endif
! 
! # if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)
! #  ifdef FEAT_GUI_W32
! 	else if (STRICMP(argv[i], "--windowid") == 0)
! #  else
  	else if (STRICMP(argv[i], "--socketid") == 0)
+ #  endif
  	{
! 	    unsigned int    id;
  	    int		    count;
  
  	    if (i == argc - 1)
  		mainerr_arg_missing((char_u *)argv[i]);
  	    if (STRNICMP(argv[i+1], "0x", 2) == 0)
! 		count = sscanf(&(argv[i + 1][2]), "%x", &id);
  	    else
! 		count = sscanf(argv[i+1], "%u", &id);
  	    if (count != 1)
  		mainerr(ME_INVALID_ARG, (char_u *)argv[i]);
  	    else
! #  ifdef FEAT_GUI_W32
! 		win_socket_id = id;
! #  else
! 		gtk_socket_id = id;
! #  endif
  	    i++;
  	}
+ # endif
+ # ifdef FEAT_GUI_GTK
  	else if (STRICMP(argv[i], "--echo-wid") == 0)
  	    echo_wid_arg = TRUE;
  # endif
***************
*** 1683,1690 ****
  		    }
  		}
  #endif
! #ifdef FEAT_GUI_GTK
  		else if (STRNICMP(argv[0] + argv_idx, "socketid", 8) == 0)
  		{
  		    /* already processed -- snatch the following arg */
  		    if (argc > 1)
--- 1695,1706 ----
  		    }
  		}
  #endif
! #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)
! # ifdef FEAT_GUI_GTK
  		else if (STRNICMP(argv[0] + argv_idx, "socketid", 8) == 0)
+ # else
+ 		else if (STRNICMP(argv[0] + argv_idx, "windowid", 8) == 0)
+ # endif
  		{
  		    /* already processed -- snatch the following arg */
  		    if (argc > 1)
***************
*** 1693,1698 ****
--- 1709,1716 ----
  			++argv;
  		    }
  		}
+ #endif
+ #ifdef FEAT_GUI_GTK
  		else if (STRNICMP(argv[0] + argv_idx, "echo-wid", 8) == 0)
  		{
  		    /* already processed, skip */
***************
*** 3120,3125 ****
--- 3138,3144 ----
  #endif
  #ifdef FEAT_GUI_W32
      main_msg(_("-P <parent title>\tOpen Vim inside parent application"));
+     main_msg(_("--windowid <HWND>\tOpen Vim inside another win32 widget"));
  #endif
  
  #ifdef FEAT_GUI_GNOME
*** ../vim-7.1.090/src/version.c	Thu Aug 30 11:46:46 2007
--- src/version.c	Thu Aug 30 12:21:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     91,
  /**/

-- 
       We're knights of the Round Table
       Our shows are formidable
       But many times
       We're given rhymes
       That are quite unsingable
       We're opera mad in Camelot
       We sing from the diaphragm a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.092 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.092 (extra, after 7.1.088)
Problem:    Wrong arguments for MoveWindowStructure().
Solution:   Remove "TRUE". (Michael Henry)
Files:	    src/gui_mac.c


*** ../vim-7.1.091/src/gui_mac.c	Thu Aug 30 10:34:19 2007
--- src/gui_mac.c	Thu Aug 30 12:48:41 2007
***************
*** 3149,3155 ****
      /* TODO:  Should make sure the window is move within range
       *	      e.g.: y > ~16 [Menu bar], x > 0, x < screen width
       */
!     MoveWindowStructure(gui.VimWindow, x, y, TRUE);
  }
  
      void
--- 3149,3155 ----
      /* TODO:  Should make sure the window is move within range
       *	      e.g.: y > ~16 [Menu bar], x > 0, x < screen width
       */
!     MoveWindowStructure(gui.VimWindow, x, y);
  }
  
      void
***************
*** 5293,5299 ****
      short	itemType;
      short	useIcon;
      short	width;
!     short	totalButtonWidth = 0;   /* the width of all button together
  					   including spacing */
      short	widestButton = 0;
      short	dfltButtonEdge     = 20;  /* gut feeling */
--- 5293,5299 ----
      short	itemType;
      short	useIcon;
      short	width;
!     short	totalButtonWidth = 0;   /* the width of all buttons together
  					   including spacing */
      short	widestButton = 0;
      short	dfltButtonEdge     = 20;  /* gut feeling */
***************
*** 5483,5489 ****
      {
  
  	macMoveDialogItem(theDialog, button, buttonItm.box.left, buttonItm.box.top, &box);
! 	/* With vertical, it's better to have all button the same lenght */
  	if (vertical)
  	{
  	    macSizeDialogItem(theDialog, button, widestButton, 0);
--- 5483,5489 ----
      {
  
  	macMoveDialogItem(theDialog, button, buttonItm.box.left, buttonItm.box.top, &box);
! 	/* With vertical, it's better to have all buttons the same length */
  	if (vertical)
  	{
  	    macSizeDialogItem(theDialog, button, widestButton, 0);
*** ../vim-7.1.091/src/version.c	Thu Aug 30 12:24:21 2007
--- src/version.c	Thu Aug 30 12:47:24 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     92,
  /**/

-- 
       In war we're tough and able.
       Quite indefatigable
       Between our quests
       We sequin vests
       And impersonate Clark Gable
       It's a busy life in Camelot.
       I have to push the pram a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.093
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.093
Problem:    Reading past end of a screen line when determining cell width.
	    (Dominique Pelle)
Solution:   Add an argument to mb_off2cells() for the maximum offset.
Files:	    src/globals.h, src/gui.c, src/mbyte.c, src/proto/mbyte.pro,
	    src/screen.c


*** ../vim-7.1.092/src/globals.h	Thu Aug 30 12:24:21 2007
--- src/globals.h	Wed Aug 29 22:27:45 2007
***************
*** 801,807 ****
  EXTERN int (*mb_char2bytes) __ARGS((int c, char_u *buf)) INIT(= latin_char2bytes);
  EXTERN int (*mb_ptr2cells) __ARGS((char_u *p)) INIT(= latin_ptr2cells);
  EXTERN int (*mb_char2cells) __ARGS((int c)) INIT(= latin_char2cells);
! EXTERN int (*mb_off2cells) __ARGS((unsigned off)) INIT(= latin_off2cells);
  EXTERN int (*mb_ptr2char) __ARGS((char_u *p)) INIT(= latin_ptr2char);
  EXTERN int (*mb_head_off) __ARGS((char_u *base, char_u *p)) INIT(= latin_head_off);
  
--- 801,807 ----
  EXTERN int (*mb_char2bytes) __ARGS((int c, char_u *buf)) INIT(= latin_char2bytes);
  EXTERN int (*mb_ptr2cells) __ARGS((char_u *p)) INIT(= latin_ptr2cells);
  EXTERN int (*mb_char2cells) __ARGS((int c)) INIT(= latin_char2cells);
! EXTERN int (*mb_off2cells) __ARGS((unsigned off, unsigned max_off)) INIT(= latin_off2cells);
  EXTERN int (*mb_ptr2char) __ARGS((char_u *p)) INIT(= latin_ptr2char);
  EXTERN int (*mb_head_off) __ARGS((char_u *base, char_u *p)) INIT(= latin_head_off);
  
*** ../vim-7.1.092/src/gui.c	Wed Aug 15 20:07:53 2007
--- src/gui.c	Wed Aug 29 22:16:51 2007
***************
*** 1080,1086 ****
  		cur_width = gui.char_width;
  	    }
  #ifdef FEAT_MBYTE
! 	    if (has_mbyte && (*mb_off2cells)(LineOffset[gui.row] + gui.col) > 1)
  	    {
  		/* Double wide character. */
  		if (shape_table[idx].shape != SHAPE_VER)
--- 1080,1087 ----
  		cur_width = gui.char_width;
  	    }
  #ifdef FEAT_MBYTE
! 	    if (has_mbyte && (*mb_off2cells)(LineOffset[gui.row] + gui.col,
! 				    LineOffset[gui.row] + screen_Columns) > 1)
  	    {
  		/* Double wide character. */
  		if (shape_table[idx].shape != SHAPE_VER)
***************
*** 1159,1165 ****
  #endif
  
  # if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
!  	|| defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_MAC))
      if (gui_has_tabline())
  	text_area_y += gui.tabline_height;
  #endif
--- 1160,1166 ----
  #endif
  
  # if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
! 	|| defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_MAC))
      if (gui_has_tabline())
  	text_area_y += gui.tabline_height;
  #endif
*** ../vim-7.1.092/src/mbyte.c	Sat Aug 11 13:57:31 2007
--- src/mbyte.c	Thu Aug 30 13:48:30 2007
***************
*** 1310,1329 ****
  /*
   * mb_off2cells() function pointer.
   * Return number of display cells for char at ScreenLines[off].
!  * Caller must make sure "off" and "off + 1" are valid!
   */
  /*ARGSUSED*/
      int
! latin_off2cells(off)
      unsigned	off;
  {
      return 1;
  }
  
      int
! dbcs_off2cells(off)
      unsigned	off;
  {
      /* Number of cells is equal to number of bytes, except for euc-jp when
       * the first byte is 0x8e. */
      if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
--- 1310,1335 ----
  /*
   * mb_off2cells() function pointer.
   * Return number of display cells for char at ScreenLines[off].
!  * We make sure that the offset used is less than "max_off".
   */
  /*ARGSUSED*/
      int
! latin_off2cells(off, max_off)
      unsigned	off;
+     unsigned	max_off;
  {
      return 1;
  }
  
      int
! dbcs_off2cells(off, max_off)
      unsigned	off;
+     unsigned	max_off;
  {
+     /* never check beyond end of the line */
+     if (off >= max_off)
+ 	return 1;
+ 
      /* Number of cells is equal to number of bytes, except for euc-jp when
       * the first byte is 0x8e. */
      if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
***************
*** 1332,1341 ****
  }
  
      int
! utf_off2cells(off)
      unsigned	off;
  {
!     return ScreenLines[off + 1] == 0 ? 2 : 1;
  }
  
  /*
--- 1338,1348 ----
  }
  
      int
! utf_off2cells(off, max_off)
      unsigned	off;
+     unsigned	max_off;
  {
!     return (off + 1 < max_off && ScreenLines[off + 1] == 0) ? 2 : 1;
  }
  
  /*
***************
*** 2899,2910 ****
      if (composing_hangul)
  	return TRUE;
  #endif
!     if (enc_dbcs != 0)
! 	return dbcs_off2cells(LineOffset[row] + col) > 1;
!     if (enc_utf8)
! 	return (col + 1 < Columns
! 		&& ScreenLines[LineOffset[row] + col + 1] == 0);
!     return FALSE;
  }
  
  # if defined(FEAT_CLIPBOARD) || defined(FEAT_GUI) || defined(FEAT_RIGHTLEFT) \
--- 2906,2913 ----
      if (composing_hangul)
  	return TRUE;
  #endif
!     return (*mb_off2cells)(LineOffset[row] + col,
! 					LineOffset[row] + screen_Columns) > 1;
  }
  
  # if defined(FEAT_CLIPBOARD) || defined(FEAT_GUI) || defined(FEAT_RIGHTLEFT) \
*** ../vim-7.1.092/src/proto/mbyte.pro	Sat May  5 20:02:52 2007
--- src/proto/mbyte.pro	Wed Aug 29 20:49:02 2007
***************
*** 12,20 ****
  int utf_ptr2cells __ARGS((char_u *p));
  int dbcs_ptr2cells __ARGS((char_u *p));
  int latin_char2cells __ARGS((int c));
! int latin_off2cells __ARGS((unsigned off));
! int dbcs_off2cells __ARGS((unsigned off));
! int utf_off2cells __ARGS((unsigned off));
  int latin_ptr2char __ARGS((char_u *p));
  int utf_ptr2char __ARGS((char_u *p));
  int mb_ptr2char_adv __ARGS((char_u **pp));
--- 12,20 ----
  int utf_ptr2cells __ARGS((char_u *p));
  int dbcs_ptr2cells __ARGS((char_u *p));
  int latin_char2cells __ARGS((int c));
! int latin_off2cells __ARGS((unsigned off, unsigned max_off));
! int dbcs_off2cells __ARGS((unsigned off, unsigned max_off));
! int utf_off2cells __ARGS((unsigned off, unsigned max_off));
  int latin_ptr2char __ARGS((char_u *p));
  int utf_ptr2char __ARGS((char_u *p));
  int mb_ptr2char_adv __ARGS((char_u **pp));
*** ../vim-7.1.092/src/screen.c	Sun Aug  5 20:10:16 2007
--- src/screen.c	Thu Aug 30 10:31:26 2007
***************
*** 1024,1030 ****
  	    type = VALID;
      }
  
!     /* Trick: we want to avoid clearning the screen twice.  screenclear() will
       * set "screen_cleared" to TRUE.  The special value MAYBE (which is still
       * non-zero and thus not FALSE) will indicate that screenclear() was not
       * called. */
--- 1024,1030 ----
  	    type = VALID;
      }
  
!     /* Trick: we want to avoid clearing the screen twice.  screenclear() will
       * set "screen_cleared" to TRUE.  The special value MAYBE (which is still
       * non-zero and thus not FALSE) will indicate that screenclear() was not
       * called. */
***************
*** 4632,4638 ****
  
  	/*
  	 * At end of screen line and there is more to come: Display the line
! 	 * so far.  If there is no more to display it is catched above.
  	 */
  	if ((
  #ifdef FEAT_RIGHTLEFT
--- 4632,4638 ----
  
  	/*
  	 * At end of screen line and there is more to come: Display the line
! 	 * so far.  If there is no more to display it is caught above.
  	 */
  	if ((
  #ifdef FEAT_RIGHTLEFT
***************
*** 4709,4717 ****
  #endif
  #ifdef FEAT_MBYTE
  			 && !(has_mbyte
! 			     && ((*mb_off2cells)(LineOffset[screen_row]) == 2
  				 || (*mb_off2cells)(LineOffset[screen_row - 1]
! 							+ (int)Columns - 2) == 2))
  #endif
  		   )
  		{
--- 4709,4721 ----
  #endif
  #ifdef FEAT_MBYTE
  			 && !(has_mbyte
! 			     && ((*mb_off2cells)(LineOffset[screen_row],
! 				     LineOffset[screen_row] + screen_Columns)
! 									  == 2
  				 || (*mb_off2cells)(LineOffset[screen_row - 1]
! 							+ (int)Columns - 2,
! 				     LineOffset[screen_row] + screen_Columns)
! 									== 2))
  #endif
  		   )
  		{
***************
*** 4871,4876 ****
--- 4875,4884 ----
  {
      unsigned	    off_from;
      unsigned	    off_to;
+ #ifdef FEAT_MBYTE
+     unsigned	    max_off_from;
+     unsigned	    max_off_to;
+ #endif
      int		    col = 0;
  #if defined(FEAT_GUI) || defined(UNIX) || defined(FEAT_VERTSPLIT)
      int		    hl;
***************
*** 4897,4902 ****
--- 4905,4914 ----
  
      off_from = (unsigned)(current_ScreenLine - ScreenLines);
      off_to = LineOffset[row] + coloff;
+ #ifdef FEAT_MBYTE
+     max_off_from = off_from + screen_Columns;
+     max_off_to = LineOffset[row] + screen_Columns;
+ #endif
  
  #ifdef FEAT_RIGHTLEFT
      if (rlflag)
***************
*** 4931,4937 ****
      {
  #ifdef FEAT_MBYTE
  	if (has_mbyte && (col + 1 < endcol))
! 	    char_cells = (*mb_off2cells)(off_from);
  	else
  	    char_cells = 1;
  #endif
--- 4943,4949 ----
      {
  #ifdef FEAT_MBYTE
  	if (has_mbyte && (col + 1 < endcol))
! 	    char_cells = (*mb_off2cells)(off_from, max_off_from);
  	else
  	    char_cells = 1;
  #endif
***************
*** 5008,5014 ****
  		 * ScreenLinesUC[] is sufficient. */
  		if (char_cells == 1
  			&& col + 1 < endcol
! 			&& (*mb_off2cells)(off_to) > 1)
  		{
  		    /* Writing a single-cell character over a double-cell
  		     * character: need to redraw the next cell. */
--- 5020,5026 ----
  		 * ScreenLinesUC[] is sufficient. */
  		if (char_cells == 1
  			&& col + 1 < endcol
! 			&& (*mb_off2cells)(off_to, max_off_to) > 1)
  		{
  		    /* Writing a single-cell character over a double-cell
  		     * character: need to redraw the next cell. */
***************
*** 5017,5024 ****
  		}
  		else if (char_cells == 2
  			&& col + 2 < endcol
! 			&& (*mb_off2cells)(off_to) == 1
! 			&& (*mb_off2cells)(off_to + 1) > 1)
  		{
  		    /* Writing the second half of a double-cell character over
  		     * a double-cell character: need to redraw the second
--- 5029,5036 ----
  		}
  		else if (char_cells == 2
  			&& col + 2 < endcol
! 			&& (*mb_off2cells)(off_to, max_off_to) == 1
! 			&& (*mb_off2cells)(off_to + 1, max_off_to) > 1)
  		{
  		    /* Writing the second half of a double-cell character over
  		     * a double-cell character: need to redraw the second
***************
*** 5037,5046 ****
  	     * char over the left halve of an existing one. */
  	    if (has_mbyte && col + char_cells == endcol
  		    && ((char_cells == 1
! 			    && (*mb_off2cells)(off_to) > 1)
  			|| (char_cells == 2
! 			    && (*mb_off2cells)(off_to) == 1
! 			    && (*mb_off2cells)(off_to + 1) > 1)))
  		clear_next = TRUE;
  #endif
  
--- 5049,5058 ----
  	     * char over the left halve of an existing one. */
  	    if (has_mbyte && col + char_cells == endcol
  		    && ((char_cells == 1
! 			    && (*mb_off2cells)(off_to, max_off_to) > 1)
  			|| (char_cells == 2
! 			    && (*mb_off2cells)(off_to, max_off_to) == 1
! 			    && (*mb_off2cells)(off_to + 1, max_off_to) > 1)))
  		clear_next = TRUE;
  #endif
  
***************
*** 5180,5189 ****
  			/* find previous character by counting from first
  			 * column and get its width. */
  			unsigned off = LineOffset[row];
  
  			while (off < off_to)
  			{
! 			    prev_cells = (*mb_off2cells)(off);
  			    off += prev_cells;
  			}
  		    }
--- 5192,5202 ----
  			/* find previous character by counting from first
  			 * column and get its width. */
  			unsigned off = LineOffset[row];
+ 			unsigned max_off = LineOffset[row] + screen_Columns;
  
  			while (off < off_to)
  			{
! 			    prev_cells = (*mb_off2cells)(off, max_off);
  			    off += prev_cells;
  			}
  		    }
***************
*** 5369,5375 ****
  static int skip_status_match_char __ARGS((expand_T *xp, char_u *s));
  
  /*
!  * Get the lenght of an item as it will be shown in the status line.
   */
      static int
  status_match_len(xp, s)
--- 5382,5388 ----
  static int skip_status_match_char __ARGS((expand_T *xp, char_u *s));
  
  /*
!  * Get the length of an item as it will be shown in the status line.
   */
      static int
  status_match_len(xp, s)
***************
*** 5435,5441 ****
      int		row;
      char_u	*buf;
      int		len;
!     int		clen;		/* lenght in screen cells */
      int		fillchar;
      int		attr;
      int		i;
--- 5448,5454 ----
      int		row;
      char_u	*buf;
      int		len;
!     int		clen;		/* length in screen cells */
      int		fillchar;
      int		attr;
      int		i;
***************
*** 6187,6192 ****
--- 6200,6206 ----
      char_u	*ptr = text;
      int		c;
  #ifdef FEAT_MBYTE
+     unsigned	max_off;
      int		mbyte_blen = 1;
      int		mbyte_cells = 1;
      int		u8c = 0;
***************
*** 6203,6208 ****
--- 6217,6225 ----
  	return;
  
      off = LineOffset[row] + col;
+ #ifdef FEAT_MBYTE
+     max_off = LineOffset[row] + screen_Columns;
+ #endif
      while (col < screen_Columns
  	    && (len < 0 || (int)(ptr - text) < len)
  	    && *ptr != NUL)
***************
*** 6326,6344 ****
  	    else if (has_mbyte
  		    && (len < 0 ? ptr[mbyte_blen] == NUL
  					     : ptr + mbyte_blen >= text + len)
! 		    && ((mbyte_cells == 1 && (*mb_off2cells)(off) > 1)
  			|| (mbyte_cells == 2
! 			    && (*mb_off2cells)(off) == 1
! 			    && (*mb_off2cells)(off + 1) > 1)))
  		clear_next_cell = TRUE;
  
  	    /* Make sure we never leave a second byte of a double-byte behind,
  	     * it confuses mb_off2cells(). */
  	    if (enc_dbcs
! 		    && ((mbyte_cells == 1 && (*mb_off2cells)(off) > 1)
  			|| (mbyte_cells == 2
! 			    && (*mb_off2cells)(off) == 1
! 			    && (*mb_off2cells)(off + 1) > 1)))
  		ScreenLines[off + mbyte_blen] = 0;
  #endif
  	    ScreenLines[off] = c;
--- 6343,6361 ----
  	    else if (has_mbyte
  		    && (len < 0 ? ptr[mbyte_blen] == NUL
  					     : ptr + mbyte_blen >= text + len)
! 		    && ((mbyte_cells == 1 && (*mb_off2cells)(off, max_off) > 1)
  			|| (mbyte_cells == 2
! 			    && (*mb_off2cells)(off, max_off) == 1
! 			    && (*mb_off2cells)(off + 1, max_off) > 1)))
  		clear_next_cell = TRUE;
  
  	    /* Make sure we never leave a second byte of a double-byte behind,
  	     * it confuses mb_off2cells(). */
  	    if (enc_dbcs
! 		    && ((mbyte_cells == 1 && (*mb_off2cells)(off, max_off) > 1)
  			|| (mbyte_cells == 2
! 			    && (*mb_off2cells)(off, max_off) == 1
! 			    && (*mb_off2cells)(off + 1, max_off) > 1)))
  		ScreenLines[off + mbyte_blen] = 0;
  #endif
  	    ScreenLines[off] = c;
***************
*** 6924,6929 ****
--- 6941,6949 ----
  {
      int		r, c;
      int		off;
+ #ifdef FEAT_MBYTE
+     int		max_off;
+ #endif
  
      /* Can't use ScreenLines unless initialized */
      if (ScreenLines == NULL)
***************
*** 6934,6943 ****
      for (r = row; r < row + height; ++r)
      {
  	off = LineOffset[r];
  	for (c = col; c < col + width; ++c)
  	{
  #ifdef FEAT_MBYTE
! 	    if (enc_dbcs != 0 && dbcs_off2cells(off + c) > 1)
  	    {
  		screen_char_2(off + c, r, c);
  		++c;
--- 6954,6966 ----
      for (r = row; r < row + height; ++r)
      {
  	off = LineOffset[r];
+ #ifdef FEAT_MBYTE
+ 	max_off = off + screen_Columns;
+ #endif
  	for (c = col; c < col + width; ++c)
  	{
  #ifdef FEAT_MBYTE
! 	    if (enc_dbcs != 0 && dbcs_off2cells(off + c, max_off) > 1)
  	    {
  		screen_char_2(off + c, r, c);
  		++c;
***************
*** 6947,6953 ****
  	    {
  		screen_char(off + c, r, c);
  #ifdef FEAT_MBYTE
! 		if (utf_off2cells(off + c) > 1)
  		    ++c;
  #endif
  	    }
--- 6970,6976 ----
  	    {
  		screen_char(off + c, r, c);
  #ifdef FEAT_MBYTE
! 		if (utf_off2cells(off + c, max_off) > 1)
  		    ++c;
  #endif
  	    }
*** ../vim-7.1.092/src/version.c	Thu Aug 30 12:50:00 2007
--- src/version.c	Thu Aug 30 13:45:25 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     93,
  /**/

-- 
There is a fine line between courage and foolishness.
Unfortunately, it's not a fence.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.094
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.094
Problem:    When checking if syntax highlighting is present, looking in the
	    current buffer instead of the specified one.
Solution:   Use "buf" instead of "curbuf".
Files:	    src/syntax.c


*** ../vim-7.1.093/src/syntax.c	Tue Aug 21 17:29:04 2007
--- src/syntax.c	Wed Aug 29 23:27:52 2007
***************
*** 5987,5994 ****
  {
      return (buf->b_syn_patterns.ga_len != 0
  	    || buf->b_syn_clusters.ga_len != 0
! 	    || curbuf->b_keywtab.ht_used > 0
! 	    || curbuf->b_keywtab_ic.ht_used > 0);
  }
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
--- 5987,5994 ----
  {
      return (buf->b_syn_patterns.ga_len != 0
  	    || buf->b_syn_clusters.ga_len != 0
! 	    || buf->b_keywtab.ht_used > 0
! 	    || buf->b_keywtab_ic.ht_used > 0);
  }
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
*** ../vim-7.1.093/src/version.c	Thu Aug 30 13:51:52 2007
--- src/version.c	Thu Aug 30 19:35:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     94,
  /**/

-- 
MAN:     You don't frighten us, English pig-dog!  Go and boil your bottoms,
         son of a silly person.  I blow my nose on you, so-called Arthur-king,
         you and your silly English K...kaniggets.
   He puts hands to his ears and blows a raspberry.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.095
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.095
Problem:    The FocusLost and FocusGained autocommands are triggered
	    asynchronously in the GUI.  This may cause arbitrary problems.
Solution:   Put the focus event in the input buffer and handle it when ready
	    for it.
Files:	    src/eval.c, src/getchar.c, src/gui.c, src/gui_gtk_x11.c,
	    src/keymap.h


*** ../vim-7.1.094/src/eval.c	Thu Aug 30 11:10:38 2007
--- src/eval.c	Mon Sep  3 22:48:09 2007
***************
*** 9912,9929 ****
  
      ++no_mapping;
      ++allow_keys;
!     if (argvars[0].v_type == VAR_UNKNOWN)
! 	/* getchar(): blocking wait. */
! 	n = safe_vgetc();
!     else if (get_tv_number_chk(&argvars[0], &error) == 1)
! 	/* getchar(1): only check if char avail */
! 	n = vpeekc();
!     else if (error || vpeekc() == NUL)
! 	/* illegal argument or getchar(0) and no char avail: return zero */
! 	n = 0;
!     else
! 	/* getchar(0) and char avail: return char */
! 	n = safe_vgetc();
      --no_mapping;
      --allow_keys;
  
--- 9912,9935 ----
  
      ++no_mapping;
      ++allow_keys;
!     for (;;)
!     {
! 	if (argvars[0].v_type == VAR_UNKNOWN)
! 	    /* getchar(): blocking wait. */
! 	    n = safe_vgetc();
! 	else if (get_tv_number_chk(&argvars[0], &error) == 1)
! 	    /* getchar(1): only check if char avail */
! 	    n = vpeekc();
! 	else if (error || vpeekc() == NUL)
! 	    /* illegal argument or getchar(0) and no char avail: return zero */
! 	    n = 0;
! 	else
! 	    /* getchar(0) and char avail: return char */
! 	    n = safe_vgetc();
! 	if (n == K_IGNORE)
! 	    continue;
! 	break;
!     }
      --no_mapping;
      --allow_keys;
  
*** ../vim-7.1.094/src/getchar.c	Thu May 10 18:43:02 2007
--- src/getchar.c	Wed Aug 29 22:38:49 2007
***************
*** 1596,1603 ****
  		continue;
  	    }
  #endif
- 
  #ifdef FEAT_GUI
  	    /* Translate K_CSI to CSI.  The special key is only used to avoid
  	     * it being recognized as the start of a special key. */
  	    if (c == K_CSI)
--- 1596,1610 ----
  		continue;
  	    }
  #endif
  #ifdef FEAT_GUI
+ 	    /* The caller doesn't need to know that the focus event is delayed
+ 	     * until getting a character. */
+ 	    if (c == K_FOCUSGAINED || c == K_FOCUSLOST)
+ 	    {
+ 		ui_focus_change(c == K_FOCUSGAINED);
+ 		continue;
+ 	    }
+ 
  	    /* Translate K_CSI to CSI.  The special key is only used to avoid
  	     * it being recognized as the start of a special key. */
  	    if (c == K_CSI)
*** ../vim-7.1.094/src/gui.c	Thu Aug 30 13:51:52 2007
--- src/gui.c	Thu Aug 30 14:10:48 2007
***************
*** 4519,4525 ****
      xim_set_focus(in_focus);
  # endif
  
!     ui_focus_change(in_focus);
  #endif
  }
  
--- 4519,4536 ----
      xim_set_focus(in_focus);
  # endif
  
!     /* Put events in the input queue only when allowed.
!      * ui_focus_change() isn't called directly, because it invokes
!      * autocommands and that must not happen asynchronously. */
!     if (!hold_gui_events)
!     {
! 	char_u  bytes[3];
! 
! 	bytes[0] = CSI;
! 	bytes[1] = KS_EXTRA;
! 	bytes[2] = in_focus ? (int)KE_FOCUSGAINED : (int)KE_FOCUSLOST;
! 	add_to_input_buf(bytes, 3);
!     }
  #endif
  }
  
*** ../vim-7.1.094/src/gui_gtk_x11.c	Tue Jun 19 18:07:52 2007
--- src/gui_gtk_x11.c	Wed Aug 29 22:43:34 2007
***************
*** 813,822 ****
      if (blink_state == BLINK_NONE)
  	gui_mch_start_blink();
  
!     /* make sure keyboard input goes to the draw area (if this is focus for a window) */
      if (widget != gui.drawarea)
  	gtk_widget_grab_focus(gui.drawarea);
  
      return TRUE;
  }
  
--- 813,827 ----
      if (blink_state == BLINK_NONE)
  	gui_mch_start_blink();
  
!     /* make sure keyboard input goes to the draw area (if this is focus for a
!      * window) */
      if (widget != gui.drawarea)
  	gtk_widget_grab_focus(gui.drawarea);
  
+     /* make sure the input buffer is read */
+     if (gtk_main_level() > 0)
+ 	gtk_main_quit();
+ 
      return TRUE;
  }
  
***************
*** 828,833 ****
--- 833,842 ----
  
      if (blink_state != BLINK_NONE)
  	gui_mch_stop_blink();
+ 
+     /* make sure the input buffer is read */
+     if (gtk_main_level() > 0)
+ 	gtk_main_quit();
  
      return TRUE;
  }
*** ../vim-7.1.094/src/keymap.h	Sat May  5 19:34:22 2007
--- src/keymap.h	Wed Aug 29 22:17:51 2007
***************
*** 254,259 ****
--- 254,261 ----
      , KE_DROP		/* DnD data is available */
      , KE_CURSORHOLD	/* CursorHold event */
      , KE_NOP		/* doesn't do something */
+     , KE_FOCUSGAINED	/* focus gained */
+     , KE_FOCUSLOST	/* focus lost */
  };
  
  /*
***************
*** 445,450 ****
--- 447,454 ----
  #define K_CMDWIN	TERMCAP2KEY(KS_EXTRA, KE_CMDWIN)
  
  #define K_DROP		TERMCAP2KEY(KS_EXTRA, KE_DROP)
+ #define K_FOCUSGAINED	TERMCAP2KEY(KS_EXTRA, KE_FOCUSGAINED)
+ #define K_FOCUSLOST	TERMCAP2KEY(KS_EXTRA, KE_FOCUSLOST)
  
  #define K_CURSORHOLD	TERMCAP2KEY(KS_EXTRA, KE_CURSORHOLD)
  
*** ../vim-7.1.094/src/version.c	Thu Aug 30 19:36:52 2007
--- src/version.c	Wed Sep  5 21:42:41 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     95,
  /**/

-- 
ARTHUR:      Who are you?
TALL KNIGHT: We are the Knights Who Say "Ni"!
BEDEVERE:    No!  Not the Knights Who Say "Ni"!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.096
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.096
Problem:    Reading past end of a string when resizing Vim. (Dominique Pelle)
Solution:   Check the string pointer before getting the char it points to.
Files:	    src/message.c


*** ../vim-7.1.095/src/message.c	Tue Aug  7 21:59:26 2007
--- src/message.c	Thu Aug 30 22:53:03 2007
***************
*** 944,949 ****
--- 944,950 ----
  		c = K_IGNORE;
  	    }
  #endif
+ 
  	    /*
  	     * Allow scrolling back in the messages.
  	     * Also accept scroll-down commands when messages fill the screen,
***************
*** 1840,1845 ****
--- 1841,1847 ----
      char_u	*sb_str = str;
      int		sb_col = msg_col;
      int		wrap;
+     int		did_last_char;
  
      did_wait_return = FALSE;
      while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)
***************
*** 1909,1915 ****
--- 1911,1920 ----
  		else
  #endif
  		    msg_screen_putchar(*s++, attr);
+ 		did_last_char = TRUE;
  	    }
+ 	    else
+ 		did_last_char = FALSE;
  
  	    if (p_more)
  		/* store text for scrolling back */
***************
*** 1944,1954 ****
  
  	    /* When we displayed a char in last column need to check if there
  	     * is still more. */
! 	    if (*s >= ' '
! #ifdef FEAT_RIGHTLEFT
! 		    && !cmdmsg_rl
! #endif
! 	       )
  		continue;
  	}
  
--- 1949,1955 ----
  
  	    /* When we displayed a char in last column need to check if there
  	     * is still more. */
! 	    if (did_last_char)
  		continue;
  	}
  
*** ../vim-7.1.095/src/version.c	Wed Sep  5 21:45:54 2007
--- src/version.c	Thu Sep  6 12:31:28 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     96,
  /**/

-- 
Yah, well, we had to carve our electrons out of driftwood we'd
find.  In the winter.  Uphill.  Both ways.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.097
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.097
Problem:    ":setlocal stl=%!1+1" does not work.
Solution:   Adjust check for pointer. (Politz)
Files:	    src/option.c


*** ../vim-7.1.096/src/option.c	Sun Aug 12 15:50:26 2007
--- src/option.c	Wed Sep  5 22:34:27 2007
***************
*** 6348,6354 ****
  		errmsg = check_stl_option(p_ruf);
  	}
  	/* check 'statusline' only if it doesn't start with "%!" */
! 	else if (varp != &p_stl || s[0] != '%' || s[1] != '!')
  	    errmsg = check_stl_option(s);
  	if (varp == &p_ruf && errmsg == NULL)
  	    comp_col();
--- 6352,6358 ----
  		errmsg = check_stl_option(p_ruf);
  	}
  	/* check 'statusline' only if it doesn't start with "%!" */
! 	else if (varp == &p_ruf || s[0] != '%' || s[1] != '!')
  	    errmsg = check_stl_option(s);
  	if (varp == &p_ruf && errmsg == NULL)
  	    comp_col();
*** ../vim-7.1.096/src/version.c	Thu Sep  6 12:53:59 2007
--- src/version.c	Thu Sep  6 13:31:37 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     97,
  /**/

-- 
Not too long ago, cut and paste was done with scissors and glue...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.098
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.098
Problem:    ":call s:var()" doesn't work if "s:var" is a Funcref. (Andy Wokula)
Solution:   Before converting "s:" into a script ID, check if it is a Funcref.
Files:	    src/eval.c


*** ../vim-7.1.097/src/eval.c	Wed Sep  5 21:45:54 2007
--- src/eval.c	Thu Sep  6 12:11:19 2007
***************
*** 19367,19372 ****
--- 19367,19394 ----
      if (lv.ll_name == NULL)
      {
  	/* Error found, but continue after the function name. */
+ 	*pp = end;
+ 	goto theend;
+     }
+ 
+     /* Check if the name is a Funcref.  If so, use the value. */
+     if (lv.ll_exp_name != NULL)
+     {
+ 	len = (int)STRLEN(lv.ll_exp_name);
+ 	name = deref_func_name(lv.ll_exp_name, &len);
+ 	if (name == lv.ll_exp_name)
+ 	    name = NULL;
+     }
+     else
+     {
+ 	len = (int)(end - *pp);
+ 	name = deref_func_name(*pp, &len);
+ 	if (name == *pp)
+ 	    name = NULL;
+     }
+     if (name != NULL)
+     {
+ 	name = vim_strsave(name);
  	*pp = end;
  	goto theend;
      }
*** ../vim-7.1.097/src/version.c	Thu Sep  6 13:32:53 2007
--- src/version.c	Thu Sep  6 14:24:10 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     98,
  /**/

-- 
Not too long ago, a program was something you watched on TV...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.099
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.099
Problem:    When the 'keymap' and 'paste' options have a non-default value,
	    ":mkexrc" and ":mksession" do not correctly set the options.
Solution:   Set the options with side effects before other options.
Files:	    src/option.c

 
*** ../vim-7.1.098/src/option.c	Thu Sep  6 13:32:53 2007
--- src/option.c	Wed Sep  5 22:34:27 2007
***************
*** 427,432 ****
--- 427,434 ----
  #define P_NOGLOB       0x100000L/* do not use local value for global vimrc */
  #define P_NFNAME       0x200000L/* only normal file name chars allowed */
  #define P_INSECURE     0x400000L/* option was set from a modeline */
+ #define P_PRI_MKRC     0x800000L/* priority for :mkvimrc (setting option has
+ 				   side effects) */
  
  #define ISK_LATIN1  (char_u *)"@,48-57,_,192-255"
  
***************
*** 773,778 ****
--- 775,782 ----
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    },
+ 			    /* P_PRI_MKRC isn't needed here, optval_default()
+ 			     * always returns TRUE for 'compatible' */
      {"compatible",  "cp",   P_BOOL|P_RALL,
  			    (char_u *)&p_cp, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)FALSE}},
***************
*** 1515,1521 ****
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    },
!     {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME,
  #ifdef FEAT_KEYMAP
  			    (char_u *)&p_keymap, PV_KMAP,
  			    {(char_u *)"", (char_u *)0L}
--- 1519,1525 ----
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    },
!     {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME|P_PRI_MKRC,
  #ifdef FEAT_KEYMAP
  			    (char_u *)&p_keymap, PV_KMAP,
  			    {(char_u *)"", (char_u *)0L}
***************
*** 1836,1842 ****
      {"paragraphs",  "para", P_STRING|P_VI_DEF,
  			    (char_u *)&p_para, PV_NONE,
  			    {(char_u *)"IPLPPPQPP LIpplpipbp", (char_u *)0L}},
!     {"paste",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_paste, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}},
      {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
--- 1840,1846 ----
      {"paragraphs",  "para", P_STRING|P_VI_DEF,
  			    (char_u *)&p_para, PV_NONE,
  			    {(char_u *)"IPLPPPQPP LIpplpipbp", (char_u *)0L}},
!     {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
  			    (char_u *)&p_paste, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}},
      {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
***************
*** 8535,8547 ****
      char_u		*varp_local = NULL;	/* fresh value */
      char		*cmd;
      int			round;
  
      /*
       * The options that don't have a default (terminal name, columns, lines)
       * are never written.  Terminal options are also not written.
       */
!     for (p = &options[0]; !istermoption(p); p++)
! 	if (!(p->flags & P_NO_MKRC) && !istermoption(p))
  	{
  	    /* skip global option when only doing locals */
  	    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))
--- 8539,8558 ----
      char_u		*varp_local = NULL;	/* fresh value */
      char		*cmd;
      int			round;
+     int			pri;
  
      /*
       * The options that don't have a default (terminal name, columns, lines)
       * are never written.  Terminal options are also not written.
+      * Do the loop over "options[]" twice: once for options with the
+      * P_PRI_MKRC flag and once without.
       */
!     for (pri = 1; pri >= 0; --pri)
!     {
!       for (p = &options[0]; !istermoption(p); p++)
! 	if (!(p->flags & P_NO_MKRC)
! 		&& !istermoption(p)
! 		&& ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0)))
  	{
  	    /* skip global option when only doing locals */
  	    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))
***************
*** 8637,8642 ****
--- 8648,8654 ----
  		}
  	    }
  	}
+     }
      return OK;
  }
  
*** ../vim-7.1.098/src/version.c	Thu Sep  6 14:25:50 2007
--- src/version.c	Thu Sep  6 16:32:31 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     99,
  /**/

-- 
Not too long ago, a keyboard was something to make music with...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.100
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.100
Problem:    Win32: Executing cscope doesn't always work properly.
Solution:   Use another way to invoke cscope. (Mike Williams)
Files:	    src/if_cscope.c, src/if_cscope.h, src/main.c,
	    src/proto/if_cscope.pro


*** ../vim-7.1.099/src/if_cscope.c	Tue Aug 21 18:02:58 2007
--- src/if_cscope.c	Sun Sep  2 16:50:50 2007
***************
*** 24,34 ****
      /* not UNIX, must be WIN32 */
  # include "vimio.h"
  # include <fcntl.h>
- # include <process.h>
- # define STDIN_FILENO    0
- # define STDOUT_FILENO   1
- # define STDERR_FILENO   2
- # define pipe(fds) _pipe(fds, 256, O_TEXT|O_NOINHERIT)
  #endif
  #include "if_cscope.h"
  
--- 24,29 ----
***************
*** 65,71 ****
  static char *	    cs_parse_results __ARGS((int cnumber, char *buf, int bufsize, char **context, char **linenumber, char **search));
  static char *	    cs_pathcomponents __ARGS((char *path));
  static void	    cs_print_tags_priv __ARGS((char **, char **, int));
! static int	    cs_read_prompt __ARGS((int ));
  static void	    cs_release_csp __ARGS((int, int freefnpp));
  static int	    cs_reset __ARGS((exarg_T *eap));
  static char *	    cs_resolve_file __ARGS((int, char *));
--- 60,66 ----
  static char *	    cs_parse_results __ARGS((int cnumber, char *buf, int bufsize, char **context, char **linenumber, char **search));
  static char *	    cs_pathcomponents __ARGS((char *path));
  static void	    cs_print_tags_priv __ARGS((char **, char **, int));
! static int	    cs_read_prompt __ARGS((int));
  static void	    cs_release_csp __ARGS((int, int freefnpp));
  static int	    cs_reset __ARGS((exarg_T *eap));
  static char *	    cs_resolve_file __ARGS((int, char *));
***************
*** 504,510 ****
  #if defined(UNIX)
      else if (S_ISREG(statbuf.st_mode) || S_ISLNK(statbuf.st_mode))
  #else
! 	/* substitute define S_ISREG from os_unix.h */
      else if (((statbuf.st_mode) & S_IFMT) == S_IFREG)
  #endif
      {
--- 499,505 ----
  #if defined(UNIX)
      else if (S_ISREG(statbuf.st_mode) || S_ISLNK(statbuf.st_mode))
  #else
! 	/* WIN32 - substitute define S_ISREG from os_unix.h */
      else if (((statbuf.st_mode) & S_IFMT) == S_IFREG)
  #endif
      {
***************
*** 717,733 ****
  cs_create_connection(i)
      int i;
  {
!     int to_cs[2], from_cs[2], len;
!     char *prog, *cmd, *ppath = NULL;
! #ifndef UNIX
!     int in_save, out_save, err_save;
!     long_i ph;
! # ifdef FEAT_GUI
!     HWND activewnd = NULL;
!     HWND consolewnd = NULL;
! # endif
  #endif
  
      /*
       * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from
       * from_cs[0] and writes to to_cs[1].
--- 712,734 ----
  cs_create_connection(i)
      int i;
  {
! #ifdef UNIX
!     int		to_cs[2], from_cs[2];
! #endif
!     int		len;
!     char	*prog, *cmd, *ppath = NULL;
! #ifdef WIN32
!     int		fd;
!     SECURITY_ATTRIBUTES sa;
!     PROCESS_INFORMATION pi;
!     STARTUPINFO si;
!     BOOL	pipe_stdin = FALSE, pipe_stdout = FALSE;
!     HANDLE	stdin_rd, stdout_rd;
!     HANDLE	stdout_wr, stdin_wr;
!     BOOL	created;
  #endif
  
+ #if defined(UNIX)
      /*
       * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from
       * from_cs[0] and writes to to_cs[1].
***************
*** 748,765 ****
  	return CSCOPE_FAILURE;
      }
  
- #if defined(UNIX)
      switch (csinfo[i].pid = fork())
      {
      case -1:
  	(void)EMSG(_("E622: Could not fork for cscope"));
  	goto err_closing;
      case 0:				/* child: run cscope. */
- #else
- 	in_save = dup(STDIN_FILENO);
- 	out_save = dup(STDOUT_FILENO);
- 	err_save = dup(STDERR_FILENO);
- #endif
  	if (dup2(to_cs[0], STDIN_FILENO) == -1)
  	    PERROR("cs_create_connection 1");
  	if (dup2(from_cs[1], STDOUT_FILENO) == -1)
--- 749,760 ----
***************
*** 768,782 ****
  	    PERROR("cs_create_connection 3");
  
  	/* close unused */
- #if defined(UNIX)
  	(void)close(to_cs[1]);
  	(void)close(from_cs[0]);
  #else
! 	/* On win32 we must close opposite ends because we are the parent */
! 	(void)close(to_cs[0]);
! 	to_cs[0] = -1;
! 	(void)close(from_cs[1]);
! 	from_cs[1] = -1;
  #endif
  	/* expand the cscope exec for env var's */
  	if ((prog = (char *)alloc(MAXPATHL + 1)) == NULL)
--- 763,794 ----
  	    PERROR("cs_create_connection 3");
  
  	/* close unused */
  	(void)close(to_cs[1]);
  	(void)close(from_cs[0]);
  #else
! 	/* WIN32 */
! 	/* Create pipes to communicate with cscope */
! 	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
! 	sa.bInheritHandle = TRUE;
! 	sa.lpSecurityDescriptor = NULL;
! 
! 	if (!(pipe_stdin = CreatePipe(&stdin_rd, &stdin_wr, &sa, 0))
! 		|| !(pipe_stdout = CreatePipe(&stdout_rd, &stdout_wr, &sa, 0)))
! 	{
! 	    (void)EMSG(_("E566: Could not create cscope pipes"));
! err_closing:
! 	    if (pipe_stdin)
! 	    {
! 		CloseHandle(stdin_rd);
! 		CloseHandle(stdin_wr);
! 	    }
! 	    if (pipe_stdout)
! 	    {
! 		CloseHandle(stdout_rd);
! 		CloseHandle(stdout_wr);
! 	    }
! 	    return CSCOPE_FAILURE;
! 	}
  #endif
  	/* expand the cscope exec for env var's */
  	if ((prog = (char *)alloc(MAXPATHL + 1)) == NULL)
***************
*** 784,789 ****
--- 796,802 ----
  #ifdef UNIX
  	    return CSCOPE_FAILURE;
  #else
+ 	    /* WIN32 */
  	    goto err_closing;
  #endif
  	}
***************
*** 800,805 ****
--- 813,819 ----
  #ifdef UNIX
  		return CSCOPE_FAILURE;
  #else
+ 		/* WIN32 */
  		goto err_closing;
  #endif
  	    }
***************
*** 818,823 ****
--- 832,838 ----
  #ifdef UNIX
  	    return CSCOPE_FAILURE;
  #else
+ 	    /* WIN32 */
  	    goto err_closing;
  #endif
  	}
***************
*** 826,831 ****
--- 841,847 ----
  #if defined(UNIX)
  	(void)sprintf(cmd, "exec %s -dl -f %s", prog, csinfo[i].fname);
  #else
+ 	/* WIN32 */
  	(void)sprintf(cmd, "%s -dl -f %s", prog, csinfo[i].fname);
  #endif
  	if (csinfo[i].ppath != NULL)
***************
*** 851,910 ****
  	exit(127);
  	/* NOTREACHED */
      default:	/* parent. */
- #else
- # ifdef FEAT_GUI
- 	activewnd = GetForegroundWindow(); /* on win9x cscope steals focus */
- 	/* Dirty hack to hide annoying console window */
- 	if (AllocConsole())
- 	{
- 	    char *title;
- 	    title = (char *)alloc(1024);
- 	    if (title == NULL)
- 		FreeConsole();
- 	    else
- 	    {
- 		GetConsoleTitle(title, 1024); /* save for future restore */
- 		SetConsoleTitle(
- 		    "GVIMCS{5499421B-CBEF-45b0-85EF-38167FDEA5C5}GVIMCS");
- 		Sleep(40); /* as stated in MS KB we must wait 40 ms */
- 		consolewnd = FindWindow(NULL,
- 			"GVIMCS{5499421B-CBEF-45b0-85EF-38167FDEA5C5}GVIMCS");
- 		if (consolewnd != NULL)
- 		    ShowWindow(consolewnd, SW_HIDE);
- 		SetConsoleTitle(title);
- 		vim_free(title);
- 	    }
- 	}
- # endif
- 	/* May be use &shell, &shellquote etc */
- # ifdef __BORLANDC__
- 	/* BCC 5.5 uses a different function name for spawnlp */
- 	ph = (long_i)spawnlp(P_NOWAIT, prog, cmd, NULL);
- # else
- 	ph = (long_i)_spawnlp(_P_NOWAIT, prog, cmd, NULL);
- # endif
- 	vim_free(prog);
- 	vim_free(cmd);
- # ifdef FEAT_GUI
- 	/* Dirty hack part two */
- 	if (activewnd != NULL)
- 	    /* restoring focus */
- 	    SetForegroundWindow(activewnd);
- 	if (consolewnd != NULL)
- 	    FreeConsole();
- 
- # endif
- 	if (ph == -1)
- 	{
- 	    PERROR(_("cs_create_connection exec failed"));
- 	    (void)EMSG(_("E623: Could not spawn cscope process"));
- 	    goto err_closing;
- 	}
- 	/* else */
- 	csinfo[i].pid = 0;
- 	csinfo[i].hProc = (HANDLE)ph;
- 
- #endif /* !UNIX */
  	/*
  	 * Save the file descriptors for later duplication, and
  	 * reopen as streams.
--- 867,872 ----
***************
*** 914,935 ****
  	if ((csinfo[i].fr_fp = fdopen(from_cs[0], "r")) == NULL)
  	    PERROR(_("cs_create_connection: fdopen for fr_fp failed"));
  
- #if defined(UNIX)
  	/* close unused */
  	(void)close(to_cs[0]);
  	(void)close(from_cs[1]);
  
  	break;
      }
  #else
! 	/* restore stdhandles */
!     dup2(in_save, STDIN_FILENO);
!     dup2(out_save, STDOUT_FILENO);
!     dup2(err_save, STDERR_FILENO);
!     close(in_save);
!     close(out_save);
!     close(err_save);
! #endif
      return CSCOPE_SUCCESS;
  } /* cs_create_connection */
  
--- 876,927 ----
  	if ((csinfo[i].fr_fp = fdopen(from_cs[0], "r")) == NULL)
  	    PERROR(_("cs_create_connection: fdopen for fr_fp failed"));
  
  	/* close unused */
  	(void)close(to_cs[0]);
  	(void)close(from_cs[1]);
  
  	break;
      }
+ 
  #else
!     /* WIN32 */
!     /* Create a new process to run cscope and use pipes to talk with it */
!     GetStartupInfo(&si);
!     si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
!     si.wShowWindow = SW_HIDE;  /* Hide child application window */
!     si.hStdOutput = stdout_wr;
!     si.hStdError  = stdout_wr;
!     si.hStdInput  = stdin_rd;
!     created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,
! 							NULL, NULL, &si, &pi);
!     vim_free(prog);
!     vim_free(cmd);
! 
!     if (!created)
!     {
! 	PERROR(_("cs_create_connection exec failed"));
! 	(void)EMSG(_("E623: Could not spawn cscope process"));
! 	goto err_closing;
!     }
!     /* else */
!     csinfo[i].pid = pi.dwProcessId;
!     csinfo[i].hProc = pi.hProcess;
!     CloseHandle(pi.hThread);
! 
!     /* TODO - tidy up after failure to create files on pipe handles. */
!     if (((fd = _open_osfhandle((intptr_t)stdin_wr, _O_TEXT|_O_APPEND)) < 0)
! 	    || ((csinfo[i].to_fp = _fdopen(fd, "w")) == NULL))
! 	PERROR(_("cs_create_connection: fdopen for to_fp failed"));
!     if (((fd = _open_osfhandle((intptr_t)stdout_rd, _O_TEXT|_O_RDONLY)) < 0)
! 	    || ((csinfo[i].fr_fp = _fdopen(fd, "r")) == NULL))
! 	PERROR(_("cs_create_connection: fdopen for fr_fp failed"));
! 
!     /* Close handles for file descriptors inherited by the cscope process */
!     CloseHandle(stdin_rd);
!     CloseHandle(stdout_wr);
! 
! #endif /* !UNIX */
! 
      return CSCOPE_SUCCESS;
  } /* cs_create_connection */
  
***************
*** 2097,2104 ****
  /*
   * PRIVATE: cs_release_csp
   *
!  * does the actual free'ing for the cs ptr with an optional flag of whether
!  * or not to free the filename.  called by cs_kill and cs_reset.
   */
      static void
  cs_release_csp(i, freefnpp)
--- 2089,2096 ----
  /*
   * PRIVATE: cs_release_csp
   *
!  * Does the actual free'ing for the cs ptr with an optional flag of whether
!  * or not to free the filename.  Called by cs_kill and cs_reset.
   */
      static void
  cs_release_csp(i, freefnpp)
***************
*** 2116,2125 ****
  	(void)fputs("q\n", csinfo[i].to_fp);
  	(void)fflush(csinfo[i].to_fp);
      }
!     /* give cscope chance to exit normally */
!     if (csinfo[i].hProc != NULL
! 	    && WaitForSingleObject(csinfo[i].hProc, 1000) == WAIT_TIMEOUT)
! 	TerminateProcess(csinfo[i].hProc, 0);
  #endif
  
      if (csinfo[i].fr_fp != NULL)
--- 2108,2120 ----
  	(void)fputs("q\n", csinfo[i].to_fp);
  	(void)fflush(csinfo[i].to_fp);
      }
!     if (csinfo[i].hProc != NULL)
!     {
! 	/* Give cscope a chance to exit normally */
! 	if (WaitForSingleObject(csinfo[i].hProc, 1000) == WAIT_TIMEOUT)
! 	    TerminateProcess(csinfo[i].hProc, 0);
! 	CloseHandle(csinfo[i].hProc);
!     }
  #endif
  
      if (csinfo[i].fr_fp != NULL)
***************
*** 2301,2306 ****
--- 2296,2316 ----
      wait_return(TRUE);
      return CSCOPE_SUCCESS;
  } /* cs_show */
+ 
+ 
+ /*
+  * PUBLIC: cs_end
+  *
+  * Only called when VIM exits to quit any cscope sessions.
+  */
+     void
+ cs_end()
+ {
+     int i;
+ 
+     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+ 	cs_release_csp(i, TRUE);
+ }
  
  #endif	/* FEAT_CSCOPE */
  
*** ../vim-7.1.099/src/if_cscope.h	Thu Jun 30 23:59:58 2005
--- src/if_cscope.h	Sun Sep  2 16:51:08 2007
***************
*** 72,78 ****
      ino_t	    st_ino;	/* inode number of cscope db */
  #else
  # if defined(WIN32)
!     int	    pid;	/* Can't get pid so set it to 0 ;) */
      HANDLE	    hProc;	/* cscope process handle */
      DWORD	    nVolume;	/* Volume serial number, instead of st_dev */
      DWORD	    nIndexHigh;	/* st_ino has no meaning in the Windows */
--- 72,78 ----
      ino_t	    st_ino;	/* inode number of cscope db */
  #else
  # if defined(WIN32)
!     DWORD	    pid;	/* PID of the connected cscope process. */
      HANDLE	    hProc;	/* cscope process handle */
      DWORD	    nVolume;	/* Volume serial number, instead of st_dev */
      DWORD	    nIndexHigh;	/* st_ino has no meaning in the Windows */
*** ../vim-7.1.099/src/main.c	Thu Aug 30 12:24:21 2007
--- src/main.c	Sun Sep  2 16:44:36 2007
***************
*** 1331,1336 ****
--- 1331,1339 ----
  #ifdef FEAT_NETBEANS_INTG
      netbeans_end();
  #endif
+ #ifdef FEAT_CSCOPE
+     cs_end();
+ #endif
  
      mch_exit(exitval);
  }
***************
*** 3671,3677 ****
  	mainerr_arg_missing((char_u *)filev[-1]);
      if (mch_dirname(cwd, MAXPATHL) != OK)
  	return NULL;
!     if ((p = vim_strsave_escaped_ext(cwd, PATH_ESC_CHARS, '\\', TRUE)) == NULL)
  	return NULL;
      ga_init2(&ga, 1, 100);
      ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd ");
--- 3674,3686 ----
  	mainerr_arg_missing((char_u *)filev[-1]);
      if (mch_dirname(cwd, MAXPATHL) != OK)
  	return NULL;
!     if ((p = vim_strsave_escaped_ext(cwd,
! #ifdef BACKSLASH_IN_FILENAME
! 		    "",  /* rem_backslash() will tell what chars to escape */
! #else
! 		    PATH_ESC_CHARS,
! #endif
! 		    '\\', TRUE)) == NULL)
  	return NULL;
      ga_init2(&ga, 1, 100);
      ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd ");
*** ../vim-7.1.099/src/proto/if_cscope.pro	Sat May  5 19:15:39 2007
--- src/proto/if_cscope.pro	Sun Sep  2 16:51:34 2007
***************
*** 6,9 ****
--- 6,10 ----
  void cs_free_tags __ARGS((void));
  void cs_print_tags __ARGS((void));
  int cs_connection __ARGS((int num, char_u *dbpath, char_u *ppath));
+ void cs_end __ARGS((void));
  /* vim: set ft=c : */
*** ../vim-7.1.099/src/version.c	Thu Sep  6 16:33:47 2007
--- src/version.c	Thu Sep  6 17:27:51 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     100,
  /**/

-- 
I have to exercise early in the morning before my brain
figures out what I'm doing.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.101
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.101
Problem:    Ruby: The Buffer.line= method does not work.
Solution:   Add the "self" argument to set_current_line(). (Jonathan Hankins)
Files:	    src/if_ruby.c


*** ../vim-7.1.100/src/if_ruby.c	Sat May 12 15:01:49 2007
--- src/if_ruby.c	Mon Sep 10 10:40:38 2007
***************
*** 789,795 ****
      return get_buffer_line(curbuf, curwin->w_cursor.lnum);
  }
  
! static VALUE set_current_line(VALUE str)
  {
      return set_buffer_line(curbuf, curwin->w_cursor.lnum, str);
  }
--- 789,795 ----
      return get_buffer_line(curbuf, curwin->w_cursor.lnum);
  }
  
! static VALUE set_current_line(VALUE self, VALUE str)
  {
      return set_buffer_line(curbuf, curwin->w_cursor.lnum, str);
  }
*** ../vim-7.1.100/src/version.c	Thu Sep  6 17:38:06 2007
--- src/version.c	Thu Sep 13 14:59:47 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     101,
  /**/

-- 
The question is:  What do you do with your life?
The wrong answer is: Become the richest guy in the graveyard.
				(billionaire and Oracle founder Larry Ellison)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.102
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.102
Problem:    Perl interface doesn't compile with new version of Perl.
Solution:   Add two variables to the dynamic library loading. (Suresh
	    Govindachar)
Files:	    src/if_perl.xs


*** ../vim-7.1.101/src/if_perl.xs	Wed Aug 16 19:33:57 2006
--- src/if_perl.xs	Wed Sep  5 22:00:36 2007
***************
*** 40,45 ****
--- 40,65 ----
  #    define PERL_SUBVERSION SUBVERSION
  #endif
  
+ /*
+  * Quoting Jan Dubois of Active State:
+  *    ActivePerl build 822 still identifies itself as 5.8.8 but already
+  *    contains many of the changes from the upcoming Perl 5.8.9 release.
+  *
+  * The changes include addition of two symbols (Perl_sv_2iv_flags,
+  * Perl_newXS_flags) not present in earlier releases.
+  *
+  * Jan Dubois suggested the following guarding scheme:
+  */
+ #if (ACTIVEPERL_VERSION >= 822)
+ # define PERL589_OR_LATER
+ #endif
+ #if (PERL_REVISION == 5) && (PERL_VERSION == 8) && (PERL_SUBVERSION >= 9)
+ # define PERL589_OR_LATER
+ #endif
+ #if (PERL_REVISION == 5) && (PERL_VERSION >= 9)
+ # define PERL589_OR_LATER
+ #endif
+ 
  #ifndef pTHX
  #    define pTHX void
  #    define pTHX_
***************
*** 109,114 ****
--- 129,138 ----
  # else
  #  define Perl_sv_catpvn dll_Perl_sv_catpvn
  # endif
+ #ifdef PERL589_OR_LATER
+ #  define Perl_sv_2iv_flags dll_Perl_sv_2iv_flags
+ #  define Perl_newXS_flags dll_Perl_newXS_flags
+ #endif
  # define Perl_sv_free dll_Perl_sv_free
  # define Perl_sv_isa dll_Perl_sv_isa
  # define Perl_sv_magic dll_Perl_sv_magic
***************
*** 192,197 ****
--- 216,225 ----
  #else
  static void (*Perl_sv_catpvn)(pTHX_ SV*, const char*, STRLEN);
  #endif
+ #ifdef PERL589_OR_LATER
+ static IV (*Perl_sv_2iv_flags)(pTHX_ SV* sv, I32 flags);
+ static CV * (*Perl_newXS_flags)(pTHX_ const char *name, XSUBADDR_t subaddr, const char *const filename, const char *const proto, U32 flags);
+ #endif
  static void (*Perl_sv_free)(pTHX_ SV*);
  static int (*Perl_sv_isa)(pTHX_ SV*, const char*);
  static void (*Perl_sv_magic)(pTHX_ SV*, SV*, int, const char*, I32);
***************
*** 266,271 ****
--- 294,303 ----
      {"Perl_sv_2pv_nolen", (PERL_PROC*)&Perl_sv_2pv_nolen},
  #else
      {"Perl_sv_2pv", (PERL_PROC*)&Perl_sv_2pv},
+ #endif
+ #ifdef PERL589_OR_LATER
+     {"Perl_sv_2iv_flags", (PERL_PROC*)&Perl_sv_2iv_flags},
+     {"Perl_newXS_flags", (PERL_PROC*)&Perl_newXS_flags},
  #endif
      {"Perl_sv_bless", (PERL_PROC*)&Perl_sv_bless},
  #if (PERL_REVISION == 5) && (PERL_VERSION >= 8)
*** ../vim-7.1.101/src/version.c	Thu Sep 13 15:00:28 2007
--- src/version.c	Thu Sep 13 15:18:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     102,
  /**/

-- 
Witches prefer brooms: vacuum-cleaners need extension cords!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.103
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.103
Problem:    Using "dw" with the cursor past the end of the last line (using
            CTRL-\ CTRL-O from Insert mode) deletes a character. (Tim Chase)
Solution:   Don't move the cursor back when the movement failed.
Files:      src/normal.c


*** ../vim-7.1.102/src/normal.c	Tue Aug 14 22:54:00 2007
--- src/normal.c	Tue Sep 11 19:32:42 2007
***************
*** 8364,8370 ****
  	n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);
  
      /* Don't leave the cursor on the NUL past a line */
!     if (curwin->w_cursor.col && gchar_cursor() == NUL)
      {
  	--curwin->w_cursor.col;
  	cap->oap->inclusive = TRUE;
--- 8364,8370 ----
  	n = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);
  
      /* Don't leave the cursor on the NUL past a line */
!     if (n != FAIL && curwin->w_cursor.col > 0 && gchar_cursor() == NUL)
      {
  	--curwin->w_cursor.col;
  	cap->oap->inclusive = TRUE;
*** ../vim-7.1.102/src/version.c	Thu Sep 13 15:19:32 2007
--- src/version.c	Thu Sep 13 15:32:05 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     103,
  /**/

-- 
ARTHUR:  Then who is your lord?
WOMAN:   We don't have a lord.
ARTHUR:  What?
DENNIS:  I told you.  We're an anarcho-syndicalist commune.  We take it in
         turns to act as a sort of executive officer for the week.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.104
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.104 (after 7.1.095)
Problem:    When 'lazyredraw' is set a focus event causes redraw to be
	    postponed until a key is pressed.
Solution:   Instead of not returning from vgetc() when a focus event is
	    encountered return K_IGNORE.  Add plain_vgetc() for when the
	    caller doesn't want to get K_IGNORE.
Files:	    src/digraph.c, src/edit.c, src/ex_cmds.c, src/ex_getln.c,
	    src/getchar.c, src/normal.c, src/proto/getchar.pro, src/window.c


*** ../vim-7.1.103/src/digraph.c	Sat Jul  7 13:57:39 2007
--- src/digraph.c	Thu Sep 13 16:11:54 2007
***************
*** 2028,2034 ****
  
      ++no_mapping;
      ++allow_keys;
!     c = safe_vgetc();
      --no_mapping;
      --allow_keys;
      if (c != ESC)		/* ESC cancels CTRL-K */
--- 2028,2034 ----
  
      ++no_mapping;
      ++allow_keys;
!     c = plain_vgetc();
      --no_mapping;
      --allow_keys;
      if (c != ESC)		/* ESC cancels CTRL-K */
***************
*** 2050,2056 ****
  #endif
  	++no_mapping;
  	++allow_keys;
! 	cc = safe_vgetc();
  	--no_mapping;
  	--allow_keys;
  	if (cc != ESC)	    /* ESC cancels CTRL-K */
--- 2050,2056 ----
  #endif
  	++no_mapping;
  	++allow_keys;
! 	cc = plain_vgetc();
  	--no_mapping;
  	--allow_keys;
  	if (cc != ESC)	    /* ESC cancels CTRL-K */
***************
*** 2350,2356 ****
      if (*curbuf->b_p_keymap == NUL)
      {
  	/* Stop any active keymap and clear the table.  Also remove
! 	 * b:keymap_unload, as no keymap is active now. */
  	keymap_unload();
  	do_cmdline_cmd((char_u *)"unlet! b:keymap_name");
      }
--- 2350,2356 ----
      if (*curbuf->b_p_keymap == NUL)
      {
  	/* Stop any active keymap and clear the table.  Also remove
! 	 * b:keymap_name, as no keymap is active now. */
  	keymap_unload();
  	do_cmdline_cmd((char_u *)"unlet! b:keymap_name");
      }
*** ../vim-7.1.103/src/edit.c	Sun Aug 12 16:38:03 2007
--- src/edit.c	Thu Sep 13 16:17:54 2007
***************
*** 788,794 ****
  	    ins_redraw(FALSE);
  	    ++no_mapping;
  	    ++allow_keys;
! 	    c = safe_vgetc();
  	    --no_mapping;
  	    --allow_keys;
  	    if (c != Ctrl_N && c != Ctrl_G && c != Ctrl_O)
--- 788,794 ----
  	    ins_redraw(FALSE);
  	    ++no_mapping;
  	    ++allow_keys;
! 	    c = plain_vgetc();
  	    --no_mapping;
  	    --allow_keys;
  	    if (c != Ctrl_N && c != Ctrl_G && c != Ctrl_O)
***************
*** 981,987 ****
  #ifdef FEAT_NETBEANS_INTG
  	case K_F21:	/* NetBeans command */
  	    ++no_mapping;		/* don't map the next key hits */
! 	    i = safe_vgetc();
  	    --no_mapping;
  	    netbeans_keycommand(i);
  	    break;
--- 981,987 ----
  #ifdef FEAT_NETBEANS_INTG
  	case K_F21:	/* NetBeans command */
  	    ++no_mapping;		/* don't map the next key hits */
! 	    i = plain_vgetc();
  	    --no_mapping;
  	    netbeans_keycommand(i);
  	    break;
***************
*** 5224,5233 ****
      i = 0;
      for (;;)
      {
! 	do
! 	    nc = safe_vgetc();
! 	while (nc == K_IGNORE || nc == K_VER_SCROLLBAR
! 						    || nc == K_HOR_SCROLLBAR);
  #ifdef FEAT_CMDL_INFO
  	if (!(State & CMDLINE)
  # ifdef FEAT_MBYTE
--- 5224,5230 ----
      i = 0;
      for (;;)
      {
! 	nc = plain_vgetc();
  #ifdef FEAT_CMDL_INFO
  	if (!(State & CMDLINE)
  # ifdef FEAT_MBYTE
***************
*** 7575,7581 ****
       * deleted when ESC is hit.
       */
      ++no_mapping;
!     regname = safe_vgetc();
  #ifdef FEAT_LANGMAP
      LANGMAP_ADJUST(regname, TRUE);
  #endif
--- 7572,7578 ----
       * deleted when ESC is hit.
       */
      ++no_mapping;
!     regname = plain_vgetc();
  #ifdef FEAT_LANGMAP
      LANGMAP_ADJUST(regname, TRUE);
  #endif
***************
*** 7586,7592 ****
  #ifdef FEAT_CMDL_INFO
  	add_to_showcmd_c(literally);
  #endif
! 	regname = safe_vgetc();
  #ifdef FEAT_LANGMAP
  	LANGMAP_ADJUST(regname, TRUE);
  #endif
--- 7583,7589 ----
  #ifdef FEAT_CMDL_INFO
  	add_to_showcmd_c(literally);
  #endif
! 	regname = plain_vgetc();
  #ifdef FEAT_LANGMAP
  	LANGMAP_ADJUST(regname, TRUE);
  #endif
***************
*** 7677,7683 ****
       * deleted when ESC is hit.
       */
      ++no_mapping;
!     c = safe_vgetc();
      --no_mapping;
      switch (c)
      {
--- 7674,7680 ----
       * deleted when ESC is hit.
       */
      ++no_mapping;
!     c = plain_vgetc();
      --no_mapping;
      switch (c)
      {
***************
*** 9356,9362 ****
       * mode message to be deleted when ESC is hit */
      ++no_mapping;
      ++allow_keys;
!     c = safe_vgetc();
      --no_mapping;
      --allow_keys;
      if (IS_SPECIAL(c) || mod_mask)	    /* special key */
--- 9353,9359 ----
       * mode message to be deleted when ESC is hit */
      ++no_mapping;
      ++allow_keys;
!     c = plain_vgetc();
      --no_mapping;
      --allow_keys;
      if (IS_SPECIAL(c) || mod_mask)	    /* special key */
***************
*** 9388,9394 ****
  	}
  	++no_mapping;
  	++allow_keys;
! 	cc = safe_vgetc();
  	--no_mapping;
  	--allow_keys;
  	if (cc != ESC)
--- 9385,9391 ----
  	}
  	++no_mapping;
  	++allow_keys;
! 	cc = plain_vgetc();
  	--no_mapping;
  	--allow_keys;
  	if (cc != ESC)
*** ../vim-7.1.103/src/ex_cmds.c	Tue Aug 21 15:28:32 2007
--- src/ex_cmds.c	Thu Sep 13 16:19:40 2007
***************
*** 4498,4504 ****
  	     *
  	     * The new text is built up in new_start[].  It has some extra
  	     * room to avoid using alloc()/free() too often.  new_start_len is
! 	     * the lenght of the allocated memory at new_start.
  	     *
  	     * Make a copy of the old line, so it won't be taken away when
  	     * updating the screen or handling a multi-line match.  The "old_"
--- 4499,4505 ----
  	     *
  	     * The new text is built up in new_start[].  It has some extra
  	     * room to avoid using alloc()/free() too often.  new_start_len is
! 	     * the length of the allocated memory at new_start.
  	     *
  	     * Make a copy of the old line, so it won't be taken away when
  	     * updating the screen or handling a multi-line match.  The "old_"
***************
*** 4669,4675 ****
  #endif
  			    ++no_mapping;	/* don't map this key */
  			    ++allow_keys;	/* allow special keys */
! 			    i = safe_vgetc();
  			    --allow_keys;
  			    --no_mapping;
  
--- 4670,4676 ----
  #endif
  			    ++no_mapping;	/* don't map this key */
  			    ++allow_keys;	/* allow special keys */
! 			    i = plain_vgetc();
  			    --allow_keys;
  			    --no_mapping;
  
*** ../vim-7.1.103/src/ex_getln.c	Mon Aug  6 22:27:12 2007
--- src/ex_getln.c	Thu Sep 13 16:20:49 2007
***************
*** 641,647 ****
  	{
  	    ++no_mapping;
  	    ++allow_keys;
! 	    c = safe_vgetc();
  	    --no_mapping;
  	    --allow_keys;
  	    /* CTRL-\ e doesn't work when obtaining an expression. */
--- 641,647 ----
  	{
  	    ++no_mapping;
  	    ++allow_keys;
! 	    c = plain_vgetc();
  	    --no_mapping;
  	    --allow_keys;
  	    /* CTRL-\ e doesn't work when obtaining an expression. */
***************
*** 1091,1101 ****
  #endif
  		putcmdline('"', TRUE);
  		++no_mapping;
! 		i = c = safe_vgetc();	/* CTRL-R <char> */
  		if (i == Ctrl_O)
  		    i = Ctrl_R;		/* CTRL-R CTRL-O == CTRL-R CTRL-R */
  		if (i == Ctrl_R)
! 		    c = safe_vgetc();	/* CTRL-R CTRL-R <char> */
  		--no_mapping;
  #ifdef FEAT_EVAL
  		/*
--- 1091,1101 ----
  #endif
  		putcmdline('"', TRUE);
  		++no_mapping;
! 		i = c = plain_vgetc();	/* CTRL-R <char> */
  		if (i == Ctrl_O)
  		    i = Ctrl_R;		/* CTRL-R CTRL-O == CTRL-R CTRL-R */
  		if (i == Ctrl_R)
! 		    c = plain_vgetc();	/* CTRL-R CTRL-R <char> */
  		--no_mapping;
  #ifdef FEAT_EVAL
  		/*
*** ../vim-7.1.103/src/getchar.c	Wed Sep  5 21:45:54 2007
--- src/getchar.c	Thu Sep 13 16:16:53 2007
***************
*** 1597,1608 ****
  	    }
  #endif
  #ifdef FEAT_GUI
! 	    /* The caller doesn't need to know that the focus event is delayed
! 	     * until getting a character. */
  	    if (c == K_FOCUSGAINED || c == K_FOCUSLOST)
  	    {
  		ui_focus_change(c == K_FOCUSGAINED);
! 		continue;
  	    }
  
  	    /* Translate K_CSI to CSI.  The special key is only used to avoid
--- 1597,1609 ----
  	    }
  #endif
  #ifdef FEAT_GUI
! 	    /* Handle focus event here, so that the caller doesn't need to
! 	     * know about it.  Return K_IGNORE so that we loop once (needed if
! 	     * 'lazyredraw' is set). */
  	    if (c == K_FOCUSGAINED || c == K_FOCUSLOST)
  	    {
  		ui_focus_change(c == K_FOCUSGAINED);
! 		c = K_IGNORE;
  	    }
  
  	    /* Translate K_CSI to CSI.  The special key is only used to avoid
***************
*** 1744,1749 ****
--- 1745,1766 ----
      c = vgetc();
      if (c == NUL)
  	c = get_keystroke();
+     return c;
+ }
+ 
+ /*
+  * Like safe_vgetc(), but loop to handle K_IGNORE.
+  * Also ignore scrollbar events.
+  */
+     int
+ plain_vgetc()
+ {
+     int c;
+ 
+     do
+     {
+ 	c = safe_vgetc();
+     } while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);
      return c;
  }
  
*** ../vim-7.1.103/src/normal.c	Thu Sep 13 15:33:18 2007
--- src/normal.c	Thu Sep 13 16:24:51 2007
***************
*** 696,702 ****
  		++allow_keys;		/* no mapping for nchar, but keys */
  	    }
  	    ++no_zero_mapping;		/* don't map zero here */
! 	    c = safe_vgetc();
  #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(c, TRUE);
  #endif
--- 696,702 ----
  		++allow_keys;		/* no mapping for nchar, but keys */
  	    }
  	    ++no_zero_mapping;		/* don't map zero here */
! 	    c = plain_vgetc();
  #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(c, TRUE);
  #endif
***************
*** 721,727 ****
  	    ca.count0 = 0;
  	    ++no_mapping;
  	    ++allow_keys;		/* no mapping for nchar, but keys */
! 	    c = safe_vgetc();		/* get next character */
  #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(c, TRUE);
  #endif
--- 721,727 ----
  	    ca.count0 = 0;
  	    ++no_mapping;
  	    ++allow_keys;		/* no mapping for nchar, but keys */
! 	    c = plain_vgetc();		/* get next character */
  #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(c, TRUE);
  #endif
***************
*** 900,906 ****
  	     * For 'g' get the next character now, so that we can check for
  	     * "gr", "g'" and "g`".
  	     */
! 	    ca.nchar = safe_vgetc();
  #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(ca.nchar, TRUE);
  #endif
--- 900,906 ----
  	     * For 'g' get the next character now, so that we can check for
  	     * "gr", "g'" and "g`".
  	     */
! 	    ca.nchar = plain_vgetc();
  #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(ca.nchar, TRUE);
  #endif
***************
*** 957,963 ****
  		im_set_active(TRUE);
  #endif
  
! 	    *cp = safe_vgetc();
  
  	    if (langmap_active)
  	    {
--- 957,963 ----
  		im_set_active(TRUE);
  #endif
  
! 	    *cp = plain_vgetc();
  
  	    if (langmap_active)
  	    {
***************
*** 1045,1051 ****
  		}
  		if (c > 0)
  		{
! 		    c = safe_vgetc();
  		    if (c != Ctrl_N && c != Ctrl_G)
  			vungetc(c);
  		    else
--- 1045,1051 ----
  		}
  		if (c > 0)
  		{
! 		    c = plain_vgetc();
  		    if (c != Ctrl_N && c != Ctrl_G)
  			vungetc(c);
  		    else
***************
*** 1064,1070 ****
  	    while (enc_utf8 && lang && (c = vpeekc()) > 0
  				 && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))
  	    {
! 		c = safe_vgetc();
  		if (!utf_iscomposing(c))
  		{
  		    vungetc(c);		/* it wasn't, put it back */
--- 1064,1070 ----
  	    while (enc_utf8 && lang && (c = vpeekc()) > 0
  				 && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))
  	    {
! 		c = plain_vgetc();
  		if (!utf_iscomposing(c))
  		{
  		    vungetc(c);		/* it wasn't, put it back */
***************
*** 4564,4570 ****
  #endif
  	    ++no_mapping;
  	    ++allow_keys;   /* no mapping for nchar, but allow key codes */
! 	    nchar = safe_vgetc();
  #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(nchar, TRUE);
  #endif
--- 4564,4570 ----
  #endif
  	    ++no_mapping;
  	    ++allow_keys;   /* no mapping for nchar, but allow key codes */
! 	    nchar = plain_vgetc();
  #ifdef FEAT_LANGMAP
  	    LANGMAP_ADJUST(nchar, TRUE);
  #endif
***************
*** 4922,4928 ****
      case 'u':	/* "zug" and "zuw": undo "zg" and "zw" */
  		++no_mapping;
  		++allow_keys;   /* no mapping for nchar, but allow key codes */
! 		nchar = safe_vgetc();
  #ifdef FEAT_LANGMAP
  		LANGMAP_ADJUST(nchar, TRUE);
  #endif
--- 4922,4928 ----
      case 'u':	/* "zug" and "zuw": undo "zg" and "zw" */
  		++no_mapping;
  		++allow_keys;   /* no mapping for nchar, but allow key codes */
! 		nchar = plain_vgetc();
  #ifdef FEAT_LANGMAP
  		LANGMAP_ADJUST(nchar, TRUE);
  #endif
*** ../vim-7.1.103/src/proto/getchar.pro	Sun May  6 15:04:24 2007
--- src/proto/getchar.pro	Thu Sep 13 16:13:19 2007
***************
*** 38,43 ****
--- 38,44 ----
  void updatescript __ARGS((int c));
  int vgetc __ARGS((void));
  int safe_vgetc __ARGS((void));
+ int plain_vgetc __ARGS((void));
  int vpeekc __ARGS((void));
  int vpeekc_nomap __ARGS((void));
  int vpeekc_any __ARGS((void));
*** ../vim-7.1.103/src/window.c	Sun Aug 12 16:55:01 2007
--- src/window.c	Thu Sep 13 16:25:01 2007
***************
*** 584,590 ****
  		++no_mapping;
  		++allow_keys;   /* no mapping for xchar, but allow key codes */
  		if (xchar == NUL)
! 		    xchar = safe_vgetc();
  #ifdef FEAT_LANGMAP
  		LANGMAP_ADJUST(xchar, TRUE);
  #endif
--- 584,590 ----
  		++no_mapping;
  		++allow_keys;   /* no mapping for xchar, but allow key codes */
  		if (xchar == NUL)
! 		    xchar = plain_vgetc();
  #ifdef FEAT_LANGMAP
  		LANGMAP_ADJUST(xchar, TRUE);
  #endif
*** ../vim-7.1.103/src/version.c	Thu Sep 13 15:33:18 2007
--- src/version.c	Thu Sep 13 18:22:59 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     104,
  /**/

-- 
ARTHUR:  I am your king!
WOMAN:   Well, I didn't vote for you.
ARTHUR:  You don't vote for kings.
WOMAN:   Well, 'ow did you become king then?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.105
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.105
Problem:    Internal error when using "0 ? {'a': 1} : {}". (A.Politz)
Solution:   When parsing a dictionary value without using the value, don't try
	    obtaining the key name.
Files:	    src/eval.c


*** ../vim-7.1.104/src/eval.c	Thu Sep  6 14:25:50 2007
--- src/eval.c	Thu Sep 13 20:29:31 2007
***************
*** 6746,6765 ****
  	    clear_tv(&tvkey);
  	    goto failret;
  	}
! 	key = get_tv_string_buf_chk(&tvkey, buf);
! 	if (key == NULL || *key == NUL)
  	{
! 	    /* "key" is NULL when get_tv_string_buf_chk() gave an errmsg */
! 	    if (key != NULL)
! 		EMSG(_(e_emptykey));
! 	    clear_tv(&tvkey);
! 	    goto failret;
  	}
  
  	*arg = skipwhite(*arg + 1);
  	if (eval1(arg, &tv, evaluate) == FAIL)	/* recursive! */
  	{
! 	    clear_tv(&tvkey);
  	    goto failret;
  	}
  	if (evaluate)
--- 6746,6769 ----
  	    clear_tv(&tvkey);
  	    goto failret;
  	}
! 	if (evaluate)
  	{
! 	    key = get_tv_string_buf_chk(&tvkey, buf);
! 	    if (key == NULL || *key == NUL)
! 	    {
! 		/* "key" is NULL when get_tv_string_buf_chk() gave an errmsg */
! 		if (key != NULL)
! 		    EMSG(_(e_emptykey));
! 		clear_tv(&tvkey);
! 		goto failret;
! 	    }
  	}
  
  	*arg = skipwhite(*arg + 1);
  	if (eval1(arg, &tv, evaluate) == FAIL)	/* recursive! */
  	{
! 	    if (evaluate)
! 		clear_tv(&tvkey);
  	    goto failret;
  	}
  	if (evaluate)
*** ../vim-7.1.104/src/version.c	Thu Sep 13 18:25:08 2007
--- src/version.c	Thu Sep 13 20:36:38 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     105,
  /**/

-- 
DENNIS:  Listen -- strange women lying in ponds distributing swords is no
         basis for a system of government.  Supreme executive power derives
         from a mandate from the masses, not from some farcical aquatic
         ceremony.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.106
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.106
Problem:    ":messages" doesn't quit listing on ":".
Solution:   Break the loop when "got_int" is set.
Files:	    src/message.c


*** ../vim-7.1.105/src/message.c	Thu Sep  6 12:53:59 2007
--- src/message.c	Thu Sep 13 21:45:57 2007
***************
*** 828,834 ****
  		_("Messages maintainer: Bram Moolenaar <Bram@vim.org>"),
  		hl_attr(HLF_T));
  
!     for (p = first_msg_hist; p != NULL; p = p->next)
  	if (p->msg != NULL)
  	    msg_attr(p->msg, p->attr);
  
--- 828,834 ----
  		_("Messages maintainer: Bram Moolenaar <Bram@vim.org>"),
  		hl_attr(HLF_T));
  
!     for (p = first_msg_hist; p != NULL && !got_int; p = p->next)
  	if (p->msg != NULL)
  	    msg_attr(p->msg, p->attr);
  
*** ../vim-7.1.105/src/version.c	Thu Sep 13 20:39:58 2007
--- src/version.c	Thu Sep 13 21:57:40 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     106,
  /**/

-- 
I'm sure that I asked CBuilder to do a "full" install.  Looks like I got
a "fool" install, instead.		Charles E Campbell, Jr, PhD


 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.107
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.107
Problem:    When doing a block selection and using "s" to change the text,
	    while triggering auto-indenting, causes the wrong text to be
	    repeated in other lines. (Adri Verhoef)
Solution:   Compute the change of indent and compensate for that.
Files:	    src/ops.c


*** ../vim-7.1.106/src/ops.c	Thu Jun 28 22:14:28 2007
--- src/ops.c	Thu Aug 30 11:41:10 2007
***************
*** 2477,2483 ****
  
  	/*
  	 * Spaces and tabs in the indent may have changed to other spaces and
! 	 * tabs.  Get the starting column again and correct the lenght.
  	 * Don't do this when "$" used, end-of-line will have changed.
  	 */
  	block_prep(oap, &bd2, oap->start.lnum, TRUE);
--- 2477,2483 ----
  
  	/*
  	 * Spaces and tabs in the indent may have changed to other spaces and
! 	 * tabs.  Get the starting column again and correct the length.
  	 * Don't do this when "$" used, end-of-line will have changed.
  	 */
  	block_prep(oap, &bd2, oap->start.lnum, TRUE);
***************
*** 2534,2540 ****
  #ifdef FEAT_VISUALEXTRA
      long		offset;
      linenr_T		linenr;
!     long		ins_len, pre_textlen = 0;
      char_u		*firstline;
      char_u		*ins_text, *newp, *oldp;
      struct block_def	bd;
--- 2534,2542 ----
  #ifdef FEAT_VISUALEXTRA
      long		offset;
      linenr_T		linenr;
!     long		ins_len;
!     long		pre_textlen = 0;
!     long		pre_indent = 0;
      char_u		*firstline;
      char_u		*ins_text, *newp, *oldp;
      struct block_def	bd;
***************
*** 2579,2585 ****
  						    || gchar_cursor() == NUL))
  	    coladvance_force(getviscol());
  # endif
! 	pre_textlen = (long)STRLEN(ml_get(oap->start.lnum));
  	bd.textcol = curwin->w_cursor.col;
      }
  #endif
--- 2581,2589 ----
  						    || gchar_cursor() == NUL))
  	    coladvance_force(getviscol());
  # endif
! 	firstline = ml_get(oap->start.lnum);
! 	pre_textlen = (long)STRLEN(firstline);
! 	pre_indent = (long)(skipwhite(firstline) - firstline);
  	bd.textcol = curwin->w_cursor.col;
      }
  #endif
***************
*** 2598,2610 ****
       */
      if (oap->block_mode && oap->start.lnum != oap->end.lnum)
      {
  	firstline = ml_get(oap->start.lnum);
! 	/*
! 	 * Subsequent calls to ml_get() flush the firstline data - take a
! 	 * copy of the required bit.
! 	 */
! 	if ((ins_len = (long)STRLEN(firstline) - pre_textlen) > 0)
  	{
  	    if ((ins_text = alloc_check((unsigned)(ins_len + 1))) != NULL)
  	    {
  		vim_strncpy(ins_text, firstline + bd.textcol, (size_t)ins_len);
--- 2602,2623 ----
       */
      if (oap->block_mode && oap->start.lnum != oap->end.lnum)
      {
+ 	/* Auto-indenting may have changed the indent.  If the cursor was past
+ 	 * the indent, exclude that indent change from the inserted text. */
  	firstline = ml_get(oap->start.lnum);
! 	if (bd.textcol > pre_indent)
! 	{
! 	    long new_indent = (long)(skipwhite(firstline) - firstline);
! 
! 	    pre_textlen += new_indent - pre_indent;
! 	    bd.textcol += new_indent - pre_indent;
! 	}
! 
! 	ins_len = (long)STRLEN(firstline) - pre_textlen;
! 	if (ins_len > 0)
  	{
+ 	    /* Subsequent calls to ml_get() flush the firstline data - take a
+ 	     * copy of the inserted text.  */
  	    if ((ins_text = alloc_check((unsigned)(ins_len + 1))) != NULL)
  	    {
  		vim_strncpy(ins_text, firstline + bd.textcol, (size_t)ins_len);
*** ../vim-7.1.106/src/version.c	Thu Sep 13 22:04:30 2007
--- src/version.c	Thu Sep 13 22:38:28 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     107,
  /**/

-- 
Windows
M!uqoms

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.108
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.108 (after 7.1.100)
Problem:    Win32: Compilation problems in Cscope code. (Jeff Lanzarotta)
Solution:   Use (long) instead of (intptr_t) when it's not defined.
Files:	    src/if_cscope.c


*** ../vim-7.1.107/src/if_cscope.c	Thu Sep  6 17:38:06 2007
--- src/if_cscope.c	Wed Sep 12 20:32:17 2007
***************
*** 726,731 ****
--- 726,740 ----
      HANDLE	stdin_rd, stdout_rd;
      HANDLE	stdout_wr, stdin_wr;
      BOOL	created;
+ # ifdef __BORLANDC__
+ #  define OPEN_OH_ARGTYPE long
+ # else
+ #  if (_MSC_VER >= 1300)
+ #   define OPEN_OH_ARGTYPE intptr_t
+ #  else
+ #   define OPEN_OH_ARGTYPE long
+ #  endif
+ # endif
  #endif
  
  #if defined(UNIX)
***************
*** 909,918 ****
      CloseHandle(pi.hThread);
  
      /* TODO - tidy up after failure to create files on pipe handles. */
!     if (((fd = _open_osfhandle((intptr_t)stdin_wr, _O_TEXT|_O_APPEND)) < 0)
  	    || ((csinfo[i].to_fp = _fdopen(fd, "w")) == NULL))
  	PERROR(_("cs_create_connection: fdopen for to_fp failed"));
!     if (((fd = _open_osfhandle((intptr_t)stdout_rd, _O_TEXT|_O_RDONLY)) < 0)
  	    || ((csinfo[i].fr_fp = _fdopen(fd, "r")) == NULL))
  	PERROR(_("cs_create_connection: fdopen for fr_fp failed"));
  
--- 918,929 ----
      CloseHandle(pi.hThread);
  
      /* TODO - tidy up after failure to create files on pipe handles. */
!     if (((fd = _open_osfhandle((OPEN_OH_ARGTYPE)stdin_wr,
! 						      _O_TEXT|_O_APPEND)) < 0)
  	    || ((csinfo[i].to_fp = _fdopen(fd, "w")) == NULL))
  	PERROR(_("cs_create_connection: fdopen for to_fp failed"));
!     if (((fd = _open_osfhandle((OPEN_OH_ARGTYPE)stdout_rd,
! 						      _O_TEXT|_O_RDONLY)) < 0)
  	    || ((csinfo[i].fr_fp = _fdopen(fd, "r")) == NULL))
  	PERROR(_("cs_create_connection: fdopen for fr_fp failed"));
  
*** ../vim-7.1.107/src/version.c	Thu Sep 13 22:40:47 2007
--- src/version.c	Fri Sep 14 19:55:12 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     108,
  /**/

-- 
Q:   How many hardware engineers does it take to change a lightbulb?
A:   None.  We'll fix it in software.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.109
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.109
Problem:    GTK: when there are many tab pages, clicking on the arrow left of
	    the labels moves to the next tab page on the right. (Simeon Bird)
Solution:   Check the X coordinate of the click and pass -1 as value for the
	    left arrow.
Files:	    src/gui_gtk_x11.c, src/term.c


*** ../vim-7.1.108/src/gui_gtk_x11.c	Wed Sep  5 21:45:54 2007
--- src/gui_gtk_x11.c	Fri Sep 14 20:59:55 2007
***************
*** 3223,3230 ****
  	{
  	    if (clicked_page == 0)
  	    {
! 		/* Click after all tabs moves to next tab page. */
! 		if (send_tabline_event(0) && gtk_main_level() > 0)
  		    gtk_main_quit();
  	    }
  #ifndef HAVE_GTK2
--- 3223,3231 ----
  	{
  	    if (clicked_page == 0)
  	    {
! 		/* Click after all tabs moves to next tab page.  When "x" is
! 		 * small guess it's the left button. */
! 		if (send_tabline_event(x < 50 ? -1 : 0) && gtk_main_level() > 0)
  		    gtk_main_quit();
  	    }
  #ifndef HAVE_GTK2
*** ../vim-7.1.108/src/term.c	Thu May 10 20:48:32 2007
--- src/term.c	Fri Sep 14 20:56:40 2007
***************
*** 4809,4814 ****
--- 4809,4816 ----
  	    if (num_bytes == -1)
  		return -1;
  	    current_tab = (int)bytes[0];
+ 	    if (current_tab == 255)	/* -1 in a byte gives 255 */
+ 		current_tab = -1;
  	    slen += num_bytes;
  	}
  	else if (key_name[0] == (int)KS_TABMENU)
*** ../vim-7.1.108/src/version.c	Fri Sep 14 19:56:18 2007
--- src/version.c	Sat Sep 15 14:05:25 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     109,
  /**/

-- 
No letters of the alphabet were harmed in the creation of this message.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.110
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.110 (after 7.1.102)
Problem:    Win32: Still compilation problems with Perl.
Solution:   Change the #ifdefs. (Suresh Govindachar)
Files:	    src/if_perl.xs


*** ../vim-7.1.109/src/if_perl.xs	Thu Sep 13 15:19:32 2007
--- src/if_perl.xs	Fri Sep 14 21:23:38 2007
***************
*** 48,60 ****
   * The changes include addition of two symbols (Perl_sv_2iv_flags,
   * Perl_newXS_flags) not present in earlier releases.
   *
!  * Jan Dubois suggested the following guarding scheme:
   */
! #if (ACTIVEPERL_VERSION >= 822)
! # define PERL589_OR_LATER
! #endif
! #if (PERL_REVISION == 5) && (PERL_VERSION == 8) && (PERL_SUBVERSION >= 9)
! # define PERL589_OR_LATER
  #endif
  #if (PERL_REVISION == 5) && (PERL_VERSION >= 9)
  # define PERL589_OR_LATER
--- 48,62 ----
   * The changes include addition of two symbols (Perl_sv_2iv_flags,
   * Perl_newXS_flags) not present in earlier releases.
   *
!  * Jan Dubois suggested the following guarding scheme.
!  *
!  * Active State defined ACTIVEPERL_VERSION as a string in versions before
!  * 5.8.8; and so the comparison to 822 below needs to be guarded.
   */
! #if (PERL_REVISION == 5) && (PERL_VERSION == 8) && (PERL_SUBVERSION >= 8)
! # if (ACTIVEPERL_VERSION >= 822) || (PERL_SUBVERSION >= 9)
! #  define PERL589_OR_LATER
! # endif
  #endif
  #if (PERL_REVISION == 5) && (PERL_VERSION >= 9)
  # define PERL589_OR_LATER
*** ../vim-7.1.109/src/version.c	Sat Sep 15 14:06:41 2007
--- src/version.c	Sat Sep 15 14:48:05 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     110,
  /**/

-- 
"It's so simple to be wise.  Just think of something stupid to say
and then don't say it."        -- Sam Levenson

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.111
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.111
Problem:    When using ":vimgrep" with the "j" flag folds from another buffer
	    may be displayed. (A.Politz)
Solution:   When not jumping to another buffer update the folds.
Files:	    src/quickfix.c


*** ../vim-7.1.110/src/quickfix.c	Thu Jun 28 21:23:52 2007
--- src/quickfix.c	Fri Sep 14 22:16:23 2007
***************
*** 1612,1619 ****
  	}
  
  	/*
! 	 * If there is only one window and is the quickfix window, create a new
! 	 * one above the quickfix window.
  	 */
  	if (((firstwin == lastwin) && bt_quickfix(curbuf)) || !usable_win)
  	{
--- 1612,1619 ----
  	}
  
  	/*
! 	 * If there is only one window and it is the quickfix window, create a
! 	 * new one above the quickfix window.
  	 */
  	if (((firstwin == lastwin) && bt_quickfix(curbuf)) || !usable_win)
  	{
***************
*** 2981,2986 ****
--- 2981,2987 ----
      buf_T	*buf;
      int		duplicate_name = FALSE;
      int		using_dummy;
+     int		redraw_for_dummy = FALSE;
      int		found_match;
      buf_T	*first_match_buf = NULL;
      time_t	seconds = 0;
***************
*** 3097,3102 ****
--- 3098,3104 ----
  	    /* Remember that a buffer with this name already exists. */
  	    duplicate_name = (buf != NULL);
  	    using_dummy = TRUE;
+ 	    redraw_for_dummy = TRUE;
  
  #if defined(FEAT_AUTOCMD) && defined(FEAT_SYN_HL)
  	    /* Don't do Filetype autocommands to avoid loading syntax and
***************
*** 3243,3252 ****
--- 3245,3272 ----
      if (qi->qf_lists[qi->qf_curlist].qf_count > 0)
      {
  	if ((flags & VGR_NOJUMP) == 0)
+ 	{
+ 	    buf = curbuf;
  	    qf_jump(qi, 0, 0, eap->forceit);
+ 	    if (buf != curbuf)
+ 		/* If we jumped to another buffer redrawing will already be
+ 		 * taken care of. */
+ 		redraw_for_dummy = FALSE;
+ 	}
      }
      else
  	EMSG2(_(e_nomatch2), s);
+ 
+     /* If we loaded a dummy buffer into the current window, the autocommands
+      * may have messed up things, need to redraw and recompute folds. */
+     if (redraw_for_dummy)
+     {
+ #ifdef FEAT_FOLDING
+ 	foldUpdateAll(curwin);
+ #else
+ 	redraw_later(NOT_VALID);
+ #endif
+     }
  
  theend:
      vim_free(regmatch.regprog);
*** ../vim-7.1.110/src/version.c	Sat Sep 15 14:48:57 2007
--- src/version.c	Sun Sep 16 13:23:48 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     111,
  /**/

-- 
Trees moving back and forth is what makes the wind blow.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.112
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.112
Problem:    Using input() with a wrong argument may crash Vim. (A.Politz)
Solution:   Init the input() return value to NULL.
Files:	    src/eval.c


*** ../vim-7.1.111/src/eval.c	Thu Sep 13 20:39:58 2007
--- src/eval.c	Sat Sep 15 19:04:51 2007
***************
*** 11565,11578 ****
      char_u	*xp_arg = NULL;
  
      rettv->v_type = VAR_STRING;
  
  #ifdef NO_CONSOLE_INPUT
      /* While starting up, there is no place to enter text. */
      if (no_console_input())
-     {
- 	rettv->vval.v_string = NULL;
  	return;
-     }
  #endif
  
      cmd_silent = FALSE;		/* Want to see the prompt. */
--- 11566,11577 ----
      char_u	*xp_arg = NULL;
  
      rettv->v_type = VAR_STRING;
+     rettv->vval.v_string = NULL;
  
  #ifdef NO_CONSOLE_INPUT
      /* While starting up, there is no place to enter text. */
      if (no_console_input())
  	return;
  #endif
  
      cmd_silent = FALSE;		/* Want to see the prompt. */
*** ../vim-7.1.111/src/version.c	Sun Sep 16 13:26:56 2007
--- src/version.c	Sun Sep 16 14:19:04 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     112,
  /**/

-- 
The early bird gets the worm. If you want something else for
breakfast, get up later.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.113
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.113
Problem:    Using map() to go over an empty list causes memory to be freed
	    twice. (A.Politz)
Solution:   Don't clear the typeval in restore_vimvar().
Files:	    src/eval.c


*** ../vim-7.1.112/src/eval.c	Sun Sep 16 14:20:18 2007
--- src/eval.c	Sun Sep 16 19:24:49 2007
***************
*** 1318,1324 ****
  {
      hashitem_T	*hi;
  
-     clear_tv(&vimvars[idx].vv_tv);
      vimvars[idx].vv_tv = *save_tv;
      if (vimvars[idx].vv_type == VAR_UNKNOWN)
      {
--- 1318,1323 ----
***************
*** 1362,1368 ****
  
      if (p_verbose == 0)
  	--emsg_off;
-     vimvars[VV_VAL].vv_str = NULL;
      restore_vimvar(VV_VAL, &save_val);
  
      return list;
--- 1361,1366 ----
***************
*** 9387,9401 ****
  {
      typval_T	rettv;
      char_u	*s;
  
      copy_tv(tv, &vimvars[VV_VAL].vv_tv);
      s = expr;
      if (eval1(&s, &rettv, TRUE) == FAIL)
! 	return FAIL;
      if (*s != NUL)  /* check for trailing chars after expr */
      {
  	EMSG2(_(e_invexpr2), s);
! 	return FAIL;
      }
      if (map)
      {
--- 9386,9401 ----
  {
      typval_T	rettv;
      char_u	*s;
+     int		retval = FAIL;
  
      copy_tv(tv, &vimvars[VV_VAL].vv_tv);
      s = expr;
      if (eval1(&s, &rettv, TRUE) == FAIL)
! 	goto theend;
      if (*s != NUL)  /* check for trailing chars after expr */
      {
  	EMSG2(_(e_invexpr2), s);
! 	goto theend;
      }
      if (map)
      {
***************
*** 9414,9423 ****
  	/* On type error, nothing has been removed; return FAIL to stop the
  	 * loop.  The error message was given by get_tv_number_chk(). */
  	if (error)
! 	    return FAIL;
      }
      clear_tv(&vimvars[VV_VAL].vv_tv);
!     return OK;
  }
  
  /*
--- 9414,9425 ----
  	/* On type error, nothing has been removed; return FAIL to stop the
  	 * loop.  The error message was given by get_tv_number_chk(). */
  	if (error)
! 	    goto theend;
      }
+     retval = OK;
+ theend:
      clear_tv(&vimvars[VV_VAL].vv_tv);
!     return retval;
  }
  
  /*
*** ../vim-7.1.112/src/version.c	Sun Sep 16 14:20:18 2007
--- src/version.c	Mon Sep 17 21:33:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     113,
  /**/

-- 
Mental Floss prevents moral decay!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.115
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.115 (after 7.1.105)
Problem:    Compiler warning for uninitialized variable. (Tony Mechelynck)
Solution:   Init variable to NULL.
Files:	    src/eval.c


*** ../vim-7.1.114/src/eval.c	Mon Sep 17 21:55:02 2007
--- src/eval.c	Sun Sep 16 19:24:49 2007
***************
*** 6704,6710 ****
      dict_T	*d = NULL;
      typval_T	tvkey;
      typval_T	tv;
!     char_u	*key;
      dictitem_T	*item;
      char_u	*start = skipwhite(*arg + 1);
      char_u	buf[NUMBUFLEN];
--- 6705,6711 ----
      dict_T	*d = NULL;
      typval_T	tvkey;
      typval_T	tv;
!     char_u	*key = NULL;
      dictitem_T	*item;
      char_u	*start = skipwhite(*arg + 1);
      char_u	buf[NUMBUFLEN];
*** ../vim-7.1.114/src/version.c	Mon Sep 17 21:55:02 2007
--- src/version.c	Mon Sep 17 22:18:42 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     115,
  /**/

-- 
Proofread carefully to see if you any words out.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.116
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.116
Problem:    Cannot display Unicode characters above 0x10000.
Solution:   Remove the replacement with a question mark when UNICODE16 is not
	    defined. (partly by Nicolas Weber)
Files:	    src/screen.c


*** ../vim-7.1.115/src/screen.c	Thu Aug 30 13:51:52 2007
--- src/screen.c	Mon Sep 10 22:29:42 2007
***************
*** 2305,2313 ****
--- 2305,2315 ----
  			prev_c = u8c;
  #endif
  		    /* Non-BMP character: display as ? or fullwidth ?. */
+ #ifdef UNICODE16
  		    if (u8c >= 0x10000)
  			ScreenLinesUC[idx] = (cells == 2) ? 0xff1f : (int)'?';
  		    else
+ #endif
  			ScreenLinesUC[idx] = u8c;
  		    for (i = 0; i < Screen_mco; ++i)
  		    {
***************
*** 3678,3690 ****
  		    if ((mb_l == 1 && c >= 0x80)
  			    || (mb_l >= 1 && mb_c == 0)
  			    || (mb_l > 1 && (!vim_isprintc(mb_c)
! 							 || mb_c >= 0x10000)))
  		    {
  			/*
  			 * Illegal UTF-8 byte: display as <xx>.
  			 * Non-BMP character : display as ? or fullwidth ?.
  			 */
  			if (mb_c < 0x10000)
  			{
  			    transchar_hex(extra, mb_c);
  # ifdef FEAT_RIGHTLEFT
--- 3680,3697 ----
  		    if ((mb_l == 1 && c >= 0x80)
  			    || (mb_l >= 1 && mb_c == 0)
  			    || (mb_l > 1 && (!vim_isprintc(mb_c)
! # ifdef UNICODE16
! 							 || mb_c >= 0x10000
! # endif
! 							 )))
  		    {
  			/*
  			 * Illegal UTF-8 byte: display as <xx>.
  			 * Non-BMP character : display as ? or fullwidth ?.
  			 */
+ # ifdef UNICODE16
  			if (mb_c < 0x10000)
+ # endif
  			{
  			    transchar_hex(extra, mb_c);
  # ifdef FEAT_RIGHTLEFT
***************
*** 3692,3702 ****
--- 3699,3711 ----
  				rl_mirror(extra);
  # endif
  			}
+ # ifdef UNICODE16
  			else if (utf_char2cells(mb_c) != 2)
  			    STRCPY(extra, "?");
  			else
  			    /* 0xff1f in UTF-8: full-width '?' */
  			    STRCPY(extra, "\357\274\237");
+ # endif
  
  			p_extra = extra;
  			c = *p_extra;
***************
*** 6245,6250 ****
--- 6254,6260 ----
  		else
  		    u8c = utfc_ptr2char(ptr, u8cc);
  		mbyte_cells = utf_char2cells(u8c);
+ # ifdef UNICODE16
  		/* Non-BMP character: display as ? or fullwidth ?. */
  		if (u8c >= 0x10000)
  		{
***************
*** 6252,6257 ****
--- 6262,6268 ----
  		    if (attr == 0)
  			attr = hl_attr(HLF_8);
  		}
+ # endif
  # ifdef FEAT_ARABIC
  		if (p_arshape && !p_tbidi && ARABIC_CHAR(u8c))
  		{
*** ../vim-7.1.116/src/version.c	Mon Sep 17 22:19:43 2007
--- src/version.c	Mon Sep 17 22:37:31 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     116,
  /**/

-- 
There can't be a crisis today, my schedule is already full.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.117
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.117
Problem:    Can't check wether Vim was compiled with Gnome. (Tony Mechelynck)
Solution:   Add gui_gnome to the has() list.
Files:	    src/eval.c


*** ../vim-7.1.116/src/eval.c	Mon Sep 17 22:19:43 2007
--- src/eval.c	Sun Sep 16 19:24:49 2007
***************
*** 10879,10884 ****
--- 10883,10891 ----
  	"gui_gtk2",
  # endif
  #endif
+ #ifdef FEAT_GUI_GNOME
+ 	"gui_gnome",
+ #endif
  #ifdef FEAT_GUI_MAC
  	"gui_mac",
  #endif
*** ../vim-7.1.116/src/version.c	Mon Sep 17 22:38:49 2007
--- src/version.c	Tue Sep 25 12:48:59 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     117,
  /**/

-- 
ARTHUR:  No, hang on!  Just answer the five questions ...
GALAHAD: Three questions ...
ARTHUR:  Three questions ...  And we shall watch ... and pray.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.118
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.118 (after 7.1.107)
Problem:    Compiler warning for Visual C compiler.
Solution:   Add typecast. (Mike Williams)
Files:	    src/ops.c


*** ../vim-7.1.117/src/ops.c	Thu Sep 13 22:40:47 2007
--- src/ops.c	Mon Sep 24 18:30:09 2007
***************
*** 2605,2611 ****
  	/* Auto-indenting may have changed the indent.  If the cursor was past
  	 * the indent, exclude that indent change from the inserted text. */
  	firstline = ml_get(oap->start.lnum);
! 	if (bd.textcol > pre_indent)
  	{
  	    long new_indent = (long)(skipwhite(firstline) - firstline);
  
--- 2605,2611 ----
  	/* Auto-indenting may have changed the indent.  If the cursor was past
  	 * the indent, exclude that indent change from the inserted text. */
  	firstline = ml_get(oap->start.lnum);
! 	if (bd.textcol > (colnr_T)pre_indent)
  	{
  	    long new_indent = (long)(skipwhite(firstline) - firstline);
  
*** ../vim-7.1.117/src/version.c	Tue Sep 25 12:50:00 2007
--- src/version.c	Tue Sep 25 14:18:37 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     118,
  /**/

-- 
BRIDGEKEEPER: What is your favorite editor?
GAWAIN:       Emacs ...  No, Viiiiiiiiiiimmmmmmm!
           "Monty Python and the Holy editor wars" PYTHON (MONTY) SOFTWARE LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.119
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.119
Problem:    Crash when 'cmdheight' set to very large value. (A.Politz)
Solution:   Limit 'cmdheight' to 'lines' minus one.  Store right value of
	    'cmdheight' when running out of room.
Files:	    src/option.c, src/window.c


*** ../vim-7.1.118/src/option.c	Thu Sep  6 16:33:47 2007
--- src/option.c	Tue Sep 25 12:17:35 2007
***************
*** 7824,7829 ****
--- 7824,7831 ----
  	    errmsg = e_positive;
  	    p_ch = 1;
  	}
+ 	if (p_ch > Rows - min_rows() + 1)
+ 	    p_ch = Rows - min_rows() + 1;
  
  	/* Only compute the new window layout when startup has been
  	 * completed. Otherwise the frame sizes may be wrong. */
*** ../vim-7.1.118/src/window.c	Thu Sep 13 18:25:08 2007
--- src/window.c	Tue Sep 25 12:13:56 2007
***************
*** 5523,5528 ****
--- 5523,5529 ----
  		{
  		    EMSG(_(e_noroom));
  		    p_ch = old_p_ch;
+ 		    curtab->tp_ch_used = p_ch;
  		    cmdline_row = Rows - p_ch;
  		    break;
  		}
*** ../vim-7.1.118/src/version.c	Tue Sep 25 14:19:35 2007
--- src/version.c	Tue Sep 25 14:48:14 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     119,
  /**/

-- 
Q: Why does /dev/null accept only integers?
A: You can't sink a float.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.121
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.121
Problem:    Using ":cd %:h" when editing a file in the current directory
	    results in an error message for using an empty string.
Solution:   When "%:h" results in an empty string use ".".
Files:	    src/eval.c


*** ../vim-7.1.120/src/eval.c	Tue Sep 25 17:54:41 2007
--- src/eval.c	Sun Sep 16 19:24:49 2007
***************
*** 21308,21321 ****
  	*usedlen += 2;
  	s = get_past_head(*fnamep);
  	while (tail > s && after_pathsep(s, tail))
! 	    --tail;
  	*fnamelen = (int)(tail - *fnamep);
  #ifdef VMS
  	if (*fnamelen > 0)
  	    *fnamelen += 1; /* the path separator is part of the path */
  #endif
! 	while (tail > s && !after_pathsep(s, tail))
! 	    mb_ptr_back(*fnamep, tail);
      }
  
      /* ":8" - shortname  */
--- 21308,21334 ----
  	*usedlen += 2;
  	s = get_past_head(*fnamep);
  	while (tail > s && after_pathsep(s, tail))
! 	    mb_ptr_back(*fnamep, tail);
  	*fnamelen = (int)(tail - *fnamep);
  #ifdef VMS
  	if (*fnamelen > 0)
  	    *fnamelen += 1; /* the path separator is part of the path */
  #endif
! 	if (*fnamelen == 0)
! 	{
! 	    /* Result is empty.  Turn it into "." to make ":cd %:h" work. */
! 	    p = vim_strsave((char_u *)".");
! 	    if (p == NULL)
! 		return -1;
! 	    vim_free(*bufp);
! 	    *bufp = *fnamep = tail = p;
! 	    *fnamelen = 1;
! 	}
! 	else
! 	{
! 	    while (tail > s && !after_pathsep(s, tail))
! 		mb_ptr_back(*fnamep, tail);
! 	}
      }
  
      /* ":8" - shortname  */
*** ../vim-7.1.120/src/version.c	Tue Sep 25 17:54:41 2007
--- src/version.c	Tue Sep 25 20:38:08 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     121,
  /**/

-- 
It is illegal for anyone to try and stop a child from playfully jumping over
puddles of water.
		[real standing law in California, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.122
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.122
Problem:    Mac: building Vim.app fails.  Using wrong architecture.
Solution:   Use line continuation for the gui_bundle dependency.  Detect the
	    system architecture with "uname -a".
Files:	    src/main.aap


*** ../vim-7.1.121/src/main.aap	Thu May 10 18:48:19 2007
--- src/main.aap	Tue Sep 25 21:26:03 2007
***************
*** 56,64 ****
      config {virtual} auto/config.h auto/config.aap :
                           auto/configure.aap configure.aap
                           config.arg config.h.in config.aap.in
          :sys CONFIG_STATUS=auto/config.status
                  ./configure.aap `file2string("config.arg")`
!                     --with-mac-arch=ppc
                      --cache-file=auto/config.cache
  
      # Configure arguments: create an empty "config.arg" file when its missing
--- 56,71 ----
      config {virtual} auto/config.h auto/config.aap :
                           auto/configure.aap configure.aap
                           config.arg config.h.in config.aap.in
+         # Use "uname -a" to detect the architecture of the system.
+         @ok, uname = redir_system('uname -a', 0)
+         @if string.find(uname, "i386") >= 0:
+         @   arch = "i386"
+         @else:
+         @   arch = "ppc"
+         :print Building for $arch system
          :sys CONFIG_STATUS=auto/config.status
                  ./configure.aap `file2string("config.arg")`
!                     --with-mac-arch=$arch
                      --cache-file=auto/config.cache
  
      # Configure arguments: create an empty "config.arg" file when its missing
***************
*** 1167,1173 ****
          :symlink `os.getcwd()`/../runtime $RESDIR/vim/runtime
  # TODO: Create the vimtutor application.
  
! gui_bundle {virtual}: $(RESDIR) bundle-dir bundle-executable bundle-info
                          bundle-resource bundle-language
  
  bundle-dir {virtual}: $(APPDIR)/Contents $(VIMTARGET)
--- 1174,1180 ----
          :symlink `os.getcwd()`/../runtime $RESDIR/vim/runtime
  # TODO: Create the vimtutor application.
  
! gui_bundle {virtual}: $(RESDIR) bundle-dir bundle-executable bundle-info \
                          bundle-resource bundle-language
  
  bundle-dir {virtual}: $(APPDIR)/Contents $(VIMTARGET)
***************
*** 1187,1193 ****
          :sys m4 $(M4FLAGSX) infplist.xml > $(APPDIR)/Contents/Info.plist
  
  bundle-resource {virtual}: bundle-dir bundle-rsrc
!     :copy {force} $(RSRC_DIR)/*.icns $(RESDIR)
  
  ### Classic resources
  # Resource fork (in the form of a .rsrc file) for Classic Vim (Mac OS 9)
--- 1194,1200 ----
          :sys m4 $(M4FLAGSX) infplist.xml > $(APPDIR)/Contents/Info.plist
  
  bundle-resource {virtual}: bundle-dir bundle-rsrc
!         :copy {force} $(RSRC_DIR)/*.icns $(RESDIR)
  
  ### Classic resources
  # Resource fork (in the form of a .rsrc file) for Classic Vim (Mac OS 9)
*** ../vim-7.1.121/src/version.c	Tue Sep 25 20:39:14 2007
--- src/version.c	Tue Sep 25 22:12:16 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     122,
  /**/

-- 
Men may not be seen publicly in any kind of strapless gown.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.123
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.123
Problem:    Win32: ":edit foo ~ foo" expands "~".
Solution:   Change the call to expand_env().
Files:	    src/ex_docmd.c, src/misc1.c, src/proto/misc1.pro, src/option.c


*** ../vim-7.1.122/src/ex_docmd.c	Sun Aug 19 22:42:27 2007
--- src/ex_docmd.c	Wed Sep 26 20:29:36 2007
***************
*** 4403,4409 ****
  			    || vim_strchr(eap->arg, '~') != NULL)
  		    {
  			expand_env_esc(eap->arg, NameBuff, MAXPATHL,
! 								 TRUE, NULL);
  			has_wildcards = mch_has_wildcard(NameBuff);
  			p = NameBuff;
  		    }
--- 4402,4408 ----
  			    || vim_strchr(eap->arg, '~') != NULL)
  		    {
  			expand_env_esc(eap->arg, NameBuff, MAXPATHL,
! 							    TRUE, TRUE, NULL);
  			has_wildcards = mch_has_wildcard(NameBuff);
  			p = NameBuff;
  		    }
*** ../vim-7.1.122/src/misc1.c	Tue Aug 14 22:15:53 2007
--- src/misc1.c	Tue Sep 25 17:30:01 2007
***************
*** 3506,3514 ****
  #endif
  
  /*
   * Expand environment variable with path name.
   * "~/" is also expanded, using $HOME.	For Unix "~user/" is expanded.
!  * Skips over "\ ", "\~" and "\$".
   * If anything fails no expansion is done and dst equals src.
   */
      void
--- 3506,3543 ----
  #endif
  
  /*
+  * Call expand_env() and store the result in an allocated string.
+  * This is not very memory efficient, this expects the result to be freed
+  * again soon.
+  */
+     char_u *
+ expand_env_save(src)
+     char_u	*src;
+ {
+     return expand_env_save_opt(src, FALSE);
+ }
+ 
+ /*
+  * Idem, but when "one" is TRUE handle the string as one file name, only
+  * expand "~" at the start.
+  */
+     char_u *
+ expand_env_save_opt(src, one)
+     char_u	*src;
+     int		one;
+ {
+     char_u	*p;
+ 
+     p = alloc(MAXPATHL);
+     if (p != NULL)
+ 	expand_env_esc(src, p, MAXPATHL, FALSE, one, NULL);
+     return p;
+ }
+ 
+ /*
   * Expand environment variable with path name.
   * "~/" is also expanded, using $HOME.	For Unix "~user/" is expanded.
!  * Skips over "\ ", "\~" and "\$" (not for Win32 though).
   * If anything fails no expansion is done and dst equals src.
   */
      void
***************
*** 3517,3531 ****
      char_u	*dst;		/* where to put the result */
      int		dstlen;		/* maximum length of the result */
  {
!     expand_env_esc(src, dst, dstlen, FALSE, NULL);
  }
  
      void
! expand_env_esc(srcp, dst, dstlen, esc, startstr)
      char_u	*srcp;		/* input string e.g. "$HOME/vim.hlp" */
      char_u	*dst;		/* where to put the result */
      int		dstlen;		/* maximum length of the result */
      int		esc;		/* escape spaces in expanded variables */
      char_u	*startstr;	/* start again after this (can be NULL) */
  {
      char_u	*src;
--- 3546,3561 ----
      char_u	*dst;		/* where to put the result */
      int		dstlen;		/* maximum length of the result */
  {
!     expand_env_esc(src, dst, dstlen, FALSE, FALSE, NULL);
  }
  
      void
! expand_env_esc(srcp, dst, dstlen, esc, one, startstr)
      char_u	*srcp;		/* input string e.g. "$HOME/vim.hlp" */
      char_u	*dst;		/* where to put the result */
      int		dstlen;		/* maximum length of the result */
      int		esc;		/* escape spaces in expanded variables */
+     int		one;		/* "srcp" is one file name */
      char_u	*startstr;	/* start again after this (can be NULL) */
  {
      char_u	*src;
***************
*** 3766,3771 ****
--- 3796,3803 ----
  	{
  	    /*
  	     * Recognize the start of a new name, for '~'.
+ 	     * Don't do this when "one" is TRUE, to avoid expanding "~" in
+ 	     * ":edit foo ~ foo".
  	     */
  	    at_start = FALSE;
  	    if (src[0] == '\\' && src[1] != NUL)
***************
*** 3773,3779 ****
  		*dst++ = *src++;
  		--dstlen;
  	    }
! 	    else if (src[0] == ' ' || src[0] == ',')
  		at_start = TRUE;
  	    *dst++ = *src++;
  	    --dstlen;
--- 3805,3811 ----
  		*dst++ = *src++;
  		--dstlen;
  	    }
! 	    else if ((src[0] == ' ' || src[0] == ',') && !one)
  		at_start = TRUE;
  	    *dst++ = *src++;
  	    --dstlen;
***************
*** 4070,4092 ****
  }
  
  /*
-  * Call expand_env() and store the result in an allocated string.
-  * This is not very memory efficient, this expects the result to be freed
-  * again soon.
-  */
-     char_u *
- expand_env_save(src)
-     char_u	*src;
- {
-     char_u	*p;
- 
-     p = alloc(MAXPATHL);
-     if (p != NULL)
- 	expand_env(src, p, MAXPATHL);
-     return p;
- }
- 
- /*
   * Our portable version of setenv.
   */
      void
--- 4102,4107 ----
***************
*** 9139,9145 ****
  	     */
  	    if (vim_strpbrk(p, (char_u *)"$~") != NULL)
  	    {
! 		p = expand_env_save(p);
  		if (p == NULL)
  		    p = pat[i];
  #ifdef UNIX
--- 9154,9160 ----
  	     */
  	    if (vim_strpbrk(p, (char_u *)"$~") != NULL)
  	    {
! 		p = expand_env_save_opt(p, TRUE);
  		if (p == NULL)
  		    p = pat[i];
  #ifdef UNIX
*** ../vim-7.1.122/src/proto/misc1.pro	Sat May  5 20:15:33 2007
--- src/proto/misc1.pro	Tue Sep 25 17:22:36 2007
***************
*** 48,57 ****
  void vim_beep __ARGS((void));
  void init_homedir __ARGS((void));
  void free_homedir __ARGS((void));
  void expand_env __ARGS((char_u *src, char_u *dst, int dstlen));
! void expand_env_esc __ARGS((char_u *srcp, char_u *dst, int dstlen, int esc, char_u *startstr));
  char_u *vim_getenv __ARGS((char_u *name, int *mustfree));
- char_u *expand_env_save __ARGS((char_u *src));
  void vim_setenv __ARGS((char_u *name, char_u *val));
  char_u *get_env_name __ARGS((expand_T *xp, int idx));
  void home_replace __ARGS((buf_T *buf, char_u *src, char_u *dst, int dstlen, int one));
--- 48,58 ----
  void vim_beep __ARGS((void));
  void init_homedir __ARGS((void));
  void free_homedir __ARGS((void));
+ char_u *expand_env_save __ARGS((char_u *src));
+ char_u *expand_env_save_opt __ARGS((char_u *src, int one));
  void expand_env __ARGS((char_u *src, char_u *dst, int dstlen));
! void expand_env_esc __ARGS((char_u *srcp, char_u *dst, int dstlen, int esc, int one, char_u *startstr));
  char_u *vim_getenv __ARGS((char_u *name, int *mustfree));
  void vim_setenv __ARGS((char_u *name, char_u *val));
  char_u *get_env_name __ARGS((expand_T *xp, int idx));
  void home_replace __ARGS((buf_T *buf, char_u *src, char_u *dst, int dstlen, int one));
*** ../vim-7.1.122/src/option.c	Tue Sep 25 14:50:19 2007
--- src/option.c	Tue Sep 25 17:20:05 2007
***************
*** 4996,5002 ****
       * For 'spellsuggest' expand after "file:".
       */
      expand_env_esc(val, NameBuff, MAXPATHL,
! 	    (char_u **)options[opt_idx].var == &p_tags,
  #ifdef FEAT_SPELL
  	    (char_u **)options[opt_idx].var == &p_sps ? (char_u *)"file:" :
  #endif
--- 4996,5002 ----
       * For 'spellsuggest' expand after "file:".
       */
      expand_env_esc(val, NameBuff, MAXPATHL,
! 	    (char_u **)options[opt_idx].var == &p_tags, FALSE,
  #ifdef FEAT_SPELL
  	    (char_u **)options[opt_idx].var == &p_sps ? (char_u *)"file:" :
  #endif
*** ../vim-7.1.122/src/version.c	Tue Sep 25 22:13:14 2007
--- src/version.c	Wed Sep 26 22:30:59 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     123,
  /**/

-- 
So when I saw the post to comp.editors, I rushed over to the FTP site to
grab it.  So I yank apart the tarball, light x candles, where x= the
vim version multiplied by the md5sum of the source divided by the MAC of
my NIC (8A3FA78155A8A1D346C3C4A), put on black robes, dim the lights,
wave a dead chicken over the hard drive, and summon the power of GNU GCC
with the magic words "make config ; make!".
		[Jason Spence, compiling Vim 5.0]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.124
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.124 (extra)
Problem:    Mac: When dropping a file on Vim.app that is already in the buffer
	    list (from .viminfo) results in editing an empty, unnamed buffer.
	    (Axel Kielhorn)  Also: warning for unused variable.
Solution:   Move to the buffer of the first agument.  Delete unused variable.
Files:	    src/gui_mac.c


*** ../vim-7.1.123/src/gui_mac.c	Thu Aug 30 12:50:00 2007
--- src/gui_mac.c	Sat Sep 29 13:12:26 2007
***************
*** 1046,1051 ****
--- 1046,1052 ----
      {
  	int i;
  	char_u *p;
+ 	int fnum = -1;
  
  	/* these are the initial files dropped on the Vim icon */
  	for (i = 0 ; i < numFiles; i++)
***************
*** 1055,1060 ****
--- 1056,1073 ----
  		mch_exit(2);
  	    else
  		alist_add(&global_alist, p, 2);
+ 	    if (fnum == -1)
+ 		fnum = GARGLIST[GARGCOUNT - 1].ae_fnum;
+ 	}
+ 
+ 	/* If the file name was already in the buffer list we need to switch
+ 	 * to it. */
+ 	if (curbuf->b_fnum != fnum)
+ 	{
+ 	    char_u cmd[30];
+ 
+ 	    vim_snprintf((char *)cmd, 30, "silent %dbuffer", fnum);
+ 	    do_cmdline_cmd(cmd);
  	}
  
  	/* Change directory to the location of the first file. */
***************
*** 2920,2926 ****
      /* TODO: Move most of this stuff toward gui_mch_init */
      Rect	windRect;
      MenuHandle	pomme;
-     long	gestalt_rc;
      EventTypeSpec   eventTypeSpec;
      EventHandlerRef mouseWheelHandlerRef;
  #ifdef USE_CARBONKEYHANDLER
--- 2933,2938 ----
*** ../vim-7.1.123/src/version.c	Wed Sep 26 22:35:06 2007
--- src/version.c	Sat Sep 29 13:13:16 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     124,
  /**/

-- 
ERIC IDLE PLAYED: THE DEAD COLLECTOR, MR BINT (A VILLAGE NE'ER-DO -WELL VERY
                  KEEN ON BURNING WITCHES), SIR ROBIN, THE GUARD WHO DOESN'T
                  HICOUGH BUT TRIES TO GET THINGS STRAIGHT, CONCORDE (SIR
                  LAUNCELOT'S TRUSTY STEED), ROGER THE SHRUBBER (A SHRUBBER),
                  BROTHER MAYNARD
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.125
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.125
Problem:    The TermResponse autocommand event is not always triggered. (Aron
	    Griffis)
Solution:   When unblocking autocommands check if v:termresponse changed and
	    trigger the event then.
Files:	    src/buffer.c, src/diff.c, src/ex_getln.c, src/fileio.c,
	    src/globals.h, src/misc2.c, src/proto/fileio.pro, src/window.c


*** ../vim-7.1.124/src/buffer.c	Sun Aug 12 15:50:26 2007
--- src/buffer.c	Wed Sep 26 20:05:38 2007
***************
*** 5515,5525 ****
  
  #ifdef FEAT_AUTOCMD
      if (!aucmd)		    /* Don't trigger BufDelete autocommands here. */
! 	++autocmd_block;
  #endif
      close_buffer(NULL, buf, DOBUF_WIPE);
  #ifdef FEAT_AUTOCMD
      if (!aucmd)
! 	--autocmd_block;
  #endif
  }
--- 5512,5522 ----
  
  #ifdef FEAT_AUTOCMD
      if (!aucmd)		    /* Don't trigger BufDelete autocommands here. */
! 	block_autocmds();
  #endif
      close_buffer(NULL, buf, DOBUF_WIPE);
  #ifdef FEAT_AUTOCMD
      if (!aucmd)
! 	unblock_autocmds();
  #endif
  }
*** ../vim-7.1.124/src/diff.c	Tue Feb 20 04:43:13 2007
--- src/diff.c	Tue Sep 25 22:01:40 2007
***************
*** 840,850 ****
  		    tmp_orig, tmp_new);
  	    append_redir(cmd, p_srr, tmp_diff);
  #ifdef FEAT_AUTOCMD
! 	    ++autocmd_block;	/* Avoid ShellCmdPost stuff */
  #endif
  	    (void)call_shell(cmd, SHELL_FILTER|SHELL_SILENT|SHELL_DOOUT);
  #ifdef FEAT_AUTOCMD
! 	    --autocmd_block;
  #endif
  	    vim_free(cmd);
  	}
--- 840,850 ----
  		    tmp_orig, tmp_new);
  	    append_redir(cmd, p_srr, tmp_diff);
  #ifdef FEAT_AUTOCMD
! 	    block_autocmds();	/* Avoid ShellCmdPost stuff */
  #endif
  	    (void)call_shell(cmd, SHELL_FILTER|SHELL_SILENT|SHELL_DOOUT);
  #ifdef FEAT_AUTOCMD
! 	    unblock_autocmds();
  #endif
  	    vim_free(cmd);
  	}
***************
*** 949,959 ****
  # endif
  		eap->arg);
  #ifdef FEAT_AUTOCMD
! 	++autocmd_block;	/* Avoid ShellCmdPost stuff */
  #endif
  	(void)call_shell(buf, SHELL_FILTER | SHELL_COOKED);
  #ifdef FEAT_AUTOCMD
! 	--autocmd_block;
  #endif
      }
  
--- 949,959 ----
  # endif
  		eap->arg);
  #ifdef FEAT_AUTOCMD
! 	block_autocmds();	/* Avoid ShellCmdPost stuff */
  #endif
  	(void)call_shell(buf, SHELL_FILTER | SHELL_COOKED);
  #ifdef FEAT_AUTOCMD
! 	unblock_autocmds();
  #endif
      }
  
*** ../vim-7.1.124/src/ex_getln.c	Thu Sep 13 18:25:08 2007
--- src/ex_getln.c	Tue Sep 25 22:03:05 2007
***************
*** 5925,5931 ****
  
  # ifdef FEAT_AUTOCMD
      /* Don't execute autocommands while creating the window. */
!     ++autocmd_block;
  # endif
      /* don't use a new tab page */
      cmdmod.tab = 0;
--- 5925,5931 ----
  
  # ifdef FEAT_AUTOCMD
      /* Don't execute autocommands while creating the window. */
!     block_autocmds();
  # endif
      /* don't use a new tab page */
      cmdmod.tab = 0;
***************
*** 5934,5939 ****
--- 5934,5942 ----
      if (win_split((int)p_cwh, WSP_BOT) == FAIL)
      {
  	beep_flush();
+ # ifdef FEAT_AUTOCMD
+ 	unblock_autocmds();
+ # endif
  	return K_IGNORE;
      }
      cmdwin_type = ccline.cmdfirstc;
***************
*** 5956,5962 ****
  
  # ifdef FEAT_AUTOCMD
      /* Do execute autocommands for setting the filetype (load syntax). */
!     --autocmd_block;
  # endif
  
      /* Showing the prompt may have set need_wait_return, reset it. */
--- 5959,5965 ----
  
  # ifdef FEAT_AUTOCMD
      /* Do execute autocommands for setting the filetype (load syntax). */
!     unblock_autocmds();
  # endif
  
      /* Showing the prompt may have set need_wait_return, reset it. */
***************
*** 6110,6116 ****
  
  # ifdef FEAT_AUTOCMD
  	/* Don't execute autocommands while deleting the window. */
! 	++autocmd_block;
  # endif
  	wp = curwin;
  	bp = curbuf;
--- 6113,6119 ----
  
  # ifdef FEAT_AUTOCMD
  	/* Don't execute autocommands while deleting the window. */
! 	block_autocmds();
  # endif
  	wp = curwin;
  	bp = curbuf;
***************
*** 6122,6128 ****
  	win_size_restore(&winsizes);
  
  # ifdef FEAT_AUTOCMD
! 	--autocmd_block;
  # endif
      }
  
--- 6125,6131 ----
  	win_size_restore(&winsizes);
  
  # ifdef FEAT_AUTOCMD
! 	unblock_autocmds();
  # endif
      }
  
*** ../vim-7.1.124/src/fileio.c	Sun Aug 12 15:50:26 2007
--- src/fileio.c	Wed Sep 26 20:02:54 2007
***************
*** 7165,7170 ****
--- 7187,7193 ----
  
  static event_T	last_event;
  static int	last_group;
+ static int	autocmd_blocked = 0;	/* block all autocmds */
  
  /*
   * Show the autocommands for one AutoPat.
***************
*** 8454,8460 ****
       * Quickly return if there are no autocommands for this event or
       * autocommands are blocked.
       */
!     if (first_autopat[(int)event] == NULL || autocmd_block > 0)
  	goto BYPASS_AU;
  
      /*
--- 8477,8483 ----
       * Quickly return if there are no autocommands for this event or
       * autocommands are blocked.
       */
!     if (first_autopat[(int)event] == NULL || autocmd_blocked > 0)
  	goto BYPASS_AU;
  
      /*
***************
*** 8766,8771 ****
--- 8789,8828 ----
  	aubuflocal_remove(buf);
  
      return retval;
+ }
+ 
+ # ifdef FEAT_EVAL
+ static char_u	*old_termresponse = NULL;
+ # endif
+ 
+ /*
+  * Block triggering autocommands until unblock_autocmd() is called.
+  * Can be used recursively, so long as it's symmetric.
+  */
+     void
+ block_autocmds()
+ {
+ # ifdef FEAT_EVAL
+     /* Remember the value of v:termresponse. */
+     if (autocmd_blocked == 0)
+ 	old_termresponse = get_vim_var_str(VV_TERMRESPONSE);
+ # endif
+     ++autocmd_blocked;
+ }
+ 
+     void
+ unblock_autocmds()
+ {
+     --autocmd_blocked;
+ 
+ # ifdef FEAT_EVAL
+     /* When v:termresponse was set while autocommands were blocked, trigger
+      * the autocommands now.  Esp. useful when executing a shell command
+      * during startup (vimdiff). */
+     if (autocmd_blocked == 0
+ 		      && get_vim_var_str(VV_TERMRESPONSE) != old_termresponse)
+ 	apply_autocmds(EVENT_TERMRESPONSE, NULL, NULL, FALSE, curbuf);
+ # endif
  }
  
  /*
*** ../vim-7.1.124/src/globals.h	Tue Sep 25 17:54:41 2007
--- src/globals.h	Tue Sep 25 22:03:39 2007
***************
*** 366,372 ****
  EXTERN int	autocmd_busy INIT(= FALSE);	/* Is apply_autocmds() busy? */
  EXTERN int	autocmd_no_enter INIT(= FALSE); /* *Enter autocmds disabled */
  EXTERN int	autocmd_no_leave INIT(= FALSE); /* *Leave autocmds disabled */
- EXTERN int	autocmd_block INIT(= 0);	/* block all autocmds */
  EXTERN int	modified_was_set;		/* did ":set modified" */
  EXTERN int	did_filetype INIT(= FALSE);	/* FileType event found */
  EXTERN int	keep_filetype INIT(= FALSE);	/* value for did_filetype when
--- 366,371 ----
*** ../vim-7.1.124/src/misc2.c	Thu May 10 19:58:47 2007
--- src/misc2.c	Tue Sep 25 22:04:39 2007
***************
*** 972,978 ****
  	return;
      entered = TRUE;
  
!     ++autocmd_block;	    /* don't want to trigger autocommands here */
  
  #ifdef FEAT_WINDOWS
      /* close all tabs and windows */
--- 973,979 ----
  	return;
      entered = TRUE;
  
!     block_autocmds();	    /* don't want to trigger autocommands here */
  
  #ifdef FEAT_WINDOWS
      /* close all tabs and windows */
*** ../vim-7.1.124/src/proto/fileio.pro	Thu Jun 28 21:57:08 2007
--- src/proto/fileio.pro	Wed Sep 26 20:05:02 2007
***************
*** 40,45 ****
--- 41,48 ----
  int trigger_cursorhold __ARGS((void));
  int has_cursormoved __ARGS((void));
  int has_cursormovedI __ARGS((void));
+ void block_autocmds __ARGS((void));
+ void unblock_autocmds __ARGS((void));
  int has_autocmd __ARGS((event_T event, char_u *sfname, buf_T *buf));
  char_u *get_augroup_name __ARGS((expand_T *xp, int idx));
  char_u *set_context_in_autocmd __ARGS((expand_T *xp, char_u *arg, int doautocmd));
*** ../vim-7.1.124/src/window.c	Tue Sep 25 14:50:19 2007
--- src/window.c	Tue Sep 25 22:05:45 2007
***************
*** 1291,1297 ****
       * Don't execute autocommands while creating the windows.  Must do that
       * when putting the buffers in the windows.
       */
!     ++autocmd_block;
  #endif
  
      /* todo is number of windows left to create */
--- 1291,1297 ----
       * Don't execute autocommands while creating the windows.  Must do that
       * when putting the buffers in the windows.
       */
!     block_autocmds();
  #endif
  
      /* todo is number of windows left to create */
***************
*** 1313,1319 ****
  	}
  
  #ifdef FEAT_AUTOCMD
!     --autocmd_block;
  #endif
  
      /* return actual number of windows */
--- 1313,1319 ----
  	}
  
  #ifdef FEAT_AUTOCMD
!     unblock_autocmds();
  #endif
  
      /* return actual number of windows */
***************
*** 3415,3421 ****
       * Don't execute autocommands while creating the tab pages.  Must do that
       * when putting the buffers in the windows.
       */
!     ++autocmd_block;
  #endif
  
      for (todo = count - 1; todo > 0; --todo)
--- 3415,3421 ----
       * Don't execute autocommands while creating the tab pages.  Must do that
       * when putting the buffers in the windows.
       */
!     block_autocmds();
  #endif
  
      for (todo = count - 1; todo > 0; --todo)
***************
*** 3423,3429 ****
  	    break;
  
  #ifdef FEAT_AUTOCMD
!     --autocmd_block;
  #endif
  
      /* return actual number of tab pages */
--- 3423,3429 ----
  	    break;
  
  #ifdef FEAT_AUTOCMD
!     unblock_autocmds();
  #endif
  
      /* return actual number of tab pages */
***************
*** 4162,4168 ****
  	/* Don't execute autocommands while the window is not properly
  	 * initialized yet.  gui_create_scrollbar() may trigger a FocusGained
  	 * event. */
! 	++autocmd_block;
  #endif
  	/*
  	 * link the window in the window list
--- 4162,4168 ----
  	/* Don't execute autocommands while the window is not properly
  	 * initialized yet.  gui_create_scrollbar() may trigger a FocusGained
  	 * event. */
! 	block_autocmds();
  #endif
  	/*
  	 * link the window in the window list
***************
*** 4207,4213 ****
  	foldInitWin(newwin);
  #endif
  #ifdef FEAT_AUTOCMD
! 	--autocmd_block;
  #endif
  #ifdef FEAT_SEARCH_EXTRA
  	newwin->w_match_head = NULL;
--- 4207,4213 ----
  	foldInitWin(newwin);
  #endif
  #ifdef FEAT_AUTOCMD
! 	unblock_autocmds();
  #endif
  #ifdef FEAT_SEARCH_EXTRA
  	newwin->w_match_head = NULL;
***************
*** 4232,4238 ****
  #ifdef FEAT_AUTOCMD
      /* Don't execute autocommands while the window is halfway being deleted.
       * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */
!     ++autocmd_block;
  #endif
  
  #ifdef FEAT_MZSCHEME
--- 4232,4238 ----
  #ifdef FEAT_AUTOCMD
      /* Don't execute autocommands while the window is halfway being deleted.
       * gui_mch_destroy_scrollbar() may trigger a FocusGained event. */
!     block_autocmds();
  #endif
  
  #ifdef FEAT_MZSCHEME
***************
*** 4295,4301 ****
      vim_free(wp);
  
  #ifdef FEAT_AUTOCMD
!     --autocmd_block;
  #endif
  }
  
--- 4295,4301 ----
      vim_free(wp);
  
  #ifdef FEAT_AUTOCMD
!     unblock_autocmds();
  #endif
  }
  
*** ../vim-7.1.124/src/version.c	Sat Sep 29 13:15:29 2007
--- src/version.c	Sat Sep 29 14:08:31 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     125,
  /**/

-- 
MICHAEL PALIN PLAYED: 1ST SOLDIER WITH A KEEN INTEREST IN BIRDS, DENNIS, MR
                      DUCK (A VILLAGE CARPENTER WHO IS ALMOST KEENER THAN
                      ANYONE ELSE TO BURN WITCHES), THREE-HEADED KNIGHT, SIR
                      GALAHAD, KING OF SWAMP CASTLE, BROTHER MAYNARD'S ROOMATE
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.126
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.126
Problem:    ":vimgrep */*" fails when a BufRead autocommand changes directory.
	    (Bernhard Kuhn)
Solution:   Change back to the original directory after loading a file.
	    Also: use shorten_fname1() to avoid duplicating code.
Files:	    src/buffer.c, src/ex_docmd.c, src/fileio.c, src/gui_gtk.c,
	    src/gui_w48.c, src/proto/ex_docmd.pro, src/proto/fileio.pro,
	    src/quickfix.c


*** ../vim-7.1.125/src/buffer.c	Sat Sep 29 14:15:00 2007
--- src/buffer.c	Wed Sep 26 20:05:38 2007
***************
*** 4261,4272 ****
  do_arg_all(count, forceit, keep_tabs)
      int	count;
      int	forceit;		/* hide buffers in current windows */
!     int keep_tabs;		/* keep curren tabs, for ":tab drop file" */
  {
      int		i;
      win_T	*wp, *wpnext;
      char_u	*opened;	/* array of flags for which args are open */
!     int		opened_len;	/* lenght of opened[] */
      int		use_firstwin = FALSE;	/* use first window for arglist */
      int		split_ret = OK;
      int		p_ea_save;
--- 4261,4272 ----
  do_arg_all(count, forceit, keep_tabs)
      int	count;
      int	forceit;		/* hide buffers in current windows */
!     int keep_tabs;		/* keep current tabs, for ":tab drop file" */
  {
      int		i;
      win_T	*wp, *wpnext;
      char_u	*opened;	/* array of flags for which args are open */
!     int		opened_len;	/* length of opened[] */
      int		use_firstwin = FALSE;	/* use first window for arglist */
      int		split_ret = OK;
      int		p_ea_save;
***************
*** 4946,4955 ****
  	/* Expand "~/" in the file name at "line + 1" to a full path.
  	 * Then try shortening it by comparing with the current directory */
  	expand_env(xline, NameBuff, MAXPATHL);
! 	mch_dirname(IObuff, IOSIZE);
! 	sfname = shorten_fname(NameBuff, IObuff);
! 	if (sfname == NULL)
! 	    sfname = NameBuff;
  
  	buf = buflist_new(NameBuff, sfname, (linenr_T)0, BLN_LISTED);
  	if (buf != NULL)	/* just in case... */
--- 4946,4952 ----
  	/* Expand "~/" in the file name at "line + 1" to a full path.
  	 * Then try shortening it by comparing with the current directory */
  	expand_env(xline, NameBuff, MAXPATHL);
! 	sfname = shorten_fname1(NameBuff);
  
  	buf = buflist_new(NameBuff, sfname, (linenr_T)0, BLN_LISTED);
  	if (buf != NULL)	/* just in case... */
*** ../vim-7.1.125/src/ex_docmd.c	Wed Sep 26 22:35:06 2007
--- src/ex_docmd.c	Wed Sep 26 20:29:36 2007
***************
*** 276,282 ****
  static void	ex_swapname __ARGS((exarg_T *eap));
  static void	ex_syncbind __ARGS((exarg_T *eap));
  static void	ex_read __ARGS((exarg_T *eap));
- static void	ex_cd __ARGS((exarg_T *eap));
  static void	ex_pwd __ARGS((exarg_T *eap));
  static void	ex_equal __ARGS((exarg_T *eap));
  static void	ex_sleep __ARGS((exarg_T *eap));
--- 276,281 ----
***************
*** 7778,7784 ****
  /*
   * ":cd", ":lcd", ":chdir" and ":lchdir".
   */
!     static void
  ex_cd(eap)
      exarg_T	*eap;
  {
--- 7777,7783 ----
  /*
   * ":cd", ":lcd", ":chdir" and ":lchdir".
   */
!     void
  ex_cd(eap)
      exarg_T	*eap;
  {
*** ../vim-7.1.125/src/fileio.c	Sat Sep 29 14:15:00 2007
--- src/fileio.c	Wed Sep 26 20:02:54 2007
***************
*** 114,120 ****
  {
      int		bw_fd;		/* file descriptor */
      char_u	*bw_buf;	/* buffer with data to be written */
!     int		bw_len;	/* lenght of data */
  #ifdef HAS_BW_FLAGS
      int		bw_flags;	/* FIO_ flags */
  #endif
--- 114,120 ----
  {
      int		bw_fd;		/* file descriptor */
      char_u	*bw_buf;	/* buffer with data to be written */
!     int		bw_len;		/* length of data */
  #ifdef HAS_BW_FLAGS
      int		bw_flags;	/* FIO_ flags */
  #endif
***************
*** 5552,5557 ****
--- 5553,5579 ----
      return (int)(p - buf);
  }
  #endif
+ 
+ /*
+  * Try to find a shortname by comparing the fullname with the current
+  * directory.
+  * Returns "full_path" or pointer into "full_path" if shortened.
+  */
+     char_u *
+ shorten_fname1(full_path)
+     char_u	*full_path;
+ {
+     char_u	dirname[MAXPATHL];
+     char_u	*p = full_path;
+ 
+     if (mch_dirname(dirname, MAXPATHL) == OK)
+     {
+ 	p = shorten_fname(full_path, dirname);
+ 	if (p == NULL || *p == NUL)
+ 	    p = full_path;
+     }
+     return p;
+ }
  
  /*
   * Try to find a shortname by comparing the fullname with the current
*** ../vim-7.1.125/src/gui_gtk.c	Tue Aug 14 14:59:41 2007
--- src/gui_gtk.c	Wed Sep 26 20:07:58 2007
***************
*** 1272,1278 ****
      GtkWidget		*fc;
  #endif
      char_u		dirbuf[MAXPATHL];
-     char_u		*p;
  
  # ifdef HAVE_GTK2
      title = CONVERT_TO_UTF8(title);
--- 1272,1277 ----
***************
*** 1363,1373 ****
  	return NULL;
  
      /* shorten the file name if possible */
!     mch_dirname(dirbuf, MAXPATHL);
!     p = shorten_fname(gui.browse_fname, dirbuf);
!     if (p == NULL)
! 	p = gui.browse_fname;
!     return vim_strsave(p);
  }
  
  #if defined(HAVE_GTK2) || defined(PROTO)
--- 1362,1368 ----
  	return NULL;
  
      /* shorten the file name if possible */
!     return vim_strsave(shorten_fname1(gui.browse_fname));
  }
  
  #if defined(HAVE_GTK2) || defined(PROTO)
***************
*** 1427,1437 ****
  	return NULL;
  
      /* shorten the file name if possible */
!     mch_dirname(dirbuf, MAXPATHL);
!     p = shorten_fname(dirname, dirbuf);
!     if (p == NULL || *p == NUL)
! 	p = dirname;
!     p = vim_strsave(p);
      g_free(dirname);
      return p;
  
--- 1422,1428 ----
  	return NULL;
  
      /* shorten the file name if possible */
!     p = vim_strsave(shorten_fname1(dirname));
      g_free(dirname);
      return p;
  
*** ../vim-7.1.125/src/gui_w48.c	Thu May 10 19:17:07 2007
--- src/gui_w48.c	Wed Sep 26 20:09:33 2007
***************
*** 3301,3311 ****
      SetFocus(s_hwnd);
  
      /* Shorten the file name if possible */
!     mch_dirname(IObuff, IOSIZE);
!     p = shorten_fname((char_u *)fileBuf, IObuff);
!     if (p == NULL)
! 	p = (char_u *)fileBuf;
!     return vim_strsave(p);
  }
  # endif /* FEAT_MBYTE */
  
--- 3301,3307 ----
      SetFocus(s_hwnd);
  
      /* Shorten the file name if possible */
!     return vim_strsave(shorten_fname1((char_u *)fileBuf));
  }
  # endif /* FEAT_MBYTE */
  
***************
*** 3450,3460 ****
      SetFocus(s_hwnd);
  
      /* Shorten the file name if possible */
!     mch_dirname(IObuff, IOSIZE);
!     p = shorten_fname((char_u *)fileBuf, IObuff);
!     if (p == NULL)
! 	p = (char_u *)fileBuf;
!     return vim_strsave(p);
  }
  #endif /* FEAT_BROWSE */
  
--- 3446,3452 ----
      SetFocus(s_hwnd);
  
      /* Shorten the file name if possible */
!     return vim_strsave(shorten_fname1((char_u *)fileBuf));
  }
  #endif /* FEAT_BROWSE */
  
*** ../vim-7.1.125/src/proto/ex_docmd.pro	Sun May  6 14:46:22 2007
--- src/proto/ex_docmd.pro	Wed Sep 26 20:30:10 2007
***************
*** 39,44 ****
--- 39,45 ----
  void tabpage_new __ARGS((void));
  void do_exedit __ARGS((exarg_T *eap, win_T *old_curwin));
  void free_cd_dir __ARGS((void));
+ void ex_cd __ARGS((exarg_T *eap));
  void do_sleep __ARGS((long msec));
  int vim_mkdir_emsg __ARGS((char_u *name, int prot));
  FILE *open_exfile __ARGS((char_u *fname, int forceit, char *mode));
*** ../vim-7.1.125/src/proto/fileio.pro	Sat Sep 29 14:15:00 2007
--- src/proto/fileio.pro	Wed Sep 26 20:05:02 2007
***************
*** 6,11 ****
--- 6,12 ----
  int buf_write __ARGS((buf_T *buf, char_u *fname, char_u *sfname, linenr_T start, linenr_T end, exarg_T *eap, int append, int forceit, int reset_changed, int filtering));
  void msg_add_fname __ARGS((buf_T *buf, char_u *fname));
  void msg_add_lines __ARGS((int insert_space, long lnum, long nchars));
+ char_u *shorten_fname1 __ARGS((char_u *full_path));
  char_u *shorten_fname __ARGS((char_u *full_path, char_u *dir_name));
  void shorten_fnames __ARGS((int force));
  void shorten_filenames __ARGS((char_u **fnames, int count));
*** ../vim-7.1.125/src/quickfix.c	Sun Sep 16 13:26:56 2007
--- src/quickfix.c	Sun Sep 30 13:58:38 2007
***************
*** 2972,2977 ****
--- 2972,2978 ----
      regmmatch_T	regmatch;
      int		fcount;
      char_u	**fnames;
+     char_u	*fname;
      char_u	*s;
      char_u	*p;
      int		fi;
***************
*** 2995,3000 ****
--- 2996,3004 ----
      int		flags = 0;
      colnr_T	col;
      long	tomatch;
+     char_u	dirname_start[MAXPATHL];
+     char_u	dirname_now[MAXPATHL];
+     char_u	*target_dir = NULL;
  
      switch (eap->cmdidx)
      {
***************
*** 3069,3085 ****
  	goto theend;
      }
  
      seconds = (time_t)0;
      for (fi = 0; fi < fcount && !got_int && tomatch > 0; ++fi)
      {
  	if (time(NULL) > seconds)
  	{
! 	    /* Display the file name every second or so. */
  	    seconds = time(NULL);
  	    msg_start();
! 	    p = msg_strtrunc(fnames[fi], TRUE);
  	    if (p == NULL)
! 		msg_outtrans(fnames[fi]);
  	    else
  	    {
  		msg_outtrans(p);
--- 3073,3095 ----
  	goto theend;
      }
  
+     /* Remember the current directory, because a BufRead autocommand that does
+      * ":lcd %:p:h" changes the meaning of short path names. */
+     mch_dirname(dirname_start, MAXPATHL);
+ 
      seconds = (time_t)0;
      for (fi = 0; fi < fcount && !got_int && tomatch > 0; ++fi)
      {
+ 	fname = shorten_fname1(fnames[fi]);
  	if (time(NULL) > seconds)
  	{
! 	    /* Display the file name every second or so, show the user we are
! 	     * working on it. */
  	    seconds = time(NULL);
  	    msg_start();
! 	    p = msg_strtrunc(fname, TRUE);
  	    if (p == NULL)
! 		msg_outtrans(fname);
  	    else
  	    {
  		msg_outtrans(p);
***************
*** 3111,3117 ****
  
  	    /* Load file into a buffer, so that 'fileencoding' is detected,
  	     * autocommands applied, etc. */
! 	    buf = load_dummy_buffer(fnames[fi]);
  
  	    p_mls = save_mls;
  #if defined(FEAT_AUTOCMD) && defined(FEAT_SYN_HL)
--- 3121,3139 ----
  
  	    /* Load file into a buffer, so that 'fileencoding' is detected,
  	     * autocommands applied, etc. */
! 	    buf = load_dummy_buffer(fname);
! 
! 	    /* When autocommands changed directory: go back.  We assume it was
! 	     * ":lcd %:p:h". */
! 	    mch_dirname(dirname_now, MAXPATHL);
! 	    if (STRCMP(dirname_start, dirname_now) != 0)
! 	    {
! 		exarg_T ea;
! 
! 		ea.arg = dirname_start;
! 		ea.cmdidx = CMD_lcd;
! 		ex_cd(&ea);
! 	    }
  
  	    p_mls = save_mls;
  #if defined(FEAT_AUTOCMD) && defined(FEAT_SYN_HL)
***************
*** 3125,3131 ****
  	if (buf == NULL)
  	{
  	    if (!got_int)
! 		smsg((char_u *)_("Cannot open file \"%s\""), fnames[fi]);
  	}
  	else
  	{
--- 3147,3153 ----
  	if (buf == NULL)
  	{
  	    if (!got_int)
! 		smsg((char_u *)_("Cannot open file \"%s\""), fname);
  	}
  	else
  	{
***************
*** 3139,3147 ****
  		while (vim_regexec_multi(&regmatch, curwin, buf, lnum,
  								     col) > 0)
  		{
  		    if (qf_add_entry(qi, &prevp,
  				NULL,       /* dir */
! 				fnames[fi],
  				0,
  				ml_get_buf(buf,
  				     regmatch.startpos[0].lnum + lnum, FALSE),
--- 3161,3170 ----
  		while (vim_regexec_multi(&regmatch, curwin, buf, lnum,
  								     col) > 0)
  		{
+ 		    ;
  		    if (qf_add_entry(qi, &prevp,
  				NULL,       /* dir */
! 				fname,
  				0,
  				ml_get_buf(buf,
  				     regmatch.startpos[0].lnum + lnum, FALSE),
***************
*** 3209,3214 ****
--- 3232,3244 ----
  
  		if (buf != NULL)
  		{
+ 		    /* If the buffer is still loaded we need to use the
+ 		     * directory we jumped to below. */
+ 		    if (buf == first_match_buf
+ 			    && target_dir == NULL
+ 			    && STRCMP(dirname_start, dirname_now) != 0)
+ 			target_dir = vim_strsave(dirname_now);
+ 
  		    /* The buffer is still loaded, the Filetype autocommands
  		     * need to be done now, in that buffer.  And the modelines
  		     * need to be done (again).  But not the window-local
***************
*** 3252,3257 ****
--- 3282,3297 ----
  		/* If we jumped to another buffer redrawing will already be
  		 * taken care of. */
  		redraw_for_dummy = FALSE;
+ 
+ 	    /* Jump to the directory used after loading the buffer. */
+ 	    if (curbuf == first_match_buf && target_dir != NULL)
+ 	    {
+ 		exarg_T ea;
+ 
+ 		ea.arg = target_dir;
+ 		ea.cmdidx = CMD_lcd;
+ 		ex_cd(&ea);
+ 	    }
  	}
      }
      else
***************
*** 3269,3274 ****
--- 3309,3315 ----
      }
  
  theend:
+     vim_free(target_dir);
      vim_free(regmatch.regprog);
  }
  
*** ../vim-7.1.125/src/version.c	Sat Sep 29 14:15:00 2007
--- src/version.c	Sun Sep 30 13:41:30 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     126,
  /**/

-- 
The MS-Windows registry is no more hostile than any other bunch of state
information... that is held in a binary format... a format that nobody
understands... and is replicated and cached in a complex and largely
undocumented way... and contains large amounts of duplicate and obfuscated
information...  (Ben Peterson)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: About patch 7.1.127
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.127
Problem:    Memory leak when doing cmdline completion. (Dominique Pelle)
Solution:   Free "orig" argument of ExpandOne() when it's not used.
Files:	    src/ex_getln.c


*** ../vim-7.1.126/src/ex_getln.c	Sat Sep 29 14:15:00 2007
--- src/ex_getln.c	Sun Sep 30 17:55:47 2007
***************
*** 3316,3321 ****
--- 3316,3325 ----
   * Return a pointer to alloced memory containing the new string.
   * Return NULL for failure.
   *
+  * "orig" is the originally expanded string, copied to allocated memory.  It
+  * should either be kept in orig_save or freed.  When "mode" is WILD_NEXT or
+  * WILD_PREV "orig" should be NULL.
+  *
   * Results are cached in xp->xp_files and xp->xp_numfiles, except when "mode"
   * is WILD_EXPAND_FREE or WILD_ALL.
   *
***************
*** 3400,3406 ****
  	    return NULL;
      }
  
! /* free old names */
      if (xp->xp_numfiles != -1 && mode != WILD_ALL && mode != WILD_LONGEST)
      {
  	FreeWild(xp->xp_numfiles, xp->xp_files);
--- 3404,3410 ----
  	    return NULL;
      }
  
!     /* free old names */
      if (xp->xp_numfiles != -1 && mode != WILD_ALL && mode != WILD_LONGEST)
      {
  	FreeWild(xp->xp_numfiles, xp->xp_files);
***************
*** 3540,3545 ****
--- 3544,3553 ----
  
      if (mode == WILD_EXPAND_FREE || mode == WILD_ALL)
  	ExpandCleanup(xp);
+ 
+     /* Free "orig" if it wasn't stored in "orig_save". */
+     if (orig != orig_save)
+ 	vim_free(orig);
  
      return ss;
  }
*** ../vim-7.1.126/src/version.c	Sun Sep 30 14:00:41 2007
--- src/version.c	Sun Sep 30 14:20:14 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     127,
  /**/

-- 
A M00se once bit my sister ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: About patch 7.1.128 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.128 (extra)
Problem:    Build problems with new version of Cygwin.
Solution:   Remove -D__IID_DEFINED__, like with MingW. (Guopeng Wen)
Files:	    src/Make_cyg.mak


*** ../vim-7.1.127/src/Make_cyg.mak	Sun Apr 30 20:46:49 2006
--- src/Make_cyg.mak	Sat Sep 29 13:09:34 2007
***************
*** 1,6 ****
  #
  # Makefile for VIM on Win32, using Cygnus gcc
! # Last updated by Dan Sharp.  Last Change: 2006 Apr 30
  #
  # Also read INSTALLpc.txt!
  #
--- 1,6 ----
  #
  # Makefile for VIM on Win32, using Cygnus gcc
! # Last updated by Dan Sharp.  Last Change: 2007 Sep 29
  #
  # Also read INSTALLpc.txt!
  #
***************
*** 503,509 ****
  	$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o
  
  $(OUTDIR)/if_ole.o:	if_ole.cpp $(INCL)
! 	$(CC) -c $(CFLAGS) -D__IID_DEFINED__ if_ole.cpp -o $(OUTDIR)/if_ole.o
  
  if_perl.c: if_perl.xs typemap
  	$(PERL)/bin/perl `cygpath -d $(PERL)/lib/ExtUtils/xsubpp` \
--- 503,509 ----
  	$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o
  
  $(OUTDIR)/if_ole.o:	if_ole.cpp $(INCL)
! 	$(CC) -c $(CFLAGS) if_ole.cpp -o $(OUTDIR)/if_ole.o
  
  if_perl.c: if_perl.xs typemap
  	$(PERL)/bin/perl `cygpath -d $(PERL)/lib/ExtUtils/xsubpp` \
*** ../vim-7.1.127/src/version.c	Sun Sep 30 22:10:45 2007
--- src/version.c	Sun Sep 30 22:27:51 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     128,
  /**/

-- 
Mynd you, m00se bites Kan be pretty nasti ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: About patch 7.1.129 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.129 (extra)
Problem:    Win32: Can't get the user name when it is longer than 15
	    characters.
Solution:   Use UNLEN instead of MAX_COMPUTERNAME_LENGTH. (Alexei Alexandrov)
Files:	    src/os_win32.c


*** ../vim-7.1.128/src/os_win32.c	Thu May 10 19:22:59 2007
--- src/os_win32.c	Mon Oct  1 20:07:24 2007
***************
*** 2378,2384 ****
      char_u  *s,
      int	    len)
  {
!     char szUserName[MAX_COMPUTERNAME_LENGTH + 1];
      DWORD cch = sizeof szUserName;
  
      if (GetUserName(szUserName, &cch))
--- 2378,2384 ----
      char_u  *s,
      int	    len)
  {
!     char szUserName[256 + 1];	/* UNLEN is 256 */
      DWORD cch = sizeof szUserName;
  
      if (GetUserName(szUserName, &cch))
*** ../vim-7.1.128/src/version.c	Sun Sep 30 22:28:08 2007
--- src/version.c	Mon Oct  1 20:32:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     129,
  /**/

-- 
ARTHUR: It is I, Arthur, son of Uther Pendragon, from the castle of Camelot.
        King of all Britons, defeator of the Saxons, sovereign of all England!
   [Pause]
SOLDIER: Get away!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: About patch 7.1.130
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.130
Problem:    Crash with specific order of undo and redo. (A.Politz)
Solution:   Clear and adjust pointers properly.  Add u_check() for debugging.
Files:	    src/undo.c, src/structs.h


*** ../vim-7.1.129/src/undo.c	Thu May 10 20:01:43 2007
--- src/undo.c	Mon Oct  1 22:49:16 2007
***************
*** 76,81 ****
--- 76,87 ----
   * buffer is unloaded.
   */
  
+ /* Uncomment the next line for including the u_check() function.  This warns
+  * for errors in the debug information. */
+ /* #define U_DEBUG 1 */
+ #define UH_MAGIC 0x18dade	/* value for uh_magic when in use */
+ #define UE_MAGIC 0xabc123	/* value for ue_magic when in use */
+ 
  #include "vim.h"
  
  /* See below: use malloc()/free() for memory management. */
***************
*** 113,118 ****
--- 119,213 ----
   */
  static int	undo_undoes = FALSE;
  
+ #ifdef U_DEBUG
+ /*
+  * Check the undo structures for being valid.  Print a warning when something
+  * looks wrong.
+  */
+ static int seen_b_u_curhead;
+ static int seen_b_u_newhead;
+ static int header_count;
+ 
+     static void
+ u_check_tree(u_header_T *uhp,
+ 	u_header_T *exp_uh_next,
+ 	u_header_T *exp_uh_alt_prev)
+ {
+     u_entry_T *uep;
+ 
+     if (uhp == NULL)
+ 	return;
+     ++header_count;
+     if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1)
+     {
+ 	EMSG("b_u_curhead found twice (looping?)");
+ 	return;
+     }
+     if (uhp == curbuf->b_u_newhead && ++seen_b_u_newhead > 1)
+     {
+ 	EMSG("b_u_newhead found twice (looping?)");
+ 	return;
+     }
+ 
+     if (uhp->uh_magic != UH_MAGIC)
+ 	EMSG("uh_magic wrong (may be using freed memory)");
+     else
+     {
+ 	/* Check pointers back are correct. */
+ 	if (uhp->uh_next != exp_uh_next)
+ 	{
+ 	    EMSG("uh_next wrong");
+ 	    smsg((char_u *)"expected: 0x%x, actual: 0x%x",
+ 						   exp_uh_next, uhp->uh_next);
+ 	}
+ 	if (uhp->uh_alt_prev != exp_uh_alt_prev)
+ 	{
+ 	    EMSG("uh_alt_prev wrong");
+ 	    smsg((char_u *)"expected: 0x%x, actual: 0x%x",
+ 					   exp_uh_alt_prev, uhp->uh_alt_prev);
+ 	}
+ 
+ 	/* Check the undo tree at this header. */
+ 	for (uep = uhp->uh_entry; uep != NULL; uep = uep->ue_next)
+ 	{
+ 	    if (uep->ue_magic != UE_MAGIC)
+ 	    {
+ 		EMSG("ue_magic wrong (may be using freed memory)");
+ 		break;
+ 	    }
+ 	}
+ 
+ 	/* Check the next alt tree. */
+ 	u_check_tree(uhp->uh_alt_next, uhp->uh_next, uhp);
+ 
+ 	/* Check the next header in this branch. */
+ 	u_check_tree(uhp->uh_prev, uhp, NULL);
+     }
+ }
+ 
+     void
+ u_check(int newhead_may_be_NULL)
+ {
+     seen_b_u_newhead = 0;
+     seen_b_u_curhead = 0;
+     header_count = 0;
+ 
+     u_check_tree(curbuf->b_u_oldhead, NULL, NULL);
+ 
+     if (seen_b_u_newhead == 0 && curbuf->b_u_oldhead != NULL
+ 	    && !(newhead_may_be_NULL && curbuf->b_u_newhead == NULL))
+ 	EMSGN("b_u_newhead invalid: 0x%x", curbuf->b_u_newhead);
+     if (curbuf->b_u_curhead != NULL && seen_b_u_curhead == 0)
+ 	EMSGN("b_u_curhead invalid: 0x%x", curbuf->b_u_curhead);
+     if (header_count != curbuf->b_u_numhead)
+     {
+ 	EMSG("b_u_numhead invalid");
+ 	smsg((char_u *)"expected: %ld, actual: %ld",
+ 			       (long)header_count, (long)curbuf->b_u_numhead);
+     }
+ }
+ #endif
+ 
  /*
   * Save the current line for both the "u" and "U" command.
   * Returns OK or FAIL.
***************
*** 243,248 ****
--- 338,346 ----
      if (!undo_allowed())
  	return FAIL;
  
+ #ifdef U_DEBUG
+     u_check(FALSE);
+ #endif
  #ifdef FEAT_NETBEANS_INTG
      /*
       * Netbeans defines areas that cannot be modified.  Bail out here when
***************
*** 294,299 ****
--- 392,400 ----
  	    uhp = (u_header_T *)U_ALLOC_LINE((unsigned)sizeof(u_header_T));
  	    if (uhp == NULL)
  		goto nomem;
+ #ifdef U_DEBUG
+ 	    uhp->uh_magic = UH_MAGIC;
+ #endif
  	}
  	else
  	    uhp = NULL;
***************
*** 316,323 ****
  	{
  	    u_header_T	    *uhfree = curbuf->b_u_oldhead;
  
! 	    /* If there is no branch only free one header. */
! 	    if (uhfree->uh_alt_next == NULL)
  		u_freeheader(curbuf, uhfree, &old_curhead);
  	    else
  	    {
--- 417,427 ----
  	{
  	    u_header_T	    *uhfree = curbuf->b_u_oldhead;
  
! 	    if (uhfree == old_curhead)
! 		/* Can't reconnect the branch, delete all of it. */
! 		u_freebranch(curbuf, uhfree, &old_curhead);
! 	    else if (uhfree->uh_alt_next == NULL)
! 		/* There is no branch, only free one header. */
  		u_freeheader(curbuf, uhfree, &old_curhead);
  	    else
  	    {
***************
*** 326,331 ****
--- 430,438 ----
  		    uhfree = uhfree->uh_alt_next;
  		u_freebranch(curbuf, uhfree, &old_curhead);
  	    }
+ #ifdef U_DEBUG
+ 	    u_check(TRUE);
+ #endif
  	}
  
  	if (uhp == NULL)		/* no undo at all */
***************
*** 478,483 ****
--- 585,593 ----
      uep = (u_entry_T *)U_ALLOC_LINE((unsigned)sizeof(u_entry_T));
      if (uep == NULL)
  	goto nomem;
+ #ifdef U_DEBUG
+     uep->ue_magic = UE_MAGIC;
+ #endif
  
      uep->ue_size = size;
      uep->ue_top = top;
***************
*** 525,530 ****
--- 635,643 ----
      curbuf->b_u_synced = FALSE;
      undo_undoes = FALSE;
  
+ #ifdef U_DEBUG
+     u_check(FALSE);
+ #endif
      return OK;
  
  nomem:
***************
*** 955,960 ****
--- 1068,1076 ----
      int		empty_buffer;		    /* buffer became empty */
      u_header_T	*curhead = curbuf->b_u_curhead;
  
+ #ifdef U_DEBUG
+     u_check(FALSE);
+ #endif
      old_flags = curhead->uh_flags;
      new_flags = (curbuf->b_changed ? UH_CHANGED : 0) +
  	       ((curbuf->b_ml.ml_flags & ML_EMPTY) ? UH_EMPTYBUF : 0);
***************
*** 1186,1191 ****
--- 1302,1310 ----
      /* The timestamp can be the same for multiple changes, just use the one of
       * the undone/redone change. */
      curbuf->b_u_seq_time = curhead->uh_time;
+ #ifdef U_DEBUG
+     u_check(FALSE);
+ #endif
  }
  
  /*
***************
*** 1515,1521 ****
  }
  
  /*
!  * Free one header and its entry list and adjust the pointers.
   */
      static void
  u_freeheader(buf, uhp, uhpp)
--- 1634,1640 ----
  }
  
  /*
!  * Free one header "uhp" and its entry list and adjust the pointers.
   */
      static void
  u_freeheader(buf, uhp, uhpp)
***************
*** 1523,1528 ****
--- 1642,1649 ----
      u_header_T	    *uhp;
      u_header_T	    **uhpp;	/* if not NULL reset when freeing this header */
  {
+     u_header_T	    *uhap;
+ 
      /* When there is an alternate redo list free that branch completely,
       * because we can never go there. */
      if (uhp->uh_alt_next != NULL)
***************
*** 1540,1546 ****
      if (uhp->uh_prev == NULL)
  	buf->b_u_newhead = uhp->uh_next;
      else
! 	uhp->uh_prev->uh_next = uhp->uh_next;
  
      u_freeentries(buf, uhp, uhpp);
  }
--- 1661,1668 ----
      if (uhp->uh_prev == NULL)
  	buf->b_u_newhead = uhp->uh_next;
      else
! 	for (uhap = uhp->uh_prev; uhap != NULL; uhap = uhap->uh_alt_next)
! 	    uhap->uh_next = uhp->uh_next;
  
      u_freeentries(buf, uhp, uhpp);
  }
***************
*** 1585,1590 ****
--- 1707,1714 ----
      /* Check for pointers to the header that become invalid now. */
      if (buf->b_u_curhead == uhp)
  	buf->b_u_curhead = NULL;
+     if (buf->b_u_newhead == uhp)
+ 	buf->b_u_newhead = NULL;  /* freeing the newest entry */
      if (uhpp != NULL && uhp == *uhpp)
  	*uhpp = NULL;
  
***************
*** 1594,1599 ****
--- 1718,1726 ----
  	u_freeentry(uep, uep->ue_size);
      }
  
+ #ifdef U_DEBUG
+     uhp->uh_magic = 0;
+ #endif
      U_FREE_LINE((char_u *)uhp);
      --buf->b_u_numhead;
  }
***************
*** 1609,1614 ****
--- 1736,1744 ----
      while (n > 0)
  	U_FREE_LINE(uep->ue_array[--n]);
      U_FREE_LINE((char_u *)uep->ue_array);
+ #ifdef U_DEBUG
+     uep->ue_magic = 0;
+ #endif
      U_FREE_LINE((char_u *)uep);
  }
  
*** ../vim-7.1.129/src/structs.h	Sun Aug 12 15:50:26 2007
--- src/structs.h	Sat Sep 29 15:03:38 2007
***************
*** 278,283 ****
--- 278,286 ----
      linenr_T	ue_lcount;	/* linecount when u_save called */
      char_u	**ue_array;	/* array of lines in undo block */
      long	ue_size;	/* number of lines in ue_array */
+ #ifdef U_DEBUG
+     int		ue_magic;	/* magic number to check allocation */
+ #endif
  };
  
  struct u_header
***************
*** 300,305 ****
--- 303,311 ----
      visualinfo_T uh_visual;	/* Visual areas before undo/after redo */
  #endif
      time_t	uh_time;	/* timestamp when the change was made */
+ #ifdef U_DEBUG
+     int		uh_magic;	/* magic number to check allocation */
+ #endif
  };
  
  /* values for uh_flags */
*** ../vim-7.1.129/src/version.c	Mon Oct  1 20:33:45 2007
--- src/version.c	Mon Oct  1 22:50:23 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     130,
  /**/

-- 
FIRST SOLDIER:  So they wouldn't be able to bring a coconut back anyway.
SECOND SOLDIER: Wait a minute! Suppose two swallows carried it together?
FIRST SOLDIER:  No, they'd have to have it on a line.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.131
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.131
Problem:    ":mksession" always adds ":setlocal autoread". (Christian J.
	    Robinson)
Solution:   Skip boolean global/local option using global value.
Files:	    src/option.c


*** ../vim-7.1.130/src/option.c	Wed Sep 26 22:35:06 2007
--- src/option.c	Sun Sep 30 16:21:08 2007
***************
*** 8753,8758 ****
--- 8753,8760 ----
      char	*name;
      int		value;
  {
+     if (value < 0)	/* global/local option using global value */
+ 	return OK;
      if (fprintf(fd, "%s %s%s", cmd, value ? "" : "no", name) < 0
  	    || put_eol(fd) < 0)
  	return FAIL;
*** ../vim-7.1.130/src/version.c	Mon Oct  1 22:53:27 2007
--- src/version.c	Tue Oct  2 20:39:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     131,
  /**/

-- 
ARTHUR: Old woman!
DENNIS: Man!
ARTHUR: Man.  I'm sorry.  Old man, What knight live in that castle over there?
DENNIS: I'm thirty-seven.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.132
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.132
Problem:    getpos("'>") may return a negative column number for a Linewise
	    selection. (A.Politz)
Solution:   Don't add one to MAXCOL.
Files:	    src/eval.c


*** ../vim-7.1.131/src/eval.c	Tue Sep 25 20:39:14 2007
--- src/eval.c	Mon Oct  1 20:56:09 2007
***************
*** 10388,10394 ****
  	    list_append_number(l, (varnumber_T)0);
  	list_append_number(l, (fp != NULL) ? (varnumber_T)fp->lnum
  							    : (varnumber_T)0);
! 	list_append_number(l, (fp != NULL) ? (varnumber_T)fp->col + 1
  							    : (varnumber_T)0);
  	list_append_number(l,
  #ifdef FEAT_VIRTUALEDIT
--- 10388,10395 ----
  	    list_append_number(l, (varnumber_T)0);
  	list_append_number(l, (fp != NULL) ? (varnumber_T)fp->lnum
  							    : (varnumber_T)0);
! 	list_append_number(l, (fp != NULL)
! 		     ? (varnumber_T)(fp->col == MAXCOL ? MAXCOL : fp->col + 1)
  							    : (varnumber_T)0);
  	list_append_number(l,
  #ifdef FEAT_VIRTUALEDIT
*** ../vim-7.1.131/src/version.c	Tue Oct  2 20:40:01 2007
--- src/version.c	Tue Oct  2 22:07:17 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     132,
  /**/

-- 
"The future's already arrived - it's just not evenly distributed yet."
		-- William Gibson

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.133
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.133 (after 7.1.126)
Problem:    shorten_fname1() linked when it's not needed.
Solution:   Add #ifdef.
Files:	    src/fileio.c


*** ../vim-7.1.132/src/fileio.c	Sun Sep 30 14:00:41 2007
--- src/fileio.c	Sun Sep 30 16:32:43 2007
***************
*** 5553,5558 ****
--- 5554,5561 ----
  }
  #endif
  
+ #if defined(FEAT_VIMINFO) || defined(FEAT_BROWSE) || \
+     defined(FEAT_QUICKFIX) || defined(PROTO)
  /*
   * Try to find a shortname by comparing the fullname with the current
   * directory.
***************
*** 5573,5578 ****
--- 5576,5582 ----
      }
      return p;
  }
+ #endif
  
  /*
   * Try to find a shortname by comparing the fullname with the current
*** ../vim-7.1.132/src/version.c	Tue Oct  2 22:07:58 2007
--- src/version.c	Wed Oct  3 12:46:59 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     133,
  /**/

-- 
"Beware of bugs in the above code; I have only proved
it correct, not tried it." -- Donald Knuth

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.134 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.134 (extra)
Problem:    Win32: Can't build with VC8
Solution:   Detect the MSVC version instead of using NMAKE_VER.
            (Mike Williams)
Files:      src/Make_mvc.mak


*** ../vim-7.1.133/src/Make_mvc.mak	Tue Feb 20 03:15:08 2007
--- src/Make_mvc.mak	Mon Oct  1 21:37:20 2007
***************
*** 92,97 ****
--- 92,99 ----
  #       Netbeans Debugging Support: NBDEBUG=[yes or no] (should be no, yes
  #       doesn't work)
  #
+ #       Visual C Version: MSVCVER=m.n (default derived from nmake if undefined)
+ #
  # You can combine any of these interfaces
  #
  # Example: To build the non-debug, GUI version with Perl interface:
***************
*** 101,107 ****
  #	This makefile gives a fineness of control which is not supported in
  #	Visual C++ configuration files.  Therefore, debugging requires a bit of
  #	extra work.
! #	Make_dvc.mak is a Visual C++ project to access that support.
  #	To use Make_dvc.mak:
  #	1) Build Vim with Make_mvc.mak.
  #	     Use a "DEBUG=yes" argument to build Vim with debug support.
--- 103,110 ----
  #	This makefile gives a fineness of control which is not supported in
  #	Visual C++ configuration files.  Therefore, debugging requires a bit of
  #	extra work.
! #	Make_dvc.mak is a Visual C++ project to access that support.  It may be
! #	badly out of date for the Visual C++ you are using...
  #	To use Make_dvc.mak:
  #	1) Build Vim with Make_mvc.mak.
  #	     Use a "DEBUG=yes" argument to build Vim with debug support.
***************
*** 198,211 ****
  !if "$(DEBUG)" != "yes"
  NODEBUG = 1
  !else
  MAKEFLAGS_GVIMEXT = DEBUG=yes
  !endif
  
  
! # Get all sorts of useful, standard macros from the SDK.  (Note that
! # MSVC 2.2 does not install <ntwin32.mak> in the \msvc20\include
! # directory, but you can find it in \msvc20\include on the CD-ROM.
! # You may also need <win32.mak> from the same place.)
  
  !include <Win32.mak>
  
--- 201,212 ----
  !if "$(DEBUG)" != "yes"
  NODEBUG = 1
  !else
+ !undef NODEBUG
  MAKEFLAGS_GVIMEXT = DEBUG=yes
  !endif
  
  
! # Get all sorts of useful, standard macros from the Platform SDK.
  
  !include <Win32.mak>
  
***************
*** 272,283 ****
  
  # Set which version of the CRT to use
  !if defined(USE_MSVCRT)
! CVARS = $(cvarsdll)
  # !elseif defined(MULTITHREADED)
  # CVARS = $(cvarsmt)
  !else
  # CVARS = $(cvars)
! CVARS = $(cvarsmt)
  !endif
  
  # need advapi32.lib for GetUserName()
--- 273,284 ----
  
  # Set which version of the CRT to use
  !if defined(USE_MSVCRT)
! # CVARS = $(cvarsdll)
  # !elseif defined(MULTITHREADED)
  # CVARS = $(cvarsmt)
  !else
  # CVARS = $(cvars)
! # CVARS = $(cvarsmt)
  !endif
  
  # need advapi32.lib for GetUserName()
***************
*** 320,326 ****
--- 321,364 ----
  INTDIR=$(OBJDIR)
  OUTDIR=$(OBJDIR)
  
+ # Derive version of VC being used from nmake if not specified
+ !if "$(MSVCVER)" == ""
+ !if "$(_NMAKE_VER)" == ""
+ MSVCVER = 4.0
+ !endif
+ !if "$(_NMAKE_VER)" == "162"
+ MSVCVER = 5.0
+ !endif
+ !if "$(_NMAKE_VER)" == "6.00.8168.0"
+ MSVCVER = 6.0
+ !endif
+ !if "$(_NMAKE_VER)" == "7.00.9466"
+ MSVCVER = 7.0
+ !endif
+ !if "$(_NMAKE_VER)" == "7.10.3077"
+ MSVCVER = 7.1
+ !endif
+ !if "$(_NMAKE_VER)" == "8.00.50727.42"
+ MSVCVER = 8.0
+ !endif
+ !if "$(_NMAKE_VER)" == "8.00.50727.762"
+ MSVCVER = 8.0
+ !endif
+ !endif
+ 
+ # Abort bulding VIM if version of VC is unrecognised.
+ !ifndef MSVCVER
+ !message *** ERROR
+ !message Cannot determine Visual C version being used.  If you are using the
+ !message Windows SDK then you must have the environment variable MSVCVER set to
+ !message your version of the VC compiler.  If you are not using the Express
+ !message version of Visual C you van either set MSVCVER or update this makefile
+ !message to handle the new value for _NMAKE_VER.
+ !error Make aborted.
+ !endif
+ 
  # Convert processor ID to MVC-compatible number
+ !if "$(MSVCVER)" != "8.0"
  !if "$(CPUNR)" == "i386"
  CPUARG = /G3
  !elseif "$(CPUNR)" == "i486"
***************
*** 334,339 ****
--- 372,386 ----
  !else
  CPUARG =
  !endif
+ !else
+ # VC8 only allows specifying SSE architecture
+ !if "$(CPUNR)" == "pentium4"
+ CPUARG = /arch:SSE2
+ !endif
+ !endif
+ 
+ LIBC =
+ DEBUGINFO = /Zi
  
  !ifdef NODEBUG
  VIM = vim
***************
*** 344,384 ****
  !else # MAXSPEED
  OPTFLAG = /Ox
  !endif
  CFLAGS = $(CFLAGS) $(OPTFLAG) -DNDEBUG $(CPUARG)
  RCFLAGS = $(rcflags) $(rcvars) -DNDEBUG
  ! ifdef USE_MSVCRT
! CFLAGS = $(CFLAGS) -MD
  LIBC = msvcrt.lib
- # CFLAGS = $(CFLAGS) $(cvarsdll)
- # ! elseif defined(MULTITHREADED)
- # LIBC = libcmt.lib
- # CFLAGS = $(CFLAGS) $(cvarsmt)
  ! else
- # LIBC = libc.lib
  LIBC = libcmt.lib
! # CFLAGS = $(CFLAGS) $(cvars)
  ! endif
  !else  # DEBUG
  VIM = vimd
  CFLAGS = $(CFLAGS) -D_DEBUG -DDEBUG /Od
  RCFLAGS = $(rcflags) $(rcvars) -D_DEBUG -DDEBUG
  # The /fixed:no is needed for Quantify. Assume not 4.? as unsupported in VC4.0.
! ! if "$(_NMAKE_VER)" == ""
  LIBC =
  ! else
  LIBC = /fixed:no
  ! endif
  ! ifdef USE_MSVCRT
! CFLAGS = $(CFLAGS) -MDd
  LIBC = $(LIBC) msvcrtd.lib
- # CFLAGS = $(CFLAGS) $(cvarsdll)
- # ! elseif defined(MULTITHREADED)
- # LIBC = $(LIBC) libcmtd.lib
- # CFLAGS = $(CFLAGS) $(cvarsmt)
  ! else
- # LIBC = $(LIBC) libcd.lib
  LIBC = $(LIBC) libcmtd.lib
! # CFLAGS = $(CFLAGS) $(cvars)
  ! endif
  !endif # DEBUG
  
--- 391,430 ----
  !else # MAXSPEED
  OPTFLAG = /Ox
  !endif
+ !if "$(MSVCVER)" == "8.0"
+ # Use link time code generation if not worried about size
+ !if "$(OPTIMIZE)" != "SPACE"
+ OPTFLAG = $(OPTFLAG) /GL
+ !endif
+ !endif
  CFLAGS = $(CFLAGS) $(OPTFLAG) -DNDEBUG $(CPUARG)
  RCFLAGS = $(rcflags) $(rcvars) -DNDEBUG
  ! ifdef USE_MSVCRT
! CFLAGS = $(CFLAGS) /MD
  LIBC = msvcrt.lib
  ! else
  LIBC = libcmt.lib
! CFLAGS = $(CFLAGS) /MT
  ! endif
  !else  # DEBUG
  VIM = vimd
+ ! if "$(CPU)" == "i386"
+ DEBUGINFO = /ZI
+ ! endif
  CFLAGS = $(CFLAGS) -D_DEBUG -DDEBUG /Od
  RCFLAGS = $(rcflags) $(rcvars) -D_DEBUG -DDEBUG
  # The /fixed:no is needed for Quantify. Assume not 4.? as unsupported in VC4.0.
! ! if "$(MSVCVER)" == "4.0"
  LIBC =
  ! else
  LIBC = /fixed:no
  ! endif
  ! ifdef USE_MSVCRT
! CFLAGS = $(CFLAGS) /MDd
  LIBC = $(LIBC) msvcrtd.lib
  ! else
  LIBC = $(LIBC) libcmtd.lib
! CFLAGS = $(CFLAGS) /MTd
  ! endif
  !endif # DEBUG
  
***************
*** 681,696 ****
  #
  # Always generate the .pdb file, so that we get debug symbols that can be used
  # on a crash (doesn't add overhead to the executable).
  #
! CFLAGS = $(CFLAGS) /Zi /Fd$(OUTDIR)/
! LINK_PDB = /PDB:$(VIM).pdb -debug # -debug:full -debugtype:cv,fixup
  
  #
  # End extra feature include
  #
  !message
  
! conflags = /nologo /subsystem:$(SUBSYSTEM) /incremental:no
  
  PATHDEF_SRC = $(OUTDIR)\pathdef.c
  
--- 727,744 ----
  #
  # Always generate the .pdb file, so that we get debug symbols that can be used
  # on a crash (doesn't add overhead to the executable).
+ # Generate edit-and-continue debug info when no optimization - allows to
+ # debug more conveniently (able to look at variables which are in registers)
  #
! CFLAGS = $(CFLAGS) /Fd$(OUTDIR)/ $(DEBUGINFO)
! LINK_PDB = /PDB:$(VIM).pdb -debug
  
  #
  # End extra feature include
  #
  !message
  
! conflags = /nologo /subsystem:$(SUBSYSTEM)
  
  PATHDEF_SRC = $(OUTDIR)\pathdef.c
  
***************
*** 702,712 ****
  conflags = $(conflags) /map /mapinfo:lines
  !ENDIF
  
! LINKARGS1 = $(linkdebug) $(conflags) /nodefaultlib:libc
  LINKARGS2 = $(CON_LIB) $(GUI_LIB) $(LIBC) $(OLE_LIB)  user32.lib $(SNIFF_LIB) \
  		$(MZSCHEME_LIB) $(PERL_LIB) $(PYTHON_LIB) $(RUBY_LIB) \
  		$(TCL_LIB) $(NETBEANS_LIB) $(XPM_LIB) $(LINK_PDB)
  
  all:	$(VIM).exe vimrun.exe install.exe uninstal.exe xxd/xxd.exe \
  		GvimExt/gvimext.dll
  
--- 750,769 ----
  conflags = $(conflags) /map /mapinfo:lines
  !ENDIF
  
! LINKARGS1 = $(linkdebug) $(conflags)
  LINKARGS2 = $(CON_LIB) $(GUI_LIB) $(LIBC) $(OLE_LIB)  user32.lib $(SNIFF_LIB) \
  		$(MZSCHEME_LIB) $(PERL_LIB) $(PYTHON_LIB) $(RUBY_LIB) \
  		$(TCL_LIB) $(NETBEANS_LIB) $(XPM_LIB) $(LINK_PDB)
  
+ # Report link time code generation progress if used. 
+ !ifdef NODEBUG
+ !if "$(MSVCVER)" == "8.0"
+ !if "$(OPTIMIZE)" != "SPACE"
+ LINKARGS1 = $(LINKARGS1) /LTCG:STATUS
+ !endif
+ !endif
+ !endif
+ 
  all:	$(VIM).exe vimrun.exe install.exe uninstal.exe xxd/xxd.exe \
  		GvimExt/gvimext.dll
  
***************
*** 794,800 ****
  
  # Create a default rule for transforming .c files to .obj files in $(OUTDIR)
  # Batch compilation is supported by nmake 1.62 (part of VS 5.0) and later)
! !IF "$(_NMAKE_VER)" == ""
  .c{$(OUTDIR)/}.obj:
  !ELSE
  .c{$(OUTDIR)/}.obj::
--- 851,857 ----
  
  # Create a default rule for transforming .c files to .obj files in $(OUTDIR)
  # Batch compilation is supported by nmake 1.62 (part of VS 5.0) and later)
! !IF "$(MSVCVER)" == "4.0"
  .c{$(OUTDIR)/}.obj:
  !ELSE
  .c{$(OUTDIR)/}.obj::
***************
*** 803,809 ****
  
  # Create a default rule for transforming .cpp files to .obj files in $(OUTDIR)
  # Batch compilation is supported by nmake 1.62 (part of VS 5.0) and later)
! !IF "$(_NMAKE_VER)" == ""
  .cpp{$(OUTDIR)/}.obj:
  !ELSE
  .cpp{$(OUTDIR)/}.obj::
--- 860,866 ----
  
  # Create a default rule for transforming .cpp files to .obj files in $(OUTDIR)
  # Batch compilation is supported by nmake 1.62 (part of VS 5.0) and later)
! !IF "$(MSVCVER)" == "4.0"
  .cpp{$(OUTDIR)/}.obj:
  !ELSE
  .cpp{$(OUTDIR)/}.obj::
*** ../vim-7.1.133/src/version.c	Wed Oct  3 12:49:24 2007
--- src/version.c	Wed Oct  3 13:23:51 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     134,
  /**/

-- 
BLACK KNIGHT: The Black Knight always triumphs. Have at you!
   ARTHUR takes his last leg off.  The BLACK KNIGHT's body lands upright.
BLACK KNIGHT: All right, we'll call it a draw.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.135
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.135
Problem:    Win32: When editing a file c:\tmp\foo and c:\tmp\\foo we have two
	    buffers for the same file. (Suresh Govindachar)
Solution:   Invoke FullName_save() when a path contains "//" or "\\".
Files:	    src/buffer.c


*** ../vim-7.1.134/src/buffer.c	Sun Sep 30 14:00:41 2007
--- src/buffer.c	Wed Oct  3 14:24:52 2007
***************
*** 4175,4203 ****
       * mess up the full path name, even though it starts with a '/'.
       * Also expand when there is ".." in the file name, try to remove it,
       * because "c:/src/../README" is equal to "c:/README".
       * For MS-Windows also expand names like "longna~1" to "longname".
       */
  #ifdef UNIX
      return FullName_save(fname, TRUE);
  #else
!     if (!vim_isAbsName(fname) || strstr((char *)fname, "..") != NULL
! #if defined(MSWIN) || defined(DJGPP)
  	    || vim_strchr(fname, '~') != NULL
! #endif
  	    )
  	return FullName_save(fname, FALSE);
  
      fname = vim_strsave(fname);
  
! #ifdef USE_FNAME_CASE
! # ifdef USE_LONG_FNAME
      if (USE_LONG_FNAME)
! # endif
      {
  	if (fname != NULL)
  	    fname_case(fname, 0);	/* set correct case for file name */
      }
! #endif
  
      return fname;
  #endif
--- 4175,4209 ----
       * mess up the full path name, even though it starts with a '/'.
       * Also expand when there is ".." in the file name, try to remove it,
       * because "c:/src/../README" is equal to "c:/README".
+      * Similarly "c:/src//file" is equal to "c:/src/file".
       * For MS-Windows also expand names like "longna~1" to "longname".
       */
  #ifdef UNIX
      return FullName_save(fname, TRUE);
  #else
!     if (!vim_isAbsName(fname)
! 	    || strstr((char *)fname, "..") != NULL
! 	    || strstr((char *)fname, "//") != NULL
! # ifdef BACKSLASH_IN_FILENAME
! 	    || strstr((char *)fname, "\\\\") != NULL
! # endif
! # if defined(MSWIN) || defined(DJGPP)
  	    || vim_strchr(fname, '~') != NULL
! # endif
  	    )
  	return FullName_save(fname, FALSE);
  
      fname = vim_strsave(fname);
  
! # ifdef USE_FNAME_CASE
! #  ifdef USE_LONG_FNAME
      if (USE_LONG_FNAME)
! #  endif
      {
  	if (fname != NULL)
  	    fname_case(fname, 0);	/* set correct case for file name */
      }
! # endif
  
      return fname;
  #endif
*** ../vim-7.1.134/src/version.c	Wed Oct  3 13:28:40 2007
--- src/version.c	Wed Oct  3 14:26:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     135,
  /**/

-- 
   A village.  Sound of chanting of Latin canon, punctuated by short, sharp
   cracks.  It comes nearer.  We see it is a line of MONKS ala SEVENTH SEAL
   flagellation scene, chanting and banging themselves on the foreheads with
   wooden boards.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.136
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.136
Problem:    Memory leak when using Ruby syntax highlighting. (Dominique Pelle)
Solution:   Free the contained-in list.
Files:	    src/syntax.c


*** ../vim-7.1.135/src/syntax.c	Thu Aug 30 19:36:52 2007
--- src/syntax.c	Sun Oct  7 15:10:54 2007
***************
*** 3354,3359 ****
--- 3354,3360 ----
      {
  	vim_free(SYN_ITEMS(buf)[i].sp_cont_list);
  	vim_free(SYN_ITEMS(buf)[i].sp_next_list);
+ 	vim_free(SYN_ITEMS(buf)[i].sp_syn.cont_in_list);
      }
  }
  
*** ../vim-7.1.135/src/version.c	Wed Oct  3 14:30:54 2007
--- src/version.c	Sun Oct  7 15:20:22 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     136,
  /**/

-- 
Every engineer dreams about saving the universe and having sex with aliens.
This is much more glamorous than the real life of an engineer, which consists
of hiding from the universe and having sex without the participation of other
life forms.                     (Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.137
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.137
Problem:    Build failure when using EXITFREE. (Dominique Pelle)
Solution:   Add an #ifdef around using clip_exclude_prog.
Files:      src/misc2.c
    

*** ../vim-7.1.136/src/misc2.c	Sat Sep 29 14:15:00 2007
--- src/misc2.c	Sun Sep 30 18:00:09 2007
***************
*** 1037,1043 ****
--- 1038,1046 ----
  
      /* Free some global vars. */
      vim_free(username);
+ # ifdef FEAT_CLIPBOARD
      vim_free(clip_exclude_prog);
+ # endif
      vim_free(last_cmdline);
      vim_free(new_last_cmdline);
      set_keep_msg(NULL, 0);
*** ../vim-7.1.136/src/version.c	Sun Oct  7 15:21:31 2007
--- src/version.c	Sun Oct  7 15:42:26 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     137,
  /**/

-- 
For society, it's probably a good thing that engineers value function over
appearance.  For example, you wouldn't want engineers to build nuclear power
plants that only _look_ like they would keep all the radiation inside.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.138
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.138
Problem:    The Perl Msg() function doesn't stop when "q" is typed at the more
	    prompt. (Hari Krishna Dara)
Solution:   Check got_int.
Files:	    src/if_perl.xs


*** ../vim-7.1.137/src/if_perl.xs	Sat Sep 15 14:48:57 2007
--- src/if_perl.xs	Wed Oct  3 17:00:16 2007
***************
*** 445,457 ****
      char *next;
      char *token = (char *)s;
  
!     while ((next = strchr(token, '\n')))
      {
  	*next++ = '\0';			/* replace \n with \0 */
  	msg_attr((char_u *)token, attr);
  	token = next;
      }
!     if (*token)
  	msg_attr((char_u *)token, attr);
  }
  
--- 445,457 ----
      char *next;
      char *token = (char *)s;
  
!     while ((next = strchr(token, '\n')) && !got_int)
      {
  	*next++ = '\0';			/* replace \n with \0 */
  	msg_attr((char_u *)token, attr);
  	token = next;
      }
!     if (*token && !got_int)
  	msg_attr((char_u *)token, attr);
  }
  
*** ../vim-7.1.137/src/version.c	Sun Oct  7 15:44:28 2007
--- src/version.c	Tue Oct  9 10:45:08 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     138,
  /**/

-- 
A consultant is a person who takes your money and annoys your employees while
tirelessly searching for the best way to extend the consulting contract.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.139
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.139
Problem:    When using marker folding and ending Insert mode with CTRL-C the
	    current fold is truncated. (Fred Kater)
Solution:   Ignore got_int while updating folds.
Files:	    src/fold.c


*** ../vim-7.1.138/src/fold.c	Thu May 10 21:02:13 2007
--- src/fold.c	Sun Oct 14 15:27:13 2007
***************
*** 858,864 ****
--- 858,871 ----
  	    || foldmethodIsDiff(wp)
  #endif
  	    || foldmethodIsSyntax(wp))
+     {
+ 	int save_got_int = got_int;
+ 
+ 	/* reset got_int here, otherwise it won't work */
+ 	got_int = FALSE;
  	foldUpdateIEMS(wp, top, bot);
+ 	got_int |= save_got_int;
+     }
  }
  
  /* foldUpdateAll() {{{2 */
*** ../vim-7.1.138/src/version.c	Tue Oct  9 10:46:39 2007
--- src/version.c	Sun Oct 14 15:31:18 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     139,
  /**/

-- 
If Pacman had affected us as kids we'd be running around in dark rooms,
munching pills and listening to repetitive music.
                       -- Marcus Brigstocke

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.140
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.140
Problem:    v:count is set only after typing a non-digit, that makes it
	    difficult to make a nice mapping.
Solution:   Set v:count while still typing the count.
Files:	    src/normal.c


*** ../vim-7.1.139/src/normal.c	Thu Sep 13 18:25:08 2007
--- src/normal.c	Sun Oct 14 17:15:36 2007
***************
*** 690,695 ****
--- 690,702 ----
  		ca.count0 = ca.count0 * 10 + (c - '0');
  	    if (ca.count0 < 0)	    /* got too large! */
  		ca.count0 = 999999999L;
+ #ifdef FEAT_EVAL
+ 	    /* Set v:count here, when called from main() and not a stuffed
+ 	     * command, so that v:count can be used in an expression mapping
+ 	     * right after the count. */
+ 	    if (toplevel && stuff_empty())
+ 		set_vcount(ca.count0, ca.count0 == 0 ? 1 : ca.count0);
+ #endif
  	    if (ctrl_w)
  	    {
  		++no_mapping;
*** ../vim-7.1.139/src/version.c	Sun Oct 14 15:32:10 2007
--- src/version.c	Sun Oct 14 17:13:15 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     140,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
11. Specify that your drive-through order is "to go".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.141
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.141
Problem:    GTK: -geom argument doesn't support a negative offset.
Solution:   Compute position from the right/lower corner.
Files:	    src/gui_gtk_x11.c


*** ../vim-7.1.140/src/gui_gtk_x11.c	Sat Sep 15 14:06:41 2007
--- src/gui_gtk_x11.c	Mon Oct  8 21:26:50 2007
***************
*** 4044,4049 ****
--- 4044,4051 ----
  	unsigned int	w, h;
  	int		x = 0;
  	int		y = 0;
+ 	guint		pixel_width;
+ 	guint		pixel_height;
  
  	mask = XParseGeometry((char *)gui.geom, &x, &y, &w, &h);
  
***************
*** 4055,4066 ****
--- 4057,4087 ----
  		p_window = h - 1;
  	    Rows = h;
  	}
+ 
+ 	pixel_width = (guint)(gui_get_base_width() + Columns * gui.char_width);
+ 	pixel_height = (guint)(gui_get_base_height() + Rows * gui.char_height);
+ 
+ #ifdef HAVE_GTK2
+ 	pixel_width  += get_menu_tool_width();
+ 	pixel_height += get_menu_tool_height();
+ #endif
+ 
  	if (mask & (XValue | YValue))
+ 	{
+ 	    int w, h;
+ 	    gui_mch_get_screen_dimensions(&w, &h);
+ 	    h += p_ghr + get_menu_tool_height();
+ 	    w += get_menu_tool_width();
+ 	    if (mask & XNegative)
+ 		x += w - pixel_width;
+ 	    if (mask & YNegative)
+ 		y += h - pixel_height;
  #ifdef HAVE_GTK2
  	    gtk_window_move(GTK_WINDOW(gui.mainwin), x, y);
  #else
  	    gtk_widget_set_uposition(gui.mainwin, x, y);
  #endif
+ 	}
  	vim_free(gui.geom);
  	gui.geom = NULL;
  
***************
*** 4071,4084 ****
  	 */
  	if (gtk_socket_id != 0  &&  (mask & WidthValue || mask & HeightValue))
  	{
- 	    guint pixel_width = (guint)(gui_get_base_width() + Columns * gui.char_width);
- 	    guint pixel_height = (guint)(gui_get_base_height() + Rows * gui.char_height);
- 
- #ifdef HAVE_GTK2
- 	    pixel_width  += get_menu_tool_width();
- 	    pixel_height += get_menu_tool_height();
- #endif
- 
  	    update_window_manager_hints(pixel_width, pixel_height);
  	    init_window_hints_state = 1;
  	    g_timeout_add(1000, check_startup_plug_hints, NULL);
--- 4092,4097 ----
*** ../vim-7.1.140/src/version.c	Sun Oct 14 17:15:45 2007
--- src/version.c	Fri Oct 19 14:28:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     141,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
35. Your husband tells you he's had the beard for 2 months.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.142
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.142
Problem:    ":redir @A>" doesn't work.
Solution:   Ignore the extra ">" also when appending. (James Vega)
Files:	    src/ex_docmd.c


*** ../vim-7.1.141/src/ex_docmd.c	Sun Sep 30 14:00:41 2007
--- src/ex_docmd.c	Tue Oct  9 11:09:09 2007
***************
*** 8426,8446 ****
  		    || *arg == '"')
  	    {
  		redir_reg = *arg++;
! 		if (*arg == '>' && arg[1] == '>')
  		    arg += 2;
! 		else if ((*arg == NUL || (*arg == '>' && arg[1] == NUL)) &&
! 			 (islower(redir_reg)
! # ifdef FEAT_CLIPBOARD
! 			    || redir_reg == '*'
! 			    || redir_reg == '+'
! # endif
! 			    || redir_reg == '"'))
  		{
  		    if (*arg == '>')
  			arg++;
! 
! 		    /* make register empty */
! 		    write_reg_contents(redir_reg, (char_u *)"", -1, FALSE);
  		}
  	    }
  	    if (*arg != NUL)
--- 8426,8442 ----
  		    || *arg == '"')
  	    {
  		redir_reg = *arg++;
! 		if (*arg == '>' && arg[1] == '>')  /* append */
  		    arg += 2;
! 		else
  		{
+ 		    /* Can use both "@a" and "@a>". */
  		    if (*arg == '>')
  			arg++;
! 		    /* Make register empty when not using @A-@Z and the
! 		     * command is valid. */
! 		    if (*arg == NUL && !isupper(redir_reg))
! 			write_reg_contents(redir_reg, (char_u *)"", -1, FALSE);
  		}
  	    }
  	    if (*arg != NUL)
*** ../vim-7.1.141/src/version.c	Fri Oct 19 14:32:50 2007
--- src/version.c	Fri Oct 19 16:18:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     142,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
36. You miss more than five meals a week downloading the latest games from
    Apogee.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.143
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.143
Problem:    Uninitialized memory read when diffing three files. (Dominique
	    Pelle)
Solution:   Remove "+ !notset" so that we don't use fields that were not
	    computed.
Files:	    src/diff.c


*** ../vim-7.1.142/src/diff.c	Sat Sep 29 14:15:00 2007
--- src/diff.c	Sun Oct 14 21:52:56 2007
***************
*** 1310,1316 ****
  		    dp->df_count[idx_new] += -off;
  		off = 0;
  	    }
! 	    for (i = idx_orig; i < idx_new + !notset; ++i)
  		if (curtab->tp_diffbuf[i] != NULL)
  		    dp->df_count[i] = dpl->df_lnum[i] + dpl->df_count[i]
  						       - dp->df_lnum[i] + off;
--- 1310,1316 ----
  		    dp->df_count[idx_new] += -off;
  		off = 0;
  	    }
! 	    for (i = idx_orig; i < idx_new; ++i)
  		if (curtab->tp_diffbuf[i] != NULL)
  		    dp->df_count[i] = dpl->df_lnum[i] + dpl->df_count[i]
  						       - dp->df_lnum[i] + off;
*** ../vim-7.1.142/src/version.c	Fri Oct 19 16:20:09 2007
--- src/version.c	Fri Oct 19 17:32:18 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     143,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
37. You start looking for hot HTML addresses in public restrooms.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.144
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.144
Problem:    After ":diffup" cursor can be in the wrong position.
Solution:   Force recomputing the cursor position.
Files:	    src/diff.c


*** ../vim-7.1.143/src/diff.c	Fri Oct 19 17:32:58 2007
--- src/diff.c	Fri Oct 19 18:54:13 2007
***************
*** 791,796 ****
--- 791,799 ----
      }
      mch_remove(tmp_orig);
  
+     /* force updating cursor position on screen */
+     curwin->w_valid_cursor.lnum = 0;
+ 
      diff_redraw(TRUE);
  
  theend:
*** ../vim-7.1.143/src/version.c	Fri Oct 19 17:32:58 2007
--- src/version.c	Fri Oct 19 18:56:49 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     144,
  /**/

-- 
He who laughs last, thinks slowest.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: Patch 7.1.145
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.145
Problem:    Insert mode completion: When using the popup menu, after
	    completing a word and typing a non-word character Vim is still
	    completing the same word, following CTRL-N doesn't work.
	    Insert mode Completion: When using CTRL-X O and there is only
	    "struct." before the cursor, typing one char to reduce the
	    matches, then BS completion stops.
Solution:   When typing a character that is not part of the item being
	    completed, stop complete mode.  For whole line completion also
	    accept a space.  For file name completion stop at a path
	    separator.
	    For omni completion stay in completion mode even if completing
	    with empty string.
Files:	    src/edit.c


*** ../vim-7.1.144/src/edit.c	Thu Sep 13 18:25:08 2007
--- src/edit.c	Fri Oct 19 16:04:38 2007
***************
*** 129,134 ****
--- 129,135 ----
  
  static void ins_ctrl_x __ARGS((void));
  static int  has_compl_option __ARGS((int dict_opt));
+ static int  ins_compl_accept_char __ARGS((int c));
  static int ins_compl_add __ARGS((char_u *str, int len, int icase, char_u *fname, char_u **cptext, int cdir, int flags, int adup));
  static int  ins_compl_equal __ARGS((compl_T *match, char_u *str, int len));
  static void ins_compl_longest_match __ARGS((compl_T *match));
***************
*** 754,761 ****
  		    continue;
  		}
  
! 		/* A printable, non-white character: Add to "compl_leader". */
! 		if (vim_isprintc(c) && !vim_iswhite(c))
  		{
  		    ins_compl_addleader(c);
  		    continue;
--- 755,763 ----
  		    continue;
  		}
  
! 		/* A non-white character that fits in with the current
! 		 * completion: Add to "compl_leader". */
! 		if (ins_compl_accept_char(c))
  		{
  		    ins_compl_addleader(c);
  		    continue;
***************
*** 2053,2058 ****
--- 2055,2094 ----
  }
  
  /*
+  * Return TRUE when character "c" is part of the item currently being
+  * completed.  Used to decide whether to abandon complete mode when the menu
+  * is visible.
+  */
+     static int
+ ins_compl_accept_char(c)
+     int c;
+ {
+     if (ctrl_x_mode & CTRL_X_WANT_IDENT)
+ 	/* When expanding an identifier only accept identifier chars. */
+ 	return vim_isIDc(c);
+ 
+     switch (ctrl_x_mode)
+     {
+ 	case CTRL_X_FILES:
+ 	    /* When expanding file name only accept file name chars. But not
+ 	     * path separators, so that "proto/<Tab>" expands files in
+ 	     * "proto", not "proto/" as a whole */
+ 	    return vim_isfilec(c) && !vim_ispathsep(c);
+ 
+ 	case CTRL_X_CMDLINE:
+ 	case CTRL_X_OMNI:
+ 	    /* Command line and Omni completion can work with just about any
+ 	     * printable character, but do stop at white space. */
+ 	    return vim_isprintc(c) && !vim_iswhite(c);
+ 
+ 	case CTRL_X_WHOLE_LINE:
+ 	    /* For while line completion a space can be part of the line. */
+ 	    return vim_isprintc(c);
+     }
+     return vim_iswordc(c);
+ }
+ 
+ /*
   * This is like ins_compl_add(), but if 'ic' and 'inf' are set, then the
   * case of the originally typed text is used, and the case of the completed
   * text is inferred, ie this tries to work out what case you probably wanted
***************
*** 3128,3135 ****
      p = line + curwin->w_cursor.col;
      mb_ptr_back(line, p);
  
!     /* Stop completion when the whole word was deleted. */
!     if ((int)(p - line) - (int)compl_col <= 0)
  	return K_BS;
  
      /* Deleted more than what was used to find matches or didn't finish
--- 3164,3174 ----
      p = line + curwin->w_cursor.col;
      mb_ptr_back(line, p);
  
!     /* Stop completion when the whole word was deleted.  For Omni completion
!      * allow the word to be deleted, we won't match everything. */
!     if ((int)(p - line) - (int)compl_col < 0
! 	    || ((int)(p - line) - (int)compl_col == 0
! 		&& (ctrl_x_mode & CTRL_X_OMNI) == 0))
  	return K_BS;
  
      /* Deleted more than what was used to find matches or didn't finish
***************
*** 4591,4604 ****
  	curs_col = curwin->w_cursor.col;
  	compl_pending = 0;
  
! 	/* if this same ctrl_x_mode has been interrupted use the text from
  	 * "compl_startpos" to the cursor as a pattern to add a new word
  	 * instead of expand the one before the cursor, in word-wise if
! 	 * "compl_startpos"
! 	 * is not in the same line as the cursor then fix it (the line has
! 	 * been split because it was longer than 'tw').  if SOL is set then
! 	 * skip the previous pattern, a word at the beginning of the line has
! 	 * been inserted, we'll look for that  -- Acevedo. */
  	if ((compl_cont_status & CONT_INTRPT) == CONT_INTRPT
  					    && compl_cont_mode == ctrl_x_mode)
  	{
--- 4630,4642 ----
  	curs_col = curwin->w_cursor.col;
  	compl_pending = 0;
  
! 	/* If this same ctrl_x_mode has been interrupted use the text from
  	 * "compl_startpos" to the cursor as a pattern to add a new word
  	 * instead of expand the one before the cursor, in word-wise if
! 	 * "compl_startpos" is not in the same line as the cursor then fix it
! 	 * (the line has been split because it was longer than 'tw').  if SOL
! 	 * is set then skip the previous pattern, a word at the beginning of
! 	 * the line has been inserted, we'll look for that  -- Acevedo. */
  	if ((compl_cont_status & CONT_INTRPT) == CONT_INTRPT
  					    && compl_cont_mode == ctrl_x_mode)
  	{
*** ../vim-7.1.144/src/version.c	Fri Oct 19 18:57:33 2007
--- src/version.c	Fri Oct 19 20:38:21 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     145,
  /**/

-- 
Micro$oft: where do you want to go today?
    Linux: where do you want to go tomorrow?
  FreeBSD: are you guys coming, or what?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
