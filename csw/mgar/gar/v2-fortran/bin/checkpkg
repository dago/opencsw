#!/bin/ksh -p
# 
# $Id$
#
# checkpkg 1.51
#
# diff to 1.46a
#  - check multiple package files
#  - checkpkg.d plugin support
#  - getopts support for command line options
#  - colors
#  - modular architecture + unit tests
#  - reliable shared library checking
#
# This script examines a package that has been put together
# for submittal to the CSW archive at opencsw.org
#
# It examines it for compliance with the packaging standards at
# http://www.opencsw.org/standards/
# It DOES NOT CATCH EVERYTHING. However, the package will be
# tested with this script before acceptance, so you may as well
# save yourself some time, and run the script yourself!
#
# Be sure to occasionally do a "pkg-get update cswutils" so that
# you know you are tracking the most current version.
# 
# TODO:
# - add message handlig to the CheckInterface class.
#

PATH=$PATH:/usr/sbin
readonly NAME_MAX_LENGTH=${NAME_MAX_LENGTH:-20}

command_basename=`basename $0`
command_basedir="${0%/${command_basename}}"
libshdir="${command_basedir}/../lib/sh"
readonly command_basename command_basedir libshdir
. "${libshdir}/libcheckpkg.sh"

LOCAL_ARCH=`uname -p`
CHECKPKG_TMPDIR=${CHECKPKG_TMPDIR:-/var/tmp}
readonly CHECKPKG_TMPDIR

# Colors only when running interactively
if [[ -t 1 ]]; then
	GREEN="\\033[0;32;40m"
	RED="\\033[1;31;40m"
	BOLD="\\033[1m"
	COLOR_RESET="\\033[00m"
else
	GREEN=""
	RED=""
	BOLD=""
	COLOR_RESET=""
fi
readonly GREEN RED BOLD COLOR_RESET

readonly selfpath="$0"
readonly selfargs="$@"

cleanup(){
	if [[ -d "$EXTRACTDIR" ]] ; then
		rm -rf $EXTRACTDIR
	fi
	cleantmparchives
}

cleantmparchives() {
	for TMPARCHIVE in $tmparchives; do
		if [[ "$TMPARCHIVE" != "" ]]; then
			[ -f "$TMPARCHIVE" ] && rm $TMPARCHIVE
		fi
	done
}

cleanupset(){
    if [ "`echo $SETINF*`" != "$SETINF*" ]; then
	rm $SETINF*
    fi
}

# Print error message, and quit program.
errmsg(){
	print ERROR: $* >/dev/fd/2
	cleanup
	cleanupset
	print "To run checkpkg in the debug mode, add the '-d' flag, for example:"
  # selfargs can be very, very long. Find a way to truncate it.
	# print "${selfpath} -d ${selfargs}"
	print "After you modify any overrides, you need to do gmake remerge repackage"
	print "or gmake platforms-remerge platforms-repackage."
	exit 1
}

debugmsg() {
	if [[ "${DEBUG}" != "" ]]; then
		print "DEBUG: $*" > /dev/fd/2
	fi
}

# TODO: Options to add:
#  - Use an pre-cached (from a catalog file?) list of md5 sums
#  - Don't use the data from /var/sadm/install/contents
display_help=0
SKIP_STATS_COLLECTION=0
MD5_SUMS_CATALOG_FILE=""
INSTALL_CONTENTS_FILES="/var/sadm/install/contents"
ANALYZE=1
PROFILE=0
QUIET=0

while getopts hsdNM:o:c:Apq opt; do
	case "${opt}" in
	  c)
	    INSTALL_CONTENTS_FILES="${INSTALL_CONTENTS_FILES} ${OPTARG}"
	    ;;
    d)
      DEBUG=1
      ;;
    h)
      display_help=1
      ;;
    N)
      SKIP_STATS_COLLECTION=1
      ;;
    M)
      MD5_SUMS_CATALOG_FILE="${OPTARG}"
      ;;
    A)
      ANALYZE=0
      ;;
    p)
      PROFILE=1
      ;;
    q) QUIET=1
      ;;
    *)
      echo "Unknown option '${opt}'"
      ;;
  esac
done
shift $(( $OPTIND -1 ))

readonly INSTALL_CONTENTS_FILES
readonly MD5_SUMS_CATALOG_FILE
readonly SKIP_STATS_COLLECTION
readonly ANALYZE
readonly PROFILE
readonly QUIET

if [[ "${display_help}" -eq 1 ]] ; then
  print 'Usage: checkpkg [options] pkg1 [pkg2 ....]'
  print 'Options:'
  print '   -c <file>  use an additional install/contents file'
  print '   -d         display debug messages'
  print '   -N         skip statistics collection'
  print '   -M <file>  use package md5sums from a catalog file'
  print '   -A         Do not analyze the results.'
  print '   -p         Enable profiling'
  print '   -q         Display less messages'
  print ''
  print 'Error tags are saved to the sqlite database.'
  exit 0
fi

# a unique filename for the list of package deps and libs we see in a 'set'
SETINF=$CHECKPKG_TMPDIR/checkpkg.$$.`date +%Y%m%d%H%M%S`
SETLIBS=$SETINF.libs
SETDEPS=$SETINF.deps
pkgnames=""
tmparchives=""

EXTRACTDIR=$CHECKPKG_TMPDIR/dissect.$$

if [ -d $EXTRACTDIR ] ; then
	errmsg ERROR: $EXTRACTDIR already exists
fi

for f in "$@"
do

  if [[ ! -f $f ]] ; then
    errmsg ERROR: $f does not exist
  fi


[ -d ${EXTRACTDIR} ] || mkdir ${EXTRACTDIR}

########################################
# Check for some common errors
#########################################

# TODO: To be ported.
#
# # find all executables and dynamic libs,and list their filenames.
# if [[ "$basedir" != "" ]] ; then
# 	print
# 	if [[ -f $EXTRACTDIR/elflist ]] ; then
# 		print "Checking relocation ability..."
# 		xargs strings < $EXTRACTDIR/elflist| grep /opt/csw
# 		if [[ $? -eq 0 ]] ; then
# 			errmsg package build as relocatable, but binaries have hardcoded /opt/csw paths in them
# 		else
# 			print trivial check passed
# 		fi
# 	else
# 		echo No relocation check done for non-binary relocatable package.
# 	fi
# fi

tmparchives="$tmparchives $TMPARCHIVE"
done

# Plugin section.  This is here for support for other programming languages
# than Python.  As of 2010-03-16 there are no checks in there.  If this keeps
# empty, if no checks in other languages get written, it could be removed.
#
# Plugins should live in checkpkg.d subdirectory in the same directory in which
# checkpkg is.  Each plugin file name should be an executable and begin with
# "checkpkg-".

test_suite_ok=1
checkpkg_module_dir="${command_basedir}/../lib/checkpkg.d"
checkpkg_module_tag="checkpkg-"
checkpkg_stats_basedir="${HOME}/.checkpkg/stats"

# Cleaning up old *.pyc files which can cause grief.  This is because of the
# move of Python libraries.
for pyc_file in ${checkpkg_module_dir}/opencsw.pyc \
                ${checkpkg_module_dir}/checkpkg.pyc; do
  if [ -f "${pyc_file}" ]; then
    echo "Removing old pyc file: '${pyc_file}'"
    rm "${pyc_file}"
  fi
done

if [[ "${DEBUG}" != "" ]]; then
	extra_options="--debug"
fi
if [[ "${PROFILE}" -eq 1 ]]; then
	extra_options="${extra_options} --profile"
fi
if [[ "${QUIET}" -eq 1 ]]; then
	quiet_options="--quiet"
else
	quiet_options=""
fi

if [[ -n "${MD5_SUMS_CATALOG_FILE}" ]]; then
	catalog_options="--catalog=${MD5_SUMS_CATALOG_FILE}"
else
	catalog_options=""
fi

# /var/sadm/install/contents cache update
# TODO: Either remove this section or stop the stats collection phase from
# updating the cache.
${command_basedir}/update_contents_cache.py ${extra_options}
if [[ $? -ne 0 ]]; then
	errmsg "Updating the contents cache has failed."
fi
if [[ "${SKIP_STATS_COLLECTION}" -eq 0 ]]; then
  # Collects package stats to be analyzed later
  ${command_basedir}/checkpkg_collect_stats.py \
      ${catalog_options} \
      ${extra_options} \
      "$@"
  if [[ "$?" -ne 0 ]]; then
    errmsg "Stats collection phase has failed."
  fi
fi

# TODO: A performance problem. The following line means that the md5sums are
# calculated once more.
if [ "${MD5_SUMS_CATALOG_FILE}" ]; then
	debugmsg "Reading md5sums from ${MD5_SUMS_CATALOG_FILE}"
	md5sums=`cat "${MD5_SUMS_CATALOG_FILE}" \
	    | awk '{print $5}' \
	    | ggrep -E '[0-9abcdef]{32}'`
else
  debugmsg "Calculating md5 sums of all the package files."
  md5sums=`gmd5sum "$@" | awk '{print $1}'`
fi
debugmsg "All md5 sums: ${md5sums}"

# Running the checks.
${command_basedir}/checkpkg_run_modules.py \
    ${extra_options} \
    -b "${checkpkg_stats_basedir}" \
    ${quiet_options} \
    ${md5sums}
if [[ "$?" -ne 0 ]]; then
  print "There was a problem analyzing package stats."
  test_suite_ok=0
fi

if [[ ${test_suite_ok} -ne 1 ]]; then
	errmsg "One or more tests have finished with an error."
fi

if [[ "${ANALYZE}" -eq 1 ]]; then
# Collecting errors and applying the overrides.
# This has to use the original files.
  ${command_basedir}/analyze_module_results.py \
      ${catalog_options} \
      ${quiet_options} \
      "$@"
  if [[ "$?" -ne 0 ]]; then
    errmsg "${RED}Checkpkg has reported errors.${COLOR_RESET}"
  else
    print "${GREEN}Checkpkg reports no errors.${COLOR_RESET}"
  fi
else
	echo "Skipping result analysis."
fi

print ""

# Cleaning up after all packages
cleanup

cleanupset
