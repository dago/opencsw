#!/bin/ksh -p
# 
# $Id$
#
# checkpkg 1.51
#
# diff to 1.46a
#  - check multiple package files
#  - checkpkg.d plugin support
#
# This script examines a package that has been put together
# for submittal to the CSW archive at opencsw.org
#
# It examines it for compliance with the packaging standards at
# http://www.opencsw.org/standards/
# It DOES NOT CATCH EVERYTHING. However, the package will be
# tested with this script before acceptance, so you may as well
# save yourself some time, and run the script yourself!
#
# Be sure to occasionally do a "pkg-get update cswutils" so that
# you know you are tracking the most current version.
# 

PATH=$PATH:/usr/sbin
readonly NAME_MAX_LENGTH=${NAME_MAX_LENGTH:-20}

command_basename=`basename $0`
command_basedir="${0%/${command_basename}}"
libshdir="${command_basedir}/../lib/sh"
readonly command_basename command_basedir libshdir
. "${libshdir}/libcheckpkg.sh"

LOCAL_ARCH=`uname -p`
if [[ -z "${CHECKPKG_TMPDIR}" ]]; then
  readonly CHECKPKG_TMPDIR="/var/tmp"
else
  readonly CHECKPKG_TMPDIR
fi

# Colors only when running interactively
if [[ -t 1 ]]; then
	GREEN="\\033[0;32;40m"
	RED="\\033[1;31;40m"
	BOLD="\\033[1m"
	COLOR_RESET="\\033[00m"
else
	GREEN=""
	RED=""
	BOLD=""
	COLOR_RESET=""
fi
readonly GREEN RED BOLD COLOR_RESET

readonly selfpath="$0"
readonly selfargs="$@"

# always print out a warning message. (to stderr)
# exit script, if quit_on_warn set


cleanup(){
	if [[ -d "$EXTRACTDIR" ]] ; then
		rm -rf $EXTRACTDIR
	fi
	cleantmparchives
}

cleantmparchives() {
	for TMPARCHIVE in $tmparchives; do
		if [[ "$TMPARCHIVE" != "" ]]; then
			[ -f "$TMPARCHIVE" ] && rm $TMPARCHIVE
		fi
	done
}

cleanupset(){
    if [ "`echo $SETINF*`" != "$SETINF*" ]; then
	rm $SETINF*
    fi
}
warnmsg(){
	print WARNING: $* >/dev/fd/2
	if [[ "$quit_on_warn" != "" ]] ; then
		cleanup
		exit 1
	fi
}

# Print error message, and quit program.
errmsg(){
	print ERROR: $* >/dev/fd/2
	cleanup
	cleanupset
	print "To run checkpkg in the debug mode, add the '-d' flag, for example:"
	print "${selfpath} -d ${selfargs}"
	print "After you modify any overrides, you need to do gmake remerge repackage"
	print "or gmake platforms-remerge platforms-repackage."
	exit 1
}

debugmsg() {
	if [[ "${DEBUG}" != "" ]]; then
		print "DEBUG: $*" > /dev/fd/2
	fi
}

set_variables_for_individual_package_check() {
	f=$1
	file $f \
	    | sed 's/^[^:]*://' \
	    | grep gzip >/dev/null
	if [ $? -eq 0 ] ; then
		TMPARCHIVE=$CHECKPKG_TMPDIR/`basename $f`
		if [[ -f $TMPARCHIVE ]] ; then
			print ERROR: $TMPARCHIVE already exists
			
		fi
		gzcat $f >$TMPARCHIVE || exit 1
		f=$TMPARCHIVE
	fi
	pkgname=`nawk 'NR == 2 {print $1; exit;}' $f`
	pkgnames="$pkgnames $pkgname"
}

if [[ "$1" == "-d" ]] ; then
	DEBUG=1
	shift
fi

if [[ "$1" == "-e" ]] ; then
	quit_on_warn=1;
	shift
fi
if [[ "$1" == "-h" ]] ; then
	print 'Usage: checkpkg [-d] [-e] pkg1 [pkg2 ....]'
	print '   -d  display debug messages'
	print '   -e  exit on warnings (soon to be obsolete)'
	shift
fi

# a unique filename for the list of package deps and libs we see in a 'set'
SETINF=$CHECKPKG_TMPDIR/checkpkg.$$.`date +%Y%m%d%H%M%S`
SETLIBS=$SETINF.libs
SETDEPS=$SETINF.deps
pkgnames=""
tmparchives=""

EXTRACTDIR=$CHECKPKG_TMPDIR/dissect.$$

if [ -d $EXTRACTDIR ] ; then
	print ERROR: $EXTRACTDIR already exists
	exit 1
fi

printf "Examining pkginfo files: "

for f in "$@"
do

if [[ ! -f $f ]] ; then
	print ERROR: $f does not exist
	exit 1
fi


debugmsg "Examining $f"
debugmsg "Looking for bad strings..."

# XPG4 grep has some kind of magical "ignore ELF header" power.
#  but... not on sol8, just sol10?
# and so does /bin/grep. but NOT /bin/egrep???
#
# Need to rewrite this whole thing to also
# check for badly set RUNPATHs. sigh.
#
# Using rot13 so that checkpkg can check itself without reporting
# an error.
badpaths="$(echo /rkcbeg/zrqhfn /bcg/ohvyq | gtr a-mn-z n-za-m)"
for badpath in $badpaths ; do
  GREP=/bin/grep gzgrep "$badpath" $f
  if [[ $? -eq 0 ]] ; then
    print ""
    print "ERROR: build-machine paths found in file $f"
    print "($badpath)"
    exit 1
  fi
done

set_variables_for_individual_package_check "$f"

[ -d ${EXTRACTDIR} ] || mkdir ${EXTRACTDIR}

# FIXME: This doesn't support multiple packages
TMPFILE=$EXTRACTDIR/pkginfo


printf "$pkgname "
dd if=$f skip=1 | (cd $EXTRACTDIR; cpio -ivd $pkgname/pkginfo >/dev/null 2>&1)
if [[ $? -ne 0 ]] ; then
	print "ERROR: could not extract $f"
	print "with (cd $EXTRACTDIR; cpio -ivd $pkgname/pkginfo)"
	ls -l $EXTRACTDIR
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
fi

mv $EXTRACTDIR/$pkgname/pkginfo $EXTRACTDIR ; rmdir $EXTRACTDIR/$pkgname

software=`sed -n 's/^NAME=\([^ -]*\) -.*$/\1/p' $TMPFILE`
version=`sed -n 's/^VERSION=//p' $TMPFILE`
desc=`sed -n 's/^DESC=//p' $TMPFILE`
email=`sed -n 's/^EMAIL=//p' $TMPFILE`
maintname=`sed -n 's/^VENDOR=.*for CSW by //p' $TMPFILE`
hotline=`sed -n 's/^HOTLINE=//p' $TMPFILE`
basedir=`sed -n 's/^BASEDIR=//p' $TMPFILE`
pkgarch=`sed -n 's/^ARCH=//p' $TMPFILE|head -1`

rm $TMPFILE

# strip out '' chars, because it interferes with mysql
desc=`print $desc | sed "s/'//g"`

#############################################################
# We now have the package expanded, in "directory" form, in
# $EXTRACTDIR/$pkgname
# Now do some extended error checking on it.
# This is similar to Debians "Lintian" phase for packages.

# TODO: Run this during the stats collection stage.
# /usr/sbin/pkgchk -d $EXTRACTDIR $pkgname || errmsg "Package failed integrity check"
# print "/usr/sbin/pkgchk passed."


########################################
# Check for some common errors
#########################################

# TODO: To be ported.
#
# # find all executables and dynamic libs,and list their filenames.
# if [[ "$basedir" != "" ]] ; then
# 	print
# 	if [[ -f $EXTRACTDIR/elflist ]] ; then
# 		print "Checking relocation ability..."
# 		xargs strings < $EXTRACTDIR/elflist| grep /opt/csw
# 		if [[ $? -eq 0 ]] ; then
# 			errmsg package build as relocatable, but binaries have hardcoded /opt/csw paths in them
# 		else
# 			print trivial check passed
# 		fi
# 	else
# 		echo No relocation check done for non-binary relocatable package.
# 	fi
# fi

tmparchives="$tmparchives $TMPARCHIVE"
done

# Terminating the line with pkgnames
echo

# Plugin section.
#
# Plugins should live in checkpkg.d subdirectory in the same directory in which
# checkpkg is.  Each plugin file name should be an executable and begin with
# "checkpkg-".

set_variables_for_individual_package_check "$f"

test_suite_ok=1
checkpkg_module_dir=${command_basedir}/../lib/checkpkg.d
checkpkg_module_tag="checkpkg-"
checkpkg_stats_basedir="${HOME}/.checkpkg/stats"

# Cleaning up old *.pyc files which can cause grief.  This is because of the
# move of Python libraries.
for pyc_file in ${checkpkg_module_dir}/opencsw.pyc \
                ${checkpkg_module_dir}/checkpkg.pyc; do
  if [ -f "${pyc_file}" ]; then
    echo "Removing old pyc file: '${pyc_file}'"
    rm "${pyc_file}"
  fi
done

if [[ "${DEBUG}" != "" ]]; then
	extra_options="--debug"
fi

# /var/sadm/install/contents cache update
${command_basedir}/update_contents_cache.py
# Collects package stats to be later analyzed
${command_basedir}/checkpkg_collect_stats.py ${extra_options} "$@"

debugmsg "checkpkg_module_dir: '$checkpkg_module_dir'"
log_files=""
module_name_format="%-40s"
md5sums=`gmd5sum "$@" | awk '{print $1}'`
if [[ -d "${checkpkg_module_dir}" ]]; then
	for plugin in "${checkpkg_module_dir}/${checkpkg_module_tag}"*; do
		if [[ -x "${plugin}" ]]; then
			plugin_base_name=`basename ${plugin}`
			plugin_log="${EXTRACTDIR}/${plugin_base_name}.log"
			log_files="${log_files} ${plugin_log}"
			plugin_name="`echo ${plugin} | sed -e 's+.*/checkpkg-++' | sed -e 's+\.py$++'`"
			error_tag_file="tags.${plugin_name}"
			printf "${BOLD}${module_name_format}${COLOR_RESET} running..." "${plugin_name}"
			debugmsg "Executing: ${plugin} $extra_options -b \"${checkpkg_stats_basedir}\"" \
		                 "-o \"${EXTRACTDIR}/${error_tag_file}\" `echo ${md5sums}`"
			${plugin} \
				$extra_options \
				-b "${checkpkg_stats_basedir}" \
				-o "${EXTRACTDIR}/${error_tag_file}" \
				${md5sums} \
				> "${plugin_log}" 2>&1
			if [[ "$?" -ne 0 ]]; then
				printf "\r${module_name_format} ${RED}[ERROR]${COLOR_RESET}        \\n" "${plugin_name}"
				test_suite_ok=0
			else
				printf "\r${module_name_format} [Done]        \\n" "${plugin_name}"
			fi
		else
			debugmsg "'${plugin}' is not executable"
		fi
	done
else
	debugmsg "module dir ${checkpkg_module_dir} does not exist"
fi

for log_file in ${log_files}; do
	log_len=`gsed -e 's/\s\+//g' "${log_file}" | gtr -s '\n' | gwc -c | awk '{print $1}'`
	if [[ "${log_len}" -gt 1 ]]; then
		print "printing ${log_file}..."
		debugmsg ">> LOG START: ${log_file}"
		cat "${log_file}"
		debugmsg "<< LOG END: ${log_file}"
	else
		debugmsg "-- LOG ${log_file} is empty"
	fi
done

# This check is special; it uses one executable for all the checks written in Python.
print "Running Python tests..."
${command_basedir}/checkpkg_run_modules.py \
    ${extra_options} \
    -b "${checkpkg_stats_basedir}" \
    -o "${EXTRACTDIR}/tags.python-checks" \
    ${md5sums}
if [[ "$?" -ne 0 ]]; then
  print "There was a problem running Python tests."
  test_suite_ok=0
else
  print "Python tests done."
fi

if [[ ${test_suite_ok} -ne 1 ]]; then
	errmsg "One or more modular tests have finished with an error."
else
	print "All modular tests completed.  Analyzing the reports."
fi

if [[ "${DEBUG}" != "" ]]; then
	override_info_printed=0
	for tagfile in ${EXTRACTDIR}/tags.*; do
		if [[ -s "${tagfile}" ]]; then
			if [[ "${override_info_printed}" -ne 1 ]]; then
				echo "# You can use the following lines to create overrides"
				echo "# See http://wiki.opencsw.org/checkpkg"
				override_info_printed=1
			fi
			echo "# ${tagfile}:"
			cat "${tagfile}"
		fi
	done
fi

# Collecting errors and applying the overrides.
# This has to use the original files.
${command_basedir}/analyze_module_results.py \
    -e "${EXTRACTDIR}" \
    "$@"
if [[ "$?" -ne 0 ]]; then
	errmsg "${RED}Modular checks are reporting errors.${COLOR_RESET}"
else
	print "${GREEN}All modular tests were successful.${COLOR_RESET}"
fi

print ""

# Cleaning up after all packages
cleanup

cleanupset
