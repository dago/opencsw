#!/bin/ksh -p
# 
# $Id$
#
# checkpkg 1.51
#
# diff to 1.46a
#  - check multiple package files
#  - checkpkg.d plugin support
#  - getopts support for command line options
#  - colors
#  - modular architecture + unit tests
#  - 
#
# This script examines a package that has been put together
# for submittal to the CSW archive at opencsw.org
#
# It examines it for compliance with the packaging standards at
# http://www.opencsw.org/standards/
# It DOES NOT CATCH EVERYTHING. However, the package will be
# tested with this script before acceptance, so you may as well
# save yourself some time, and run the script yourself!
#
# Be sure to occasionally do a "pkg-get update cswutils" so that
# you know you are tracking the most current version.
# 
# TODOs before commit:
#  - bad strings check
#  - pkgchk run
#

PATH=$PATH:/usr/sbin
readonly NAME_MAX_LENGTH=${NAME_MAX_LENGTH:-20}

command_basename=`basename $0`
command_basedir="${0%/${command_basename}}"
libshdir="${command_basedir}/../lib/sh"
readonly command_basename command_basedir libshdir
. "${libshdir}/libcheckpkg.sh"

LOCAL_ARCH=`uname -p`
CHECKPKG_TMPDIR=${CHECKPKG_TMPDIR:-/var/tmp}
readonly CHECKPKG_TMPDIR

# Colors only when running interactively
if [[ -t 1 ]]; then
	GREEN="\\033[0;32;40m"
	RED="\\033[1;31;40m"
	BOLD="\\033[1m"
	COLOR_RESET="\\033[00m"
else
	GREEN=""
	RED=""
	BOLD=""
	COLOR_RESET=""
fi
readonly GREEN RED BOLD COLOR_RESET

readonly selfpath="$0"
readonly selfargs="$@"

# always print out a warning message. (to stderr)
# exit script, if quit_on_warn set


cleanup(){
	if [[ -d "$EXTRACTDIR" ]] ; then
		rm -rf $EXTRACTDIR
	fi
	cleantmparchives
}

cleantmparchives() {
	for TMPARCHIVE in $tmparchives; do
		if [[ "$TMPARCHIVE" != "" ]]; then
			[ -f "$TMPARCHIVE" ] && rm $TMPARCHIVE
		fi
	done
}

cleanupset(){
    if [ "`echo $SETINF*`" != "$SETINF*" ]; then
	rm $SETINF*
    fi
}
warnmsg(){
	print WARNING: $* >/dev/fd/2
	if [[ "$quit_on_warn" != "" ]] ; then
		cleanup
		exit 1
	fi
}

# Print error message, and quit program.
errmsg(){
	print ERROR: $* >/dev/fd/2
	cleanup
	cleanupset
	print "To run checkpkg in the debug mode, add the '-d' flag, for example:"
	# print "${selfpath} -d ${selfargs}"
	print "After you modify any overrides, you need to do gmake remerge repackage"
	print "or gmake platforms-remerge platforms-repackage."
	exit 1
}

debugmsg() {
	if [[ "${DEBUG}" != "" ]]; then
		print "DEBUG: $*" > /dev/fd/2
	fi
}

# TODO: Options to add:
#  - Use an pre-cached (from a catalog file?) list of md5 sums
#  - Don't use the data from /var/sadm/install/contents
SAVE_TAGS=0
display_help=0
SKIP_STATS_COLLECTION=0
MD5_SUMS_CATALOG_FILE=""

while getopts hsdNM: opt; do
	case "${opt}" in
	  s)
      SAVE_TAGS=1
      SAVED_TAGS_FILE=error-tags.txt
      ;;
    d)
      DEBUG=1
      ;;
    e)
      quit_on_warn=1
      ;;
    h)
      display_help=1
      ;;
    N)
      SKIP_STATS_COLLECTION=1
      ;;
    M)
      MD5_SUMS_CATALOG_FILE="${OPTARG}"
      ;;
    *)
      echo "Unknown option '${opt}'"
      ;;
  esac
done
shift $(( $OPTIND -1 ))

readonly SAVE_TAGS SAVED_TAGS_FILE MD5_SUMS_CATALOG_FILE

if [[ "${display_help}" -eq 1 ]] ; then
	print 'Usage: checkpkg [options] pkg1 [pkg2 ....]'
	print 'Options:'
	print '   -s  save error tags on disk'
	print '   -d  display debug messages'
	print '   -e  exit on warnings (soon to be obsolete)'
	exit 0
fi

if [[ "${SAVE_TAGS}" -eq 1 ]]; then
  if [[ -f "${SAVED_TAGS_FILE}" ]]; then
  	rm "${SAVED_TAGS_FILE}"
  fi
fi

# a unique filename for the list of package deps and libs we see in a 'set'
SETINF=$CHECKPKG_TMPDIR/checkpkg.$$.`date +%Y%m%d%H%M%S`
SETLIBS=$SETINF.libs
SETDEPS=$SETINF.deps
pkgnames=""
tmparchives=""

EXTRACTDIR=$CHECKPKG_TMPDIR/dissect.$$

if [ -d $EXTRACTDIR ] ; then
	errmsg ERROR: $EXTRACTDIR already exists
fi

for f in "$@"
do

  if [[ ! -f $f ]] ; then
    errmsg ERROR: $f does not exist
  fi


[ -d ${EXTRACTDIR} ] || mkdir ${EXTRACTDIR}

########################################
# Check for some common errors
#########################################

# TODO: To be ported.
#
# # find all executables and dynamic libs,and list their filenames.
# if [[ "$basedir" != "" ]] ; then
# 	print
# 	if [[ -f $EXTRACTDIR/elflist ]] ; then
# 		print "Checking relocation ability..."
# 		xargs strings < $EXTRACTDIR/elflist| grep /opt/csw
# 		if [[ $? -eq 0 ]] ; then
# 			errmsg package build as relocatable, but binaries have hardcoded /opt/csw paths in them
# 		else
# 			print trivial check passed
# 		fi
# 	else
# 		echo No relocation check done for non-binary relocatable package.
# 	fi
# fi

tmparchives="$tmparchives $TMPARCHIVE"
done

# Plugin section.  This is here for support for other programming languages
# than Python.  As of 2010-03-16 there are no checks in there.  If this keeps
# empty, if no checks in other languages get written, it could be removed.
#
# Plugins should live in checkpkg.d subdirectory in the same directory in which
# checkpkg is.  Each plugin file name should be an executable and begin with
# "checkpkg-".

test_suite_ok=1
checkpkg_module_dir=${command_basedir}/../lib/checkpkg.d
checkpkg_module_tag="checkpkg-"
checkpkg_stats_basedir="${HOME}/.checkpkg/stats"

# Cleaning up old *.pyc files which can cause grief.  This is because of the
# move of Python libraries.
for pyc_file in ${checkpkg_module_dir}/opencsw.pyc \
                ${checkpkg_module_dir}/checkpkg.pyc; do
  if [ -f "${pyc_file}" ]; then
    echo "Removing old pyc file: '${pyc_file}'"
    rm "${pyc_file}"
  fi
done

if [[ "${DEBUG}" != "" ]]; then
	extra_options="--debug"
fi

# /var/sadm/install/contents cache update
${command_basedir}/update_contents_cache.py
if [[ "${SKIP_STATS_COLLECTION}" -eq 0 ]]; then
  # Collects package stats to be later analyzed
  ${command_basedir}/checkpkg_collect_stats.py ${extra_options} "$@"
  if [[ "$?" -ne 0 ]]; then
    errmsg "Stats collection phase has failed."
  fi
fi

debugmsg "checkpkg_module_dir: '$checkpkg_module_dir'"
log_files=""
module_name_format="%-40s"
# TODO: A performance problem. The following line means that the md5sums are
# calculated once more.
debugmsg "Calculating md5 sums of all the package files."
md5sums=`gmd5sum "$@" | awk '{print $1}'`
debugmsg "All md5 sums: ${md5sums}"
if [[ -d "${checkpkg_module_dir}" ]]; then
	for plugin in "${checkpkg_module_dir}/${checkpkg_module_tag}"*; do
		if [[ -x "${plugin}" ]]; then
			plugin_base_name=`basename ${plugin}`
			plugin_log="${EXTRACTDIR}/${plugin_base_name}.log"
			log_files="${log_files} ${plugin_log}"
			plugin_name="`echo ${plugin} | sed -e 's+.*/checkpkg-++' | sed -e 's+\.py$++'`"
			error_tag_file="tags.${plugin_name}"
			debugmsg "Executing: ${plugin} $extra_options -b \"${checkpkg_stats_basedir}\"" \
		           "-o \"${EXTRACTDIR}/${error_tag_file}\" `echo ${md5sums}`"
			printf "${BOLD}${module_name_format}${COLOR_RESET} running..." "${plugin_name}"
			${plugin} \
				$extra_options \
				-b "${checkpkg_stats_basedir}" \
				-o "${EXTRACTDIR}/${error_tag_file}" \
				${md5sums} \
				> "${plugin_log}" 2>&1
			if [[ "$?" -ne 0 ]]; then
				printf "\r${module_name_format} ${RED}[ERROR]${COLOR_RESET}        \\n" \
				       "${plugin_name}"
				test_suite_ok=0
			else
				printf "\r${module_name_format} [Done]        \\n" "${plugin_name}"
			fi
		else
			debugmsg "'${plugin}' is not executable"
		fi
	done
else
	debugmsg "module dir ${checkpkg_module_dir} does not exist"
fi

for log_file in ${log_files}; do
	log_len=`gsed -e 's/\s\+//g' "${log_file}" | gtr -s '\n' | gwc -c | awk '{print $1}'`
	if [[ "${log_len}" -gt 1 ]]; then
		print "printing ${log_file}..."
		debugmsg ">> LOG START: ${log_file}"
		cat "${log_file}"
		debugmsg "<< LOG END: ${log_file}"
	else
		debugmsg "-- LOG ${log_file} is empty"
	fi
done

# This check is special; it uses one executable for all the checks written in Python.
print "Analyzing collected statistics..."
${command_basedir}/checkpkg_run_modules.py \
    ${extra_options} \
    -b "${checkpkg_stats_basedir}" \
    -o "${EXTRACTDIR}/tags.python-checks" \
    ${md5sums}
if [[ "$?" -ne 0 ]]; then
  print "There was a problem analyzing package stats."
  test_suite_ok=0
fi

if [[ ${test_suite_ok} -ne 1 ]]; then
	errmsg "One or more tests have finished with an error."
fi

if [[ "${DEBUG}" != "" ]]; then
	override_info_printed=0
	for tagfile in ${EXTRACTDIR}/tags.*; do
		if [[ -s "${tagfile}" ]]; then
			if [[ "${override_info_printed}" -ne 1 ]]; then
				echo "# You can use the following lines to create overrides"
				echo "# See http://wiki.opencsw.org/checkpkg"
				override_info_printed=1
			fi
			echo "# ${tagfile}:"
			cat "${tagfile}"
		fi
    if [[ "${SAVE_TAGS}" -eq 1 ]]; then
    	echo "Saving ${tagfile} to `pwd`/${SAVED_TAGS_FILE}"
      cat "${tagfile}" >> "${SAVED_TAGS_FILE}"
    fi
	done
fi

# Collecting errors and applying the overrides.
# This has to use the original files.
${command_basedir}/analyze_module_results.py \
    -e "${EXTRACTDIR}" \
    "$@"
if [[ "$?" -ne 0 ]]; then
	errmsg "${RED}Modular checks are reporting errors.${COLOR_RESET}"
else
	print "${GREEN}All modular tests were successful.${COLOR_RESET}"
fi

print ""

# Cleaning up after all packages
cleanup

cleanupset
