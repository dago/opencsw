#!/bin/ksh -p
# 
# $Id$
#
# checkpkg 1.51
#
# diff to 1.46a
#  - check multiple package files
#  - checkpkg.d plugin support
#
# This script examines a package that has been put together
# for submittal to the CSW archive at opencsw.org
#
# It examines it for compliance with the packaging standards at
# http://www.opencsw.org/standards/
# It DOES NOT CATCH EVERYTHING. However, the package will be
# tested with this script before acceptance, so you may as well
# save yourself some time, and run the script yourself!
#
# Be sure to occasionally do a "pkg-get update cswutils" so that
# you know you are tracking the most current version.
# 


PATH=$PATH:/usr/sbin

LOCAL_ARCH=`uname -p`
if [[ -z "${CHECKPKG_TMPDIR}" ]]; then
  readonly CHECKPKG_TMPDIR="/var/tmp"
else
  readonly CHECKPKG_TMPDIR
fi

# Colors only when running interactively
if [[ -t 1 ]]; then
	GREEN="\\033[0;32;40m"
	RED="\\033[1;31;40m"
	COLOR_RESET="\\033[00m"
else
	GREEN=""
	RED=""
	COLOR_RESET=""
fi

# always print out a warning message. (to stderr)
# exit script, if quit_on_warn set


cleanup(){
	if [[ -d "$EXTRACTDIR" ]] ; then
		rm -rf $EXTRACTDIR
	fi
	cleantmparchives
}

cleantmparchives() {
	for TMPARCHIVE in $tmparchives; do
		if [[ "$TMPARCHIVE" != "" ]]; then
			[ -f "$TMPARCHIVE" ] && rm $TMPARCHIVE
		fi
	done
}

cleanupset(){
    if [ "`echo $SETINF*`" != "$SETINF*" ]; then
	rm $SETINF*
    fi
}
warnmsg(){
	print WARNING: $* >/dev/fd/2
	if [[ "$quit_on_warn" != "" ]] ; then
		cleanup
		exit 1
	fi
}

# Print error message, and quit program.
errmsg(){
	print ERROR: $* >/dev/fd/2
	cleanup
	cleanupset
	exit 1
}

debugmsg() {
	if [[ "${DEBUG}" != "" ]]; then
		print "DEBUG: $*" > /dev/fd/2
	fi
}

set_variables_for_individual_package_check() {
	f=$1
	file $f \
	    | sed 's/^[^:]*://' \
	    | grep gzip >/dev/null
	if [ $? -eq 0 ] ; then
		TMPARCHIVE=$CHECKPKG_TMPDIR/`basename $f`
		if [[ -f $TMPARCHIVE ]] ; then
			print ERROR: $TMPARCHIVE already exists
			
		fi
		gzcat $f >$TMPARCHIVE || exit 1
		f=$TMPARCHIVE
	fi
	pkgname=`nawk 'NR == 2 {print $1; exit;}' $f`
	pkgnames="$pkgnames $pkgname"
}

if [[ "$1" == "-d" ]] ; then
	DEBUG=1
	shift
fi

if [[ "$1" == "-e" ]] ; then
	quit_on_warn=1;
	shift
fi
if [[ "$1" == "-h" ]] ; then
	print 'Usage: checkpkg [-e] pkg1 [pkg2 ....]'
	print '   -e = "exit on warnings"'
	shift
fi

# a unique filename for the list of package deps and libs we see in a 'set'
SETINF=$CHECKPKG_TMPDIR/checkpkg.$$.`date +%Y%m%d%H%M%S`
SETLIBS=$SETINF.libs
SETDEPS=$SETINF.deps
pkgnames=""
tmparchives=""

EXTRACTDIR=$CHECKPKG_TMPDIR/dissect.$$

if [ -d $EXTRACTDIR ] ; then
	print ERROR: $EXTRACTDIR already exists
	exit 1
fi

for f in "$@"
do



if [[ ! -f $f ]] ; then
	print ERROR: $f does not exist
	exit 1
fi


case $f in
	*)
	print Examining $f

	print Looking for bad strings...

	# XPG4 grep has some kind of magical "ignore ELF header" power.
	#  but... not on sol8, just sol10?
	# and so does /bin/grep. but NOT /bin/egrep???
	#
	# Need to rewrite this whole thing to also
	# check for badly set RUNPATHs. sigh.
	#
	# Using rot13 so that checkpkg can check itself without reporting
	# an error.
	badpaths="$(echo /rkcbeg/zrqhfn /bcg/ohvyq | gtr a-mn-z n-za-m)"
	for badpath in $badpaths ; do
		GREP=/bin/grep gzgrep "$badpath" $f
		if [[ $? -eq 0 ]] ; then
			print ""
			print ERROR: build-machine paths found in file $f
			print '($badpath)'
			exit 1
		fi
	done
esac

print Extracting all files for more detailed inspection...

set_variables_for_individual_package_check "$f"

mkdir $EXTRACTDIR

# FIXME: This doesn't support multiple packages
TMPFILE=$EXTRACTDIR/pkginfo


dd if=$f skip=1 | (cd $EXTRACTDIR; cpio -ivd $pkgname/pkginfo)
if [[ $? -ne 0 ]] ; then
	print ERROR: could not extract $f
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
fi

mv $EXTRACTDIR/$pkgname/pkginfo $EXTRACTDIR ; rmdir $EXTRACTDIR/$pkgname

software=`sed -n 's/^NAME=\([^ -]*\) -.*$/\1/p' $TMPFILE`
version=`sed -n 's/^VERSION=//p' $TMPFILE`
desc=`sed -n 's/^DESC=//p' $TMPFILE`
email=`sed -n 's/^EMAIL=//p' $TMPFILE`
maintname=`sed -n 's/^VENDOR=.*for CSW by //p' $TMPFILE`
hotline=`sed -n 's/^HOTLINE=//p' $TMPFILE`
basedir=`sed -n 's/^BASEDIR=//p' $TMPFILE`
pkgarch=`sed -n 's/^ARCH=//p' $TMPFILE|head -1`

case $software in
     *[A-Z]*)
	echo ERROR: $software must be all lowercase
	exit 1
	;;
esac

case `basename $f` in
	${software}-${version}-*)
		# file name looks okay
	;;
	${software}-*)
		print ERROR: filename missing full version field $version
		rm -rf $EXTRACTDIR $TMPARCHIVE
		 exit 1
	;;
	*)
		print ERROR: filename  should start with $software-$version-
		rm -rf $EXTRACTDIR $TMPARCHIVE
		exit  1
esac



if [ "$maintname" = "" ] ; then
	# the old format, in the DESC field
	maintname=`sed -n 's/^DESC=.*for CSW by //p' $TMPFILE`

	# Since the DESC field has been coopted, take
	# description from second half of NAME field now.
	desc=`sed -n 's/^NAME=[^ -]* - //p' $TMPFILE`
else
	if [ "$desc" = "" ] ; then
		desc=`sed -n 's/^NAME=[^ -]* - //p' $TMPFILE`
	fi
fi

rm $TMPFILE

# strip out '' chars, because it interferes with mysql
desc=`print $desc | sed "s/'//g"`


print Info for pkg $pkgname

print software= "'$software'"
print arch= "'$pkgarch'"
print desc="'$desc'"
print pkgname="'$pkgname'"
print version="'$version'"
print maintainer name="'$maintname'"
print maint email="'$email'"
print hotline="'$hotline'"
if [ "$basedir" != "" ] ; then
	print basedir="'$basedir'"
fi

if [[ ${#software} -gt 20 ]] ; then errmsg $f: software name greater than 20 chars ; fi
if [[ ${#pkgname} -gt 20 ]] ; then errmsg $f: pkg name greater than 20 chars; fi

if [ "$software" = "" ] ; then errmsg $f: software field not set properly in NAME ; fi
if [ "$pkgname" = "" ] ; then errmsg $f: pkgname field blank ; fi
if [ "$desc" = "" ] ; then errmsg $f: no description in either NAME or DESC field ; fi
if [ ${#desc} -gt 100 ] ; then errmsg $f: description greater than 100 chars ; fi
if [ "$version" = "" ] ; then errmsg $f: VERSION field blank ;  fi
if [ "$maintname" = "" ] ; then errmsg $f: maintainer name not detected. Fill out VENDOR field properly ; fi
if [ "$email" = "" ] ; then errmsg $f: EMAIL field blank ; fi
if [ "$hotline" = "" ] ; then errmsg $f: HOTLINE field blank ; fi


case $version in
	*-*)
		print ERROR: VERSION field not allowed to have '"-"' in it
		exit 1
	;;
	*,REV=20[01][0-9].[0-9][0-9].[0-9][0-9]*)
		:
	;;
	*)
		print ERROR: no REV=YYYY.MM.DD field in VERSION
		exit 1
	;;
esac

case $pkgarch in
	sparc|i386|all)
	;;
	sparc.*|i386.*)
	;;

	*)
	print ERROR: non-standard ARCH def in package: $pkgarch
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
esac

case $f in
  *${pkgarch}*)
    print "f: $f, pkgarch: $pkgarch"
    ;;
  *)
    print "The file name is '$f'."
    print "The pkgarch is '$pkgarch'."
    errmsg "ERROR: package file name and pkgarch don't match."
    ;;
esac

goodarch=yes
case $f in
	*${LOCAL_ARCH}*)
		
	;;
	*)
		print NOTE: pkg must be for arch $LOCAL_ARCH to check dynamic libs
		goodarch=no		
	;;
esac


#if [ "$goodarch" = "no" ] ; then
#	# neutral architechture. cant check libraries for it.
#	print ""
#	rm -rf $EXTRACTDIR $TMPARCHIVE
#	exit 0
#fi


# This function exists, because pkgtrans is BROKEN!!
# It leaves a directory in /var/tmp/aaXXXXXXX, even after clean quit
# SO, emulate pkgtrans behaviour, for "pkgtrans src destdir pkgname"
#   Except that we ignore pkgname arg, and just do first one we find.
#  and we are a bit hacky about how we do things.
pkgtrans(){
	if [[ ! -d $2 ]] ; then
		print ERROR: $2 is not a directory >/dev/fd/2
		return 1
	fi
	hdrblks=`(dd if=$1 skip=1 2>/dev/null| cpio -i -t  >/dev/null) 2>&1 |
		nawk '{print $1; exit;}'`

	## print initial hdrblks=$hdrblks

	hdrblks=$(($hdrblks + 1))
	mkdir $2/$3 || return 1

	dd if=$1 skip=$hdrblks 2>/dev/null | (cd $2/$3 ; cpio -ivdm)
	# on fail, SOMETIMES cpio returns 1, but sometimes it returns 0!!
	if [[ ! -d $2/$3/install ]] ; then
		print retrying extract with different archive offset...
		# no, I cant tell in advance why/when the prev fails
		hdrblks=$(($hdrblks + 1))
		dd if=$1 skip=$hdrblks 2>/dev/null| (cd $2/$3 ; cpio -ivdm)
	fi
}

print ""
print Extracing pkg for examination of files...
pkgtrans $f $EXTRACTDIR $pkgname

#############################################################
# We now have the package expanded, in "directory" form, in
# $EXTRACTDIR/$pkgname
# Now do some extended error checking on it.
# This is similar to Debians "Lintian" phase for packages.

/usr/sbin/pkgchk -d $EXTRACTDIR $pkgname || errmsg "Package failed integrity check"

print "/usr/sbin/pkgchk passed."


########################################
# Check for some common errors
if [[ $pkgname != "CSWcommon" ]] ; then

	if [[ $LOGNAME != "root" ]] ; then
		nawk '$6 == "'$LOGNAME'" {print; exit 1}' $EXTRACTDIR/$pkgname/pkgmap
		if [[ $? -eq 1 ]] ; then
			print ERROR: files owned by $LOGNAME in prototype file
			rm -rf $EXTRACTDIR $TMPARCHIVE
			exit 1
		fi
	fi

	egrep 'd none /opt ' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	errmsg You should not have an entry for /opt in your prototype file
	fi
	egrep 'd none [^ ]* 06' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	errmsg You must have execute permission set on directories
	fi
	egrep '/opt/csw/man|d none man' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	errmsg /opt/csw/man should not have a directory entry in prototype
	fi
	egrep '/opt/csw/doc|d none doc' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	errmsg /opt/csw/doc should not have a directory entry in prototype
	fi
	egrep '/opt/csw/info|d none info' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	errmsg /opt/csw/info should not have a directory entry in prototype
	fi
	egrep 'lib/charset.alias' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	warnmsg Only CSWiconv should have lib/charset.alias in it
	fi
	egrep 'share/locale/locale.alias' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	warnmsg Only CSWcommon should have share/locale/locale.alias in it
	fi
	fgrep  '? ? ?' $EXTRACTDIR/$pkgname/pkgmap |
	egrep '[/]opt[/]csw'
	if [[ $? -eq 0 ]] ; then
	errmsg "You should only use '? ? ?' for non-csw paths. Use appropriate explicit perms/ownership instead"
	fi
	# this is like "installed package info". It is acceptible
	# to update it in a postinstall script, but not have it
	# directly in the pkgmap. A "e" entry might be acceptible though.
	egrep ' f .*/perllocal.pod' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	errmsg perllocal.pod should be removed from prototype file
	fi
fi
# special case. sigh.
if [[ $pkgname != "CSWtexinfo" ]] ; then
	egrep '/opt/csw/share/info/dir[ ]|none share/info/dir[ ]' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	errmsg /opt/csw/share/info/dir should only be in CSWtexinfo
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
	fi
fi
#########################################
# find all executables and dynamic libs,and list their filenames.
listbinaries() {
	if [ ! -d $1 ] ; then
		print errmsg $1 not a directory
		rm -rf $EXTRACTDIR
		exit 1
	fi

	find $1 -print | xargs file |grep ELF |nawk -F: '{print $1}'
}




if [[ "$goodarch" = "yes" ]] ; then
	# man ld.so.1 for more info on this hack
	export LD_NOAUXFLTR=1

	listbinaries $EXTRACTDIR/$pkgname >$EXTRACTDIR/elflist
	# have to do this for ldd to work. arrg.
	if [ -s "$EXTRACTDIR/elflist" ] ; then
		chmod 0755 `cat $EXTRACTDIR/elflist`

	#cat $EXTRACTDIR/elflist| xargs ldd  2>/dev/null |fgrep  '.so' |
	#              sed 's:^.*=>[^/]*::' | nawk '{print $1}' |sort -u >$EXTRACTDIR/liblist

		cat $EXTRACTDIR/elflist| xargs /usr/ccs/bin/dump -Lv |nawk '$2=="NEEDED"{print $3}' |
			sort -u | egrep -v $EXTRACTDIR >$EXTRACTDIR/liblist

			

		print libraries used are:
		cat $EXTRACTDIR/liblist
		print "cross-referencing with depend file (May take a while)"
	else
		print No dynamic libraries in the package
	fi
fi

#If these dont exist, it is Bad.
touch $EXTRACTDIR/liblist $EXTRACTDIR/libpkgs

# store things that look like shared objects from the package map for
# delayed library validation.
grep "\.so" $EXTRACTDIR/$pkgname/pkgmap >> $SETLIBS

if [[ -f $EXTRACTDIR/$pkgname/install/depend ]] ; then
	print 
	print "Examining 'depend' file"
else
	# They may have forgotten to create/add in a depend file
	# Remind people what the package depends on
	# print "Analysing dynamic dependancies, if any"
	touch $EXTRACTDIR/$pkgname/install/depend
fi

# sanity check against "depends on self"
nawk '$2=="'$pkgname'" {exit 1}' $EXTRACTDIR/$pkgname/install/depend
if [[ $? -ne 0 ]] ; then
	print ERROR: $pkgname references self in depend file
	exit 1
fi

# Verify that there are no multiple depends
repeated_depends="$(awk '{print $2}' $EXTRACTDIR/$pkgname/install/depend \
  | sort | uniq -c | awk '{print $1}' | sort | uniq | wc -l)"
if [[ "$repeated_depends" -gt 1 ]]; then
        cat $EXTRACTDIR/$pkgname/install/depend
        errmsg "$pkgname has multiple depends"
fi

#to retain a record of all packages currently being examined from $@
echo $pkgname >> $SETDEPS

nawk '$1=="P" {print $2}'  $EXTRACTDIR/$pkgname/install/depend |
	sort >$EXTRACTDIR/deppkgs
for dep in `cat $EXTRACTDIR/deppkgs`
do
    pkginfo $dep
    if [[ $? -ne 0 ]]; then
	#if we've already looked at the package named $dep,
	#it'll be in the file.
 	awk "\$1 == \"$dep\" {print}" $SETDEPS | /usr/bin/grep $dep >/dev/null
 	if [[ $? -ne 0 ]]; then #we haven't yet seen this package in our set
	    echo "Can't validate dependence on $dep.  Storing for delayed validation."
	    #store for validation at the end.
	    echo "$dep $pkgname" >> $SETDEPS.missing
	else
	    echo "Found $dep as part of the package set being evaluated."
	fi
    fi
done

if [[ "$basedir" != "" ]] ; then
	print
	if [[ -f $EXTRACTDIR/elflist ]] ; then
		print "Checking relocation ability..."
		xargs strings < $EXTRACTDIR/elflist| grep /opt/csw
		if [[ $? -eq 0 ]] ; then
			errmsg package build as relocatable, but binaries have hardcoded /opt/csw paths in them
		else
			print trivial check passed
		fi
	else
		echo No relocation check done for non-binary relocatable package.
	fi
fi

# Plugin section.
#
# Plugins should live in checkpkg.d subdirectory in the same directory in which
# checkpkg is.  Each plugin file name should be an executable and begin with
# "checkpkg-".

tmparchives="$tmparchives $TMPARCHIVE"
done

# All packages have been extracted.

set_variables_for_individual_package_check "$f"

echo "Running modular tests"
test_suite_ok=1
checkpkg_scriptname=`basename $0`
checkpkg_basedir=${0%/${checkpkg_scriptname}}
plugindir=${checkpkg_basedir}/checkpkg.d

# /var/sadm/install/contents cache update
${plugindir}/update_contents_cache.py

if [[ "${DEBUG}" != "" ]]; then
	extra_options="--debug"
fi
debugmsg "plugindir: '$plugindir'"
log_files=""
if [[ -d "$plugindir" ]]; then
	# echo plugin dir exists
	for plugin in "${plugindir}"/checkpkg-*; do
		if [[ -x "${plugin}" ]]; then
			debugmsg "Executing: ${plugin} $extra_options -e \"${EXTRACTDIR}\" ${pkgnames}"
			plugin_base_name=`basename ${plugin}`
			plugin_log="${EXTRACTDIR}/${plugin_base_name}.log"
			log_files="${log_files} ${plugin_log}"
			printf "TEST: ${plugin} running..."
			${plugin} $extra_options -e "${EXTRACTDIR}" ${pkgnames} > "${plugin_log}" 2>&1
			if [[ "$?" -ne 0 ]]; then
				printf "\rTEST: ${plugin} ${RED}[FAIL]${COLOR_RESET}        \\n"
				test_suite_ok=0
			else
				printf "\rTEST: ${plugin} ${GREEN}[OK]${COLOR_RESET}        \\n"
			fi
		else
			debugmsg "'${plugin}' is not executable"
		fi
	done
else
	debugmsg "plugin dir does not exist"
fi

echo
for log_file in ${log_files}; do
	if [[ -s "${log_file}" ]]; then
		echo "LOG START: ${log_file}"
		echo
		cat "${log_file}"
		echo
		echo "LOG END: ${log_file}"
	fi
done
echo

if [[ ${test_suite_ok} -ne 1 ]]; then
	errmsg "One or more modular tests have failed."
else
	print "All tests were successful."
fi

print ""

# Cleaning up after all packages
cleanup

if [ -s $SETDEPS.missing ]; then
    print "Doing late evaluations of package dependencies."
    while read mdep; do
	dep=`echo $mdep | nawk '{print $1}'`
	pkg=`echo $mdep | nawk '{print $2}'`
	/usr/bin/grep $dep $SETDEPS >/dev/null
	if [ $? -ne 0 ]; then
	    errmsg "Couldn't validate $dep as a dependency in package $pkg"
	else
	    print "Validated $dep as a dependency for $pkg."
	fi
    done < $SETDEPS.missing
fi

cleanupset
