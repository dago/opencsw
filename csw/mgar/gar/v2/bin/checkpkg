#!/bin/ksh -p
# 
# $Id$
#
# checkpkg 1.51
#
# diff to 1.46a
#  - check multiple package files
#  - checkpkg.d plugin support
#  - getopts support for command line options
#  - colors
#  - modular architecture + unit tests
#  - reliable shared library checking
#
# This script examines a package that has been put together
# for submittal to the CSW archive at opencsw.org
#
# It examines it for compliance with the packaging standards at
# http://www.opencsw.org/standards/
# It DOES NOT CATCH EVERYTHING. However, the package will be
# tested with this script before acceptance, so you may as well
# save yourself some time, and run the script yourself!
#
# Be sure to occasionally do a "pkg-get update cswutils" so that
# you know you are tracking the most current version.
# 
# TODO:
# - add message handlig to the CheckInterface class.
#

PATH=$PATH:/usr/sbin
readonly NAME_MAX_LENGTH=${NAME_MAX_LENGTH:-20}

command_basename=`basename $0`
command_basedir="${0%/${command_basename}}"
libshdir="${command_basedir}/../lib/sh"
readonly command_basename command_basedir libshdir
. "${libshdir}/libcheckpkg.sh"

LOCAL_ARCH=`uname -p`
CHECKPKG_TMPDIR=${CHECKPKG_TMPDIR:-/var/tmp}
readonly CHECKPKG_TMPDIR

# Colors only when running interactively
if [[ -t 1 ]]; then
	GREEN="\\033[0;32;40m"
	RED="\\033[1;31;40m"
	BOLD="\\033[1m"
	COLOR_RESET="\\033[00m"
else
	GREEN=""
	RED=""
	BOLD=""
	COLOR_RESET=""
fi
readonly GREEN RED BOLD COLOR_RESET

readonly selfpath="$0"
readonly selfargs="$@"

cleanup(){
	if [[ -d "$EXTRACTDIR" ]] ; then
		rm -rf $EXTRACTDIR
	fi
	cleantmparchives
}

cleantmparchives() {
	for TMPARCHIVE in $tmparchives; do
		if [[ "$TMPARCHIVE" != "" ]]; then
			[ -f "$TMPARCHIVE" ] && rm $TMPARCHIVE
		fi
	done
}

cleanupset(){
    if [ "`echo $SETINF*`" != "$SETINF*" ]; then
	rm $SETINF*
    fi
}

# Print error message, and quit program.
errmsg(){
	print ERROR: $* >/dev/fd/2
	cleanup
	cleanupset
	print "To run checkpkg in the debug mode, add the '-d' flag, for example:"
  # selfargs can be very, very long. Find a way to truncate it.
	# print "${selfpath} -d ${selfargs}"
	print "After you modify any overrides, you need to do gmake remerge repackage"
	print "or gmake platforms-remerge platforms-repackage."
	exit 1
}

debugmsg() {
	if [[ "${DEBUG}" != "" ]]; then
		print "DEBUG: $*" > /dev/fd/2
	fi
}

# TODO: Options to add:
#  - Use an pre-cached (from a catalog file?) list of md5 sums
#  - Don't use the data from /var/sadm/install/contents
SAVE_TAGS=0
SAVED_TAGS_FILE=error-tags.txt
display_help=0
SKIP_STATS_COLLECTION=0
MD5_SUMS_CATALOG_FILE=""
INSTALL_CONTENTS_FILES="/var/sadm/install/contents"

while getopts hsdNM:o:c: opt; do
	case "${opt}" in
	  c)
	    INSTALL_CONTENTS_FILES="${INSTALL_CONTENTS_FILES} ${OPTARG}"
	    ;;
	  s)
      SAVE_TAGS=1
      ;;
    o)
      SAVED_TAGS_FILE="${OPTARG}"
      ;;
    d)
      DEBUG=1
      ;;
    h)
      display_help=1
      ;;
    N)
      SKIP_STATS_COLLECTION=1
      ;;
    M)
      MD5_SUMS_CATALOG_FILE="${OPTARG}"
      ;;
    *)
      echo "Unknown option '${opt}'"
      ;;
  esac
done
shift $(( $OPTIND -1 ))

readonly INSTALL_CONTENTS_FILES
readonly MD5_SUMS_CATALOG_FILE
readonly SAVED_TAGS_FILE
readonly SAVE_TAGS
readonly SKIP_STATS_COLLECTION

if [[ "${display_help}" -eq 1 ]] ; then
  print 'Usage: checkpkg [options] pkg1 [pkg2 ....]'
  print 'Options:'
  print '   -c <file>  use an additional install/contents file'
  print '   -s         save error tags on disk'
  print '   -o <file>  save tag output to file'
  print '   -d         display debug messages'
  print '   -N         skip statistics collection'
  print '   -M <file>  use package md5sums from a catalog file'
  exit 0
fi

if [[ "${SAVE_TAGS}" -eq 1 ]]; then
  if [[ -f "${SAVED_TAGS_FILE}" ]]; then
  	rm "${SAVED_TAGS_FILE}"
  fi
fi

# a unique filename for the list of package deps and libs we see in a 'set'
SETINF=$CHECKPKG_TMPDIR/checkpkg.$$.`date +%Y%m%d%H%M%S`
SETLIBS=$SETINF.libs
SETDEPS=$SETINF.deps
pkgnames=""
tmparchives=""

EXTRACTDIR=$CHECKPKG_TMPDIR/dissect.$$

if [ -d $EXTRACTDIR ] ; then
	errmsg ERROR: $EXTRACTDIR already exists
fi

for f in "$@"
do

  if [[ ! -f $f ]] ; then
    errmsg ERROR: $f does not exist
  fi


[ -d ${EXTRACTDIR} ] || mkdir ${EXTRACTDIR}

########################################
# Check for some common errors
#########################################

# TODO: To be ported.
#
# # find all executables and dynamic libs,and list their filenames.
# if [[ "$basedir" != "" ]] ; then
# 	print
# 	if [[ -f $EXTRACTDIR/elflist ]] ; then
# 		print "Checking relocation ability..."
# 		xargs strings < $EXTRACTDIR/elflist| grep /opt/csw
# 		if [[ $? -eq 0 ]] ; then
# 			errmsg package build as relocatable, but binaries have hardcoded /opt/csw paths in them
# 		else
# 			print trivial check passed
# 		fi
# 	else
# 		echo No relocation check done for non-binary relocatable package.
# 	fi
# fi

tmparchives="$tmparchives $TMPARCHIVE"
done

# Plugin section.  This is here for support for other programming languages
# than Python.  As of 2010-03-16 there are no checks in there.  If this keeps
# empty, if no checks in other languages get written, it could be removed.
#
# Plugins should live in checkpkg.d subdirectory in the same directory in which
# checkpkg is.  Each plugin file name should be an executable and begin with
# "checkpkg-".

test_suite_ok=1
checkpkg_module_dir=${command_basedir}/../lib/checkpkg.d
checkpkg_module_tag="checkpkg-"
checkpkg_stats_basedir="${HOME}/.checkpkg/stats"

# Cleaning up old *.pyc files which can cause grief.  This is because of the
# move of Python libraries.
for pyc_file in ${checkpkg_module_dir}/opencsw.pyc \
                ${checkpkg_module_dir}/checkpkg.pyc; do
  if [ -f "${pyc_file}" ]; then
    echo "Removing old pyc file: '${pyc_file}'"
    rm "${pyc_file}"
  fi
done

if [[ "${DEBUG}" != "" ]]; then
	extra_options="--debug"
fi

if [[ -n "${MD5_SUMS_CATALOG_FILE}" ]]; then
	catalog_options="--catalog=${MD5_SUMS_CATALOG_FILE}"
else
	catalog_options=""
fi

# /var/sadm/install/contents cache update
${command_basedir}/update_contents_cache.py
if [[ "${SKIP_STATS_COLLECTION}" -eq 0 ]]; then
  # Collects package stats to be analyzed later
  ${command_basedir}/checkpkg_collect_stats.py \
      ${catalog_options} \
      ${extra_options} \
      "$@"
  if [[ "$?" -ne 0 ]]; then
    errmsg "Stats collection phase has failed."
  fi
fi

debugmsg "checkpkg_module_dir: '$checkpkg_module_dir'"
log_files=""
module_name_format="%-40s"
# TODO: A performance problem. The following line means that the md5sums are
# calculated once more.
if [ "${MD5_SUMS_CATALOG_FILE}" ]; then
	debugmsg "Reading md5sums from ${MD5_SUMS_CATALOG_FILE}"
	md5sums=`cat "${MD5_SUMS_CATALOG_FILE}" \
	    | awk '{print $5}' \
	    | ggrep -E '[0-9abcdef]{32}'`
else
  debugmsg "Calculating md5 sums of all the package files."
  md5sums=`gmd5sum "$@" | awk '{print $1}'`
fi
debugmsg "All md5 sums: ${md5sums}"
if [[ -d "${checkpkg_module_dir}" ]]; then
	for plugin in "${checkpkg_module_dir}/${checkpkg_module_tag}"*; do
		if [[ -x "${plugin}" ]]; then
			plugin_base_name=`basename ${plugin}`
			plugin_log="${EXTRACTDIR}/${plugin_base_name}.log"
			log_files="${log_files} ${plugin_log}"
			plugin_name="`echo ${plugin} | sed -e 's+.*/checkpkg-++' | sed -e 's+\.py$++'`"
			error_tag_file="tags.${plugin_name}"
			debugmsg "Executing: ${plugin} $extra_options -b \"${checkpkg_stats_basedir}\"" \
		           "-o \"${EXTRACTDIR}/${error_tag_file}\" `echo ${md5sums}`"
			printf "${BOLD}${module_name_format}${COLOR_RESET} running..." "${plugin_name}"
			${plugin} \
				$extra_options \
				-b "${checkpkg_stats_basedir}" \
				-o "${EXTRACTDIR}/${error_tag_file}" \
				${md5sums} \
				> "${plugin_log}" 2>&1
			if [[ "$?" -ne 0 ]]; then
				printf "\r${module_name_format} ${RED}[ERROR]${COLOR_RESET}        \\n" \
				       "${plugin_name}"
				test_suite_ok=0
			else
				printf "\r${module_name_format} [Done]        \\n" "${plugin_name}"
			fi
		else
			debugmsg "'${plugin}' is not executable"
		fi
	done
else
	debugmsg "module dir ${checkpkg_module_dir} does not exist"
fi

for log_file in ${log_files}; do
	log_len=`gsed -e 's/\s\+//g' "${log_file}" | gtr -s '\n' | gwc -c | awk '{print $1}'`
	if [[ "${log_len}" -gt 1 ]]; then
		print "printing ${log_file}..."
		debugmsg ">> LOG START: ${log_file}"
		cat "${log_file}"
		debugmsg "<< LOG END: ${log_file}"
	else
		debugmsg "-- LOG ${log_file} is empty"
	fi
done

# This check is special; it uses one executable for all the checks written in Python.
print "Analyzing collected statistics..."
${command_basedir}/checkpkg_run_modules.py \
    ${extra_options} \
    -b "${checkpkg_stats_basedir}" \
    -o "${EXTRACTDIR}/tags.python-checks" \
    ${md5sums}
if [[ "$?" -ne 0 ]]; then
  print "There was a problem analyzing package stats."
  test_suite_ok=0
fi

if [[ ${test_suite_ok} -ne 1 ]]; then
	errmsg "One or more tests have finished with an error."
fi

if [[ "${DEBUG}" != "" ]]; then
	override_info_printed=0
	for tagfile in ${EXTRACTDIR}/tags.*; do
		if [[ -s "${tagfile}" ]]; then
			if [[ "${override_info_printed}" -ne 1 ]]; then
				echo "# You can use the following lines to create overrides"
				echo "# See http://wiki.opencsw.org/checkpkg"
				override_info_printed=1
			fi
			echo "# ${tagfile}:"
			cat "${tagfile}"
		fi
    if [[ "${SAVE_TAGS}" -eq 1 ]]; then
    	echo "Saving ${tagfile} to `pwd`/${SAVED_TAGS_FILE}"
      cat "${tagfile}" >> "${SAVED_TAGS_FILE}"
    fi
	done
fi

# Collecting errors and applying the overrides.
# This has to use the original files.
${command_basedir}/analyze_module_results.py \
    -e "${EXTRACTDIR}" \
    "$@"
if [[ "$?" -ne 0 ]]; then
	errmsg "${RED}Modular checks are reporting errors.${COLOR_RESET}"
else
	print "${GREEN}All modular tests were successful.${COLOR_RESET}"
fi

print ""

# Cleaning up after all packages
cleanup

cleanupset
