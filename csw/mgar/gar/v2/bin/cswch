#!/usr/bin/env python
"""Maintain OpenCSW changelog.

The changelog files generated are modeled after the Debian changelog

 http://www.debian.org/doc/debian-policy/ch-source.html#s-dpkgchangelog

except that the header line for each entry is somewhat
simplyfied. Instead of using

 package (version) distribution(s); urgency=urgency

it uses

 package (version,REV=revision)

$Id$

"""
import argparse
import datetime
import dateutil.tz
import email.utils
import logging
import os
import pwd
import pysvn
import re
import sys
import time
import unittest
import errno

### T E S T S ###

class TestOpenCSWRev(unittest.TestCase):
    """Test opencsw_rev()"""

    def test_opencsw_rev(self):
        """revision string from date"""
        rev = ChangeLogHeader.opencsw_rev(datetime.date(1979, 1, 1))
        self.assertEqual(rev, '1979.01.01')

    def test_opencsw_rev_default(self):
        """revision from current date"""
        rev = ChangeLogHeader.opencsw_rev()
        self.assertEqual(rev, datetime.date.today().strftime('%Y.%m.%d'))


class TestChangeLogHeader(unittest.TestCase):
    """Test ChangeLogHeader"""

    def test_changelogheader(self):
        """initialize changelog header with keywords"""
        chlg = ChangeLogHeader(package='test', version='0.1', rev='1991.09.04')
        self.assertEqual('test (0.1,REV=1991.09.04)', str(chlg))

    def test_parser(self):
        """initialize changelog header from line"""
        chlg = ChangeLogHeader(line='test (0.1,REV=1991.09.04)')
        self.assertEqual('test (0.1,REV=1991.09.04)', str(chlg))

    def test_garbled(self):
        """test garbled changelog header"""
        self.assertRaises(GarbledChangeLogHeader,
                          ChangeLogHeader, line='test (0,REV=1991.9.4)')


class TestChangeLogFooter(unittest.TestCase):
    """Test ChangeLogFooter"""

    def test_changelogfooter(self):
        """initialize changelog footer from arguments"""
        chlg = ChangeLogFooter(maintainer="Rafael Ostertag",
                               email="raos@opencsw.org",
                               timestamp=datetime.datetime(1979, 1, 1,
                                                           0, 0, 0))
        self.assertEqual(' -- Rafael Ostertag <raos@opencsw.org>  Mon, 01 Jan 1979 00:00:00 +0100', str(chlg))

    def test_parser(self):
        """initialize changelog footer from line"""
        test_footer = ' -- Rafael Ostertag <raos@opencsw.org>  Sun, 16 Mar 2014 10:10:33 +0100'
        chlg = ChangeLogFooter(line=test_footer)
        self.assertEqual(test_footer, str(chlg))

    def test_garbled(self):
        """test garbled changelog footer"""
        self.assertRaises(GarbledChangeLogFooter,
                          ChangeLogFooter, line=' -- Rafael Ostertag <raos@opencsw.org>  Sun, 16 Mar 2014 10:10:33 +010')


class TestChangeLogParagraph(unittest.TestCase):
    """Test ChangeLogParagraph."""

    def test_init_single_line_bullet(self):
        """initialize ChangeLog paragraph with one line"""
        line = '  * Lorem ipsum dolor sit amet, consectetur adipiscing'
        chpg = ChangeLogParagraph(line)
        self.assertEqual(line, str(chpg))
        self.assertEqual('Lorem ipsum dolor sit amet, consectetur adipiscing',
                         repr(chpg))

    def test_init_single_line_plain(self):
        """initialize ChangeLog paragraph with one line"""
        line = '  Lorem ipsum dolor sit amet, consectetur adipiscing'
        chpg = ChangeLogParagraph(line)
        self.assertEqual(line, str(chpg))
        self.assertEqual('Lorem ipsum dolor sit amet, consectetur adipiscing',
                         repr(chpg))

    def test_line_add_bullet(self):
        """Test adding a new line to an existing paragraph"""
        line = "  * short line"
        chpg = ChangeLogParagraph(line)

        chpg.add_line("and another line appended")

        self.assertEqual('short line and another line appended', repr(chpg))
        self.assertEqual('  * short line and another line appended',
                         str(chpg))

    def test_line_add_plain(self):
        """Test adding a new line to an existing paragraph"""
        line = "  short line"
        chpg = ChangeLogParagraph(line)

        chpg.add_line("and another line appended")

        self.assertEqual('short line and another line appended', repr(chpg))
        self.assertEqual('  short line and another line appended',
                         str(chpg))


    def test_newline_handling_bullet(self):
        """test newline handling of ChangeLogParagraph"""
        lines = """  * Lorem ipsum dolor sit amet,
    consectetur adipiscing"""
        chpg = ChangeLogParagraph(lines)
        self.assertEqual('  * Lorem ipsum dolor sit amet, consectetur adipiscing', str(chpg))
        self.assertEqual('Lorem ipsum dolor sit amet, consectetur adipiscing', repr(chpg))

    def test_newline_handling_plain(self):
        """test newline handling of ChangeLogParagraph"""
        lines = """  Lorem ipsum dolor sit amet,
  consectetur adipiscing"""
        chpg = ChangeLogParagraph(lines)
        self.assertEqual('  Lorem ipsum dolor sit amet, consectetur adipiscing', str(chpg))
        self.assertEqual('Lorem ipsum dolor sit amet, consectetur adipiscing', repr(chpg))

    def test_init_from_multiple_lines(self):
        """Test initialization from multiple lines"""

        lines = ['  * Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent posuere est a pellentesque imperdiet.',
                  'Vivamus dapibus enim eu magna vehicula posuere. Pellentesque adipiscing purus id diam auctor gravida. Sed leo odio,',
                  'molestie quis ante sed, commodo consequat nulla. Vivamus interdum vel lorem eget faucibus. Suspendisse dignissim orci sit amet dolor venenatis convallis.',
                  'Suspendisse fringilla tortor vitae dolor blandit ullamcorper. Cras sed mauris eu lorem scelerisque blandit quis vel mauris. Nam a urna aliquet, cursus erat a, fermentum justo. Sed hendrerit dui magna, ac tempus est vestibulum at.',
                  'Duis in massa ut nisl euismod auctor nec ac odio. Phasellus suscipit neque quis metus vestibulum molestie. Phasellus eget molestie elit, et fringilla purus. Morbi augue lectus, mattis ut mauris onvallis, eleifend condimentum nunc. Phasellus sit amet facilisis massa. Cras non porttitor turpis.']
        formatted = """  * Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent
    posuere est a pellentesque imperdiet. Vivamus dapibus enim eu magna
    vehicula posuere. Pellentesque adipiscing purus id diam auctor
    gravida. Sed leo odio, molestie quis ante sed, commodo consequat
    nulla. Vivamus interdum vel lorem eget faucibus. Suspendisse
    dignissim orci sit amet dolor venenatis convallis. Suspendisse
    fringilla tortor vitae dolor blandit ullamcorper. Cras sed mauris eu
    lorem scelerisque blandit quis vel mauris. Nam a urna aliquet,
    cursus erat a, fermentum justo. Sed hendrerit dui magna, ac tempus
    est vestibulum at. Duis in massa ut nisl euismod auctor nec ac odio.
    Phasellus suscipit neque quis metus vestibulum molestie. Phasellus
    eget molestie elit, et fringilla purus. Morbi augue lectus, mattis
    ut mauris onvallis, eleifend condimentum nunc. Phasellus sit amet
    facilisis massa. Cras non porttitor turpis."""
        chpg = ChangeLogParagraph(*lines)
        self.assertEqual(formatted, str(chpg))


class TestChangeLogEntry(unittest.TestCase):
    """Test ChangeLogEntry class"""

    def test_entry(self):
        """Test a simple changelog entry"""
        clg_entry = ChangeLogEntry()
        clg_header = ChangeLogHeader(package='cswch', version='0.1')
        clg_paragraph1 = ChangeLogParagraph("  * One Line")
        clg_paragraph2 = ChangeLogParagraph("  * Two Lines")
        clg_footer = ChangeLogFooter()

        clg_entry.add_header(clg_header)
        clg_entry.add_footer(clg_footer)
        clg_entry.add_paragraph(clg_paragraph1)
        clg_entry.add_paragraph(clg_paragraph2)

        expected_string = str(clg_header) + '\n\n' +\
                          str(clg_paragraph1) + '\n\n' +\
                          str(clg_paragraph2) + '\n\n' +\
                          str(clg_footer) + '\n\n\n'

        self.assertEqual(expected_string, str(clg_entry))


### C O D E ###

class GarbledChangeLogHeader(Exception):
    """Garbled ChangeLog header

    Raised if parsing of ChangeLog header fails.

    """
    def __init__(self, header):
        super(GarbledChangeLogHeader, self).__init__()
        self.header = header

    def __str__(self):
        return "Garbled ChangeLog header: %s" % self.header

    def __repr__(self):
        return str(self)


class GarbledChangeLogFooter(Exception):
    """Garbled ChangeLog footer

    Raised if parsing of ChangeLog footer fails.

    """
    def __init__(self, footer):
        super(GarbledChangeLogFooter, self).__init__()
        self.footer = footer

    def __str__(self):
        return "Garbled ChangeLog footer: %s" % self.footer

    def __repr__(self):
        return str(self)


class EmptyChangeLogFile(Exception):
    """Empty ChangeLog File

    Raised if operation expect existing entries in the ChangeLog File
    but none is found.

    """
    def __init__(self, filename):
        super(EmptyChangeLogFile, self).__init__()
        self.filename = filename

    def __str__(self):
        return "Empty ChangeLog: %s" % (self.filename,)

    def __repr__(self):
        return str(self)


class ChangeLogHeader(object):
    """Constitutes a changelog header.

    It has the form

    package (version,REV=rev)

    and marks the start of a changelog entry.

    """
    def __init__(self, **kwargs):
        """Initialize ChangeLogHeader

        :param line: parses the given line

        :param package: the package name

        :param version: version of the upstream packages

        :param rev: revision of the opencsw package

        """
        if 'line' in kwargs:
            self.parse_line(kwargs['line'])
            return

        assert 'package' in kwargs and 'version' in kwargs

        self.package = kwargs['package']
        self.version = kwargs['version']

        if 'rev' not in kwargs:
            self.rev = ChangeLogHeader.opencsw_rev()
        else:
            self.rev = kwargs['rev']

    def __str__(self):
        """Get the ChangeLog header"""
        return ChangeLogHeader.format_str % {'package': self.package,
                                             'version': self.version,
                                             'rev': self.rev}

    def parse_line(self, line):
        """Parse ChangeLog header

        Dissect a ChangeLog header into package, version, and
        revision.

        """
        matches = ChangeLogHeader.compiled_re.match(line)

        if matches is None:
            raise GarbledChangeLogHeader(line)

        self.package = matches.group('package')
        self.version = matches.group('version')
        self.rev = matches.group('rev')

    @classmethod
    def opencsw_rev(cls, date=None):
        """Convert a date to as string suitable for REV=

        If no date is specified, the current date is used.

        """
        if date is None:
            date = datetime.date.today()

        return date.strftime('%Y.%m.%d')

    format_str = r'%(package)s (%(version)s,REV=%(rev)s)'
    parse_re = r'(?P<package>[\w-]+) \((?P<version>[\d\.]+),REV=(?P<rev>\d{4}\.\d{2}\.\d{2})\)'
    compiled_re = re.compile(parse_re)


class ChangeLogFooter(object):
    """End a changelog entry.

    It has the form

    [one space]-- maintainer name <email address>[two spaces]  date
    """
    def __init__(self, **kwargs):
        if len(kwargs) == 0:
            maintainer = ChangeLogFooter.get_maintainer()
            self.maintainer = maintainer[0]
            self.email = maintainer[1]
            self.timestamp = ChangeLogFooter.get_rfc2822timestamp()

            return

        if 'line' in kwargs:
            self.parse_line(kwargs['line'])
            return

        assert 'maintainer' in kwargs and 'email' in kwargs

        self.maintainer = kwargs['maintainer']
        self.email = kwargs['email']

        if 'timestamp' in kwargs:
            self.timestamp = ChangeLogFooter.get_rfc2822timestamp(kwargs['timestamp'])
        else:
            self.timestamp = ChangeLogFooter.get_rfc2822timestamp()

    def __str__(self):
        return ChangeLogFooter.format_str % {'maintainer': self.maintainer,
                                             'email': self.email,
                                             'timestamp': self.timestamp}

    def parse_line(self, line):
        """Parse ChangeLog footer

        Dissect a ChangeLog footer into maintainer, email, and
        timestamp.

        """
        matches = ChangeLogFooter.compiled_re.match(line)

        if matches is None:
            raise GarbledChangeLogFooter(line)

        self.maintainer = matches.group('maintainer')
        self.email = matches.group('email')
        self.timestamp = matches.group('timestamp')

    @classmethod
    def get_rfc2822timestamp(cls, date_obj=None):
        """Return a timestamp in the proper format.

        The proper format is a timestamp in the format specified in RFC
        2822.

        :param date_obj: datetime object or none, in which case the current time
        will be taken.

        """
        if date_obj is None:
            timezone = dateutil.tz.tzlocal()
            today = datetime.datetime.now(timezone)
            return email.utils.formatdate(time.mktime(today.timetuple()), True)

        return email.utils.formatdate(time.mktime(date_obj.timetuple()), True)

    @classmethod
    def get_maintainer(cls):
        """Get maintainer name and email.

        Return maintainer and email as tuple.

        """
        if 'LOGNAME' in os.environ:
            fullname = pwd.getpwnam(os.environ['LOGNAME'])[4]
            m_email = "%s@opencsw.org" % os.environ['LOGNAME']
        else:
            fullname = pwd.getpwnam(os.getlogin())[4]
            m_email = "%s@opencsw.org" % os.getlogin()

        return (fullname, m_email)

    format_str = r' -- %(maintainer)s <%(email)s>  %(timestamp)s'
    parse_re = r' -- (?P<maintainer>[\w\d ]+) <(?P<email>[\w\d@ \.]+)>  (?P<timestamp>\w{3}, \d{1,2} \w{3} \d{4} \d{2}:\d{2}:\d{2} (\+|-)\d{4})'
    compiled_re = re.compile(parse_re)


class ChangeLogParagraph(object):
    """A changelog paragraph

    It has the form

    [two spaces]* change details
                  more change details

    or

    [two spaces]line1
                line2

    The first line added is analyzed to find out which type of
    paragraph we're dealing with.

    """
    def __init__(self, *args, **kwargs):
        """Initialize ChangeLog paragraph.

        Initialize ChangeLog paragraph from one ore several
        lines. Optionally, maxcol can be specified.

        """
        assert len(args) > 0

        if 'maxcol' in kwargs:
            self.maxcol = kwargs['maxcol']
        else:
            self.maxcol = 72

        # will be set according to the style of the first line
        self.bullet_style = False

        self.paragraph = ""
        [self.add_line(l) for l in args]

    def add_line(self, line):
        """Add another line to the paragraph"""

        # Analyze the first line in order to find out the type of
        # paragraph, i.e. bullet style or plain style
        if self.paragraph == "" and ChangeLogParagraph.sanitize_re_c.match(line):
            # it's a bullet style paragraph
            self.bullet_style = True

        # Get rid of all leading '\s+\*?\s+' and concatenate all
        # arguments.
        self.paragraph = " ".join([self.paragraph, ChangeLogParagraph.sanitize_re_c.sub("", line)])

        # Some sanitation
        self.paragraph = self.paragraph.strip()
        self.paragraph = ChangeLogParagraph.whitespace_re_c.sub(' ',
                                                                self.paragraph)

    def __repr__(self):
        return self.paragraph

    def __str__(self):
        words = self.paragraph.split()

        if self.bullet_style:
            # line length starts at 4, because we have to take ' * ' into
            # account for the first line.
            line_indent = 4
            continuation_indent = 4
            formatted_paragraph = '  * '
        else:
            line_indent = 2
            continuation_indent = 2
            formatted_paragraph = '  '

        line_length = line_indent

        for word in words:
            if len(word) + line_length < self.maxcol:
                formatted_paragraph = formatted_paragraph + word + ' '
                line_length = line_length + len(word) + 1
            else:
                # chop off the last space
                formatted_paragraph = formatted_paragraph.rstrip()
                # add newline and reset line length counter
                formatted_paragraph = formatted_paragraph + '\n' +\
                                      ' ' * continuation_indent + word + ' '
                line_length = continuation_indent + len(word)

        formatted_paragraph = formatted_paragraph.rstrip()
        return formatted_paragraph

    sanitize_re = r'^\s+\*\s+'
    sanitize_re_c = re.compile(sanitize_re)
    whitespace_re = r'\s{2,}|\n+'
    whitespace_re_c = re.compile(whitespace_re)


class ChangeLogEntry(object):
    """A ChangeLogEntry

    A ChangeLogEntry is comprised of a ChangeLogHeader,
    ChangeLogFooter, and one or more ChangeLogParagraph's.

    """

    def __init__(self, *args):
        if len(args) == 3:
            assert len(args) == 3
            assert isinstance(args[0], ChangeLogHeader)
            assert isinstance(args[1], list)
            assert isinstance(args[2], ChangeLogFooter)
            self.header = args[0]
            self.paragraphs = args[1]
            self.footer = args[2]
        else:
            self.header = None
            self.footer = None
            self.paragraphs = list()

    def add_header(self, cl_header):
        """Add a ChangeLog Entry header.

        Add or replace the ChangeLog Entry header.

        """
        assert cl_header is not None
        self.header = cl_header

    def add_footer(self, cl_footer):
        """Add a ChangeLog Entry footer.

        Add or replace the ChangeLog Entry footer.

        """
        assert cl_footer is not None
        self.footer = cl_footer

    def add_paragraph(self, cl_paragraph, infront=False):
        """Add a ChangeLog Entry paragraph.

        Add another ChangeLog Entry paragraph.

        If :param infront: is True, the paragraph will be prepended to
        the paragraph list. Else it will be appended.

        """
        assert cl_paragraph is not None

        if infront:
            self.paragraphs.insert(0, cl_paragraph)
        else:
            self.paragraphs.append(cl_paragraph)

    def remove_paragraph(self, index):
        """Remove a ChangeLog paragraph

        Remove a ChangeLog paragraph from the list of paragraphs. The
        removed paragraph will be returned to the caller.

        """
        chlogp = self.paragraphs[index]
        del self.paragraphs[index]
        return chlogp

    def __str__(self):
        return str(self.header) + '\n\n' +\
            "\n\n".join([str(paragraph) for paragraph in
                         self.paragraphs]) + '\n\n' +\
            str(self.footer) + '\n\n\n'


class ChangeLogFile(object):
    """A ChangeLog file"""

    def __init__(self, filename):
        self.filename = filename
        self.changelog_entries = list()

    def read(self):
        changelog_entry = None
        current_paragraph = None
        with open(self.filename, "r") as fobj:
            only_whitespace_re = re.compile(r'^\s+$')
            entry_start_re = re.compile(r'^[\w\d\.=(),]+')

            for line in fobj:
                line = line.rstrip('\n')

                if only_whitespace_re.match(line) or line == "":
                    if current_paragraph is not None:
                        # This ends the current paragraph
                        changelog_entry.add_paragraph(current_paragraph)
                        current_paragraph = None

                    continue

                # is it the start of an entry?
                if entry_start_re.match(line):
                    assert changelog_entry is None

                    changelog_entry = ChangeLogEntry()
                    changelog_entry.add_header(ChangeLogHeader(line=line))
                    continue

                # is it the footer, and thus marks the end of a entry?
                if line.startswith(' -- '):
                    # is there a paragraph pending?
                    if current_paragraph is not None:
                        changelog_entry.add_paragraph(current_paragraph)

                    changelog_entry.add_footer(ChangeLogFooter(line=line))
                    # append entry to the list
                    self.changelog_entries.append(changelog_entry)

                    changelog_entry = None
                    current_paragraph = None
                    continue

                if current_paragraph is None:
                    current_paragraph = ChangeLogParagraph(line)
                else:
                    current_paragraph.add_line(line)

    def save(self):
        """Save ChangeLog entries to file"""
        with open(self.filename, 'w') as fobj:
            [fobj.write(str(changelog_entry)) for changelog_entry in
             self.changelog_entries]

    def versions(self):
        """Return a list of all versions in the ChangeLog file"""

        if (len(self.changelog_entries) < 1):
            return None

        return [changelog_entry.header.version for changelog_entry in
                self.changelog_entries]

    def count_entries(self):
        """Return the number of ChangeLog entries"""
        return len(self.changelog_entries)

    def get_package(self):
        """Get the package name

        Package name is returned as defined by the first entry of the
        ChangeLog file.

        """
        if len(self.changelog_entries) < 1:
            return ""

        return self.changelog_entries[0].header.package

    def add_entry(self, *args):
        """Add an entry to the ChangeLog.

        If only one argument is passed, it has to be a
        ChangeLogEntry. Else three arguments are expected, which have
        to be of the type ChangeLogHeader, ChangeLogParagraphs list,
        ChangeLogFooter

        """
        if len(args) == 1:
            assert args[0] is ChangeLogEntry
            changelog_entry = args[0]
        else:
            assert len(args) == 3
            assert isinstance(args[0], ChangeLogHeader)
            assert isinstance(args[1], list)
            assert isinstance(args[2], ChangeLogFooter)
            changelog_entry = ChangeLogEntry(args[0], args[1],
                                             args[2])

        self.changelog_entries.insert(0, changelog_entry)

    def create(self, *args):
        """Create a new ChangeLog file

        Create a new ChangeLog file. Any existing entries will be
        overwritten.

        """

        self.changelog_entries = list()
        self.add_entry(*args)
        self.save()

    def update_latest(self, paragraph):
        """Add paragraph(s) to the latest entry.

        :param paragraph: can be a list of ChangeLogParagraph or a
        single ChangeLogParagrph.

        """

        assert len(self.changelog_entries) > 0

        if paragraph is list:
            [self.changelog_entries[0].add_paragraph(par, True) for par
             in paragraph]
        else:
            self.changelog_entries[0].add_paragraph(paragraph, True)

        latest_header = self.changelog_entries[0].header
        latest_header.rev = ChangeLogHeader.opencsw_rev()
        self.changelog_entries[0].add_header(latest_header)
        self.changelog_entries[0].add_footer(ChangeLogFooter())


    def svn_add(self):
        """Add file to svn repository

        Has only effect if the directory is a subversion working
        directory.  Else it does nothing.

        """
        assert len(self.changelog_entries) > 0

        # First of all, make sure the file exists
        if not os.path.exists(self.filename):
            raise OSError((errno.ENOENT, 'No such file: %s' % self.filename))

        svnclient = pysvn.Client()

        # see if directory holding the file is part of a SVN
        # repo
        directory = os.path.dirname(self.filename)
        if directory == "":
            directory = './'

        try:
            svnentry = svnclient.info(directory)
        except pysvn.ClientError:
            # Most likely it is not a working directory, so we bail out
            logging.warning("'%s' is not a SVN working directory. Cannot add file '%s'.",
                            directory, self.filename)
            return

        svnclient.add([self.filename])
        logging.info("Scheduled file '%s' for addition to SVN repository", self.filename)


def new_changelog_entry(filename, version, log):
    changelog_file = ChangeLogFile(filename)
    changelog_file.read()

    if changelog_file.versions() is None:
        raise EmptyChangeLogFile(filename)

    # get the package from the first entry
    package = changelog_file.get_package()

    header = ChangeLogHeader(package=package,
                             version=version)
    paragraphs = [ChangeLogParagraph(log_para) for log_para in log]
    footer = ChangeLogFooter()

    changelog_file.add_entry(header, paragraphs, footer)
    changelog_file.save()

def update_changelog_entry(filename, log):
    changelog_file = ChangeLogFile(filename)
    changelog_file.read()

    if changelog_file.versions() is None:
        raise EmptyChangeLogFile(filename)

    [changelog_file.update_latest(ChangeLogParagraph(l)) for l in
     log]
    changelog_file.save()

def create_changelog_file(filename, overwrite, package, version, log, register_svn):
    header = ChangeLogHeader(package=package,
                                  version=version)
    footer = ChangeLogFooter()
    paragraphs = [ChangeLogParagraph(log_para) for log_para in log]

    if os.path.exists(filename) and not overwrite:
        logging.error("Changelog '%s' already exists. Won't overwrite", filename)
        sys.exit(1)

    changelog_file = ChangeLogFile(filename)
    changelog_file.create(header, paragraphs, footer)

    if (register_svn):
        changelog_file.svn_add()

def get_version(logfile, allversions):
    changelog_file = ChangeLogFile(logfile)
    changelog_file.read()

    if allversions:
        print("\n".join(changelog_file.versions()))
    else:
        print(changelog_file.versions()[0])

def cmdline_parse():
    """Parse the command line

    Returns the result of argparse.parse_args()

    """
    parser = argparse.ArgumentParser(description="Maintain OpenCSW changelogs")
    parser.add_argument('--logfile',
                        help='filename to use (default: %(default)s)',
                        default='files/changelog.CSW')
    subparser = parser.add_subparsers(help='sub-command help',
                                      dest='command')

    parser_create = subparser.add_parser('create',
                                         help="create new changelog.CSW file. Existing file will not be overwritten.")
    parser_create.add_argument('package',
                               help="package name")
    parser_create.add_argument('version',
                               help="package version")
    parser_create.add_argument('--log-item',
                               help="the log entry to be recorded as list item",
                               nargs='*')
    parser_create.add_argument('--log-paragraph',
                               help="the log entry to be recorded as plain paragraph",
                               nargs='*')
    parser_create.add_argument('--force', help="force creation of file. Overwrite existing file.",
                               default=False, action='store_const',
                               const=True)
    parser_create.add_argument('--no-svn', help="Do not add file to SVN repository.",
                               default=False, action='store_const',
                               const=True)

    parser_new = subparser.add_parser('new',
                                      help="new changelog entry")
    parser_new.add_argument('version',
                            help="new version")
    parser_new.add_argument('--log-item',
                               help="the log entry to be recorded as list item",
                               nargs='*')
    parser_new.add_argument('--log-paragraph',
                               help="the log entry to be recorded as plain paragraph",
                               nargs='*')


    parser_update = subparser.add_parser('update',
                                         help="update the latest changelog entry")
    parser_update.add_argument('--log-item',
                               help="the log entry to be recorded as list item",
                               nargs='*')
    parser_update.add_argument('--log-paragraph',
                               help="the log entry to be recorded as plain paragraph",
                               nargs='*')

    parser_version = subparser.add_parser('version',
                                          help="retrieve version from changelog.CSW")
    parser_version.add_argument('--all-versions',
                                help="retrieve all versions",
                                default=False, action='store_const',
                                const=True)

    parser_test = subparser.add_parser('test', help="test cswch")

    arguments = parser.parse_args()

    if arguments.command in ['create', 'new', 'update'] and\
       arguments.log_paragraph is None and\
       arguments.log_item is None:
        parser.error("'%s' requires either '--log-paragraph' or '--log-item'" % arguments.command)

    return arguments

def compile_log(logitem, logparagraph):
    log = list()
    if logitem:
        log = ['  * ' + item for item in logitem]

    if logparagraph:
        log.extend(logparagraph)

    return log


if __name__ == '__main__':
    arguments = cmdline_parse()

    if arguments.command == "test":
        # cheat unittest into thinking that there are no command line
        # arguments.
        del sys.argv[1:]
        unittest.main()

    if arguments.command == "create":
        log = compile_log(arguments.log_item, arguments.log_paragraph)
        create_changelog_file(arguments.logfile,
                              arguments.force,
                              arguments.package,
                              arguments.version,
                              log,
                              not arguments.no_svn)

    if arguments.command == "new":
        log = compile_log(arguments.log_item, arguments.log_paragraph)
        new_changelog_entry(arguments.logfile,
                            arguments.version,
                            log)

    if arguments.command == "update":
        log = compile_log(arguments.log_item, arguments.log_paragraph)
        update_changelog_entry(arguments.logfile, log)

    if arguments.command == "version":
        get_version(arguments.logfile, arguments.all_versions)
