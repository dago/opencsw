# $Id$
# coding=utf-8

import ConfigParser
import errno
import logging
import os
import re
import sqlobject

WS_RE = re.compile(r"\s+")

CHECKPKG_CONFIG_FILENAME = "checkpkg.ini"
CHECKPKG_RELMGR_CONFIG_FILENAME = "checkpkg_relmgr.ini"
CHECKPKG_AUTO_CONFIG_FILENAME = "checkpkg_auto.ini"
CHECKPKG_DEFAULTS_FILENAME = "checkpkg_defaults.ini"
CHECKPKG_DIR = "%(HOME)s/.checkpkg"
CHECKPKG_SITE_CONFIG_DIR = "/etc/opt/csw"
CHECKPKG_SRC_BASEDIR = os.path.dirname(__file__)
USER_CONFIG_FILE_TMPL = os.path.join(CHECKPKG_DIR, CHECKPKG_CONFIG_FILENAME)
AUTO_CONFIG_FILE_TMPL = os.path.join(CHECKPKG_DIR,
                                     CHECKPKG_AUTO_CONFIG_FILENAME)
SITE_CONFIG_FILE = os.path.join(CHECKPKG_SITE_CONFIG_DIR,
                                CHECKPKG_CONFIG_FILENAME)
SITE_CONFIG_RELMGR_FILE = os.path.join(CHECKPKG_SITE_CONFIG_DIR,
                                       CHECKPKG_RELMGR_CONFIG_FILENAME)
DEFAULTS_FILE = os.path.join(CHECKPKG_SRC_BASEDIR, CHECKPKG_DEFAULTS_FILENAME)

CONFIGURATION_FILE_LOCATIONS = [
    # Last entry wins.
    # The distinction between the autogenerated and user config file is
    # important.  The autogenerated file contains values that a user can
    # later change, but which can be overridden by the site-global config
    # file.  Think about a usage scenario, where a user first runs checkpkg on
    # a host on a buildfarm which happens to not have the site-global config
    # file.  When run, checkpkg will notice that there's no configuration and
    # will autogenerate the config file.  Now, when the same user (with the
    # same home directory) logs into a host that has the site-global config
    # file, it's expected that checkpkg will connect to the shared database.
    # To achieve this, the site-global config has to have priority over the
    # autogenerated file.
    (DEFAULTS_FILE,                True),
    (AUTO_CONFIG_FILE_TMPL,        False),
    (SITE_CONFIG_FILE,             False),
    (SITE_CONFIG_RELMGR_FILE,      False),
    (USER_CONFIG_FILE_TMPL,        False)
]


class Error(Exception):
  "Generic error."


class ConfigurationError(Error):
  "A problem with configuration."


def MkdirP(p):
  try:
    os.makedirs(p)
  except OSError as e:
    if e.errno == errno.EEXIST: pass
    else: raise


def HomeExists():
  if "HOME" not in os.environ:
    return False
  return True


def GetConfig():
  config = ConfigParser.SafeConfigParser()
  file_was_found = False
  filenames_read = []
  for file_name_tmpl, default_file in CONFIGURATION_FILE_LOCATIONS:
    filename = None
    try:
      filename = file_name_tmpl % os.environ
      if os.path.exists(filename):
        if not default_file:
          file_was_found = True
        filename_found = file_name_tmpl % os.environ
        filenames_read.append(filename_found)
        config.read(filename_found)
    except KeyError, e:
      logging.warn(e)
  if not file_was_found:
    if HomeExists():
      db_file = os.path.join(CHECKPKG_DIR % os.environ, "checkpkg.db")
      checkpkg_dir = CHECKPKG_DIR % os.environ
      MkdirP(checkpkg_dir)
      config_file = AUTO_CONFIG_FILE_TMPL % os.environ
      logging.warning(
          "No configuration file found.  Will attempt to create "
          "an sane default configuration in %s."
          % repr(config_file))
      if not config.has_section("database"):
        config.add_section("database")
      config.set("database", "type", "sqlite")
      config.set("database", "name", db_file)
      config.set("database", "host", "")
      config.set("database", "user", "")
      config.set("database", "password", "")
      config.set("database", "auto_manage", "yes")
      with open(config_file, "w") as fd:
        config.write(fd)
      logging.debug("Configuration has been written.")
  if not config.has_section("database"):
    logging.fatal(
        "Section 'database' not found in the config files: %s. "
        "Please refer to the documentation: "
        "http://wiki.opencsw.org/checkpkg" % filenames_read)
    raise SystemExit
  return config


def ComposeDatabaseUri(config):
  db_data = {
      'db_type': config.get("database", "type"),
      'db_name': config.get("database", "name"),
      'db_host': config.get("database", "host"),
      'db_user': config.get("database", "user"),
      'db_password': config.get("database", "password")}
  logging.debug("db_name: %(db_name)s, db_user: %(db_user)s" % db_data)
  if db_data["db_type"] == "mysql":
    db_uri_tmpl = "%(db_type)s://%(db_user)s:%(db_password)s@%(db_host)s/%(db_name)s"
  elif db_data["db_type"] == "sqlite":
    db_uri_tmpl = "%(db_type)s://%(db_name)s"
  else:
    raise ConfigurationError(
        "Database type %s is not supported" % repr(db_data["db_type"]))
  db_uri = db_uri_tmpl % db_data
  return db_uri


def SetUpSqlobjectConnection():
  config = GetConfig()
  db_uri = ComposeDatabaseUri(config)
  sqo_conn = sqlobject.connectionForURI(db_uri)
  sqlobject.sqlhub.processConnection = sqo_conn
