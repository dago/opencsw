#!/usr/bin/env python

#
# The contents of this file are subject to the COMMON DEVELOPMENT AND
# DISTRIBUTION LICENSE (CDDL) (the "License"); you may not use this
# file except in compliance with the License.
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 3 or later (the "GPL"),
# in which case the provisions of the GPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL, and not to allow others to
# use your version of this file under the terms of the CDDL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the CDDL, or the GPL.
#
# Copyright 2010 OpenCSW (http://www.opencsw.org).  All rights reserved.
# Use is subject to license terms.
#
#
# Contributors list :
#
#    William Bonnet wbonnet@opencsw.org
#
#

# Import all the needed modules
import sys
import string
import re
import os
import shutil
import subprocess
import pysvn
import MySQLdb

from urllib2 import Request, urlopen, URLError
from optparse import OptionParser

# ---------------------------------------------------------------------------------------------------------------------
#
#
class InvalidSourceDirectoryContentException(Exception):
    """Exception raised when a method is called on the Abstract command class
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, message):
        self.message = message


# ---------------------------------------------------------------------------------------------------------------------
#
#
class AbstractCommandMethodCallException(Exception):
    """Exception raised when a method is called on the Abstract command class
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, message):
        self.message = message

# ---------------------------------------------------------------------------------------------------------------------
#
#
class SvnClientException(Exception):
    """Exception raised when an error occur while using svnClient
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, message):
        self.message = message

# ---------------------------------------------------------------------------------------------------------------------
#
#
class DatabaseConnectionException(Exception):
    """Exception raised when an error occur while connecting to the database
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, message):
        self.message = message

# ---------------------------------------------------------------------------------------------------------------------
#
#
class UpstreamUrlRetrievalFailedException(Exception):
    """Exception raised when an unsuported protocol is specified in the upstream url
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, url):
        self.url  = url

# ---------------------------------------------------------------------------------------------------------------------
#
#
class NoUpstreamVersionFoundException(Exception):
    """Exception raised when searching the upstream page content does not match the regexp
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, url, regexp):
        self.url     = url
        self.regexp  = regexp


# ---------------------------------------------------------------------------------------------------------------------
#
#
class MissingArgumentException(Exception):
    """Exception raised when a command line argument is missing
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, value):
        self.parameter = value

    def __str__(self):
        return repr(self.parameter)


# ---------------------------------------------------------------------------------------------------------------------
#
#
class CommandLineParser(object):
    """This class is used to parse command line. It process only options. Command verb is parsed by the main procedure
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self):
        # Create the parser object
        self.parser = OptionParser()

        # Add options to parser
        self.parser.add_option("-V", "--verbose", help="Activate verbose mode", action="store_true", dest="verbose")
        self.parser.add_option("-c", "--current-version", help="Current package version", action="store", dest="current_version")
        self.parser.add_option("-d", "--target-location", help="Target location. This is the directory in which the branch will be created (parent of the branch directory). Default value is ../branches", action="store", dest="target_location")
        self.parser.add_option("-r", "--regexp", help="Version matching regular expression", action="store", dest="regexp")
        self.parser.add_option("-s", "--source-directory", help="Source directory (place from where the build is copied). Default value is current directory", action="store", dest="source_directory")
        self.parser.add_option("-t", "--target-version", help="Package target version", action="store", dest="target_version")
        self.parser.add_option("-u", "--upstream-url", help="Upstream version page url", action="store", dest="upstream_url")

        # Option used for storing version information in the database
        self.parser.add_option("-g", "--gar-version", help="Gar version of the package", action="store", dest="gar_version")
        self.parser.add_option("-w", "--upstream-version", help="Upstream version of the package", action="store", dest="upstream_version")
        self.parser.add_option("-a", "--gar-path", help="Relative path in svn repository", action="store", dest="gar_path")
        self.parser.add_option("-n", "--catalog-name", help="Catalog name", action="store", dest="catalog_name")
        self.parser.add_option("-p", "--package-name", help="Package name", action="store", dest="package_name")
        self.parser.add_option("-e", "--execution-date", help="Check date to be stored in the database", action="store", dest="execution_date")

        self.parser.add_option("-S", "--database-schema", help="Defines the database to use in the connection string", action="store", dest="database_schema")
        self.parser.add_option("-H", "--database-host", help="Defines the database host to use in the connection string", action="store", dest="database_host")
        self.parser.add_option("-U", "--database-user", help="Defines the database user to use in the connection string", action="store", dest="database_user")
        self.parser.add_option("-P", "--database-password", help="Defines the database password to use in the connection string", action="store", dest="database_password")

    # -----------------------------------------------------------------------------------------------------------------

    def parse(self):
        (self.options, self.args) = self.parser.parse_args()
        return self.options, self.args

# ---------------------------------------------------------------------------------------------------------------------
#
#
class ConfigurationParser(object):
    """This handles parameters retrieved either from command line or configuration file.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def initialize(self, args):
        """Initialize configuration object. If configurations contains files reference, values from the files are
        read and copied into this object. Next attempts to retrieve files stored information will read values from
        this object.
        """

        # This member variable is a flag which defines the status of the verbose mode (True : activated)
        if args.verbose != None:
            self._verbose = args.verbose
        else:
            self._verbose = False

        # This member variable defines the value of the version of the package
        if args.current_version != None:
            self._current_version = args.current_version

        # This member variable defines the value of the regexp used to match the upstream web page
        if args.regexp != None:
            self._regexp = args.regexp

        # This member variable defines the url of the upstream web page used to check for new version
        if args.upstream_url != None:
            self._upstream_url = args.upstream_url

        # This member variable defines the target version of the package during upgrade
        if args.target_version != None:
            self._target_version = args.target_version

        # This member variable defines the target directory of the package during upgrade. This is the location of the new branch
        if args.target_location != None:
            self._target_location = args.target_location

        # This member variable defines the source directory of the package during upgrade. This is the location of the trunk (most of the time)
        if args.source_directory != None:
            self._source_directory = args.source_directory

        # This member variable defines the version of the package stored in the gar build description
        if args.gar_version != None:
            self._gar_version = args.gar_version

        # This member variable defines the upstream version of package
        if args.upstream_version != None:
            self._upstream_version = args.upstream_version

        # This member variable defines the relative path in the svn repository
        if args.gar_path != None:
            self._gar_path = args.gar_path

        # This member variable defines the catalog name of the package
        if args.catalog_name != None:
            self._catalog_name = args.catalog_name

        # This member variable defines the package name
        if args.package_name != None:
            self._package_name = args.package_name

        # This member variable defines the date of the execution (it is useful to be able to define a date to construct history of versions)
        if args.execution_date != None:
            self._execution_date = args.execution_date

        # This member variable defines the database to use in the connection string
        if args.database_schema != None:
            self._database_schema = args.database_schema

        # This member variable defines the database host to use in the connection string
        if args.database_host != None:
            self._database_host = args.database_host
	
        # This member variable defines the database user to use in the connection string
        if args.database_user != None:
            self._database_user = args.database_user

        # This member variable defines the database password to use in the connection string
        if args.database_password != None:
            self._database_password = args.database_password

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self):

        # Initialize all variables to None. Even if useless, the purpose of this to keep up to date the list
        self._verbose = None
        self._current_version = None
        self._regexp = None
        self._upstream_url = None
        self._target_version = None
        self._source_directory = "."
        self._target_location = "../branches"
        self._gar_version = None
        self._upstream_version = None
        self._gar_path = None
        self._catalog_name = None
        self._package_name = None
        self._execution_date = None
        self._database_schema = None
        self._database_host = None
        self._database_user = None
        self._database_password = None

    # -----------------------------------------------------------------------------------------------------------------

    def getCurrentVersion(self):
        return self._current_version

    # -----------------------------------------------------------------------------------------------------------------

    def getRegexp(self):
        return self._regexp

    # -----------------------------------------------------------------------------------------------------------------

    def getUpstreamURL(self):
        return self._upstream_url

    # -----------------------------------------------------------------------------------------------------------------

    def getVerbose(self):
        return self._verbose

    # -----------------------------------------------------------------------------------------------------------------

    def getSourceDirectory(self):
        return self._source_directory

    # -----------------------------------------------------------------------------------------------------------------

    def getTargetLocation(self):
        return self._target_location

    # -----------------------------------------------------------------------------------------------------------------

    def getTargetVersion(self):
        return self._target_version

    # -----------------------------------------------------------------------------------------------------------------

    def getGarVersion(self):
        return self._gar_version

    # -----------------------------------------------------------------------------------------------------------------

    def getUpstreamVersion(self):
        return self._upstream_version

    # -----------------------------------------------------------------------------------------------------------------

    def getGarPath(self):
        return self._gar_path

    # -----------------------------------------------------------------------------------------------------------------

    def getCatalogName(self):
        return self._catalog_name

    # -----------------------------------------------------------------------------------------------------------------

    def getPackageName(self):
        return self._package_name

    # -----------------------------------------------------------------------------------------------------------------

    def getExecutionDate(self):
        return self._execution_date

    # -----------------------------------------------------------------------------------------------------------------

    def getDatabaseSchema(self):
        return self._database_schema

    # -----------------------------------------------------------------------------------------------------------------

    def getDatabaseHost(self):
        return self._database_host

    # -----------------------------------------------------------------------------------------------------------------

    def getDatabaseUser(self):
        return self._database_user

    # -----------------------------------------------------------------------------------------------------------------

    def getDatabasePassword(self):
        return self._database_password

# ---------------------------------------------------------------------------------------------------------------------
#
#
class AbstractCommand(object):
    """Base class for command implementation. You should create a derived class per command to implemente.
       A "command" represent a concrete action verb given to the program.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        self.configParser = ConfigurationParser()
        self.name = name

    # -----------------------------------------------------------------------------------------------------------------

    def getName(self):
        return self.name

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, arguments):
        print "Internal error : Abstract command method called\n"
        raise AbstractCommandMethodCallException("execute")

# ---------------------------------------------------------------------------------------------------------------------
#
#
class UpstreamWatchCommand(AbstractCommand):
    """UpstreamWatch command. This command is the base class used for all upstream watch commands. It provides argument checking
    url content retrieving, version comparison, etc.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(UpstreamWatchCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def UrlContentRetrieve(self, url):

        try:
            # Request the upstream URL and open it
            req = Request(url)
            response = urlopen(req)

        except URLError, e:
            if hasattr(e, 'reason'):
                print 'We failed to reach a server during retrieval of : ' + url
                print 'Reason: ', e.reason
            elif hasattr(e, 'code'):
                print 'The server couldn\'t fulfill the request during retrieval of : ' + url
                print 'Error code: ', e.code

            # Check for response code value. We should get a 200
            raise UpstreamUrlRetrievalFailedException(url)

        else:
            # everything is fine, retrieve the page content
            return response.read()


    # -----------------------------------------------------------------------------------------------------------------

    def CompareVersionAndGetNewest(self, version1, version2):

        # we consider the version to be composed of several elements separated by '.' ',' '-' or '_'
        # an elements can be a string or a number
        # at each step we extract the next elements of the two version strings and compare them

        # Retrieve the tokens from both version. Use . - , and _ as splitters
    	splittingRegExp = "(?:[\.,_-])"
        tokens1 = re.split(splittingRegExp, version1)
        tokens2 = re.split(splittingRegExp, version2)

        if self.configParser.getVerbose():
            print "Comparing " + version1 + " and " + version2

        # Iterates the toeksn of version 1, pop tokens one by one and compare to the token at same
        # in version 2
        while len(tokens1) > 0:
            # If we still have tokens in version 1 and version 2 is empty, then version 1 is newer
            # TODO: may have to deal with beta suffixes...
            if len(tokens2) == 0:
                return version1

            # Convert both elements to integer
            # TODO : handles chars in versions
            elem1 = tokens1.pop(0)
            elem2 = tokens2.pop(0)

            # If both elements are integer, then convert to int before comparison, otherwise compare strings
            try:
                elem1 = int(elem1)
                elem2 = int(elem2)
            except:
                elem1 = str(elem1)
                elem2 = str(elem2)
                # print "Doing string comparison"

            # print "Comparing %(elem1)s and %(elem2)s" % { 'elem1' : elem1 , 'elem2' : elem2 }

            # if elements are the same continue the loop
            if elem1 == elem2:
                continue

            # Test if elem1 is more recent
            if elem1 > elem2:
                # print "%(elem1)s > %(elem2)s" % { 'elem1' : elem1 , 'elem2' : elem2 }
                return version1
            else:
                # print "%(elem1)s < %(elem2)s" % { 'elem1' : elem1 , 'elem2' : elem2 }
                return version2

        return version1

# ---------------------------------------------------------------------------------------------------------------------
#
#
class CheckUpstreamCommand(UpstreamWatchCommand):
    """CheckUpstream command. This command retrieve the upstream web page and search for a new version. Version check is
    done by matching the regexp from the makefile on the page. Results are sorted to get the highest available and
    compared to current version
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(CheckUpstreamCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def checkArgument(self):

        # Variable used to flag that we have a missing argument
        argsValid = True

        # Current version is mandatory
        if self.configParser.getCurrentVersion() == None:
            print "Error : Current version is not defined. Please use --current-version flag, or --help to display help"
            argsValid = False

        # Regexp is mandatory
        if self.configParser.getRegexp() == None:
            print "Error : Regexp is not defined. Please use --regexp flag, or --help to display help"
            argsValid = False

        # UpstreamURL is mandatory
        if self.configParser.getUpstreamURL() == None:
            print "Error : Upstream version page URL is not defined. Please use --upstream-url flag, or --help to display help"
            argsValid = False

        # If arguments are not valid raise an exception
        if argsValid == False:
            raise MissingArgumentException("Some mandatory arguments are missing. Unable to continue.")

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, args):

        try:

            # Initialize configuration
            self.configParser.initialize(opts)

            # Need a way to check that all options needed are available
            self.checkArgument()

            # Call the method in charge of retrieving upstream content
            content = self.UrlContentRetrieve(self.configParser.getUpstreamURL())

            # Search the strings matching the regexp passed through command line arguments
            p = re.compile(self.configParser.getRegexp())
            matches = p.findall(content)

            # Check if we have found some results
            if len(matches) == 0:
                raise NoUpstreamVersionFoundException(self.configParser.getUpstreamURL(), self.configParser.getRegexp())
                print "No match found, we should trigger some error since even current version has not been found"
                return False
            else:
                newestVersion = self.configParser.getCurrentVersion()
                while len(matches) > 0:
                    newestVersion = self.CompareVersionAndGetNewest(newestVersion, matches.pop(0))

            # At the end of the processing loop, test if we have a newer version avail, if yes output it
            if newestVersion <>  self.configParser.getCurrentVersion():
                print newestVersion

            # Exit after processing, eveythin gis ok, return true to the command processor
            return True

        except MissingArgumentException, (instance):

            # Display a cool error message :)
            print instance.parameter

            # Exits through exception handling, thus return false to the command processor
            return False

        except UpstreamUrlRetrievalFailedException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False

        except NoUpstreamVersionFoundException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False


# ---------------------------------------------------------------------------------------------------------------------
#
#
class GetUpstreamLatestVersionCommand(UpstreamWatchCommand):
    """GetUpstreamLatestVersion command. This command retrieve the upstream web page and search for the latest version.
    Version check is done by matching the regexp from the makefile on the page. Results are sorted to get the newest version
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(GetUpstreamLatestVersionCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def checkArgument(self):

        # Variable used to flag that we have a missing argument
        argsValid = True

        # Regexp is mandatory
        if self.configParser.getRegexp() == None:
            print "Error : Regexp is not defined. Please use --regexp flag, or --help to display help"
            argsValid = False

        # UpstreamURL is mandatory
        if self.configParser.getUpstreamURL() == None:
            print "Error : Upstream version page URL is not defined. Please use --upstream-url flag, or --help to display help"
            argsValid = False

        # If arguments are not valid raise an exception
        if argsValid == False:
            raise MissingArgumentException("Some mandatory arguments are missing. Unable to continue.")

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, args):

        try:

            # Initialize configuration
            self.configParser.initialize(opts)

            # Need a way to check that all options needed are available
            self.checkArgument()

            # Call the method in charge of retrieving upstream content
            content = self.UrlContentRetrieve(self.configParser.getUpstreamURL())

            # Search the strings matching the regexp passed through command line arguments
            p = re.compile(self.configParser.getRegexp())
            matches = p.findall(content)

            # Check if we have found some results
            if len(matches) == 0:
                raise NoUpstreamVersionFoundException(self.configParser.getUpstreamURL(), self.configParser.getRegexp())
                print "No match found, we should trigger some error since even current version has not been found"
                return False
            else:
                newestVersion = matches.pop(0)
                while len(matches) > 0:
                    newestVersion = self.CompareVersionAndGetNewest(newestVersion, matches.pop(0))

            # At the end of the processing loop, we print the version
            print newestVersion

            # Exit after processing, eveythin gis ok, return true to the command processor
            return True

        except MissingArgumentException, (instance):

            # Display a cool error message :)
            print instance.parameter

            # Exits through exception handling, thus return false to the command processor
            return False

        except UpstreamUrlRetrievalFailedException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False

        except NoUpstreamVersionFoundException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False

# ---------------------------------------------------------------------------------------------------------------------
#
#
class GetUpstreamVersionListCommand(UpstreamWatchCommand):
    """GetUpstreamVersionList command. This command retrieve the upstream web page and search for all the versions.
    Version check is done by matching the regexp from the makefile on the page. 
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(GetUpstreamVersionListCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def checkArgument(self):

        # Variable used to flag that we have a missing argument
        argsValid = True

        # Regexp is mandatory
        if self.configParser.getRegexp() == None:
            print "Error : Regexp is not defined. Please use --regexp flag, or --help to display help"
            argsValid = False

        # UpstreamURL is mandatory
        if self.configParser.getUpstreamURL() == None:
            print "Error : Upstream version page URL is not defined. Please use --upstream-url flag, or --help to display help"
            argsValid = False

        # If arguments are not valid raise an exception
        if argsValid == False:
            raise MissingArgumentException("Some mandatory arguments are missing. Unable to continue.")

    # -----------------------------------------------------------------------------------------------------------------

    def compareAndSortVersion(self, a, b):
        """This function is a wrapper to the comparison function. CompareVersionAndGetNewest returns the string containing
        the newest version of the two arguments. Since sort method used on list need to have an integer return value, this
        wrapper do the call to CompareVersionAndGetNewest and returns an int
        """
    
        if self.CompareVersionAndGetNewest(a,b) == a:
            return 1
        else:
            return -1

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, args):

        try:

            # Initialize configuration
            self.configParser.initialize(opts)

            # Need a way to check that all options needed are available
            self.checkArgument()

            # Call the method in charge of retrieving upstream content
            content = self.UrlContentRetrieve(self.configParser.getUpstreamURL())

            # Search the strings matching the regexp passed through command line arguments
            p = re.compile(self.configParser.getRegexp())
            matches = p.findall(content)

            # Check if we have found some results
            if len(matches) == 0:
                raise NoUpstreamVersionFoundException(self.configParser.getUpstreamURL(), self.configParser.getRegexp())
                print "No match found, we should trigger some error since even current version has not been found"
                return False
            else:
                # Remove duplicated entries
                myList = []
                for version in matches:
                    myList.append(version)

                l = list(set(myList))
                l.sort(self.compareAndSortVersion)

                # Print every version in the list
                for version in l:
                    print version

            # Exit after processing, eveythin gis ok, return true to the command processor
            return True

        except MissingArgumentException, (instance):

            # Display a cool error message :)
            print instance.parameter

            # Exits through exception handling, thus return false to the command processor
            return False

        except UpstreamUrlRetrievalFailedException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False

        except NoUpstreamVersionFoundException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False


# ---------------------------------------------------------------------------------------------------------------------
#
#
class UpgradeToVersionCommand(UpstreamWatchCommand):
    """UpgradeToVersion command. This command upgrade the build description from a version to another.
    Current files in trunk are copied to a new branch. Branch is named accord to the following pattern :
    PKG/branches/upgrade_from_CURRENTVERSION_to_DESTVERSION. After copy, version in the Makefile is modified.
    An optional argument can be passed to commit after branch creation.
    
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(UpgradeToVersionCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def checkArgument(self):

        # Variable used to flag that we have a missing argument
        argsValid = True

        # FromVersion is mandatory
        if self.configParser.getCurrentVersion() == None:
            print "Error : Current version is not defined. Please use --current-version flag, or --help to display help"
            argsValid = False

        # ToVersion is mandatory
        if self.configParser.getTargetVersion() == None:
            print "Error : Target version is not defined. Please use --target-version flag, or --help to display help"
            argsValid = False

        # ToVersion is mandatory
        if self.configParser.getTargetLocation() == None:
            print "Error : Target directory is not defined. Please use --target-location flag, or --help to display help"
            argsValid = False

        # If arguments are not valid raise an exception
        if argsValid == False:
            raise MissingArgumentException("Some mandatory arguments are missing. Unable to continue.")

    # -----------------------------------------------------------------------------------------------------------------

    def checkWorkingDirectory(self):
        """ This method checks that the command is executed from a valid working directory. A valid working directory
            is a directory in which we find a package buildDescription that means a Makefile and a gar directory or symlink
        """

        # Check that the Makefile exist
        if os.path.isfile(self.configParser.getSourceDirectory() + "/Makefile") == False:
            # No it does not exist, thus generate an error message
            msg = "Error : there is no Makefile under %(src)s" % { "src" : os.path.abspath(self.configParser.getSourceDirectory()) }
    
            # Then raise an exception
            raise InvalidSourceDirectoryContentException(msg)

        # Check that the gar directory exists (can be a directory or symlink)
        if os.path.isdir(self.configParser.getSourceDirectory() + "/gar") == False:
            # No it does not exist, thus generate an error message
            msg = "Error : there is no gar directory under %(src)s" % { "src" : os.path.abspath(self.configParser.getSourceDirectory()) }
    
            # Then raise an exception
            raise InvalidSourceDirectoryContentException(msg)

    # -----------------------------------------------------------------------------------------------------------------

    def getGarRelativeTargetDirectory(self):
        """ This method return None if gar directory is an actual directory, or a relative path if gar is a symlink to 
            a real directory. In case of a symlink pointing to another symlink, we do not try to get the absolute path
            having one level of indirection is enough. 
            The target directory is a relative path. This path is adjusted to be consistent from the target directory. It
            has to be modified since it is basically a relative path from the source directory.            
        """

        # Get the newgar information
        garDir = self.configParser.getSourceDirectory() + "/gar"
        if os.path.islink(garDir):
            garTarget = os.path.relpath(os.path.abspath(os.readlink(garDir)), os.path.abspath(targetDir))
        else:
            garTarget = None
    
    # -----------------------------------------------------------------------------------------------------------------

    def getGarRelativeTargetDirectory(self):
        """ This method return None if gar directory is an actual directory, or a relative path if gar is a symlink to 
            a real directory. In case of a symlink pointing to another symlink, we do not try to get the absolute path
            having one level of indirection is enough. 
            The target directory is a relative path. This path is adjusted to be consistent from the target directory. It
            has to be modified since it is basically a relative path from the source directory.            
        """

        # Get the newgar information
        garDir = self.configParser.getSourceDirectory() + "/gar"
        if os.path.islink(garDir):
            garTarget = os.path.relpath(os.path.abspath(os.readlink(garDir)), os.path.abspath(self.getTargetDirectory()))
        else:
            garTarget = None

        return garTarget

    # -----------------------------------------------------------------------------------------------------------------

    def getTargetDirectory(self):
        """ This method return the target directory which is a computed value based on target location, current version
            and target version
        """

        return self.configParser.getTargetLocation() + "/upgrade_from_" + self.configParser.getCurrentVersion() + "_to_" + self.configParser.getTargetVersion()

    # -----------------------------------------------------------------------------------------------------------------

    def copySvnSourceToTarget(self, garRelativeTarget):
        """ This method copy sources from the working copy to the target in the same working copy. If garRelativeTarget is not 
            None, it means gar directory is a symlink. Then once copy is done it is deleted in the target directory and
            recreated to point to the new relative directory
        """

        try:
            # Create a new svn client
            svnClient = pysvn.Client()

            # Do the actual copy in the svn working copy
            svnClient.copy(os.path.abspath(self.configParser.getSourceDirectory()), self.getTargetDirectory())

            # Backup the current directory
            curDir = os.getcwd()

            # Change to target directory
            os.chdir(self.getTargetDirectory())

            # Test if gar relative path is defined
            if garRelativeTarget:
                # Test if gar directory is a symlink and 
                if os.path.islink("./gar"):
                    os.remove("./gar")
                    os.symlink(garRelativeTarget, "./gar")
                # No ... :( This a "should not happen error" since it was a symlink before the copy. Exit
                else:
                    print "Internal error : gar is not a symlink but garRelativeTarget is defined"
                    return False
            # No else but ... If gar relative path is not defined, we have copied a real directory. Nothing to do in this case

            # Restore the working directory
            os.chdir(curDir)

        # SVN client exception handling    
        except pysvn.ClientError , e:
            # Generate a cool error message
            msg = "SVN Client error : " + e.args[0] + "\n" + "Error occured when executing command svnClient.copy(%(src)s, %(dest)s)" \
                  % { 'src' : os.path.abspath(self.configParser.getSourceDirectory()), 'dest' : self.getTargetDirectory() }

            # Then raise the exception
            raise SvnClientException(msg)

    # -----------------------------------------------------------------------------------------------------------------

    def modifyVersion(self):
        """ This method modifies the version in the Makefile. It replaces current version by new version. 
            Version has to be defined on a single line strting by VERSION, having some spaces or tabs then 
            and egal sign = then some tabs or spaces and the version vaue to finish the line
        """

        # Backup the current directory
        curDir = os.getcwd()

        # Change to target directory
        os.chdir(self.getTargetDirectory())

        # Array storing the Makefile lines
        lines = []

        # Iterate each line in  the file                
        for line in open("./Makefile", 'r'):
            # Match the file line by line               
            m = re.match(r"\s*VERSION\s*=\s*(?P<version>.*)", line)

            # Test if this is a match
            if m == None:
                # No, thus output the current line without modifications
                lines.append(line)
            else:   
                # Yes it is a match, thus output the modified line
                lines.append("VERSION = " + self.configParser.getTargetVersion() + "\n")

        # Open the new Makefile for output
        f = open("./Makefile", 'w')

        # Iterates the array of lines and write each one to the Makefile 
        for element in lines:
            f.write(element)

        # Close the Makefile
        f.close()

        # Restore the working directory
        os.chdir(curDir)

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, args):

        try:

            # Initialize configuration
            self.configParser.initialize(opts)

            # Need a way to check that all options needed are available
            self.checkArgument()

            # Check that the command is launched from a valid directory
            self.checkWorkingDirectory()

            # Generates the target directory
            self.getTargetDirectory()

            # Get the new gar information
            garRelativeTarget = self.getGarRelativeTargetDirectory()

            # Copy target directory to destination
            self.copySvnSourceToTarget(garRelativeTarget)

            # Modify the version inside the Makefile
            self.modifyVersion()

            # Exit after processing, eveythin gis ok, return true to the command processor
            return True

        # Handles exception that occurs when arguments are incorrect
        except MissingArgumentException, instance:

            # Display a cool error message :)
            print instance.parameter

            # Exits through exception handling, thus return false to the command processor
            return False

        # Handles SVN client exception
        except SvnClientException , e:
            
            # Display a cool error message :)
            print e.message

            # Exits through exception handling, thus return false to the command processor
            return False

        # Handles exceptions which might occur while checking source directory content
        except InvalidSourceDirectoryContentException , e:
            
            # Display a cool error message :)
            print e.message

            # Exits through exception handling, thus return false to the command processor
            return False

# ---------------------------------------------------------------------------------------------------------------------
#
#
class ReportPackageVersionCommand(UpstreamWatchCommand):
    """ReportPackageVersion command. This command report and store in the database the values of version and date passed 
    by arguments to upstream watch. Unique key is the composed by garpath and catalog name. It means the same package can
    lie into different path in the svn repository.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(ReportPackageVersionCommand, self).__init__(name)
        self.conn = None

    # -----------------------------------------------------------------------------------------------------------------

    def openDatabaseConnection(self):
        """This method open a connection to the mysql database using value from the configuration parser. The result of 
        connect method is stored into a connection object
        """

        # Open the database connection
        try:
            self.conn = MySQLdb.connect(host   = self.configParser.getDatabaseHost(),
                                       passwd = self.configParser.getDatabasePassword(),
                                       db     = self.configParser.getDatabaseSchema(),
                                       user   = self.configParser.getDatabaseUser() )

        except MySQLdb.Error, e:
            msg = "Error %d: %s" % (e.args[0], e.args[1])
            raise DatabaseConnectionException(msg)

        # Check that the object we got in return if defiend
        if self.conn == None:
            # No, raise a DatabaseConnectionException
            msg = "Unable to connect to database using host = %(host)s, db = %(db)s, user = %(user)s, passwd = %(passwd)% " % { "host" : self.configParser.getDatabaseHost(), "passwd" : self.configParser.getDatabasePassword(), "db" : self.configParser.getDatabaseSchema(), "user" : self.configParser.getDatabaseUser() }
            raise DatabaseConnectionException(msg)

    # -----------------------------------------------------------------------------------------------------------------

    def closeDatabaseConnection(self):
        """This method close the connection opened by openDatabaseConnection. 
        """

        # Check that the connection object is valid
        if self.conn :
            # Yes, commit pending transactions
            self.conn.commit()

            # Close the connection
            self.conn.close()
        else:
            # No,  raise a DatabaseConnectionException
            msg = "Unable to disconnect from the database. Connection objet is not defined"
            raise DatabaseConnectionException(msg)

    # -----------------------------------------------------------------------------------------------------------------

    def updateVersionInDatabase(self):
        """This method updates the version in the database. First it checks for the package to update using a unique 
        key composed of gar svn path and catalog name. If not found the package is created, otherwise it is updated.
        In both case, if data are writtent to the database, entries in history table are created.
        """

        try:
            # Check that the connection is defined
            if self.conn == None:
                # No,  raise a DatabaseConnectionException
                msg = "Unable to query the database. Connection objet is not defined"
                raise DatabaseConnectionException(msg)

            # Get a cursor object        
            cursor = self.conn.cursor(MySQLdb.cursors.DictCursor)

            # First retrieve the id_pkg and deletion flag from the database
            cursor.execute("select ID_PKG , PKG_IS_DELETED from UWATCH_PKG_VERSION where PKG_GAR_PATH = %s and PKG_CATALOGNAME = %s", \
                            (self.configParser.getGarPath(), self.configParser.getCatalogName() ) )

            # If rowcount = 0 then the package does not exist. It has to be inserted in the database
            if cursor.rowcount == 0:
                print "pas de ligne"

                # Insert the package in the package version table

                cursor.execute("insert into UWATCH_PKG_VERSION (PKG_GAR_PATH, PKG_CATALOGNAME, PKG_NAME, PKG_GAR_VERSION, PKG_LAST_GAR_CHECK_DATE) \
                                values ( %s , %s , %s , %s , %s )" , (self.configParser.getGarPath(), self.configParser.getCatalogName(), \
                                self.configParser.getPackageName(), self.configParser.getGarVersion(), self.configParser.getExecutionDate() ) )


#   ID_PKG                         int                            not null AUTO_INCREMENT,
#   PKG_GAR_PATH                   varchar(255)                   not null ,
#   PKG_NAME                       varchar(64)                    not null ,
#   PKG_CATALOGNAME                varchar(64)                    not null ,
#   PKG_CURRENT_VERSION            varchar(255)                   null ,
#   PKG_CURRENT_REVISION           varchar(255)                   null ,
#   PKG_GAR_VERSION                varchar(255)                   not null ,
#   PKG_UPSTREAM_VERSION           varchar(255)                   null ,
#   PKG_LAST_GAR_CHECK_DATE        timestamp                      not null ,
#   PKG_LAST_UPSTREAM_CHECK_DATE   timestamp                      null ,
#   PKG_LAST_CURRENT_CHECK_DATE    timestamp                      null ,
#   PKG_IS_DELETED                 boolean                        not null default false,


               

                # Insert history line for gar version
                # Test if current version is passed
                    # Yes, compare current current version from commandline and database
                        # Values are different. We have to update the database
                        # Update the current version and revision date                    
                        # Insert a line in the version history
                    # No, nothing to do
                    # In all cases update the last check date

                # Test if upstream version is passed
                    # Yes, compare current upstream version from commandline and database
                        # Values are different. We have to update the database
                        # Update the gar version
                        # Insert a line in the version history
                    # No, nothing to do
                    # In all cases update the last check date

            else:
                print "Number of rows detected : %d" % cursor.rowcount
                # Test if the deleted flag is set
                    # Yes thus package has to be undeleted

                    # No, flag is not set, package is updated in standard way

                        # Test if gar version is passed
                            # Yes, compare current gar version from commandline and database
                                # Values are different. We have to update the database
                                # Update the gar version
                                # Insert a line in the version history
                            # No, nothing to do
                            # In all cases update the last check date

                        # Test if current version is passed
                            # Yes, compare current current version from commandline and database
                                # Values are different. We have to update the database
                                # Update the current version and revision date                    
                                # Insert a line in the version history
                            # No, nothing to do
                            # In all cases update the last check date

                        # Test if upstream version is passed
                            # Yes, compare current upstream version from commandline and database
                                # Values are different. We have to update the database
                                # Update the gar version
                                # Insert a line in the version history
                            # No, nothing to do
                            # In all cases update the last check date

#   ID_PKG                         int                            not null AUTO_INCREMENT,
#   PKG_GARPATH                    varchar(255)                   not null ,
#   PKG_NAME                       varchar(64)                    not null ,
#   PKG_CATALOGNAME                varchar(64)                    not null ,
#   PKG_CURRENT_VERSION            varchar(255)                   not null ,
#   PKG_CURRENT_REVISION           varchar(255)                   not null ,
#   PKG_GAR_VERSION                varchar(255)                   not null ,
#   PKG_UPSTREAM_VERSION           varchar(255)                   not null ,
#   PKG_LAST_GAR_CHECK_DATE        timestamp                      not null ,
#   PKG_LAST_UPSTREAM_CHECK_DATE   timestamp                      not null ,
#   PKG_LAST_CURRENT_CHECK_DATE    timestamp                      not null ,
#   PKG_IS_DELETED                 boolean                        not null default false,


            print "Number of rows inserted: %d" % cursor.rowcount

            # Close the cursor on the database
            cursor.close()

        except MySQLdb.Error, e:
            msg = "Error %d: %s" % (e.args[0], e.args[1])
            raise DatabaseConnectionException(msg)


    # -----------------------------------------------------------------------------------------------------------------

    def checkArgument(self):

        # Variable used to flag that we have a missing argument
        argsValid = True

        # Gar path is mandatory
        if self.configParser.getGarPath() == None:
            print "Error : Gar path is not defined. Please use --gar-path flag, or --help to display help"
            argsValid = False

        # Catalog name is mandatory
        if self.configParser.getCatalogName() == None:
            print "Error : Catalog name is not defined. Please use --catalog-name flag, or --help to display help"
            argsValid = False

        # Package name is mandatory
        if self.configParser.getPackageName() == None:
            print "Error : Package name is not defined. Please use --package-name flag, or --help to display help"
            argsValid = False

        # Execution date is mandatory
        if self.configParser.getExecutionDate() == None:
            print "Error : Execution date is not defined. Please use --execution-date flag, or --help to display help"
            argsValid = False

        # Gar version is mandatory, other version are optional. Gar the version is the only mandatory in the database
        # It has to be passed in argument in case the package does not exist yet
        if self.configParser.getGarVersion() == None:
            print "Error : Gar version is not defined. Please use --gar-version flag, or --help to display help"
            argsValid = False

        # Database schema is mandatory
        if self.configParser.getDatabaseSchema() == None:
            print "Error : Database schema is not defined. Please define the value in the ~/.uwatchrc file, use --database-schema flag, or --help to display help"
            argsValid = False

        # Database host is mandatory
        if self.configParser.getDatabaseHost() == None:
            print "Error : Database host is not defined. Please define the value in the ~/.uwatchrc file, use --database-host flag, or --help to display help"
            argsValid = False

        # Database user is mandatory
        if self.configParser.getDatabaseUser() == None:
            print "Error : Database user is not defined. Please define the value in the ~/.uwatchrc file, use --database-user flag, or --help to display help"
            argsValid = False

        # Database password is mandatory
        if self.configParser.getDatabasePassword() == None:
            print "Error : Database password is not defined. Please define the value in the ~/.uwatchrc file, use --database-password flag, or --help to display help"
            argsValid = False
    
        # If arguments are not valid raise an exception
        if argsValid == False:
            raise MissingArgumentException("Some mandatory arguments are missing. Unable to continue.")

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, args):

        try:

            # Initialize configuration
            self.configParser.initialize(opts)

            # Need a way to check that all options needed are available
            self.checkArgument()

            # Connection to the database
            self.openDatabaseConnection()

            # Connection to the database
            self.updateVersionInDatabase()

            # Connection to the database
            self.closeDatabaseConnection()

            # Exit after processing, eveythin gis ok, return true to the command processor
            return True

        except MissingArgumentException, (instance):

            # Display a cool error message :)
            print instance.parameter

            # Exits through exception handling, thus return false to the command processor
            return False

        except DatabaseConnectionException, (instance):

            # Display a cool error message :)
            print instance.message

            # Exits through exception handling, thus return false to the command processor
            return False



# ---------------------------------------------------------------------------------------------------------------------
#
#
class CommandProcessor(object):
    """This class receive commands from the main loop and forward call to concrete command.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self):
        """Initialize the objects in charge of concrete command processing. Each object instance are stored in a
        map using a key which is the action verb used on the command line.
        """

        # Defines the map storing the concrete commands
        self.commandArray = {}

        # Creates all the concrete commands
        cmd = CheckUpstreamCommand("check-upstream")
        self.commandArray[cmd.getName()] = cmd

        cmd = GetUpstreamLatestVersionCommand("get-upstream-latest-version")
        self.commandArray[cmd.getName()] = cmd

        cmd = GetUpstreamVersionListCommand("get-upstream-version-list")
        self.commandArray[cmd.getName()] = cmd

        cmd = UpgradeToVersionCommand("upgrade-to-version")
        self.commandArray[cmd.getName()] = cmd

        cmd = ReportPackageVersionCommand("report-package-version")
        self.commandArray[cmd.getName()] = cmd

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, arguments):
        """This method checks that an action is supplied and call the action handler
        """

        # Check that an action verb is supplied. If none an error is returned
        if len(arguments) == 0:
            print "Error : no action supplied"
            return 1

        # The first element in the arguments array is the action verb. Retrieve the command
        # using action verb as key
        if self.commandArray.has_key(arguments[0]):
            return self.commandArray[arguments[0]].execute(opts, arguments)
        else:
            print "Error : %(action)s action is not supported" % { 'action' : arguments[0] }
            return 2


# ---------------------------------------------------------------------------------------------------------------------
#
# Fonction principale
#
def main():
    """Program main loop. Process args and call concrete command action.
    """

    # Create the command processor object
    commandProcessor = CommandProcessor()

    # Parse command line arguments
    cliParser  = CommandLineParser()

    # Call the command line parser
    (opts, args) = cliParser.parse()

    # Call the execute method on the command processor. This method is in charge to find the concrete command
    return commandProcessor.execute(opts, args)

# Exit with main return code
if __name__ == '__main__':
    sys.exit(main())

