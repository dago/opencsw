#!/opt/csw/bin/python

#
# The contents of this file are subject to the COMMON DEVELOPMENT AND
# DISTRIBUTION LICENSE (CDDL) (the "License"); you may not use this
# file except in compliance with the License.
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 3 or later (the "GPL"),
# in which case the provisions of the GPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL, and not to allow others to
# use your version of this file under the terms of the CDDL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the CDDL, or the GPL.
#
# Copyright 2010 OpenCSW (http://www.opencsw.org).  All rights reserved.
# Use is subject to license terms.
#
#
# Contributors list :
#
#    William Bonnet wbonnet@opencsw.org
#
#

# Import all the needed modules
import sys
import string
import re
import os
import shutil
import subprocess
import pysvn

from urllib2 import Request, urlopen, URLError
from optparse import OptionParser

# ---------------------------------------------------------------------------------------------------------------------
#
#
class InvalidSourceDirectoryContentException(Exception):
    """Exception raised when a method is called on the Abstract command class
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, message):
        self.message = message


# ---------------------------------------------------------------------------------------------------------------------
#
#
class AbstractCommandMethodCallException(Exception):
    """Exception raised when a method is called on the Abstract command class
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, message):
        self.message = message

# ---------------------------------------------------------------------------------------------------------------------
#
#
class SvnClientException(Exception):
    """Exception raised when an error occur while using svnClient
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, message):
        self.message = message

# ---------------------------------------------------------------------------------------------------------------------
#
#
class UpstreamUrlRetrievalFailedException(Exception):
    """Exception raised when an unsuported protocol is specified in the upstream url
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, url):
        self.url  = url

# ---------------------------------------------------------------------------------------------------------------------
#
#
class NoUpstreamVersionFoundException(Exception):
    """Exception raised when searching the upstream page content does not match the regexp
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, url, regexp):
        self.url     = url
        self.regexp  = regexp


# ---------------------------------------------------------------------------------------------------------------------
#
#
class MissingArgumentException(Exception):
    """Exception raised when a command line argument is missing
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, value):
        self.parameter = value

    def __str__(self):
        return repr(self.parameter)


# ---------------------------------------------------------------------------------------------------------------------
#
#
class CommandLineParser(object):
    """This class is used to parse command line. It process only options. Command verb is parsed by the main procedure
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self):
        # Create the parser object
        self.parser = OptionParser()

        # Add options to parser
        self.parser.add_option("-V", "--verbose", help="Activate verbose mode", action="store_true", dest="verbose")
        self.parser.add_option("-c", "--current-version", help="Current package version", action="store", dest="current_version")
        self.parser.add_option("-d", "--target-location", help="Target location. This is the directory in which the branch will be created (parent of the branch directory). Default value is ../branches", action="store", dest="target_location")
        self.parser.add_option("-r", "--regexp", help="Version matching regular expression", action="store", dest="regexp")
        self.parser.add_option("-s", "--source-directory", help="Source directory (place from where the build is copied). Default value is current directory", action="store", dest="source_directory")
        self.parser.add_option("-t", "--target-version", help="Package target version", action="store", dest="target_version")
        self.parser.add_option("-u", "--upstream-url", help="Upstream version page url", action="store", dest="upstream_url")

    # -----------------------------------------------------------------------------------------------------------------

    def parse(self):
        (self.options, self.args) = self.parser.parse_args()
        return self.options, self.args

# ---------------------------------------------------------------------------------------------------------------------
#
#
class ConfigurationParser(object):
    """This handles parameters retrieved either from command line or configuration file.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def initialize(self, args):
        """Initialize configuration object. If configurations contains files reference, values from the files are
        read and copied into this object. Next attempts to retrieve files stored information will read values from
        this object.
        """

        # This member variable is a flag which defines the status of the verbose mode (True : activated)
        if args.verbose != None:
            self._verbose = args.verbose
        else:
            self._verbose = False

        # This member variable defines the value of the version of the package
        if args.current_version != None:
            self._current_version = args.current_version

        # This member variable defines the value of the regexp used to match the upstream web page
        if args.regexp != None:
            self._regexp = args.regexp

        # This member variable defines the url of the upstream web page used to check for new version
        if args.upstream_url != None:
            self._upstream_url = args.upstream_url

        # This member variable defines the target version of the package during upgrade
        if args.target_version != None:
            self._target_version = args.target_version

        # This member variable defines the target directory of the package during upgrade. This is the location of the new branch
        if args.target_location != None:
            self._target_location = args.target_location

        # This member variable defines the source directory of the package during upgrade. This is the location of the trunk (most of the time)
        if args.source_directory != None:
            self._source_directory = args.source_directory

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self):

        # Initialize all variables to None. Even if useless, the purpose of this to keep up to date the list
        self._verbose = None
        self._current_version = None
        self._regexp = None
        self._upstream_url = None
        self._target_version = None
        self._source_directory = "."
        self._target_location = "../branches"

    # -----------------------------------------------------------------------------------------------------------------

    def getCurrentVersion(self):
        return self._current_version

    # -----------------------------------------------------------------------------------------------------------------

    def getRegexp(self):
        return self._regexp

    # -----------------------------------------------------------------------------------------------------------------

    def getUpstreamURL(self):
        return self._upstream_url

    # -----------------------------------------------------------------------------------------------------------------

    def getVerbose(self):
        return self._verbose

    # -----------------------------------------------------------------------------------------------------------------

    def getSourceDirectory(self):
        return self._source_directory

    # -----------------------------------------------------------------------------------------------------------------

    def getTargetLocation(self):
        return self._target_location

    # -----------------------------------------------------------------------------------------------------------------

    def getTargetVersion(self):
        return self._target_version

# ---------------------------------------------------------------------------------------------------------------------
#
#
class AbstractCommand(object):
    """Base class for command implementation. You should create a derived class per command to implemente.
       A "command" represent a concrete action verb given to the program.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        self.configParser = ConfigurationParser()
        self.name = name

    # -----------------------------------------------------------------------------------------------------------------

    def getName(self):
        return self.name

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, arguments):
        print "Internal error : Abstract command method called\n"
        raise AbstractCommandMethodCallException("execute")

# ---------------------------------------------------------------------------------------------------------------------
#
#
class UpstreamWatchCommand(AbstractCommand):
    """UpstreamWatch command. This command is the base class used for all upstream watch commands. It provides argument checking
    url content retrieving, version comparison, etc.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(UpstreamWatchCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def UrlContentRetrieve(self, url):

        try:
            # Request the upstream URL and open it
            req = Request(url)
            response = urlopen(req)

        except URLError, e:
            if hasattr(e, 'reason'):
                print 'We failed to reach a server during retrieval of : ' + url
                print 'Reason: ', e.reason
            elif hasattr(e, 'code'):
                print 'The server couldn\'t fulfill the request during retrieval of : ' + url
                print 'Error code: ', e.code

            # Check for response code value. We should get a 200
            raise UpstreamUrlRetrievalFailedException(url)

        else:
            # everything is fine, retrieve the page content
            return response.read()


    # -----------------------------------------------------------------------------------------------------------------

    def CompareVersionAndGetNewest(self, version1, version2):

        # we consider the version to be composed of several elements separated by '.' ',' '-' or '_'
        # an elements can be a string or a number
        # at each step we extract the next elements of the two version strings and compare them

        # Retrieve the tokens from both version. Use . - , and _ as splitters
    	splittingRegExp = "(?:[\.,_-])"
        tokens1 = re.split(splittingRegExp, version1)
        tokens2 = re.split(splittingRegExp, version2)

        if self.configParser.getVerbose():
            print "Comparing " + version1 + " and " + version2

        # Iterates the toeksn of version 1, pop tokens one by one and compare to the token at same
        # in version 2
        while len(tokens1) > 0:
            # If we still have tokens in version 1 and version 2 is empty, then version 1 is newer
            # TODO: may have to deal with beta suffixes...
            if len(tokens2) == 0:
                return version1

            # Convert both elements to integer
            # TODO : handles chars in versions
            elem1 = tokens1.pop(0)
            elem2 = tokens2.pop(0)

            # If both elements are integer, then convert to int before comparison, otherwise compare strings
            try:
                elem1 = int(elem1)
                elem2 = int(elem2)
            except:
                elem1 = str(elem1)
                elem2 = str(elem2)
                # print "Doing string comparison"

            # print "Comparing %(elem1)s and %(elem2)s" % { 'elem1' : elem1 , 'elem2' : elem2 }

            # if elements are the same continue the loop
            if elem1 == elem2:
                continue

            # Test if elem1 is more recent
            if elem1 > elem2:
                # print "%(elem1)s > %(elem2)s" % { 'elem1' : elem1 , 'elem2' : elem2 }
                return version1
            else:
                # print "%(elem1)s < %(elem2)s" % { 'elem1' : elem1 , 'elem2' : elem2 }
                return version2

        return version1

# ---------------------------------------------------------------------------------------------------------------------
#
#
class CheckUpstreamCommand(UpstreamWatchCommand):
    """CheckUpstream command. This command retrieve the upstream web page and search for a new version. Version check is
    done by matching the regexp from the makefile on the page. Results are sorted to get the highest available and
    compared to current version
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(CheckUpstreamCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def checkArgument(self):

        # Variable used to flag that we have a missing argument
        argsValid = True

        # Current version is mandatory
        if self.configParser.getCurrentVersion() == None:
            print "Error : Current version is not defined. Please use --current-version flag, or --help to display help"
            argsValid = False

        # Regexp is mandatory
        if self.configParser.getRegexp() == None:
            print "Error : Regexp is not defined. Please use --regexp flag, or --help to display help"
            argsValid = False

        # UpstreamURL is mandatory
        if self.configParser.getUpstreamURL() == None:
            print "Error : Upstream version page URL is not defined. Please use --upstream-url flag, or --help to display help"
            argsValid = False

        # If arguments are not valid raise an exception
        if argsValid == False:
            raise MissingArgumentException("Some mandatory arguments are missing. Unable to continue.")

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, args):

        try:

            # Initialize configuration
            self.configParser.initialize(opts)

            # Need a way to check that all options needed are available
            self.checkArgument()

            # Call the method in charge of retrieving upstream content
            content = self.UrlContentRetrieve(self.configParser.getUpstreamURL())

            # Search the strings matching the regexp passed through command line arguments
            p = re.compile(self.configParser.getRegexp())
            matches = p.findall(content)

            # Check if we have found some results
            if len(matches) == 0:
                raise NoUpstreamVersionFoundException(self.configParser.getUpstreamURL(), self.configParser.getRegexp())
                print "No match found, we should trigger some error since even current version has not been found"
                return False
            else:
                newestVersion = self.configParser.getCurrentVersion()
                while len(matches) > 0:
                    newestVersion = self.CompareVersionAndGetNewest(newestVersion, matches.pop(0))

            # At the end of the processing loop, test if we have a newer version avail, if yes output it
            if newestVersion <>  self.configParser.getCurrentVersion():
                print newestVersion

            # Exit after processing, eveythin gis ok, return true to the command processor
            return True

        except MissingArgumentException, (instance):

            # Display a cool error message :)
            print instance.parameter

            # Exits through exception handling, thus return false to the command processor
            return False

        except UpstreamUrlRetrievalFailedException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False

        except NoUpstreamVersionFoundException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False


# ---------------------------------------------------------------------------------------------------------------------
#
#
class GetUpstreamLatestVersionCommand(UpstreamWatchCommand):
    """GetUpstreamLatestVersion command. This command retrieve the upstream web page and search for the latest version.
    Version check is done by matching the regexp from the makefile on the page. Results are sorted to get the newest version
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(GetUpstreamLatestVersionCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def checkArgument(self):

        # Variable used to flag that we have a missing argument
        argsValid = True

        # Regexp is mandatory
        if self.configParser.getRegexp() == None:
            print "Error : Regexp is not defined. Please use --regexp flag, or --help to display help"
            argsValid = False

        # UpstreamURL is mandatory
        if self.configParser.getUpstreamURL() == None:
            print "Error : Upstream version page URL is not defined. Please use --upstream-url flag, or --help to display help"
            argsValid = False

        # If arguments are not valid raise an exception
        if argsValid == False:
            raise MissingArgumentException("Some mandatory arguments are missing. Unable to continue.")

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, args):

        try:

            # Initialize configuration
            self.configParser.initialize(opts)

            # Need a way to check that all options needed are available
            self.checkArgument()

            # Call the method in charge of retrieving upstream content
            content = self.UrlContentRetrieve(self.configParser.getUpstreamURL())

            # Search the strings matching the regexp passed through command line arguments
            p = re.compile(self.configParser.getRegexp())
            matches = p.findall(content)

            # Check if we have found some results
            if len(matches) == 0:
                raise NoUpstreamVersionFoundException(self.configParser.getUpstreamURL(), self.configParser.getRegexp())
                print "No match found, we should trigger some error since even current version has not been found"
                return False
            else:
                newestVersion = matches.pop(0)
                while len(matches) > 0:
                    newestVersion = self.CompareVersionAndGetNewest(newestVersion, matches.pop(0))

            # At the end of the processing loop, we print the version
            print newestVersion

            # Exit after processing, eveythin gis ok, return true to the command processor
            return True

        except MissingArgumentException, (instance):

            # Display a cool error message :)
            print instance.parameter

            # Exits through exception handling, thus return false to the command processor
            return False

        except UpstreamUrlRetrievalFailedException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False

        except NoUpstreamVersionFoundException, (instance):

            # Exits through exception handling, thus return false to the command processor
            return False


# ---------------------------------------------------------------------------------------------------------------------
#
#
class UpgradeToVersionCommand(UpstreamWatchCommand):
    """UpgradeToVersion command. This command upgrade the build description from a version to another.
    Current files in trunk are copied to a new branch. Branch is named accord to the following pattern :
    PKG/branches/upgrade_from_CURRENTVERSION_to_DESTVERSION. After copy, version in the Makefile is modified.
    An optional argument can be passed to commit after branch creation.
    
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self, name):
        super(UpgradeToVersionCommand, self).__init__(name)

    # -----------------------------------------------------------------------------------------------------------------

    def checkArgument(self):

        # Variable used to flag that we have a missing argument
        argsValid = True

        # FromVersion is mandatory
        if self.configParser.getCurrentVersion() == None:
            print "Error : Current version is not defined. Please use --current-version flag, or --help to display help"
            argsValid = False

        # ToVersion is mandatory
        if self.configParser.getTargetVersion() == None:
            print "Error : Target version is not defined. Please use --target-version flag, or --help to display help"
            argsValid = False

        # ToVersion is mandatory
        if self.configParser.getTargetLocation() == None:
            print "Error : Target directory is not defined. Please use --target-location flag, or --help to display help"
            argsValid = False

        # If arguments are not valid raise an exception
        if argsValid == False:
            raise MissingArgumentException("Some mandatory arguments are missing. Unable to continue.")

    # -----------------------------------------------------------------------------------------------------------------

    def checkWorkingDirectory(self):
        """ This method checks that the command is executed from a valid working directory. A valid working directory
            is a directory in which we find a package buildDescription that means a Makefile and a gar directory or symlink
        """

        # Check that the Makefile exist
        if os.path.isfile(self.configParser.getSourceDirectory() + "/Makefile") == False:
            # No it does not exist, thus generate an error message
            msg = "Error : there is no Makefile under %(src)s" % { "src" : os.path.abspath(self.configParser.getSourceDirectory()) }
    
            # Then raise an exception
            raise InvalidSourceDirectoryContentException(msg)

        # Check that the gar directory exists (can be a directory or symlink)
        if os.path.isdir(self.configParser.getSourceDirectory() + "/gar") == False:
            # No it does not exist, thus generate an error message
            msg = "Error : there is no gar directory under %(src)s" % { "src" : os.path.abspath(self.configParser.getSourceDirectory()) }
    
            # Then raise an exception
            raise InvalidSourceDirectoryContentException(msg)

    # -----------------------------------------------------------------------------------------------------------------

    def getGarRelativeTargetDirectory(self):
        """ This method return None if gar directory is an actual directory, or a relative path if gar is a symlink to 
            a real directory. In case of a symlink pointing to another symlink, we do not try to get the absolute path
            having one level of indirection is enough. 
            The target directory is a relative path. This path is adjusted to be consistent from the target directory. It
            has to be modified since it is basically a relative path from the source directory.            
        """

        # Get the newgar information
        garDir = self.configParser.getSourceDirectory() + "/gar"
        if os.path.islink(garDir):
            garTarget = os.path.relpath(os.path.abspath(os.readlink(garDir)), os.path.abspath(targetDir))
        else:
            garTarget = None
    
    # -----------------------------------------------------------------------------------------------------------------

    def getGarRelativeTargetDirectory(self):
        """ This method return None if gar directory is an actual directory, or a relative path if gar is a symlink to 
            a real directory. In case of a symlink pointing to another symlink, we do not try to get the absolute path
            having one level of indirection is enough. 
            The target directory is a relative path. This path is adjusted to be consistent from the target directory. It
            has to be modified since it is basically a relative path from the source directory.            
        """

        # Get the newgar information
        garDir = self.configParser.getSourceDirectory() + "/gar"
        if os.path.islink(garDir):
            garTarget = os.path.relpath(os.path.abspath(os.readlink(garDir)), os.path.abspath(self.getTargetDirectory()))
        else:
            garTarget = None

        return garTarget

    # -----------------------------------------------------------------------------------------------------------------

    def getTargetDirectory(self):
        """ This method return the target directory which is a computed value based on target location, current version
            and target version
        """

        return self.configParser.getTargetLocation() + "/upgrade_from_" + self.configParser.getCurrentVersion() + "_to_" + self.configParser.getTargetVersion()

    # -----------------------------------------------------------------------------------------------------------------

    def copySvnSourceToTarget(self, garRelativeTarget):
        """ This method copy sources from the working copy to the target in the same working copy. If garRelativeTarget is not 
            None, it means gar directory is a symlink. Then once copy is done it is deleted in the target directory and
            recreated to point to the new relative directory
        """

        try:
            # Create a new svn client
            svnClient = pysvn.Client()

            # Do the actual copy in the svn working copy
            svnClient.copy(os.path.abspath(self.configParser.getSourceDirectory()), self.getTargetDirectory())

            # Backup the current directory
            curDir = os.getcwd()

            # Change to target directory
            os.chdir(self.getTargetDirectory())

            # Test if gar relative path is defined
            if garRelativeTarget:
                # Test if gar directory is a symlink and 
                if os.path.islink("./gar"):
                    os.remove("./gar")
                    os.symlink(garRelativeTarget, "./gar")
                # No ... :( This a "should not happen error" since it was a symlink before the copy. Exit
                else:
                    print "Internal error : gar is not a symlink but garRelativeTarget is defined"
                    return False
            # No else but ... If gar relative path is not defined, we have copied a real directory. Nothing to do in this case

            # Restore the working directory
            os.chdir(curDir)

        # SVN client exception handling    
        except pysvn.ClientError , e:
            # Generate a cool error message
            msg = "SVN Client error : " + e.args[0] + "\n" + "Error occured when executing command svnClient.copy(%(src)s, %(dest)s)" \
                  % { 'src' : os.path.abspath(self.configParser.getSourceDirectory()), 'dest' : self.getTargetDirectory() }

            # Then raise the exception
            raise SvnClientException(msg)

    # -----------------------------------------------------------------------------------------------------------------

    def modifyVersion(self):
        """ This method modifies the version in the Makefile. It replaces current version by new version. 
            Version has to be defined on a single line strting by VERSION, having some spaces or tabs then 
            and egal sign = then some tabs or spaces and the version vaue to finish the line
        """

        # Backup the current directory
        curDir = os.getcwd()

        # Change to target directory
        os.chdir(self.getTargetDirectory())

        # Array storing the Makefile lines
        lines = []

        # Iterate each line in  the file                
        for line in open("./Makefile", 'r'):
            # Match the file line by line               
            m = re.match(r"\s*VERSION\s*=\s*(?P<version>.*)", line)

            # Test if this is a match
            if m == None:
                # No, thus output the current line without modifications
                lines.append(line)
            else:   
                # Yes it is a match, thus output the modified line
                lines.append("VERSION = " + self.configParser.getTargetVersion() + "\n")

        # Open the new Makefile for output
        f = open("./Makefile", 'w')

        # Iterates the array of lines and write each one to the Makefile 
        for element in lines:
            f.write(element)

        # Close the Makefile
        f.close()

        # Restore the working directory
        os.chdir(curDir)

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, args):

        try:

            # Initialize configuration
            self.configParser.initialize(opts)

            # Need a way to check that all options needed are available
            self.checkArgument()

            # Check that the command is launched from a valid directory
            self.checkWorkingDirectory()

            # Generates the target directory
            self.getTargetDirectory()

            # Get the new gar information
            garRelativeTarget = self.getGarRelativeTargetDirectory()

            # Copy target directory to destination
            self.copySvnSourceToTarget(garRelativeTarget)

            # Modify the version inside the Makefile
            self.modifyVersion()

            # Exit after processing, eveythin gis ok, return true to the command processor
            return True

        # Handles exception that occurs when arguments are incorrect
        except MissingArgumentException, instance:

            # Display a cool error message :)
            print instance.parameter

            # Exits through exception handling, thus return false to the command processor
            return False

        # Handles SVN client exception
        except SvnClientException , e:
            
            # Display a cool error message :)
            print e.message

            # Exits through exception handling, thus return false to the command processor
            return False

        # Handles exceptions which might occur while checking source directory content
        except InvalidSourceDirectoryContentException , e:
            
            # Display a cool error message :)
            print e.message

            # Exits through exception handling, thus return false to the command processor
            return False

# ---------------------------------------------------------------------------------------------------------------------
#
#
class CommandProcessor(object):
    """This class receive commands from the main loop and forward call to concrete command.
    """

    # -----------------------------------------------------------------------------------------------------------------

    def __init__(self):
        """Initialize the objects in charge of concrete command processing. Each object instance are stored in a
        map using a key which is the action verb used on the command line.
        """

        # Defines the map storing the concrete commands
        self.commandArray = {}

        # Creates all the concrete commands
        cmd = CheckUpstreamCommand("check-upstream")
        self.commandArray[cmd.getName()] = cmd

        cmd = GetUpstreamLatestVersionCommand("get-upstream-latest-version")
        self.commandArray[cmd.getName()] = cmd

        cmd = UpgradeToVersionCommand("upgrade-to-version")
        self.commandArray[cmd.getName()] = cmd

    # -----------------------------------------------------------------------------------------------------------------

    def execute(self, opts, arguments):
        """This method checks that an action is supplied and call the action handler
        """

        # Check that an action verb is supplied. If none an error is returned
        if len(arguments) == 0:
            print "Error : no action supplied"
            return 1

        # The first element in the arguments array is the action verb. Retrieve the command
        # using action verb as key
        if self.commandArray.has_key(arguments[0]):
            return self.commandArray[arguments[0]].execute(opts, arguments)
        else:
            print "Error : %(action)s action is not supported" % { 'action' : arguments[0] }
            return 2

# ---------------------------------------------------------------------------------------------------------------------
#
# Fonction principale
#
def main():
    """Program main loop. Process args and call concrete command action.
    """

    # Create the command processor object
    commandProcessor = CommandProcessor()

    # Parse command line arguments
    cliParser  = CommandLineParser()

    # Call the command line parser
    (opts, args) = cliParser.parse()

    # Call the execute method on the command processor. This method is in charge to find the concrete command
    return commandProcessor.execute(opts, args)

# Exit with main return code
if __name__ == '__main__':
    sys.exit(main())

