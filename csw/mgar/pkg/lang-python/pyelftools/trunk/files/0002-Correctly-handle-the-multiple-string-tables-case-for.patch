From b6a5e70d938ccf3532b5c6ae6de04fd68bfaca39 Mon Sep 17 00:00:00 2001
From: Yann Rouillard <yann@pleiades.fr.eu.org>
Date: Tue, 9 Jul 2013 20:22:27 +0200
Subject: [PATCH] Correctly handle the "multiple string tables" case for string
 resolution in the dynamic section

The string table used to resolve various strings in the dynamic section
is given by an entry of the dynamic section, the one with the DT_STRTAB tag.
As several string tables with the same name can co-exist in an elf file
we must explicitely look for the string table pointed by this tag instead
of relying on a section search by name.
---
 elftools/elf/dynamic.py | 33 +++++++++++++++++++++++++++------
 1 file changed, 27 insertions(+), 6 deletions(-)

diff --git a/elftools/elf/dynamic.py b/elftools/elf/dynamic.py
index 60fb450..dd150be 100644
--- a/elftools/elf/dynamic.py
+++ b/elftools/elf/dynamic.py
@@ -28,12 +28,11 @@ class DynamicTag(object):
         ['DT_NEEDED', 'DT_RPATH', 'DT_RUNPATH', 'DT_SONAME',
          'DT_SUNW_FILTER'])
 
-    def __init__(self, entry, elffile):
+    def __init__(self, entry, stringtable=None):
         self.entry = entry
-        if entry.d_tag in self._HANDLED_TAGS:
-            dynstr = elffile.get_section_by_name(b'.dynstr')
+        if entry.d_tag in self._HANDLED_TAGS and stringtable:
             setattr(self, entry.d_tag[3:].lower(),
-                    dynstr.get_string(self.entry.d_val))
+                    stringtable.get_string(self.entry.d_val))
 
     def __getitem__(self, name):
         """ Implement dict-like access to entries
@@ -44,7 +43,7 @@ class DynamicTag(object):
         return '<DynamicTag (%s): %r>' % (self.entry.d_tag, self.entry)
 
     def __str__(self):
-        if self.entry.d_tag in self._HANDLED_TAGS:
+        if hasattr(self, self.entry.d_tag[3:].lower()):
             s = '"%s"' % getattr(self, self.entry.d_tag[3:].lower())
         else:
             s = '%#x' % self.entry.d_ptr
@@ -61,6 +60,28 @@ class Dynamic(object):
         self._num_tags = -1
         self._offset = position
         self._tagsize = self._elfstructs.Elf_Dyn.sizeof()
+        # Several string tables can exist in a elf file, so we
+        # must find the one associated with the dynamic section,
+        # which is the one pointed at by the DT_STRTAB dynamic tag
+        self._find_and_set_stringtable()
+
+    def _find_and_set_stringtable(self):
+        """ Find and set the stringtable section associated
+            with the dynamic section
+        """
+        # We don't have yet the stringtable, so we set it to None to be able
+        # to iterate through tags without trying to do string table resolution
+        # at that time
+        self._stringtable = None
+        for tag in self.iter_tags():
+            if tag['d_tag'] == 'DT_STRTAB':
+                # the DT_STRTAB tag points directly to the string table address
+                # not the section header, so we iterate throught sections until
+                # we found the one which points to the same offset
+                for section in self._elffile.iter_sections():
+                    if section['sh_addr'] == tag['d_val']:
+                        self._stringtable = section
+                        return
 
     def iter_tags(self, type=None):
         """ Yield all tags (limit to |type| if specified)
@@ -80,7 +101,7 @@ class Dynamic(object):
             self._elfstructs.Elf_Dyn,
             self._stream,
             stream_pos=offset)
-        return DynamicTag(entry, self._elffile)
+        return DynamicTag(entry, self._stringtable)
 
     def num_tags(self):
         """ Number of dynamic tags in the file
-- 
1.8.3.1

