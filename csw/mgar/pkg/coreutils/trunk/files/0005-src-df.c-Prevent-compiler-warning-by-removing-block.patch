From 947aa78883636ef8e2469d1a89e8e6cb7a142dff Mon Sep 17 00:00:00 2001
From: Ben Walton <bwalton@opencsw.org>
Date: Sun, 1 Jun 2014 19:55:24 +0200
Subject: [PATCH] src/df.c: Prevent compiler warning by removing block

gcc 4.9.0 thinks that v may be uninitialized due to the block around the options in a switch/case statement.

Signed-off-by: Ben Walton <bwalton@opencsw.org>
---
 src/df.c | 98 +++++++++++++++++++++++++++++++---------------------------------
 1 file changed, 48 insertions(+), 50 deletions(-)

diff --git a/src/df.c b/src/df.c
index 969670e..10541a8 100644
--- a/src/df.c
+++ b/src/df.c
@@ -967,56 +967,54 @@ get_dev (char const *disk, char const *mount_point, char const* file,
 
         case PCENT_FIELD:
         case IPCENT_FIELD:
-          {
-            double pct = -1;
-            if (! known_value (v->used) || ! known_value (v->available))
-              ;
-            else if (!v->negate_used
-                     && v->used <= TYPE_MAXIMUM (uintmax_t) / 100
-                     && v->used + v->available != 0
-                     && (v->used + v->available < v->used)
-                     == v->negate_available)
-              {
-                uintmax_t u100 = v->used * 100;
-                uintmax_t nonroot_total = v->used + v->available;
-                pct = u100 / nonroot_total + (u100 % nonroot_total != 0);
-              }
-            else
-              {
-                /* The calculation cannot be done easily with integer
-                   arithmetic.  Fall back on floating point.  This can suffer
-                   from minor rounding errors, but doing it exactly requires
-                   multiple precision arithmetic, and it's not worth the
-                   aggravation.  */
-                double u = v->negate_used ? - (double) - v->used : v->used;
-                double a = v->negate_available
-                           ? - (double) - v->available : v->available;
-                double nonroot_total = u + a;
-                if (nonroot_total)
-                  {
-                    long int lipct = pct = u * 100 / nonroot_total;
-                    double ipct = lipct;
-
-                    /* Like 'pct = ceil (dpct);', but avoid ceil so that
-                       the math library needn't be linked.  */
-                    if (ipct - 1 < pct && pct <= ipct + 1)
-                      pct = ipct + (ipct < pct);
-                  }
-              }
-
-            if (0 <= pct)
-              {
-                if (asprintf (&cell, "%.0f%%", pct) == -1)
-                  cell = NULL;
-              }
-            else
-              cell = strdup ("-");
-
-            if (!cell)
-              xalloc_die ();
-
-            break;
-          }
+	  double pct = -1;
+	  if (! known_value (v->used) || ! known_value (v->available))
+	    ;
+	  else if (!v->negate_used
+		   && v->used <= TYPE_MAXIMUM (uintmax_t) / 100
+		   && v->used + v->available != 0
+		   && (v->used + v->available < v->used)
+		   == v->negate_available)
+	    {
+	      uintmax_t u100 = v->used * 100;
+	      uintmax_t nonroot_total = v->used + v->available;
+	      pct = u100 / nonroot_total + (u100 % nonroot_total != 0);
+	    }
+	  else
+	    {
+	      /* The calculation cannot be done easily with integer
+		 arithmetic.  Fall back on floating point.  This can suffer
+		 from minor rounding errors, but doing it exactly requires
+		 multiple precision arithmetic, and it's not worth the
+		 aggravation.  */
+	      double u = v->negate_used ? - (double) - v->used : v->used;
+	      double a = v->negate_available
+		         ? - (double) - v->available : v->available;
+	      double nonroot_total = u + a;
+	      if (nonroot_total)
+		{
+		  long int lipct = pct = u * 100 / nonroot_total;
+		  double ipct = lipct;
+
+		  /* Like 'pct = ceil (dpct);', but avoid ceil so that
+		     the math library needn't be linked.  */
+		  if (ipct - 1 < pct && pct <= ipct + 1)
+		    pct = ipct + (ipct < pct);
+		}
+	    }
+
+	  if (0 <= pct)
+	    {
+	      if (asprintf (&cell, "%.0f%%", pct) == -1)
+		cell = NULL;
+	    }
+	  else
+	    cell = strdup ("-");
+
+	  if (!cell)
+	    xalloc_die ();
+
+	  break;
 
         case FILE_FIELD:
           cell = xstrdup (file);
-- 
1.8.4.1

