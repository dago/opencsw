diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..0ca708e
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,7 @@
+configure
+autom4te.cache
+Makefile
+config.log
+config.status
+etckeeper
+etckeeper.conf
diff --git a/Makefile b/Makefile
deleted file mode 100644
index b2d6565..0000000
--- a/Makefile
+++ /dev/null
@@ -1,48 +0,0 @@
-# You should configure etckeeper.conf for your distribution before
-# installing etckeeper.
-CONFFILE=etckeeper.conf
-include $(CONFFILE)
-
-DESTDIR?=
-prefix=/usr
-sbindir=${prefix}/sbin
-etcdir=/etc
-mandir=${prefix}/share/man
-vardir=/var
-
-INSTALL=install 
-INSTALL_EXE=${INSTALL} -D
-INSTALL_DATA=${INSTALL} -m 0644 -D
-
-build: etckeeper.spec
-	-./etckeeper-bzr/__init__.py build || echo "** bzr support not built"
-	
-install:
-	mkdir -p $(DESTDIR)$(etcdir)/etckeeper/ $(DESTDIR)$(vardir)/cache/etckeeper/
-	cp -a *.d $(DESTDIR)$(etcdir)/etckeeper/
-	$(INSTALL_DATA) $(CONFFILE) $(DESTDIR)$(etcdir)/etckeeper/etckeeper.conf
-	$(INSTALL_EXE) etckeeper $(DESTDIR)$(sbindir)/etckeeper
-	$(INSTALL_DATA) etckeeper.8 $(DESTDIR)$(mandir)/man8/etckeeper.8
-	$(INSTALL_DATA) bash_completion $(DESTDIR)$(etcdir)/bash_completion.d/etckeeper
-ifeq ($(HIGHLEVEL_PACKAGE_MANAGER),apt)
-	$(INSTALL_DATA) apt.conf $(DESTDIR)$(etcdir)/apt/apt.conf.d/05etckeeper
-	mkdir -p $(DESTDIR)$(etcdir)/cruft/filters-unex
-	$(INSTALL_DATA) cruft_filter $(DESTDIR)$(etcdir)/cruft/filters-unex/etckeeper
-endif
-ifeq ($(LOWLEVEL_PACKAGE_MANAGER),pacman-g2)
-	$(INSTALL_DATA) pacman-g2.hook $(DESTDIR)$(etcdir)/pacman-g2/hooks/etckeeper
-endif
-ifeq ($(HIGHLEVEL_PACKAGE_MANAGER),yum)
-	$(INSTALL_DATA) yum-etckeeper.py $(DESTDIR)$(prefix)/lib/yum-plugins/etckeeper.py
-	$(INSTALL_DATA) yum-etckeeper.conf $(DESTDIR)$(etcdir)/yum/pluginconf.d/etckeeper.conf
-endif
-	-./etckeeper-bzr/__init__.py install --root=$(DESTDIR) || echo "** bzr support not installed"
-	echo "** installation successful"
-
-clean: etckeeper.spec
-	rm -rf build
-
-etckeeper.spec:
-	sed -i "s/Version:.*/Version: $$(perl -e '$$_=<>;print m/\((.*?)\)/'<debian/changelog)/" etckeeper.spec
-
-.PHONY: etckeeper.spec
diff --git a/Makefile.am b/Makefile.am
new file mode 100644
index 0000000..5fdabbf
--- /dev/null
+++ b/Makefile.am
@@ -0,0 +1,84 @@
+sysconfdirdir = $(sysconfdir)/$(PACKAGE)
+
+KEEPERSCRIPTS = $(wildcard *.d)
+KSFILES = $(foreach KD,$(KEEPERSCRIPTS),$(wildcard $(KD)/*))
+KSINPUTS = $(filter %.in,$(KSFILES))
+KSINPUTTRANS = $(patsubst %.in,%,$(KSINPUTS))
+KSNONINPUTS = $(filter-out %.in,$(KSFILES))
+
+sbin_SCRIPTS = etckeeper
+man_MANS = etckeeper.8
+sysconfdir_DATA = etckeeper.conf
+
+APTFILES = apt.conf
+YUMFILES = yum-etckeeper.py yum-etckeeper.conf
+PACMANFILES = pacman-g2.hook
+BASHFILES = bash_completion
+CRUFTFILES = cruft_filter
+
+OPTS =
+if INST_BASH_COMPLETION
+OPTS += inst-bash
+endif
+if INST_CRUFT_FILTER
+OPTS += inst-cruft
+endif
+
+EXTRA_DIST = $(NEED_SUBST) $(APTFILES) $(YUMFILES) $(PACMANFILES) $(KEEPERSCRIPTFILES) $(BASHFILES) $(CRUFTFILES) $(KSINPUTS)
+
+CLEANFILES = $(sbin_SCRIPTS) $(man8_MANS) $(sysconfdir_DATA) $(KSINPUTTRANS)
+
+NEED_SUBST = etckeeper.in etckeeper.conf.in etckeeper.8.in $(KSINPUTS)
+
+# files that need autoconf-ish substitutions.
+REQ_SUBST = $(NEED_SUBST:.in=)
+
+do_subst = sed \
+		-e 's|@datadir[@]|$(pkgdatadir)|g' \
+		-e 's|@prefix[@]|$(prefix)|g' \
+		-e 's|@sysconfdir[@]|$(sysconfdir)|g' \
+		-e 's|@docdir[@]|$(docdir)|g' \
+		-e 's|@HIGHLEVEL[@]|$(HIGHLEVEL)|g' \
+		-e 's|@LOWLEVEL[@]|$(LOWLEVEL)|g' \
+		-e 's|@VCS[@]|$(VCS)|g' \
+		-e 's|@SHELLPATH[@]|$(SHELLPATH)|g'
+
+$(REQ_SUBST): % : %.in Makefile
+	$(do_subst) < $(srcdir)/$< > $@
+
+high-apt: apt.conf
+	$(MKDIR_P) $(DESTDIR)/$(sysconfdir)/apt/apt.conf.d
+	$(INSTALL_DATA) apt.conf $(DESTDIR)/$(sysconfdir)/apt/apt.conf.d/05etckeeper
+
+low-dpkg:
+	/bin/true
+
+high-yum: yum-etckeeper.py yum-etckeeper.conf
+	$(MKDIR_P) $(DESTDIR)$(libdir)/yum-plugins $(DESTDIR)$(sysconfdir)/yum
+	$(INSTALL_DATA) yum-etckeeper.py $(DESTDIR)$(libdir)/yum-plugins/
+	$(INSTALL_DATA) yum-etckeeper.conf $(DESTDIR)$(sysconfdir)/yum/
+
+low-rpm:
+	/bin/true
+
+high-pacman-g2:
+	/bin/true
+
+low-pacman-g2:
+	$(MKDIR_P) $(DESTDIR)$(sysconfdir)/pacman-g2/hooks
+	$(INSTALL_DATA)  pacman-g2.hook $(DESTDIR)/$(sysconfdir)/pacman-g2/hook/
+
+inst-bash:
+	$(MKDIR_P) $(DESTDIR)$(sysconfdir)/bash_completion.d
+	$(INSTALL_DATA) bash_completion $(DESTDIR)$(sysconfdir)/bash_completion.d/etckeeper
+
+inst-cruft:
+	$(MKDIR_P) $(DESTDIR)$(sysconfdir)/cruft/filters-unex
+	$(INSTALL_DATA) cruft_filter $(DESTDIR)$(sysconfdir)/cruft/filters-unex/etckeeper
+
+$(KEEPERSCRIPTS): $(KSINPUTTRANS)
+	$(MKDIR_P) $(DESTDIR)$(sysconfdirdir)/$@
+	$(INSTALL_DATA) $(filter $@/%,$(KSINPUTTRANS) $(KSNONINPUTS)) $(DESTDIR)$(sysconfdirdir)/$@
+
+install-data-local: $(KEEPERSCRIPTS) high-$(HIGHLEVEL) low-$(LOWLEVEL) $(OPTS)
+
diff --git a/commit.d/10vcs-test b/commit.d/10vcs-test
deleted file mode 100755
index e33d734..0000000
--- a/commit.d/10vcs-test
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/sh
-set -e
-	
-not_enabled_warning() {
-	echo "etckeeper warning: etckeeper is not yet enabled for $(pwd)" >&2
-	echo "etckeeper warning: run etckeeper init to enable it" >&2
-}
-
-if [ "$VCS" = git ] && [ ! -d .git ]; then
-	not_enabled_warning
-elif [ "$VCS" = hg ] && [ ! -d .hg ]; then
-	not_enabled_warning
-elif [ "$VCS" = bzr ] && [ ! -d .bzr ]; then
-	not_enabled_warning
-elif [ "$VCS" = darcs ] && [ ! -d _darcs ]; then
-	not_enabled_warning
-fi
diff --git a/commit.d/10vcs-test.in b/commit.d/10vcs-test.in
new file mode 100644
index 0000000..5aa6b52
--- /dev/null
+++ b/commit.d/10vcs-test.in
@@ -0,0 +1,17 @@
+#!@SHELLPATH@
+set -e
+	
+not_enabled_warning() {
+	echo "etckeeper warning: etckeeper is not yet enabled for $(pwd)" >&2
+	echo "etckeeper warning: run etckeeper init to enable it" >&2
+}
+
+if [ "$VCS" = git ] && [ ! -d .git ]; then
+	not_enabled_warning
+elif [ "$VCS" = hg ] && [ ! -d .hg ]; then
+	not_enabled_warning
+elif [ "$VCS" = bzr ] && [ ! -d .bzr ]; then
+	not_enabled_warning
+elif [ "$VCS" = darcs ] && [ ! -d _darcs ]; then
+	not_enabled_warning
+fi
diff --git a/commit.d/30bzr-add b/commit.d/30bzr-add
deleted file mode 100755
index 3e7e95d..0000000
--- a/commit.d/30bzr-add
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = bzr ] && [ -d .bzr ]; then
-	if ! bzr add -q .; then
-		echo "etckeeper warning: bzr add failed" >&2
-	fi
-fi
diff --git a/commit.d/30bzr-add.in b/commit.d/30bzr-add.in
new file mode 100644
index 0000000..e9012c7
--- /dev/null
+++ b/commit.d/30bzr-add.in
@@ -0,0 +1,8 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = bzr ] && [ -d .bzr ]; then
+	if ! bzr add -q .; then
+		echo "etckeeper warning: bzr add failed" >&2
+	fi
+fi
diff --git a/commit.d/30darcs-add b/commit.d/30darcs-add
deleted file mode 100755
index 98be4bf..0000000
--- a/commit.d/30darcs-add
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = darcs ] && [ -d _darcs ]; then
-	rc=0
-	res=$( darcs add -qr . 2>&1 ) || rc=$?
-	if test $rc -ne 0; then
-		if ! test $rc -eq 2 -a "${res%No files were added}" != "$res"; then
-			printf "%s" "$res"
-			echo "etckeeper warning: darcs add failed" >&2
-		fi
-	fi
-	unset rc res
-fi
diff --git a/commit.d/30darcs-add.in b/commit.d/30darcs-add.in
new file mode 100644
index 0000000..46b50f2
--- /dev/null
+++ b/commit.d/30darcs-add.in
@@ -0,0 +1,14 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = darcs ] && [ -d _darcs ]; then
+	rc=0
+	res=$( darcs add -qr . 2>&1 ) || rc=$?
+	if test $rc -ne 0; then
+		if ! test $rc -eq 2 -a "${res%No files were added}" != "$res"; then
+			printf "%s" "$res"
+			echo "etckeeper warning: darcs add failed" >&2
+		fi
+	fi
+	unset rc res
+fi
diff --git a/commit.d/30git-add b/commit.d/30git-add
deleted file mode 100755
index 66d96a9..0000000
--- a/commit.d/30git-add
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ] && [ -d .git ]; then
-	if ! git add .; then
-		echo "etckeeper warning: git add failed" >&2
-	fi
-fi
diff --git a/commit.d/30git-add.in b/commit.d/30git-add.in
new file mode 100644
index 0000000..09b5a8b
--- /dev/null
+++ b/commit.d/30git-add.in
@@ -0,0 +1,8 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ] && [ -d .git ]; then
+	if ! git add .; then
+		echo "etckeeper warning: git add failed" >&2
+	fi
+fi
diff --git a/commit.d/30hg-addremove b/commit.d/30hg-addremove
deleted file mode 100755
index 1b999bb..0000000
--- a/commit.d/30hg-addremove
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = hg ] && [ -d .hg ]; then
-	if ! hg addremove .; then
-		echo "etckeeper warning: hg addremove failed" >&2
-	fi
-fi
diff --git a/commit.d/30hg-addremove.in b/commit.d/30hg-addremove.in
new file mode 100644
index 0000000..25218cd
--- /dev/null
+++ b/commit.d/30hg-addremove.in
@@ -0,0 +1,8 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = hg ] && [ -d .hg ]; then
+	if ! hg addremove .; then
+		echo "etckeeper warning: hg addremove failed" >&2
+	fi
+fi
diff --git a/commit.d/40git-rm b/commit.d/40git-rm
deleted file mode 100755
index 26f492a..0000000
--- a/commit.d/40git-rm
+++ /dev/null
@@ -1,27 +0,0 @@
-#!/bin/sh
-set -e
-
-IFS='
-'
-
-if [ "$VCS" = git ] && [ -d .git ]; then
-	for file in $(git ls-files --deleted); do
-		if [ ! -d "$file" ]; then
-			# git removes directories when the last file
-			# in them is removed, but empty directories
-			# may be significant in /etc. Touch a flag file
-			# to prevent git from removing the directory.
-			dir="$(dirname "$file")"
-			flagfile=""
-			if [ -d "$dir" ] && 
-			   [ -n "$(find "$dir" -maxdepth 0 -empty)" ]; then
-				flagfile="$dir/.etckeeper-keep-empty"
-				touch "$flagfile"
-			fi
-			git rm --quiet "$file"
-			if [ -n "$flagfile" ]; then
-				rm -f "$flagfile"
-			fi
-		fi
-	done
-fi
diff --git a/commit.d/40git-rm.in b/commit.d/40git-rm.in
new file mode 100644
index 0000000..e7e41a8
--- /dev/null
+++ b/commit.d/40git-rm.in
@@ -0,0 +1,27 @@
+#!@SHELLPATH@
+set -e
+
+IFS='
+'
+
+if [ "$VCS" = git ] && [ -d .git ]; then
+	for file in $(git ls-files --deleted); do
+		if [ ! -d "$file" ]; then
+			# git removes directories when the last file
+			# in them is removed, but empty directories
+			# may be significant in /etc. Touch a flag file
+			# to prevent git from removing the directory.
+			dir="$(dirname "$file")"
+			flagfile=""
+			if [ -d "$dir" ] && 
+			   [ -n "$(find "$dir" -maxdepth 0 -empty)" ]; then
+				flagfile="$dir/.etckeeper-keep-empty"
+				touch "$flagfile"
+			fi
+			git rm --quiet "$file"
+			if [ -n "$flagfile" ]; then
+				rm -f "$flagfile"
+			fi
+		fi
+	done
+fi
diff --git a/commit.d/50vcs-commit b/commit.d/50vcs-commit
deleted file mode 100755
index 1f4ab03..0000000
--- a/commit.d/50vcs-commit
+++ /dev/null
@@ -1,41 +0,0 @@
-#!/bin/sh
-set -e
-
-message="$1"
-hostname=`hostname -f`
-
-if [ "$VCS" = git ] && [ -d .git ]; then
-	if [ -n "$SUDO_USER" ]; then
-		export GIT_COMMITTER_NAME="$SUDO_USER"
-		export GIT_COMMITTER_EMAIL="$SUDO_USER@$hostname"
-	fi
-	if [ -n "$message" ]; then
-		git commit $GIT_COMMIT_OPTIONS -m "$message"
-	else
-		git commit $GIT_COMMIT_OPTIONS
-	fi
-elif [ "$VCS" = hg ] && [ -d .hg ]; then
-	if [ -n "$SUDO_USER" ]; then
-		export LOGNAME="$SUDO_USER"
-	fi
-	if [ -n "$message" ]; then
-		hg commit $HG_COMMIT_OPTIONS -m "$message"
-	else
-		hg commit $HG_COMMIT_OPTIONS
-	fi
-elif [ "$VCS" = bzr ] && [ -d .bzr ]; then
-	if [ -n "$SUDO_USER" ]; then
-		export EMAIL="$SUDO_USER <$SUDO_USER@$hostname>"
-	fi
-	if [ -n "$message" ]; then
-		bzr commit $BZR_COMMIT_OPTIONS -m "$message"
-	else
-		bzr commit $BZR_COMMIT_OPTIONS
-	fi
-elif [ "$VCS" = darcs ] && [ -d _darcs ]; then
-	logfile="$( mktemp -t etckeeper-$VCS.XXXXXXXXXX )"
-	printf "%b" "$message" > "$logfile"
-	darcs record $DARCS_COMMIT_OPTIONS --logfile="$logfile"
-	rm -f "$logfile"
-	unset logfile
-fi
diff --git a/commit.d/50vcs-commit.in b/commit.d/50vcs-commit.in
new file mode 100644
index 0000000..067e55f
--- /dev/null
+++ b/commit.d/50vcs-commit.in
@@ -0,0 +1,41 @@
+#!@SHELLPATH@
+set -e
+
+message="$1"
+hostname=`hostname -f`
+
+if [ "$VCS" = git ] && [ -d .git ]; then
+	if [ -n "$SUDO_USER" ]; then
+		export GIT_COMMITTER_NAME="$SUDO_USER"
+		export GIT_COMMITTER_EMAIL="$SUDO_USER@$hostname"
+	fi
+	if [ -n "$message" ]; then
+		git commit $GIT_COMMIT_OPTIONS -m "$message"
+	else
+		git commit $GIT_COMMIT_OPTIONS
+	fi
+elif [ "$VCS" = hg ] && [ -d .hg ]; then
+	if [ -n "$SUDO_USER" ]; then
+		export LOGNAME="$SUDO_USER"
+	fi
+	if [ -n "$message" ]; then
+		hg commit $HG_COMMIT_OPTIONS -m "$message"
+	else
+		hg commit $HG_COMMIT_OPTIONS
+	fi
+elif [ "$VCS" = bzr ] && [ -d .bzr ]; then
+	if [ -n "$SUDO_USER" ]; then
+		export EMAIL="$SUDO_USER <$SUDO_USER@$hostname>"
+	fi
+	if [ -n "$message" ]; then
+		bzr commit $BZR_COMMIT_OPTIONS -m "$message"
+	else
+		bzr commit $BZR_COMMIT_OPTIONS
+	fi
+elif [ "$VCS" = darcs ] && [ -d _darcs ]; then
+	logfile="$( mktemp -t etckeeper-$VCS.XXXXXXXXXX )"
+	printf "%b" "$message" > "$logfile"
+	darcs record $DARCS_COMMIT_OPTIONS --logfile="$logfile"
+	rm -f "$logfile"
+	unset logfile
+fi
diff --git a/configure.ac b/configure.ac
new file mode 100644
index 0000000..39e742f
--- /dev/null
+++ b/configure.ac
@@ -0,0 +1,85 @@
+AC_INIT([etckeeper], [0.37])
+AM_INIT_AUTOMAKE
+
+dnl for MKDIR_P
+AC_PREREQ([2.60])
+
+AC_CONFIG_SRCDIR([apt.conf])
+
+AC_PROG_INSTALL
+AC_PROG_MKDIR_P
+
+dnl EK_WITH_OPT(optname, optvar, default, valid)
+dnl --------------------------------------------
+dnl Commodity --with options that map to stock behaviours
+dnl valid should be a | separated list of options
+AC_DEFUN([EK_WITH_OPT], [
+  AC_ARG_WITH([$1], [AS_HELP_STRING([--with-$1],
+              [select the $2 package/tool to use (default is $3) (valid: $4)])],
+	      [
+AC_MSG_CHECKING([whether '$withval' is a valid $2 selection])
+if test "$4" = "any"; then
+   $2=$withval
+else
+	case "$4" in
+	     *"$withval"*) $2=$withval;;
+	      *) $2=error;;
+	esac
+fi
+
+AS_IF([test "x$$2" != "xerror"],
+	    AC_MSG_RESULT([yes]),
+		AC_MSG_RESULT([no])
+		AC_MSG_ERROR(['$withvar' is an invalid $2 selection], [1]))
+	],
+	      [$2=$3])
+dnl if no default is supplied, we're not setting a value for etckeeper.conf
+AS_IF([test "$4" != "any"],
+	    AC_MSG_NOTICE([$2 in etckeeper.conf will be $$2])
+)
+AC_SUBST([$2])
+])
+
+dnl EK_DISABLE_ADDON(addon, var, name)
+dnl ----------------------------------
+dnl Disable the installation of various addon features (bash completion, etc)
+dnl $1 = add-on-option
+dnl $2 = AUTOCONF_VAR
+dnl $3 = english name
+AC_DEFUN([EK_DISABLE_ADDON], [
+  AC_ARG_ENABLE([$1], [AS_HELP_STRING([--disable-$1],
+  		        [Do not install $3 files.])],
+[
+			case "$enableval" in
+			     no)
+			         AC_MSG_NOTICE([disabling $3 installation])
+			     	 $2=
+				 ;;
+			      *)
+			         AC_MSG_NOTICE([enabling $3 installation])
+			      	 $2=yes
+				 ;;
+			esac
+]
+			,
+[
+			AC_MSG_NOTICE([enabling $3 installation])
+			$2=yes
+])
+
+  AM_CONDITIONAL([INST_$2], [ test x$$2 = xyes ])
+])
+
+
+EK_WITH_OPT(vcs, VCS, git, git|bzr|darcs|hg)
+EK_WITH_OPT(highlevel, HIGHLEVEL, apt, apt|yum|pacman-g2)
+EK_WITH_OPT(lowlevel, LOWLEVEL, dpkg, dpkg|rpm|pacman-g2)
+EK_WITH_OPT(shell, SHELLPATH, /bin/sh, any)
+
+EK_DISABLE_ADDON(bash-completion, BASH_COMPLETION, bash completion)
+EK_DISABLE_ADDON(cruft-filter, CRUFT_FILTER, cruft filter)
+
+
+AC_CONFIG_FILES([Makefile])
+
+AC_OUTPUT
diff --git a/etckeeper b/etckeeper
deleted file mode 100755
index 1b6c76c..0000000
--- a/etckeeper
+++ /dev/null
@@ -1,92 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ -z "$ETCKEEPER_CONF_DIR" ]; then
-	ETCKEEPER_CONF_DIR=/etc/etckeeper
-fi
-
-conf="$ETCKEEPER_CONF_DIR/etckeeper.conf"
-
-usage() {
-	echo "usage: etckeeper command [-d directory]" >&2
-	exit 1
-}
-
-if [ -e $conf ]; then
-	. $conf
-fi
-
-if [ -z "$VCS" ]; then
-	echo "Please configure a VCS in $conf" >&2
-	exit 1
-fi
-export VCS
-
-if [ ! -z "$GIT_COMMIT_OPTIONS" ]; then
-	export GIT_COMMIT_OPTIONS
-fi
-if [ ! -z "$HG_COMMIT_OPTIONS" ]; then
-	export HG_COMMIT_OPTIONS
-fi
-if [ ! -z "$BZR_COMMIT_OPTIONS" ]; then
-	export BZR_COMMIT_OPTIONS
-fi
-if [ ! -z "$DARCS_COMMIT_OPTIONS" ]; then
-	export DARCS_COMMIT_OPTIONS
-fi
-
-if [ ! -z "$HIGHLEVEL_PACKAGE_MANAGER" ]; then
-	export HIGHLEVEL_PACKAGE_MANAGER
-fi
-if [ ! -z "$LOWLEVEL_PACKAGE_MANAGER" ]; then
-	export LOWLEVEL_PACKAGE_MANAGER
-fi
-if [ ! -z "$AVOID_COMMIT_BEFORE_INSTALL" ]; then
-	export AVOID_COMMIT_BEFORE_INSTALL
-fi
-
-if [ -z "$1" ]; then
-	usage
-fi
-command="$1"
-shift 1
-
-# compatability code
-if [ "$command" = "post-apt" ]; then
-	command=post-install
-elif [ "$command" = "pre-apt" ]; then
-	command=pre-install
-fi
-
-if [ ! -d "$ETCKEEPER_CONF_DIR/$command.d" ]; then
-	echo "etckeeper: $ETCKEEPER_CONF_DIR/$command.d does not exist" >&2
-	exit 1
-fi
-
-if [ "x$1" = "x-d" ]; then
-	if [ -n "$2" ]; then
-		ETCKEEPER_DIR="$2"
-		shift 2
-	else
-		usage
-	fi
-fi
-
-if [ -z "$ETCKEEPER_DIR" ]; then
-	ETCKEEPER_DIR=/etc
-fi
-cd "$ETCKEEPER_DIR"
-export ETCKEEPER_DIR
-
-lsscripts() {
-	perl -e '
-		$dir=shift;
-		print join "\n", grep { ! -d $_ && -x $_ }
-			grep /^\Q$dir\/\E[-a-zA-Z0-9]+$/,
-			glob "$dir/*";
-	' "$1"
-}
-
-for script in $(lsscripts "$ETCKEEPER_CONF_DIR/$command.d"); do
-	"$script" "$@"
-done
diff --git a/etckeeper.8 b/etckeeper.8
deleted file mode 100644
index 9070503..0000000
--- a/etckeeper.8
+++ /dev/null
@@ -1,62 +0,0 @@
-.\" -*- nroff -*-
-.TH ETCKEEPER 8 "" "" ""
-.SH NAME
-etckeeper \- store /etc in git, mercurial, bazaar, or darcs
-.SH SYNOPSIS
-.B etckeeper command [-d directory]
-.SH DESCRIPTION
-etckeeper manages /etc be stored in a git, mercurial, bazaar, or darcs
-repository. By default each of the commands operates on /etc, but a
-different directory can be specified to operate on a clone of the /etc
-repository located elsewhere.
-.SH COMMANDS
-.TP
-.B init
-This initialises and sets up a git, mercurial, bazaar, or darcs
-repository (depending on the VCS setting in
-/etc/etckeeper/etckeeper.conf). Typically this is run in /etc once
-when starting to use etckeeper on a machine. It can also be used to
-initialise a clone of the /etc repository located elsewhere.
-.TP
-.B commit [message]
-Commits all changes in /etc to the repository. A commit message can be
-specified. You may also use the underlying VCS to commit manually.
-.TP
-.B pre-commit
-This is called as a pre-commit hook. It stores metadata and does sanity
-checks.
-.TP
-.B pre-install
-This is called by apt's DPkg::Pre-Install-Pkgs hook, or by equivilant hooks
-of other package managers. It allows committing any uncommitted changes before
-packages are installed, upgraded, etc.
-.TP
-.B post-install
-This is called by apt's DPkg::Post-Invoke hook, or by equivilant hooks
-of other package managers. It commits changes made by packages into the
-repository. (You can also call this by hand after running dpkg by hand.)
-.TP
-.B unclean
-This returns true if the directory contains uncommitted changes.
-.TP
-.B update-ignore
-This updates the VCS ignore file. Content outside a "managed by etckeeper"
-block is not touched. This is generally run when upgrading to a new version
-of etckeeper.
-.TP
-.B uninit [-f]
-This command DESTROYS DATA! It is the inverse of the init command, removing
-VCS information and etckeeper's own bookkeeping information from the
-directory. Use with caution. A typical use case would be to run etckeeper
-uninit, then modify etckeeper.conf to use a different VCS, and then run
-etckeeper init. (The -f switch can be used to force uninit without
-prompting.)
-.SH FILES
-/etc/etckeeper/etckeeper.conf is the configuration file.
-
-/etc/etckeeper also contains directories containing the programs that are
-run for each of the above commands.
-.SH SEE ALSO
-/usr/share/doc/etckeeper/README.gz
-.SH AUTHOR 
-Joey Hess <joey@kitenet.net>
diff --git a/etckeeper.8.in b/etckeeper.8.in
new file mode 100644
index 0000000..528b44b
--- /dev/null
+++ b/etckeeper.8.in
@@ -0,0 +1,62 @@
+.\" -*- nroff -*-
+.TH ETCKEEPER 8 "" "" ""
+.SH NAME
+etckeeper \- store /etc in git, mercurial, bazaar, or darcs
+.SH SYNOPSIS
+.B etckeeper command [-d directory]
+.SH DESCRIPTION
+etckeeper manages /etc be stored in a git, mercurial, bazaar, or darcs
+repository. By default each of the commands operates on /etc, but a
+different directory can be specified to operate on a clone of the /etc
+repository located elsewhere.
+.SH COMMANDS
+.TP
+.B init
+This initialises and sets up a git, mercurial, bazaar, or darcs
+repository (depending on the VCS setting in
+@sysconfdir@/etckeeper/etckeeper.conf). Typically this is run in /etc once
+when starting to use etckeeper on a machine. It can also be used to
+initialise a clone of the /etc repository located elsewhere.
+.TP
+.B commit [message]
+Commits all changes in /etc to the repository. A commit message can be
+specified. You may also use the underlying VCS to commit manually.
+.TP
+.B pre-commit
+This is called as a pre-commit hook. It stores metadata and does sanity
+checks.
+.TP
+.B pre-install
+This is called by apt's DPkg::Pre-Install-Pkgs hook, or by equivilant hooks
+of other package managers. It allows committing any uncommitted changes before
+packages are installed, upgraded, etc.
+.TP
+.B post-install
+This is called by apt's DPkg::Post-Invoke hook, or by equivilant hooks
+of other package managers. It commits changes made by packages into the
+repository. (You can also call this by hand after running dpkg by hand.)
+.TP
+.B unclean
+This returns true if the directory contains uncommitted changes.
+.TP
+.B update-ignore
+This updates the VCS ignore file. Content outside a "managed by etckeeper"
+block is not touched. This is generally run when upgrading to a new version
+of etckeeper.
+.TP
+.B uninit [-f]
+This command DESTROYS DATA! It is the inverse of the init command, removing
+VCS information and etckeeper's own bookkeeping information from the
+directory. Use with caution. A typical use case would be to run etckeeper
+uninit, then modify etckeeper.conf to use a different VCS, and then run
+etckeeper init. (The -f switch can be used to force uninit without
+prompting.)
+.SH FILES
+@sysconfdir@/etckeeper/etckeeper.conf is the configuration file.
+
+@sysconfdir@/etckeeper also contains directories containing the programs that are
+run for each of the above commands.
+.SH SEE ALSO
+@docdir@/README.gz
+.SH AUTHOR 
+Joey Hess <joey@kitenet.net>
diff --git a/etckeeper.conf b/etckeeper.conf
deleted file mode 100644
index f810870..0000000
--- a/etckeeper.conf
+++ /dev/null
@@ -1,34 +0,0 @@
-# The VCS to use.
-# VCS="hg"
-VCS="git"
-# VCS="bzr"
-# VCS="darcs"
-
-# Options passed to git commit when run by etckeeper.
-#GIT_COMMIT_OPTIONS=""
-
-# Options passed to hg commit when run by etckeeper.
-#HG_COMMIT_OPTIONS=""
-
-# Options passed to bzr commit when run by etckeeper.
-#BZR_COMMIT_OPTIONS=""
-
-# Options passed to darcs commit when run by etckeeper.
-#DARCS_COMMIT_OPTIONS=""
-
-# Uncomment to avoid etckeeper committing existing changes
-# to /etc automatically once per day.
-#AVOID_DAILY_AUTOCOMMITS=1
-
-# Uncomment to avoid etckeeper committing existing changes to 
-# /etc before installation. It will cancel the installation,
-# so you can commit the changes by hand.
-#AVOID_COMMIT_BEFORE_INSTALL=1
-
-# The high-level package manager that's being used.
-# (apt, pacman-g2, yum etc)
-HIGHLEVEL_PACKAGE_MANAGER=apt
-
-# The low-level package manager that's being used.
-# (dpkg, rpm, pacman-g2, etc)
-LOWLEVEL_PACKAGE_MANAGER=dpkg
diff --git a/etckeeper.conf.in b/etckeeper.conf.in
new file mode 100644
index 0000000..980b52c
--- /dev/null
+++ b/etckeeper.conf.in
@@ -0,0 +1,31 @@
+# The VCS to use.  Valid options are: git, hg, bzr and darcs
+VCS="@VCS@"
+
+# Options passed to git commit when run by etckeeper.
+#GIT_COMMIT_OPTIONS=""
+
+# Options passed to hg commit when run by etckeeper.
+#HG_COMMIT_OPTIONS=""
+
+# Options passed to bzr commit when run by etckeeper.
+#BZR_COMMIT_OPTIONS=""
+
+# Options passed to darcs commit when run by etckeeper.
+#DARCS_COMMIT_OPTIONS=""
+
+# Uncomment to avoid etckeeper committing existing changes
+# to /etc automatically once per day.
+#AVOID_DAILY_AUTOCOMMITS=1
+
+# Uncomment to avoid etckeeper committing existing changes to 
+# /etc before installation. It will cancel the installation,
+# so you can commit the changes by hand.
+#AVOID_COMMIT_BEFORE_INSTALL=1
+
+# The high-level package manager that's being used.
+# (apt, pacman-g2, yum etc)
+HIGHLEVEL_PACKAGE_MANAGER=@HIGHLEVEL@
+
+# The low-level package manager that's being used.
+# (dpkg, rpm, pacman-g2, etc)
+LOWLEVEL_PACKAGE_MANAGER=@LOWLEVEL@
diff --git a/etckeeper.in b/etckeeper.in
new file mode 100644
index 0000000..bcea0b0
--- /dev/null
+++ b/etckeeper.in
@@ -0,0 +1,92 @@
+#!@SHELLPATH@
+set -e
+
+if [ -z "$ETCKEEPER_CONF_DIR" ]; then
+	ETCKEEPER_CONF_DIR=@sysconfdir@/etckeeper
+fi
+
+conf="$ETCKEEPER_CONF_DIR/etckeeper.conf"
+
+usage() {
+	echo "usage: etckeeper command [-d directory]" >&2
+	exit 1
+}
+
+if [ -e $conf ]; then
+	. $conf
+fi
+
+if [ -z "$VCS" ]; then
+	echo "Please configure a VCS in $conf" >&2
+	exit 1
+fi
+export VCS
+
+if [ ! -z "$GIT_COMMIT_OPTIONS" ]; then
+	export GIT_COMMIT_OPTIONS
+fi
+if [ ! -z "$HG_COMMIT_OPTIONS" ]; then
+	export HG_COMMIT_OPTIONS
+fi
+if [ ! -z "$BZR_COMMIT_OPTIONS" ]; then
+	export BZR_COMMIT_OPTIONS
+fi
+if [ ! -z "$DARCS_COMMIT_OPTIONS" ]; then
+	export DARCS_COMMIT_OPTIONS
+fi
+
+if [ ! -z "$HIGHLEVEL_PACKAGE_MANAGER" ]; then
+	export HIGHLEVEL_PACKAGE_MANAGER
+fi
+if [ ! -z "$LOWLEVEL_PACKAGE_MANAGER" ]; then
+	export LOWLEVEL_PACKAGE_MANAGER
+fi
+if [ ! -z "$AVOID_COMMIT_BEFORE_INSTALL" ]; then
+	export AVOID_COMMIT_BEFORE_INSTALL
+fi
+
+if [ -z "$1" ]; then
+	usage
+fi
+command="$1"
+shift 1
+
+# compatability code
+if [ "$command" = "post-apt" ]; then
+	command=post-install
+elif [ "$command" = "pre-apt" ]; then
+	command=pre-install
+fi
+
+if [ ! -d "$ETCKEEPER_CONF_DIR/$command.d" ]; then
+	echo "etckeeper: $ETCKEEPER_CONF_DIR/$command.d does not exist" >&2
+	exit 1
+fi
+
+if [ "x$1" = "x-d" ]; then
+	if [ -n "$2" ]; then
+		ETCKEEPER_DIR="$2"
+		shift 2
+	else
+		usage
+	fi
+fi
+
+if [ -z "$ETCKEEPER_DIR" ]; then
+	ETCKEEPER_DIR=/etc
+fi
+cd "$ETCKEEPER_DIR"
+export ETCKEEPER_DIR
+
+lsscripts() {
+	perl -e '
+		$dir=shift;
+		print join "\n", grep { ! -d $_ && -x $_ }
+			grep /^\Q$dir\/\E[-a-zA-Z0-9]+$/,
+			glob "$dir/*";
+	' "$1"
+}
+
+for script in $(lsscripts "$ETCKEEPER_CONF_DIR/$command.d"); do
+	"$script" "$@"
+done
diff --git a/init.d/10restore-metadata b/init.d/10restore-metadata
deleted file mode 100755
index 9c2bf65..0000000
--- a/init.d/10restore-metadata
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-set -e
-
-# Note that metastore doesn't check that the .metastore file only changes
-# perms of files in the current directory. It's ok to trust the .metastore
-# file won't do anything shady, because, as documented, etckeeper-init
-# should only be run on repositories you trust.
-if [ -e .metadata ]; then
-	if which metastore >/dev/null; then
-		metastore --apply --mtime
-	else
-		echo "etckeeper warning: legacy .metastore file is present but metastore is not installed" >&2
-	fi
-fi
diff --git a/init.d/10restore-metadata.in b/init.d/10restore-metadata.in
new file mode 100644
index 0000000..8aef5b5
--- /dev/null
+++ b/init.d/10restore-metadata.in
@@ -0,0 +1,14 @@
+#!@SHELLPATH@
+set -e
+
+# Note that metastore doesn't check that the .metastore file only changes
+# perms of files in the current directory. It's ok to trust the .metastore
+# file won't do anything shady, because, as documented, etckeeper-init
+# should only be run on repositories you trust.
+if [ -e .metadata ]; then
+	if which metastore >/dev/null; then
+		metastore --apply --mtime
+	else
+		echo "etckeeper warning: legacy .metastore file is present but metastore is not installed" >&2
+	fi
+fi
diff --git a/init.d/20restore-etckeeper b/init.d/20restore-etckeeper
deleted file mode 100755
index 5dc4425..0000000
--- a/init.d/20restore-etckeeper
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/bin/sh
-set -e
-
-# Used by .etckeeper to run a command if the file it acts on
-# (the last parameter) exists.
-maybe () {
-	command="$1"
-	shift 1
-
-	if eval [ -e "\$$#" ]; then
-		"$command" "$@"
-	fi
-}
-
-# Yes, this runs code from the repository. As documented, etckeeper-init
-# should only be run on repositories you trust.
-if [ -e .etckeeper ]; then
-	. ./.etckeeper
-else
-	touch .etckeeper
-	chmod 600 .etckeeper
-fi
diff --git a/init.d/20restore-etckeeper.in b/init.d/20restore-etckeeper.in
new file mode 100644
index 0000000..8ffb7f1
--- /dev/null
+++ b/init.d/20restore-etckeeper.in
@@ -0,0 +1,22 @@
+#!@SHELLPATH@
+set -e
+
+# Used by .etckeeper to run a command if the file it acts on
+# (the last parameter) exists.
+maybe () {
+	command="$1"
+	shift 1
+
+	if eval [ -e "\$$#" ]; then
+		"$command" "$@"
+	fi
+}
+
+# Yes, this runs code from the repository. As documented, etckeeper-init
+# should only be run on repositories you trust.
+if [ -e .etckeeper ]; then
+	. ./.etckeeper
+else
+	touch .etckeeper
+	chmod 600 .etckeeper
+fi
diff --git a/init.d/40vcs-init b/init.d/40vcs-init
deleted file mode 100755
index 3c7a3bb..0000000
--- a/init.d/40vcs-init
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ] && [ ! -e .git ]; then
-	git init
-	echo "$(hostname) /etc repository" > .git/description
-elif [ "$VCS" = hg ] && [ ! -e .hg ]; then
-	hg init
-	echo  "[web]" > .hg/hgrc
-	echo  "description = $(hostname) /etc repository" >> .hg/hgrc
-elif [ "$VCS" = bzr ] && [ ! -e .bzr ]; then
-	bzr init
-	bzr nick "$(hostname) /etc repository"
-elif [ "$VCS" = darcs ] && [ ! -e _darcs ]; then
-	darcs initialize
-	echo "$(hostname) /etc repository" > _darcs/prefs/motd
-fi
diff --git a/init.d/40vcs-init.in b/init.d/40vcs-init.in
new file mode 100644
index 0000000..1cf512f
--- /dev/null
+++ b/init.d/40vcs-init.in
@@ -0,0 +1,17 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ] && [ ! -e .git ]; then
+	git init
+	echo "$(hostname) /etc repository" > .git/description
+elif [ "$VCS" = hg ] && [ ! -e .hg ]; then
+	hg init
+	echo  "[web]" > .hg/hgrc
+	echo  "description = $(hostname) /etc repository" >> .hg/hgrc
+elif [ "$VCS" = bzr ] && [ ! -e .bzr ]; then
+	bzr init
+	bzr nick "$(hostname) /etc repository"
+elif [ "$VCS" = darcs ] && [ ! -e _darcs ]; then
+	darcs initialize
+	echo "$(hostname) /etc repository" > _darcs/prefs/motd
+fi
diff --git a/init.d/50vcs-ignore b/init.d/50vcs-ignore
deleted file mode 100755
index bcc88ba..0000000
--- a/init.d/50vcs-ignore
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/sh
-set -e
-
-etckeeper update-ignore || true
diff --git a/init.d/50vcs-ignore.in b/init.d/50vcs-ignore.in
new file mode 100644
index 0000000..0e703dc
--- /dev/null
+++ b/init.d/50vcs-ignore.in
@@ -0,0 +1,4 @@
+#!@SHELLPATH@
+set -e
+
+etckeeper update-ignore || true
diff --git a/init.d/50vcs-perm b/init.d/50vcs-perm
deleted file mode 100755
index 4dd080b..0000000
--- a/init.d/50vcs-perm
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ]; then
-	chmod 700 .git
-elif [ "$VCS" = hg ]; then
-	chmod 700 .hg
-elif [ "$VCS" = bzr ]; then
-	chmod 700 .bzr
-elif [ "$VCS" = darcs ]; then
-	chmod 700 _darcs
-fi
diff --git a/init.d/50vcs-perm.in b/init.d/50vcs-perm.in
new file mode 100644
index 0000000..95b2a2e
--- /dev/null
+++ b/init.d/50vcs-perm.in
@@ -0,0 +1,12 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ]; then
+	chmod 700 .git
+elif [ "$VCS" = hg ]; then
+	chmod 700 .hg
+elif [ "$VCS" = bzr ]; then
+	chmod 700 .bzr
+elif [ "$VCS" = darcs ]; then
+	chmod 700 _darcs
+fi
diff --git a/init.d/50vcs-pre-commit-hook b/init.d/50vcs-pre-commit-hook
deleted file mode 100755
index 06d433b..0000000
--- a/init.d/50vcs-pre-commit-hook
+++ /dev/null
@@ -1,47 +0,0 @@
-#!/bin/sh
-set -e
-
-case "$VCS" in
-	git)
-		if [ -x .git/hooks/pre-commit ]; then
-			if ! grep -q "etckeeper pre-commit" .git/hooks/pre-commit; then
-				echo "etckeeper warning: .git/hooks/pre-commit needs to be manually modified to run: etckeeper pre-commit -d `pwd`" >&2
-			fi
-		else
-			cat >.git/hooks/pre-commit <<EOF
-#!/bin/sh
-# pre-commit hook for etckeeper, to store metadata and do sanity checks
-set -e
-etckeeper pre-commit -d `pwd`
-EOF
-		chmod +x .git/hooks/pre-commit
-		fi
-	;;
-	hg)
-		if [ -e .hg/hgrc ] && grep "^\[hooks\]" .hg/hgrc; then
-			echo "etckeeper warning: [hooks] section in .hg/hgrc needs to be manually modified to run: etckeeper pre-commit -d `pwd`" >&2
-		else
-		touch .hg/hgrc
-		cat >>.hg/hgrc <<EOF
-[hooks]
-# pre-commit hook for etckeeper, to store metadata and do sanity checks
-precommit = etckeeper pre-commit -d `pwd`
-EOF
-		fi
-	;;
-	darcs)
-		if [ -e _darcs/prefs/defaults ]; then
-			if ! ( grep -q "record prehook etckeeper pre-commit" _darcs/prefs/defaults &&
-				grep -q "whatsnew prehook etckeeper pre-commit" _darcs/prefs/defaults ); then
-				echo "etckeeper warning: _darcs/prefs/defaults needs to be manually modified to run: etckeeper pre-commit -d `pwd`" >&2
-			fi
-		else
-			cat >_darcs/prefs/defaults <<EOF
-record prehook etckeeper pre-commit -d `pwd`
-record run-prehook
-whatsnew prehook etckeeper pre-commit -d `pwd`
-whatsnew run-prehook
-EOF
-		fi
-	;;
-esac
diff --git a/init.d/50vcs-pre-commit-hook.in b/init.d/50vcs-pre-commit-hook.in
new file mode 100644
index 0000000..f0152c1
--- /dev/null
+++ b/init.d/50vcs-pre-commit-hook.in
@@ -0,0 +1,47 @@
+#!@SHELLPATH@
+set -e
+
+case "$VCS" in
+	git)
+		if [ -x .git/hooks/pre-commit ]; then
+			if ! grep -q "etckeeper pre-commit" .git/hooks/pre-commit; then
+				echo "etckeeper warning: .git/hooks/pre-commit needs to be manually modified to run: etckeeper pre-commit -d `pwd`" >&2
+			fi
+		else
+			cat >.git/hooks/pre-commit <<EOF
+#!@SHELLPATH@
+# pre-commit hook for etckeeper, to store metadata and do sanity checks
+set -e
+etckeeper pre-commit -d `pwd`
+EOF
+		chmod +x .git/hooks/pre-commit
+		fi
+	;;
+	hg)
+		if [ -e .hg/hgrc ] && grep "^\[hooks\]" .hg/hgrc; then
+			echo "etckeeper warning: [hooks] section in .hg/hgrc needs to be manually modified to run: etckeeper pre-commit -d `pwd`" >&2
+		else
+		touch .hg/hgrc
+		cat >>.hg/hgrc <<EOF
+[hooks]
+# pre-commit hook for etckeeper, to store metadata and do sanity checks
+precommit = etckeeper pre-commit -d `pwd`
+EOF
+		fi
+	;;
+	darcs)
+		if [ -e _darcs/prefs/defaults ]; then
+			if ! ( grep -q "record prehook etckeeper pre-commit" _darcs/prefs/defaults &&
+				grep -q "whatsnew prehook etckeeper pre-commit" _darcs/prefs/defaults ); then
+				echo "etckeeper warning: _darcs/prefs/defaults needs to be manually modified to run: etckeeper pre-commit -d `pwd`" >&2
+			fi
+		else
+			cat >_darcs/prefs/defaults <<EOF
+record prehook etckeeper pre-commit -d `pwd`
+record run-prehook
+whatsnew prehook etckeeper pre-commit -d `pwd`
+whatsnew run-prehook
+EOF
+		fi
+	;;
+esac
diff --git a/init.d/60darcs-deleted-symlinks b/init.d/60darcs-deleted-symlinks
deleted file mode 100755
index 8d10d56..0000000
--- a/init.d/60darcs-deleted-symlinks
+++ /dev/null
@@ -1,48 +0,0 @@
-#!/bin/sh
-set -e
-
-filter_ignore() {
-	if [ "$VCS" = darcs ]; then
-		ignorefile=.darcsignore
-	fi
-
-	if [ "$VCS" = darcs ] && [ -e "$ignorefile" ]; then
-		# Spaces embedded into patterns would break it.
-		# But really, why would anyone want to use ' ' instead of '\s' ?
-		#patterns=$( grep -v '^[[:space:]]*\(#\|$\)' "$ignorefile" | xargs -n 1 printf " -e %s" )
-		#grep -Ev $patterns
-		#unset patterns
-		# Alternative using a temp file
-		patternsfile="$( mktemp -t etckeeper-$VCS.XXXXXXXXXX )"
-		grep -v '^[[:space:]]*\(#\|$\)' "$ignorefile" > "$patternsfile" || true
-		grep -Evf "$patternsfile"
-		rm -f "$patternsfile"
-		unset patternsfile
-	else
-		cat -
-	fi
-}
-
-
-if [ "$VCS" = darcs ];then
-	NOVCS='. -wholename ./.git -prune -o -wholename ./.bzr -prune -o -wholename ./.hg -prune -o -wholename ./_darcs -prune -o'
-
-	# We assume that if .etckeeper is empty this is the first run
-	if [ -s .etckeeper ]; then
-		linksindex="$( mktemp -t etckeeper-$VCS.XXXXXXXXXX )"
-		grep '^ln -s' .etckeeper | while IFS="'" read n n n link n; do
-			printf "%s\n" "$link" >> "$linksindex"
-		done
-
-		# Warn about symbolic links that shouldn't exist
-		if links=$( find $NOVCS -type l -print | filter_ignore | grep -vFf "$linksindex" ); then
-			printf "%s\n%s\n" \
-				"The following symbolic links should not exist:" \
-				"$links" >&2
-		fi
-
-		rm -f "$linksindex"
-		unset links linksindex
-	fi
-
-fi
diff --git a/init.d/60darcs-deleted-symlinks.in b/init.d/60darcs-deleted-symlinks.in
new file mode 100644
index 0000000..f7ee17f
--- /dev/null
+++ b/init.d/60darcs-deleted-symlinks.in
@@ -0,0 +1,48 @@
+#!@SHELLPATH@
+set -e
+
+filter_ignore() {
+	if [ "$VCS" = darcs ]; then
+		ignorefile=.darcsignore
+	fi
+
+	if [ "$VCS" = darcs ] && [ -e "$ignorefile" ]; then
+		# Spaces embedded into patterns would break it.
+		# But really, why would anyone want to use ' ' instead of '\s' ?
+		#patterns=$( grep -v '^[[:space:]]*\(#\|$\)' "$ignorefile" | xargs -n 1 printf " -e %s" )
+		#grep -Ev $patterns
+		#unset patterns
+		# Alternative using a temp file
+		patternsfile="$( mktemp -t etckeeper-$VCS.XXXXXXXXXX )"
+		grep -v '^[[:space:]]*\(#\|$\)' "$ignorefile" > "$patternsfile" || true
+		grep -Evf "$patternsfile"
+		rm -f "$patternsfile"
+		unset patternsfile
+	else
+		cat -
+	fi
+}
+
+
+if [ "$VCS" = darcs ];then
+	NOVCS='. -wholename ./.git -prune -o -wholename ./.bzr -prune -o -wholename ./.hg -prune -o -wholename ./_darcs -prune -o'
+
+	# We assume that if .etckeeper is empty this is the first run
+	if [ -s .etckeeper ]; then
+		linksindex="$( mktemp -t etckeeper-$VCS.XXXXXXXXXX )"
+		grep '^ln -s' .etckeeper | while IFS="'" read n n n link n; do
+			printf "%s\n" "$link" >> "$linksindex"
+		done
+
+		# Warn about symbolic links that shouldn't exist
+		if links=$( find $NOVCS -type l -print | filter_ignore | grep -vFf "$linksindex" ); then
+			printf "%s\n%s\n" \
+				"The following symbolic links should not exist:" \
+				"$links" >&2
+		fi
+
+		rm -f "$linksindex"
+		unset links linksindex
+	fi
+
+fi
diff --git a/init.d/70vcs-add b/init.d/70vcs-add
deleted file mode 100755
index 9a9ec45..0000000
--- a/init.d/70vcs-add
+++ /dev/null
@@ -1,27 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ]; then
-	if ! git add .; then
-		echo "etckeeper warning: git add failed" >&2
-	fi
-elif [ "$VCS" = hg ]; then
-	if ! hg add .; then
-		echo "etckeeper warning: hg add failed" >&2
-	fi
-elif [ "$VCS" = bzr ]; then
-	if ! bzr add .; then
-		echo "etckeeper warning: bzr add failed" >&2
-	fi
-elif [ "$VCS" = darcs ]; then
-	# Don't warn if all the files were already added.
-	rc=0
-	res=$( darcs add -qr . 2>&1 ) || rc=$?
-	if test $rc -ne 0; then
-		if ! test $rc -eq 2 -a "${res%No files were added}" != "$res"; then
-			printf "%s" "$res"
-			echo "etckeeper warning: darcs add failed" >&2
-		fi
-	fi
-	unset rc res
-fi
diff --git a/init.d/70vcs-add.in b/init.d/70vcs-add.in
new file mode 100644
index 0000000..eb8a94c
--- /dev/null
+++ b/init.d/70vcs-add.in
@@ -0,0 +1,27 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ]; then
+	if ! git add .; then
+		echo "etckeeper warning: git add failed" >&2
+	fi
+elif [ "$VCS" = hg ]; then
+	if ! hg add .; then
+		echo "etckeeper warning: hg add failed" >&2
+	fi
+elif [ "$VCS" = bzr ]; then
+	if ! bzr add .; then
+		echo "etckeeper warning: bzr add failed" >&2
+	fi
+elif [ "$VCS" = darcs ]; then
+	# Don't warn if all the files were already added.
+	rc=0
+	res=$( darcs add -qr . 2>&1 ) || rc=$?
+	if test $rc -ne 0; then
+		if ! test $rc -eq 2 -a "${res%No files were added}" != "$res"; then
+			printf "%s" "$res"
+			echo "etckeeper warning: darcs add failed" >&2
+		fi
+	fi
+	unset rc res
+fi
diff --git a/install-sh b/install-sh
new file mode 100755
index 0000000..a5897de
--- /dev/null
+++ b/install-sh
@@ -0,0 +1,519 @@
+#!/bin/sh
+# install - install a program, script, or datafile
+
+scriptversion=2006-12-25.00
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
+#
+#
+# FSF changes to this file are in the public domain.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+
+nl='
+'
+IFS=" ""	$nl"
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit=${DOITPROG-}
+if test -z "$doit"; then
+  doit_exec=exec
+else
+  doit_exec=$doit
+fi
+
+# Put in absolute file names if you don't have them in your path;
+# or use environment vars.
+
+chgrpprog=${CHGRPPROG-chgrp}
+chmodprog=${CHMODPROG-chmod}
+chownprog=${CHOWNPROG-chown}
+cmpprog=${CMPPROG-cmp}
+cpprog=${CPPROG-cp}
+mkdirprog=${MKDIRPROG-mkdir}
+mvprog=${MVPROG-mv}
+rmprog=${RMPROG-rm}
+stripprog=${STRIPPROG-strip}
+
+posix_glob='?'
+initialize_posix_glob='
+  test "$posix_glob" != "?" || {
+    if (set -f) 2>/dev/null; then
+      posix_glob=
+    else
+      posix_glob=:
+    fi
+  }
+'
+
+posix_mkdir=
+
+# Desired mode of installed file.
+mode=0755
+
+chgrpcmd=
+chmodcmd=$chmodprog
+chowncmd=
+mvcmd=$mvprog
+rmcmd="$rmprog -f"
+stripcmd=
+
+src=
+dst=
+dir_arg=
+dst_arg=
+
+copy_on_change=false
+no_target_directory=
+
+usage="\
+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
+
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
+
+Options:
+     --help     display this help and exit.
+     --version  display version info and exit.
+
+  -c            (ignored)
+  -C            install only if different (preserve the last data modification time)
+  -d            create directories instead of installing files.
+  -g GROUP      $chgrpprog installed files to GROUP.
+  -m MODE       $chmodprog installed files to MODE.
+  -o USER       $chownprog installed files to USER.
+  -s            $stripprog installed files.
+  -t DIRECTORY  install into DIRECTORY.
+  -T            report an error if DSTFILE is a directory.
+
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
+  RMPROG STRIPPROG
+"
+
+while test $# -ne 0; do
+  case $1 in
+    -c) ;;
+
+    -C) copy_on_change=true;;
+
+    -d) dir_arg=true;;
+
+    -g) chgrpcmd="$chgrpprog $2"
+	shift;;
+
+    --help) echo "$usage"; exit $?;;
+
+    -m) mode=$2
+	case $mode in
+	  *' '* | *'	'* | *'
+'*	  | *'*'* | *'?'* | *'['*)
+	    echo "$0: invalid mode: $mode" >&2
+	    exit 1;;
+	esac
+	shift;;
+
+    -o) chowncmd="$chownprog $2"
+	shift;;
+
+    -s) stripcmd=$stripprog;;
+
+    -t) dst_arg=$2
+	shift;;
+
+    -T) no_target_directory=true;;
+
+    --version) echo "$0 $scriptversion"; exit $?;;
+
+    --)	shift
+	break;;
+
+    -*)	echo "$0: invalid option: $1" >&2
+	exit 1;;
+
+    *)  break;;
+  esac
+  shift
+done
+
+if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
+  # When -d is used, all remaining arguments are directories to create.
+  # When -t is used, the destination is already specified.
+  # Otherwise, the last argument is the destination.  Remove it from $@.
+  for arg
+  do
+    if test -n "$dst_arg"; then
+      # $@ is not empty: it contains at least $arg.
+      set fnord "$@" "$dst_arg"
+      shift # fnord
+    fi
+    shift # arg
+    dst_arg=$arg
+  done
+fi
+
+if test $# -eq 0; then
+  if test -z "$dir_arg"; then
+    echo "$0: no input file specified." >&2
+    exit 1
+  fi
+  # It's OK to call `install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
+
+if test -z "$dir_arg"; then
+  trap '(exit $?); exit' 1 2 13 15
+
+  # Set umask so as not to create temps with too-generous modes.
+  # However, 'strip' requires both read and write access to temps.
+  case $mode in
+    # Optimize common cases.
+    *644) cp_umask=133;;
+    *755) cp_umask=22;;
+
+    *[0-7])
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw='% 200'
+      fi
+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
+    *)
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw=,u+rw
+      fi
+      cp_umask=$mode$u_plus_rw;;
+  esac
+fi
+
+for src
+do
+  # Protect names starting with `-'.
+  case $src in
+    -*) src=./$src;;
+  esac
+
+  if test -n "$dir_arg"; then
+    dst=$src
+    dstdir=$dst
+    test -d "$dstdir"
+    dstdir_status=$?
+  else
+
+    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f "$src" && test ! -d "$src"; then
+      echo "$0: $src does not exist." >&2
+      exit 1
+    fi
+
+    if test -z "$dst_arg"; then
+      echo "$0: no destination specified." >&2
+      exit 1
+    fi
+
+    dst=$dst_arg
+    # Protect names starting with `-'.
+    case $dst in
+      -*) dst=./$dst;;
+    esac
+
+    # If destination is a directory, append the input filename; won't work
+    # if double slashes aren't ignored.
+    if test -d "$dst"; then
+      if test -n "$no_target_directory"; then
+	echo "$0: $dst_arg: Is a directory" >&2
+	exit 1
+      fi
+      dstdir=$dst
+      dst=$dstdir/`basename "$src"`
+      dstdir_status=0
+    else
+      # Prefer dirname, but fall back on a substitute if dirname fails.
+      dstdir=`
+	(dirname "$dst") 2>/dev/null ||
+	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	     X"$dst" : 'X\(//\)[^/]' \| \
+	     X"$dst" : 'X\(//\)$' \| \
+	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
+	echo X"$dst" |
+	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)[^/].*/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\).*/{
+		   s//\1/
+		   q
+		 }
+		 s/.*/./; q'
+      `
+
+      test -d "$dstdir"
+      dstdir_status=$?
+    fi
+  fi
+
+  obsolete_mkdir_used=false
+
+  if test $dstdir_status != 0; then
+    case $posix_mkdir in
+      '')
+	# Create intermediate dirs using mode 755 as modified by the umask.
+	# This is like FreeBSD 'install' as of 1997-10-28.
+	umask=`umask`
+	case $stripcmd.$umask in
+	  # Optimize common cases.
+	  *[2367][2367]) mkdir_umask=$umask;;
+	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;
+
+	  *[0-7])
+	    mkdir_umask=`expr $umask + 22 \
+	      - $umask % 100 % 40 + $umask % 20 \
+	      - $umask % 10 % 4 + $umask % 2
+	    `;;
+	  *) mkdir_umask=$umask,go-w;;
+	esac
+
+	# With -d, create the new directory with the user-specified mode.
+	# Otherwise, rely on $mkdir_umask.
+	if test -n "$dir_arg"; then
+	  mkdir_mode=-m$mode
+	else
+	  mkdir_mode=
+	fi
+
+	posix_mkdir=false
+	case $umask in
+	  *[123567][0-7][0-7])
+	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
+	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
+	    ;;
+	  *)
+	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
+	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0
+
+	    if (umask $mkdir_umask &&
+		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
+	    then
+	      if test -z "$dir_arg" || {
+		   # Check for POSIX incompatibilities with -m.
+		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
+		   # other-writeable bit of parent directory when it shouldn't.
+		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
+		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
+		   case $ls_ld_tmpdir in
+		     d????-?r-*) different_mode=700;;
+		     d????-?--*) different_mode=755;;
+		     *) false;;
+		   esac &&
+		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
+		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
+		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
+		   }
+		 }
+	      then posix_mkdir=:
+	      fi
+	      rmdir "$tmpdir/d" "$tmpdir"
+	    else
+	      # Remove any dirs left behind by ancient mkdir implementations.
+	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
+	    fi
+	    trap '' 0;;
+	esac;;
+    esac
+
+    if
+      $posix_mkdir && (
+	umask $mkdir_umask &&
+	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
+      )
+    then :
+    else
+
+      # The umask is ridiculous, or mkdir does not conform to POSIX,
+      # or it failed possibly due to a race condition.  Create the
+      # directory the slow way, step by step, checking for races as we go.
+
+      case $dstdir in
+	/*) prefix='/';;
+	-*) prefix='./';;
+	*)  prefix='';;
+      esac
+
+      eval "$initialize_posix_glob"
+
+      oIFS=$IFS
+      IFS=/
+      $posix_glob set -f
+      set fnord $dstdir
+      shift
+      $posix_glob set +f
+      IFS=$oIFS
+
+      prefixes=
+
+      for d
+      do
+	test -z "$d" && continue
+
+	prefix=$prefix$d
+	if test -d "$prefix"; then
+	  prefixes=
+	else
+	  if $posix_mkdir; then
+	    (umask=$mkdir_umask &&
+	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
+	    # Don't fail if two instances are running concurrently.
+	    test -d "$prefix" || exit 1
+	  else
+	    case $prefix in
+	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
+	      *) qprefix=$prefix;;
+	    esac
+	    prefixes="$prefixes '$qprefix'"
+	  fi
+	fi
+	prefix=$prefix/
+      done
+
+      if test -n "$prefixes"; then
+	# Don't fail if two instances are running concurrently.
+	(umask $mkdir_umask &&
+	 eval "\$doit_exec \$mkdirprog $prefixes") ||
+	  test -d "$dstdir" || exit 1
+	obsolete_mkdir_used=true
+      fi
+    fi
+  fi
+
+  if test -n "$dir_arg"; then
+    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
+    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
+      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
+  else
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=$dstdir/_inst.$$_
+    rmtmp=$dstdir/_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
+
+    # Copy the file name to the temp name.
+    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above "$doit $cpprog $src $dsttmp" command.
+    #
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
+    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
+    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
+
+    # If -C, don't bother to copy if it wouldn't change the file.
+    if $copy_on_change &&
+       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
+       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&
+
+       eval "$initialize_posix_glob" &&
+       $posix_glob set -f &&
+       set X $old && old=:$2:$4:$5:$6 &&
+       set X $new && new=:$2:$4:$5:$6 &&
+       $posix_glob set +f &&
+
+       test "$old" = "$new" &&
+       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
+    then
+      rm -f "$dsttmp"
+    else
+      # Rename the file to the real destination.
+      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
+
+      # The rename failed, perhaps because mv can't rename something else
+      # to itself, or perhaps because mv is so ancient that it does not
+      # support -f.
+      {
+	# Now remove or move aside any old file at destination location.
+	# We try this two ways since rm can't unlink itself on some
+	# systems and the destination file might be busy for other
+	# reasons.  In this case, the final cleanup might fail but the new
+	# file should still install successfully.
+	{
+	  test ! -f "$dst" ||
+	  $doit $rmcmd -f "$dst" 2>/dev/null ||
+	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
+	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
+	  } ||
+	  { echo "$0: cannot unlink or rename $dst" >&2
+	    (exit 1); exit 1
+	  }
+	} &&
+
+	# Now rename the file to the real destination.
+	$doit $mvcmd "$dsttmp" "$dst"
+      }
+    fi || exit 1
+
+    trap '' 0
+  fi
+done
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-end: "$"
+# End:
diff --git a/list-installed.d/50list-installed b/list-installed.d/50list-installed
deleted file mode 100755
index 177a6c2..0000000
--- a/list-installed.d/50list-installed
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/bin/sh
-# Output to stdout a *sorted* list of all currently installed 
-# (or removed but still with config-files) packages, in the
-# format "package version\n" (or something similar).
-if [ "$LOWLEVEL_PACKAGE_MANAGER" = dpkg ]; then
-	dpkg-query -W -f '${Status}\t${Package} ${Version}\n' | \
-		egrep '(ok installed|ok config-files)' | cut -f2,3
-elif [ "$LOWLEVEL_PACKAGE_MANAGER" = rpm ]; then
-	rpm -qa --queryformat "%{name} %{version} %{arch}\n" | sort
-fi
diff --git a/list-installed.d/50list-installed.in b/list-installed.d/50list-installed.in
new file mode 100644
index 0000000..dcee3a1
--- /dev/null
+++ b/list-installed.d/50list-installed.in
@@ -0,0 +1,10 @@
+#!@SHELLPATH@
+# Output to stdout a *sorted* list of all currently installed 
+# (or removed but still with config-files) packages, in the
+# format "package version\n" (or something similar).
+if [ "$LOWLEVEL_PACKAGE_MANAGER" = dpkg ]; then
+	dpkg-query -W -f '${Status}\t${Package} ${Version}\n' | \
+		egrep '(ok installed|ok config-files)' | cut -f2,3
+elif [ "$LOWLEVEL_PACKAGE_MANAGER" = rpm ]; then
+	rpm -qa --queryformat "%{name} %{version} %{arch}\n" | sort
+fi
diff --git a/post-install.d/50vcs-commit b/post-install.d/50vcs-commit
deleted file mode 100755
index 12fd187..0000000
--- a/post-install.d/50vcs-commit
+++ /dev/null
@@ -1,20 +0,0 @@
-#!/bin/sh
-set -e
-		
-pl="/var/cache/etckeeper/packagelist"
-NL="
-"
-
-if etckeeper unclean; then
-	message="committing changes in /etc after $HIGHLEVEL_PACKAGE_MANAGER run"
-
-	if [ -e $pl.pre-install ]; then
-		diff="$(etckeeper list-installed | diff -U0 $pl.pre-install - | tail -n+4 | egrep '^[-+]')" || true
-		if [ -n "$diff" ]; then
-			message="$message$NL${NL}Package changes:$NL$diff"
-		fi
-		rm -f $pl.pre-install
-	fi
-
-	etckeeper commit "$(printf "$message")"
-fi
diff --git a/post-install.d/50vcs-commit.in b/post-install.d/50vcs-commit.in
new file mode 100644
index 0000000..d0cf86d
--- /dev/null
+++ b/post-install.d/50vcs-commit.in
@@ -0,0 +1,20 @@
+#!@SHELLPATH@
+set -e
+		
+pl="/var/cache/etckeeper/packagelist"
+NL="
+"
+
+if etckeeper unclean; then
+	message="committing changes in /etc after $HIGHLEVEL_PACKAGE_MANAGER run"
+
+	if [ -e $pl.pre-install ]; then
+		diff="$(etckeeper list-installed | diff -U0 $pl.pre-install - | tail -n+4 | egrep '^[-+]')" || true
+		if [ -n "$diff" ]; then
+			message="$message$NL${NL}Package changes:$NL$diff"
+		fi
+		rm -f $pl.pre-install
+	fi
+
+	etckeeper commit "$(printf "$message")"
+fi
diff --git a/pre-commit.d/20warn-hardlinks b/pre-commit.d/20warn-hardlinks
deleted file mode 100755
index 008e2f1..0000000
--- a/pre-commit.d/20warn-hardlinks
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ] || [ "$VCS" = hg ] || [ "$VCS" = bzr ] || [ "$VCS" = darcs ]; then
-	hardlinks=$(find -type f -not -links 1 | grep -v '/\(.git\|.hg\|.bzr\|_darcs\)/' ) || true
-	if [ -n "$hardlinks" ]; then
-		echo "etckeeper warning: hardlinked files could cause problems with $VCS:" >&2
-		echo "$hardlinks" >&2
-	fi
-fi
diff --git a/pre-commit.d/20warn-hardlinks.in b/pre-commit.d/20warn-hardlinks.in
new file mode 100644
index 0000000..479b0e5
--- /dev/null
+++ b/pre-commit.d/20warn-hardlinks.in
@@ -0,0 +1,10 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ] || [ "$VCS" = hg ] || [ "$VCS" = bzr ] || [ "$VCS" = darcs ]; then
+	hardlinks=$(find -type f -not -links 1 | grep -v '/\(.git\|.hg\|.bzr\|_darcs\)/' ) || true
+	if [ -n "$hardlinks" ]; then
+		echo "etckeeper warning: hardlinked files could cause problems with $VCS:" >&2
+		echo "$hardlinks" >&2
+	fi
+fi
diff --git a/pre-commit.d/20warn-special-file b/pre-commit.d/20warn-special-file
deleted file mode 100755
index 665a3ce..0000000
--- a/pre-commit.d/20warn-special-file
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ] || [ "$VCS" = hg ] || [ "$VCS" = bzr ] || [ "$VCS" = darcs ]; then
-	special=$(find -not -type d -not -type f -not -type l | grep -v '/\(.git\|.hg\|.bzr\|_darcs\)/') || true
-	if [ -n "$special" ]; then
-		echo "etckeeper warning: special files could cause problems with $VCS:" >&2
-		echo "$special" >&2
-	fi
-fi
-
-true
diff --git a/pre-commit.d/20warn-special-file.in b/pre-commit.d/20warn-special-file.in
new file mode 100644
index 0000000..4921abe
--- /dev/null
+++ b/pre-commit.d/20warn-special-file.in
@@ -0,0 +1,12 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ] || [ "$VCS" = hg ] || [ "$VCS" = bzr ] || [ "$VCS" = darcs ]; then
+	special=$(find -not -type d -not -type f -not -type l | grep -v '/\(.git\|.hg\|.bzr\|_darcs\)/') || true
+	if [ -n "$special" ]; then
+		echo "etckeeper warning: special files could cause problems with $VCS:" >&2
+		echo "$special" >&2
+	fi
+fi
+
+true
diff --git a/pre-commit.d/30store-metadata b/pre-commit.d/30store-metadata
deleted file mode 100755
index f4125f6..0000000
--- a/pre-commit.d/30store-metadata
+++ /dev/null
@@ -1,130 +0,0 @@
-#!/bin/sh
-set -e
-
-# Filters out UNKNOWN users and groups, prints a warning on stderr.
-filter_unknown() {
-	CMD=$1
-	while read line; do
-		# if the first n chars of $line equal "$CMD UNKNOWN "...
-		if [ "$(printf %.$((9+${#CMD}))s "$line")" = "$CMD UNKNOWN " ]; then
-			echo Bad "$2" for "$line" >&2
-		else
-			echo "$line"
-		fi
-	done
-}
-
-filter_ignore() {
-	if [ "$VCS" = darcs ]; then
-		ignorefile=.darcsignore
-	fi
-
-	if [ "$VCS" = darcs ] && [ -e "$ignorefile" ]; then
-		# Spaces embedded into patterns would break it.
-		# But really, why would anyone want to use ' ' instead of '\s' ?
-		#patterns=$( grep -v '^[[:space:]]*\(#\|$\)' "$ignorefile" | xargs -n 1 printf " -e %s" )
-		#grep -Ev $patterns
-		#unset patterns
-		# Alternative using a temp file
-		patternsfile="$( mktemp -t etckeeper-$VCS.XXXXXXXXXX )"
-		grep -v '^[[:space:]]*\(#\|$\)' "$ignorefile" > "$patternsfile" || true
-		grep -Evf "$patternsfile"
-		rm -f "$patternsfile"
-		unset patternsfile
-	else
-		cat -
-	fi
-}
-
-generate_metadata() {
-	# This function generates the script commands to fix any files
-	# that aren't owner=root, group=root, or mode=0644 or 0755.
-	# The script is produced on stdout.  Errors go to stderr.
-	# 
-	# The script can use a 'maybe' function, which only runs a command
-	# if the file in its last argument exists.
-
-	# We maintain the permissions on the directory containing VCS data
-	# but we want find to ignore the VCS files themselves.
-	# 
-	# (Note that when using this, the find expression must end with 
-	# -print or -exec, else the excluded directories will actually be
-	# printed!)
-	NOVCS='. -wholename ./.git -prune -o -wholename ./.bzr -prune -o -wholename ./.hg -prune -o -wholename ./_darcs -prune -o'
-
-	# Keep the sort order the same at all times.
-	LC_COLLATE=C
-	export LC_COLLATE
-
-	if [ "$VCS" = git ] || [ "$VCS" = hg ]; then
-		# These version control systems do not track directories,
-		# so empty directories must be stored specially.
-		find $NOVCS -type d -empty -print |
-			sort | sed -e "s/^/mkdir -p '/" -e "s/\$/'/"
-	fi
-
-	if [ "$VCS" = darcs ]; then
-		# This version control system does not track symlinks,
-		# so they must be stored specially.
-		find $NOVCS -type l -print | sort | filter_ignore | while read link; do
-			dest=$( readlink "$link" )
-			printf "ln -sf '%s' '%s'\n" "$dest" "$link"
-		done
-	fi
-
-	# Find all files and directories that don't have the current user as the owner
-	find $NOVCS \! -user "$(id -u)" -exec stat --format="maybe chown %U '{}'" {} \; \
-		| sort | filter_unknown 'maybe chown' owner
-	# Find all files and directories that don't have root as the group
-	find $NOVCS \! -group $(id -g) -exec stat --format="maybe chgrp %G '{}'" {} \; \
-		| sort | filter_unknown 'maybe chgrp' group
-
-	# Find all directories that aren't 0755
-	find $NOVCS -type d \! -perm 0755 \
-		-exec stat --format="maybe chmod %a '{}'" {} \; | sort
-
-	if [ "$VCS" = darcs ]; then
-		# Find all files that aren't 0644 (darcs doesn't maintain
-		# the executable bit).
-		find $NOVCS -type f \! -perm 0644 \
-			-exec stat --format="maybe chmod %a '{}'" {} \; | sort
-	else
-		# Find all files that aren't 0644 or 0755 (we can assume the VCS will
-		# maintain the executable bit).
-		find $NOVCS -type f \! -perm 0644 \! -perm 0755 \
-			-exec stat --format="maybe chmod %a '{}'" {} \; | sort
-	fi
-
-	# We don't handle xattrs.
-	# Maybe check for getfattr/setfattr and use them if they're available?
-}
-
-if [ "$VCS" = git ] || [ "$VCS" = hg ] || [ "$VCS" = bzr ] || [ "$VCS" = darcs ]; then
-	if [ -f .metadata ]; then
-		# remove obsolete .metadata file
-		# git allows fully deleting it at this point, other VCS
-		# may not (the repo is locked for hg).
-		if [ "$VCS" = git ]; then
-			$VCS rm .metadata
-		else
-			rm -f .metadata
-		fi
-	fi
-
-	echo "# Generated by etckeeper.  Do not edit." > .etckeeper
-	echo >> .etckeeper
-
-	# Make sure the file is not readable by others, since it can leak
-	# information about contents of non-readable directories in /etc.
-	chmod 700 .etckeeper
-
-	generate_metadata >> .etckeeper
-
-	# stage the file as part of the current commit
-	if [ "$VCS" = git ]; then
-		# this will do nothing if the metadata file is unchanged.
-		git add .etckeeper
-	fi
-	# hg, bzr and darcs add not done, they will automatically
-	# include the file in the current commit
-fi
diff --git a/pre-commit.d/30store-metadata.in b/pre-commit.d/30store-metadata.in
new file mode 100644
index 0000000..9fb2162
--- /dev/null
+++ b/pre-commit.d/30store-metadata.in
@@ -0,0 +1,130 @@
+#!@SHELLPATH@
+set -e
+
+# Filters out UNKNOWN users and groups, prints a warning on stderr.
+filter_unknown() {
+	CMD=$1
+	while read line; do
+		# if the first n chars of $line equal "$CMD UNKNOWN "...
+		if [ "$(printf %.$((9+${#CMD}))s "$line")" = "$CMD UNKNOWN " ]; then
+			echo Bad "$2" for "$line" >&2
+		else
+			echo "$line"
+		fi
+	done
+}
+
+filter_ignore() {
+	if [ "$VCS" = darcs ]; then
+		ignorefile=.darcsignore
+	fi
+
+	if [ "$VCS" = darcs ] && [ -e "$ignorefile" ]; then
+		# Spaces embedded into patterns would break it.
+		# But really, why would anyone want to use ' ' instead of '\s' ?
+		#patterns=$( grep -v '^[[:space:]]*\(#\|$\)' "$ignorefile" | xargs -n 1 printf " -e %s" )
+		#grep -Ev $patterns
+		#unset patterns
+		# Alternative using a temp file
+		patternsfile="$( mktemp -t etckeeper-$VCS.XXXXXXXXXX )"
+		grep -v '^[[:space:]]*\(#\|$\)' "$ignorefile" > "$patternsfile" || true
+		grep -Evf "$patternsfile"
+		rm -f "$patternsfile"
+		unset patternsfile
+	else
+		cat -
+	fi
+}
+
+generate_metadata() {
+	# This function generates the script commands to fix any files
+	# that aren't owner=root, group=root, or mode=0644 or 0755.
+	# The script is produced on stdout.  Errors go to stderr.
+	# 
+	# The script can use a 'maybe' function, which only runs a command
+	# if the file in its last argument exists.
+
+	# We maintain the permissions on the directory containing VCS data
+	# but we want find to ignore the VCS files themselves.
+	# 
+	# (Note that when using this, the find expression must end with 
+	# -print or -exec, else the excluded directories will actually be
+	# printed!)
+	NOVCS='. -wholename ./.git -prune -o -wholename ./.bzr -prune -o -wholename ./.hg -prune -o -wholename ./_darcs -prune -o'
+
+	# Keep the sort order the same at all times.
+	LC_COLLATE=C
+	export LC_COLLATE
+
+	if [ "$VCS" = git ] || [ "$VCS" = hg ]; then
+		# These version control systems do not track directories,
+		# so empty directories must be stored specially.
+		find $NOVCS -type d -empty -print |
+			sort | sed -e "s/^/mkdir -p '/" -e "s/\$/'/"
+	fi
+
+	if [ "$VCS" = darcs ]; then
+		# This version control system does not track symlinks,
+		# so they must be stored specially.
+		find $NOVCS -type l -print | sort | filter_ignore | while read link; do
+			dest=$( readlink "$link" )
+			printf "ln -sf '%s' '%s'\n" "$dest" "$link"
+		done
+	fi
+
+	# Find all files and directories that don't have the current user as the owner
+	find $NOVCS \! -user "$(id -u)" -exec stat --format="maybe chown %U '{}'" {} \; \
+		| sort | filter_unknown 'maybe chown' owner
+	# Find all files and directories that don't have root as the group
+	find $NOVCS \! -group $(id -g) -exec stat --format="maybe chgrp %G '{}'" {} \; \
+		| sort | filter_unknown 'maybe chgrp' group
+
+	# Find all directories that aren't 0755
+	find $NOVCS -type d \! -perm 0755 \
+		-exec stat --format="maybe chmod %a '{}'" {} \; | sort
+
+	if [ "$VCS" = darcs ]; then
+		# Find all files that aren't 0644 (darcs doesn't maintain
+		# the executable bit).
+		find $NOVCS -type f \! -perm 0644 \
+			-exec stat --format="maybe chmod %a '{}'" {} \; | sort
+	else
+		# Find all files that aren't 0644 or 0755 (we can assume the VCS will
+		# maintain the executable bit).
+		find $NOVCS -type f \! -perm 0644 \! -perm 0755 \
+			-exec stat --format="maybe chmod %a '{}'" {} \; | sort
+	fi
+
+	# We don't handle xattrs.
+	# Maybe check for getfattr/setfattr and use them if they're available?
+}
+
+if [ "$VCS" = git ] || [ "$VCS" = hg ] || [ "$VCS" = bzr ] || [ "$VCS" = darcs ]; then
+	if [ -f .metadata ]; then
+		# remove obsolete .metadata file
+		# git allows fully deleting it at this point, other VCS
+		# may not (the repo is locked for hg).
+		if [ "$VCS" = git ]; then
+			$VCS rm .metadata
+		else
+			rm -f .metadata
+		fi
+	fi
+
+	echo "# Generated by etckeeper.  Do not edit." > .etckeeper
+	echo >> .etckeeper
+
+	# Make sure the file is not readable by others, since it can leak
+	# information about contents of non-readable directories in /etc.
+	chmod 700 .etckeeper
+
+	generate_metadata >> .etckeeper
+
+	# stage the file as part of the current commit
+	if [ "$VCS" = git ]; then
+		# this will do nothing if the metadata file is unchanged.
+		git add .etckeeper
+	fi
+	# hg, bzr and darcs add not done, they will automatically
+	# include the file in the current commit
+fi
diff --git a/pre-install.d/10packagelist b/pre-install.d/10packagelist
deleted file mode 100755
index f83acee..0000000
--- a/pre-install.d/10packagelist
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/sh
-# This list will be later used when committing.
-etckeeper list-installed > /var/cache/etckeeper/packagelist.pre-install
diff --git a/pre-install.d/10packagelist.in b/pre-install.d/10packagelist.in
new file mode 100644
index 0000000..4d0f79d
--- /dev/null
+++ b/pre-install.d/10packagelist.in
@@ -0,0 +1,3 @@
+#!@SHELLPATH@
+# This list will be later used when committing.
+etckeeper list-installed > /var/cache/etckeeper/packagelist.pre-install
diff --git a/pre-install.d/50uncommitted-changes b/pre-install.d/50uncommitted-changes
deleted file mode 100755
index 47750ac..0000000
--- a/pre-install.d/50uncommitted-changes
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$1" = "fail-debconf" ]; then
-	. /usr/share/debconf/confmodule
-	db_subst etckeeper/commit_failed VCS "$VCS"
-	db_input critical etckeeper/commit_failed || true
-	db_go || true
-	db_reset etckeeper/commit_failed || true
-fi
-
-if etckeeper unclean; then
-	if [ "$AVOID_COMMIT_BEFORE_INSTALL" = 1 ]; then
-		echo "" >&2
-		echo "** etckeeper detected uncommitted changes in /etc prior to $HIGHLEVEL_PACKAGE_MANAGER run" >&2 
-		echo "** Aborting $HIGHLEVEL_PACKAGE_MANAGER run. Manually commit and restart." >&2
-		echo "" >&2
-		exit 1
-	fi
-	if ! etckeeper commit "saving uncommitted changes in /etc prior to $HIGHLEVEL_PACKAGE_MANAGER run"; then
-		if [ -e /usr/share/debconf/confmodule ]; then
-			$0 fail-debconf
-		else
-			echo "error: etckeeper failed to commit changes in /etc using $VCS"
-			exit 1
-		fi
-	fi
-fi
diff --git a/pre-install.d/50uncommitted-changes.in b/pre-install.d/50uncommitted-changes.in
new file mode 100644
index 0000000..bf01ac0
--- /dev/null
+++ b/pre-install.d/50uncommitted-changes.in
@@ -0,0 +1,28 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$1" = "fail-debconf" ]; then
+	. /usr/share/debconf/confmodule
+	db_subst etckeeper/commit_failed VCS "$VCS"
+	db_input critical etckeeper/commit_failed || true
+	db_go || true
+	db_reset etckeeper/commit_failed || true
+fi
+
+if etckeeper unclean; then
+	if [ "$AVOID_COMMIT_BEFORE_INSTALL" = 1 ]; then
+		echo "" >&2
+		echo "** etckeeper detected uncommitted changes in /etc prior to $HIGHLEVEL_PACKAGE_MANAGER run" >&2 
+		echo "** Aborting $HIGHLEVEL_PACKAGE_MANAGER run. Manually commit and restart." >&2
+		echo "" >&2
+		exit 1
+	fi
+	if ! etckeeper commit "saving uncommitted changes in /etc prior to $HIGHLEVEL_PACKAGE_MANAGER run"; then
+		if [ -e /usr/share/debconf/confmodule ]; then
+			$0 fail-debconf
+		else
+			echo "error: etckeeper failed to commit changes in /etc using $VCS"
+			exit 1
+		fi
+	fi
+fi
diff --git a/unclean.d/50test b/unclean.d/50test
deleted file mode 100755
index 84e6be7..0000000
--- a/unclean.d/50test
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ]; then
-	[ -d .git ] && [ -n "`git ls-files --modified --deleted --others --exclude-standard`" ]
-elif [ "$VCS" = hg ]; then
-	[ -d .hg ] && ! hg status 2>&1 | wc -l | grep -q "^0$"
-elif [ "$VCS" = bzr ]; then
-	[ -d .bzr ] && ! bzr status 2>/dev/null | wc -l | grep -q "^0$"
-elif [ "$VCS" = darcs ]; then
-	[ -d _darcs ] && darcs whatsnew -l >/dev/null
-fi
diff --git a/unclean.d/50test.in b/unclean.d/50test.in
new file mode 100644
index 0000000..41dda67
--- /dev/null
+++ b/unclean.d/50test.in
@@ -0,0 +1,12 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ]; then
+	[ -d .git ] && [ -n "`git ls-files --modified --deleted --others --exclude-standard`" ]
+elif [ "$VCS" = hg ]; then
+	[ -d .hg ] && ! hg status 2>&1 | wc -l | grep -q "^0$"
+elif [ "$VCS" = bzr ]; then
+	[ -d .bzr ] && ! bzr status 2>/dev/null | wc -l | grep -q "^0$"
+elif [ "$VCS" = darcs ]; then
+	[ -d _darcs ] && darcs whatsnew -l >/dev/null
+fi
diff --git a/uninit.d/01prompt b/uninit.d/01prompt
deleted file mode 100755
index 07f2e41..0000000
--- a/uninit.d/01prompt
+++ /dev/null
@@ -1,20 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$1" != "-f" ]; then
-	echo "** Warning: This will DESTROY all recorded history for $ETCKEEPER_DIR,"
-	echo "** including the $VCS repository and ignore file."
-	echo ""
-	printf "Are you sure you want to do this? [yN] "
-	read answer
-	case "$answer" in 
-		[Yy]*)
-			echo "Proceeding.."
-			exit 0
-		;;
-		*)
-			echo "Aborting etckeeper uninit."
-			exit 1
-		;;
-	esac
-fi
diff --git a/uninit.d/01prompt.in b/uninit.d/01prompt.in
new file mode 100644
index 0000000..6b64a39
--- /dev/null
+++ b/uninit.d/01prompt.in
@@ -0,0 +1,20 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$1" != "-f" ]; then
+	echo "** Warning: This will DESTROY all recorded history for $ETCKEEPER_DIR,"
+	echo "** including the $VCS repository and ignore file."
+	echo ""
+	printf "Are you sure you want to do this? [yN] "
+	read answer
+	case "$answer" in 
+		[Yy]*)
+			echo "Proceeding.."
+			exit 0
+		;;
+		*)
+			echo "Aborting etckeeper uninit."
+			exit 1
+		;;
+	esac
+fi
diff --git a/uninit.d/50remove-metadata b/uninit.d/50remove-metadata
deleted file mode 100755
index 0be8d36..0000000
--- a/uninit.d/50remove-metadata
+++ /dev/null
@@ -1,6 +0,0 @@
-#!/bin/sh
-set -e
-
-# Files generated by etckeeper to store metadata the VCS cannot preserve.
-rm -f .etckeeper
-rm -f .metadata # only generated by old versions
diff --git a/uninit.d/50remove-metadata.in b/uninit.d/50remove-metadata.in
new file mode 100644
index 0000000..29332a1
--- /dev/null
+++ b/uninit.d/50remove-metadata.in
@@ -0,0 +1,6 @@
+#!@SHELLPATH@
+set -e
+
+# Files generated by etckeeper to store metadata the VCS cannot preserve.
+rm -f .etckeeper
+rm -f .metadata # only generated by old versions
diff --git a/uninit.d/50vcs-uninit b/uninit.d/50vcs-uninit
deleted file mode 100755
index c9896ed..0000000
--- a/uninit.d/50vcs-uninit
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ]; then
-	rm -rf .git .gitignore
-elif [ "$VCS" = hg ]; then
-	rm -rf .hg .hgignore
-elif [ "$VCS" = bzr ]; then
-	rm -rf .bzr .bzrignore
-elif [ "$VCS" = darcs ]; then
-	rm -rf _darcs .darcsignore
-fi
diff --git a/uninit.d/50vcs-uninit.in b/uninit.d/50vcs-uninit.in
new file mode 100644
index 0000000..df23a2b
--- /dev/null
+++ b/uninit.d/50vcs-uninit.in
@@ -0,0 +1,12 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ]; then
+	rm -rf .git .gitignore
+elif [ "$VCS" = hg ]; then
+	rm -rf .hg .hgignore
+elif [ "$VCS" = bzr ]; then
+	rm -rf .bzr .bzrignore
+elif [ "$VCS" = darcs ]; then
+	rm -rf _darcs .darcsignore
+fi
diff --git a/update-ignore.d/01update-ignore b/update-ignore.d/01update-ignore
deleted file mode 100755
index 510e13f..0000000
--- a/update-ignore.d/01update-ignore
+++ /dev/null
@@ -1,160 +0,0 @@
-#!/bin/sh
-set -e
-
-if [ "$VCS" = git ]; then
-	dir=.git
-	file=.gitignore
-elif [ "$VCS" = hg ]; then
-	dir=.hg
-	file=.hgignore
-elif [ "$VCS" = bzr ]; then
-	dir=.bzr
-	file=.bzrignore
-elif [ "$VCS" = darcs ]; then
-	dir=_darcs
-	file=.darcsignore
-else
-	echo "etckeeper: unsupported VCS $VCS" >&2
-	exit 1
-fi
-
-if [ ! -d "$dir" ]; then
-	exit 0
-fi
-
-managed_by_etckeeper="managed by etckeeper"
-
-nl() {
-	echo >>"$file"
-}
-
-comment() {
-	comment="$1"
-	echo "# $comment" >>"$file"
-}
-
-ignore() {
-	glob="$1"
-	
-	case "$VCS" in
-		git|bzr)
-			echo "$glob" >>"$file"
-		;;
-		hg)
-			# rather than converting the glob to a regexp, just
-			# configure hg to use globs
-			if [ -z "$hg_syntax_printed" ]; then
-				comment "use glob syntax"
-				echo "syntax: glob" >>"$file"
-				nl
-				hg_syntax_printed=1
-			fi
-			echo "$glob" >>"$file"
-		;;
-		darcs)
-			# darcs doesn't understand globs, so we need to translate
-			# them into regexs. Not a complete converter, but suitable
-			# for given globs.
-			if [ "${glob%\*}" != "$glob" ]; then
-				glob="${glob%\*}"
-			else
-				glob="$glob"'($|/)'
-			fi
-			if [ "${glob#\*}" != "$glob" ]; then
-				glob="${glob#\*}"
-			else
-				glob='(^|/)'"$glob"
-			fi
-			glob="$( printf %s $glob | sed -e 's/\./\\./g;s/\*/[^\/]*/g;s/\?/[^\/]/g' )"
-			echo "$glob" >>"$file"
-	esac
-}
-
-writefile () {
-	comment "begin section $managed_by_etckeeper (do not edit this section by hand)"
-	nl
-
-	if [ "$VCS" = darcs ]; then
-		darcs setpref boringfile .darcsignore
-	fi
-
-	if [ "$LOWLEVEL_PACKAGE_MANAGER" = dpkg ]; then
-		comment "new and old versions of conffiles, stored by dpkg"
-		ignore "*.dpkg-*"
-		nl
-	elif [ "$LOWLEVEL_PACKAGE_MANAGER" = "rpm" ]; then
-		comment "new and old versions of conffiles, stored by apt/rpm"
-		ignore "*.rpm*"
-		nl
-	elif [ "$LOWLEVEL_PACKAGE_MANAGER" = "pacman-g2" ]; then
-		comment "new and old versions of conffiles, stored by pacman"
-		ignore "*.pacnew"
-		ignore "*.pacorig"
-		ignore "*.pacsave"
-		nl
-	fi
-	
-	comment "mount(8) records system state here, no need to store these"
-	ignore blkid.tab
-	ignore blkid.tab.old
-	nl
-	
-	comment "some other files in /etc that typically do not need to be tracked"
-	ignore nologin
-	ignore ld.so.cache
-	ignore mtab
-	ignore .pwd.lock
-	ignore network/run
-	ignore adjtime
-	ignore lvm/cache
-	nl
-	
-	comment "editor temp files"
-	ignore "*~"
-	ignore ".*.sw?"
-	ignore ".sw?"
-	ignore "#*#"
-	ignore DEADJOE
-
-	nl
-	comment "end section $managed_by_etckeeper"
-}
-
-if [ -e "$file" ]; then
-	if ! grep -q "$managed_by_etckeeper" "$file"; then
-		echo "etckeeper: "$file" does not contain \"$managed_by_etckeeper\" comment; not updating"
-		exit 1
-	fi
-	realfile="$file"
-	if [ -n "`type -p tempfile`" ]; then
-		tempfile="tempfile"
-	elif [ -n "`type -p mktemp`" ]; then
-		tempfile="mktemp"
-	else
-		echo "etckeeper warning: can't find tempfile or mktemp" >&2
-	fi
-	file=$($tempfile)
-	(
-		skipping=
-		while read line; do
-			if echo "$line" | grep -q "$managed_by_etckeeper"; then
-				if [ ! "$skipping" ]; then
-					skipping=1
-				else
-					skipping=
-					writefile
-				fi
-			elif [ ! "$skipping" ]; then
-				echo "$line" >> "$file"
-			fi
-		done
-		if [ "$skipping" ]; then
-			# reached end of file w/o ending block
-			writefile
-		fi
-	) <"$realfile"
-
-	mv -f "$file" "$realfile"
-else
-	writefile
-fi
diff --git a/update-ignore.d/01update-ignore.in b/update-ignore.d/01update-ignore.in
new file mode 100644
index 0000000..2de6e61
--- /dev/null
+++ b/update-ignore.d/01update-ignore.in
@@ -0,0 +1,160 @@
+#!@SHELLPATH@
+set -e
+
+if [ "$VCS" = git ]; then
+	dir=.git
+	file=.gitignore
+elif [ "$VCS" = hg ]; then
+	dir=.hg
+	file=.hgignore
+elif [ "$VCS" = bzr ]; then
+	dir=.bzr
+	file=.bzrignore
+elif [ "$VCS" = darcs ]; then
+	dir=_darcs
+	file=.darcsignore
+else
+	echo "etckeeper: unsupported VCS $VCS" >&2
+	exit 1
+fi
+
+if [ ! -d "$dir" ]; then
+	exit 0
+fi
+
+managed_by_etckeeper="managed by etckeeper"
+
+nl() {
+	echo >>"$file"
+}
+
+comment() {
+	comment="$1"
+	echo "# $comment" >>"$file"
+}
+
+ignore() {
+	glob="$1"
+	
+	case "$VCS" in
+		git|bzr)
+			echo "$glob" >>"$file"
+		;;
+		hg)
+			# rather than converting the glob to a regexp, just
+			# configure hg to use globs
+			if [ -z "$hg_syntax_printed" ]; then
+				comment "use glob syntax"
+				echo "syntax: glob" >>"$file"
+				nl
+				hg_syntax_printed=1
+			fi
+			echo "$glob" >>"$file"
+		;;
+		darcs)
+			# darcs doesn't understand globs, so we need to translate
+			# them into regexs. Not a complete converter, but suitable
+			# for given globs.
+			if [ "${glob%\*}" != "$glob" ]; then
+				glob="${glob%\*}"
+			else
+				glob="$glob"'($|/)'
+			fi
+			if [ "${glob#\*}" != "$glob" ]; then
+				glob="${glob#\*}"
+			else
+				glob='(^|/)'"$glob"
+			fi
+			glob="$( printf %s $glob | sed -e 's/\./\\./g;s/\*/[^\/]*/g;s/\?/[^\/]/g' )"
+			echo "$glob" >>"$file"
+	esac
+}
+
+writefile () {
+	comment "begin section $managed_by_etckeeper (do not edit this section by hand)"
+	nl
+
+	if [ "$VCS" = darcs ]; then
+		darcs setpref boringfile .darcsignore
+	fi
+
+	if [ "$LOWLEVEL_PACKAGE_MANAGER" = dpkg ]; then
+		comment "new and old versions of conffiles, stored by dpkg"
+		ignore "*.dpkg-*"
+		nl
+	elif [ "$LOWLEVEL_PACKAGE_MANAGER" = "rpm" ]; then
+		comment "new and old versions of conffiles, stored by apt/rpm"
+		ignore "*.rpm*"
+		nl
+	elif [ "$LOWLEVEL_PACKAGE_MANAGER" = "pacman-g2" ]; then
+		comment "new and old versions of conffiles, stored by pacman"
+		ignore "*.pacnew"
+		ignore "*.pacorig"
+		ignore "*.pacsave"
+		nl
+	fi
+	
+	comment "mount(8) records system state here, no need to store these"
+	ignore blkid.tab
+	ignore blkid.tab.old
+	nl
+	
+	comment "some other files in /etc that typically do not need to be tracked"
+	ignore nologin
+	ignore ld.so.cache
+	ignore mtab
+	ignore .pwd.lock
+	ignore network/run
+	ignore adjtime
+	ignore lvm/cache
+	nl
+	
+	comment "editor temp files"
+	ignore "*~"
+	ignore ".*.sw?"
+	ignore ".sw?"
+	ignore "#*#"
+	ignore DEADJOE
+
+	nl
+	comment "end section $managed_by_etckeeper"
+}
+
+if [ -e "$file" ]; then
+	if ! grep -q "$managed_by_etckeeper" "$file"; then
+		echo "etckeeper: "$file" does not contain \"$managed_by_etckeeper\" comment; not updating"
+		exit 1
+	fi
+	realfile="$file"
+	if [ -n "`type -p tempfile`" ]; then
+		tempfile="tempfile"
+	elif [ -n "`type -p mktemp`" ]; then
+		tempfile="mktemp"
+	else
+		echo "etckeeper warning: can't find tempfile or mktemp" >&2
+	fi
+	file=$($tempfile)
+	(
+		skipping=
+		while read line; do
+			if echo "$line" | grep -q "$managed_by_etckeeper"; then
+				if [ ! "$skipping" ]; then
+					skipping=1
+				else
+					skipping=
+					writefile
+				fi
+			elif [ ! "$skipping" ]; then
+				echo "$line" >> "$file"
+			fi
+		done
+		if [ "$skipping" ]; then
+			# reached end of file w/o ending block
+			writefile
+		fi
+	) <"$realfile"
+
+	mv -f "$file" "$realfile"
+else
+	writefile
+fi
