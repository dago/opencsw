#!/bin/sh
#
# i.cswinitsmf - Class action script for CSW SMF support
#
# $Id$
#
# Original concept by Philip Brown
# Written and maintained by Peter Bonivart
#
# 2008-04-21 First release
# 2009-03-28 Added support for refresh
# 2009-04-21 Do not create rc links unless enabled (Bug ID 0003633),
#            Persistent state across upgrades (Bug ID 0003634)
# 2009-04-22 Fix bug when starting packages with multiple services (Ihsan Dogan)
# 2009-04-24 Temporarily disabled the "persistent state" code until it can be
#            used per service, not just per package
# 2009-05-28 Enabled persistent state code again after receiving patch
#            from Yann.
#            Support AUTOENABLE to force no start regardless of
#            local csw.conf (Bug ID 0003635).
#            Support custom manifests (Bug ID 0003636)
# 2009-08-05 Set new timeout values for manifest (Bug ID 0003764)
# 2009-08-10 Fix autoenable bug (Bug ID 0003785)
# 2010-10-25 Fix grep bug in FMRI 'dot in name' detection (Bug ID 0004588)

DEBUG=		# clear to disable debug, set to anything to enable
SVCDIR=/var/opt/csw/svc

SMF_STATE_DIR="$PKG_INSTALL_ROOT/etc/opt/csw/preserve/$PKG"
SMF_STATE_FILE="$SMF_STATE_DIR/smf.state"

# retrieve the previous state of a service identified by the given FRMI
load_smf_service_state ()
{
    SMF_STATE="enabled"

    if [ -f "$SMF_STATE_FILE" ]; then
        set -- `/usr/bin/awk " \\\$1 == \"$1\" { print \\\$2 } " "$SMF_STATE_FILE"`
        if [ "$1" = "disabled" ]; then
            SMF_STATE="disabled"
        fi
    fi
}

# Source csw.conf, if it exists
if [ -f $PKG_INSTALL_ROOT/opt/csw/etc/csw.conf ] ; then
  . $PKG_INSTALL_ROOT/opt/csw/etc/csw.conf
fi
if [ -f $PKG_INSTALL_ROOT/etc/opt/csw/csw.conf ] ; then
  . $PKG_INSTALL_ROOT/etc/opt/csw/csw.conf
fi

# Determine if SMF should be used or not
smf=no

if [ -f /usr/sbin/svccfg -a -f /usr/sbin/svcadm ]; then
  smf=yes
fi

if [ "$use_smf" = "no" ]; then
  smf=no
fi

if [ "$DEBUG" ]; then
  echo PACKAGE: $PKGINST SMF: $smf
fi

# Copy files, set up SMF
echo "Installing class <cswinitsmf> ..."

while read src dest
do
  if [ "$DEBUG" ]; then
    echo SRC: $src DEST: $dest
  fi
  service="`basename $dest`"

  # Determine if service should be started or not
  daemon=yes
  if [ "$autoenable_daemons" = "no" ]; then
    daemon=no
  fi
  eval autoenable_service="\$autoenable_$service"
  if [ "$autoenable_service" = "no" ]; then
    daemon=no
  elif [ "$autoenable_service" = "yes" ]; then
    daemon=yes
  fi

  if [ "$smf" = "yes" ]; then
    # Copy the service script
    /usr/bin/cp $src $dest || exit 2
    FMRI=
    if [ "`grep '^#FMRI' $dest`" ]; then
      FMRI=`grep '^#FMRI' $dest | awk '{print $2}'`
      if [ "`echo $FMRI | grep '\.'`" ]; then
        echo "WARNING! FMRI path contained an illegal dot (removed)"
        FMRI=`echo $FMRI | sed 's/\.//g'`
        echo "New FMRI path: $FMRI"
      fi
    fi
    if [ ! "$FMRI" ]; then
      FMRI=network
    fi
    # Creating FMRI path on system if needed
    testpath=$SVCDIR/manifest
    for i in `echo $FMRI | sed 's/\// /g'`; do
      testpath=$testpath/$i
      if [ ! -d $testpath ]; then
        echo Creating $testpath ...
        /usr/bin/mkdir $testpath
        /usr/bin/chown root:bin $testpath
        /usr/bin/chmod 755 $testpath
        /usr/sbin/installf -c cswinitsmf $PKGINST $testpath d 755 root bin
      fi
    done
    if [ "$DEBUG" ]; then
      echo FMRI: $FMRI
    fi
    echo Creating service script in $SVCDIR/method/svc-$service ...
    /usr/bin/ln -s $dest $SVCDIR/method/svc-$service
    /usr/sbin/installf -c cswinitsmf $PKGINST $SVCDIR/method/svc-$service=$dest s
    /usr/bin/chmod 755 $SVCDIR/method/svc-$service
    /usr/bin/chown root:bin $SVCDIR/method/svc-$service

    MANIFEST=
    if [ "`grep '^#MANIFEST' $dest`" ]; then
      MANIFEST=`grep '^#MANIFEST' $dest | awk '{print $2}'`
    fi
    if [ ! "$MANIFEST" ]; then
      # Creating manifest
      echo Creating manifest ...
      # Add first part of manifest
      MANIFEST=$SVCDIR/manifest/$FMRI/$service.xml
      cat > $MANIFEST << EOF
<?xml version='1.0'?>
<!DOCTYPE service_bundle SYSTEM '/usr/share/lib/xml/dtd/service_bundle.dtd.1'>
<!--
Service manifest for $service
Autogenerated by CSWinitsmf
2008-04-21 Peter Bonivart
-->

<service_bundle type='manifest' name='$service:$service'>

<service
  name='$FMRI/$service'
  type='service'
  version='1'>
  <create_default_instance enabled='false' />
  <single_instance />

  <dependency name='fs'
    grouping='require_all'
    restart_on='none'
    type='service'>
    <service_fmri value='svc:/system/filesystem/local' />
  </dependency>

  <dependency name='net'
    grouping='require_all'
    restart_on='none'
    type='service'>
    <service_fmri value='svc:/network/loopback' />
  </dependency>

  <exec_method
    type='method'
    name='start'
    exec='$SVCDIR/method/svc-$service start'
    timeout_seconds='120'>
  </exec_method>

  <exec_method
    type='method'
    name='stop'
    exec='$SVCDIR/method/svc-$service stop'
    timeout_seconds='60'>
  </exec_method>

EOF

      # Add restart option to manifest if service script supports it
      if [ "`/usr/bin/egrep 'restart.?\)' $SVCDIR/method/svc-$service`" ]; then
        cat >> $MANIFEST << EOF
  <exec_method
    type='method'
    name='restart'
    exec='$SVCDIR/method/svc-$service restart'
    timeout_seconds='180'>
  </exec_method>

EOF
      fi

      # Add refresh option to manifest if service script supports it
      if [ "`/usr/bin/egrep 'refresh.?\)' $SVCDIR/method/svc-$service`" ]; then
        cat >> $MANIFEST << EOF
  <exec_method
    type='method'
    name='refresh'
    exec='$SVCDIR/method/svc-$service refresh'
    timeout_seconds='60'>
  </exec_method>

EOF
      fi

      # Add last part of manifest
      cat >> $MANIFEST << EOF
</service>

</service_bundle>
EOF
      /usr/sbin/installf -c cswinitsmf $PKGINST $MANIFEST f 644 root bin
      /usr/bin/chmod 644 $MANIFEST
      /usr/bin/chown root:bin $MANIFEST
    else
      # Custom manifest
      echo Using custom manifest ...
    fi

    if [ "$DEBUG" ]; then
      echo MANIFEST: $MANIFEST
    fi

    # Register with SMF
    echo Configuring service in SMF ...
    /usr/sbin/svccfg import $MANIFEST > /dev/null 2>&1
    /usr/sbin/svcadm disable svc:/$FMRI/$service > /dev/null 2>&1
    echo $PKGINST is using Service Management Facility. The FMRI is svc:/$FMRI/$service:default

    # Start service
    AUTOENABLE="yes"
    if [ "`grep '^#AUTOENABLE' $dest`" ]; then
      AUTOENABLE=`grep '^#AUTOENABLE' $dest | awk '{print $2}' | /usr/xpg4/bin/tr -s '[:upper:]' '[:lower:]'`
    fi
    if [ "$daemon" = "yes" -a "$AUTOENABLE" != "no" -a "$AUTOENABLE" != "false" ]; then
      load_smf_service_state "$FMRI/$service"
      if [ "$SMF_STATE" = "enabled" ]; then
        echo "Clearing svc:/$FMRI/$service in case it's in the maintenance state..."
        /usr/sbin/svcadm clear svc:/$FMRI/$service > /dev/null 2>&1
        echo Enabling svc:/$FMRI/$service ...
        /usr/sbin/svcadm enable svc:/$FMRI/$service > /dev/null 2>&1
      fi
    fi
  else
    # Copy the service script
    echo $dest
    /usr/bin/cp $src $dest || exit 2

    # Create link to /etc/init.d
    echo /etc/init.d/$service
    /usr/bin/ln -s $dest /etc/init.d/$service
    /usr/sbin/installf -c cswinitsmf $PKGINST /etc/init.d/$service=$dest s

    # Create rc-symlinks if enabled
    if [ "$daemon" = "yes" ]; then
      RC_KNUM=
      if [ "`grep '^#RC_KNUM' $dest`" ]; then
        RC_KNUM=`grep '^#RC_KNUM' $dest | awk '{print $2}'`
      fi
      RC_SNUM=
      if [ "`grep '^#RC_SNUM' $dest`" ]; then
        RC_SNUM=`grep '^#RC_SNUM' $dest | awk '{print $2}'`
      fi
      RC_KLEV=
      if [ "`grep '^#RC_KLEV' $dest`" ]; then
        RC_KLEV=`grep '^#RC_KLEV' $dest | awk '{print $2}'`
        RC_KLEV=`echo $RC_KLEV | sed 's/,/ /g'`
      fi
      RC_SLEV=
      if [ "`grep '^#RC_SLEV' $dest`" ]; then
        RC_SLEV=`grep '^#RC_SLEV' $dest | awk '{print $2}'`
        RC_SLEV=`echo $RC_SLEV | sed 's/,/ /g'`
      fi
      if [ ! "$RC_KNUM" ]; then
        RC_KNUM=20
      fi
      if [ ! "$RC_SNUM" ]; then
        RC_SNUM=80
      fi
      if [ ! "$RC_KLEV" ]; then
        RC_KLEV="0 1 2 S"
      fi
      if [ ! "$RC_SLEV" ]; then
        RC_SLEV=3
      fi
      if [ "$DEBUG" ]; then
        echo RC_KNUM: $RC_KNUM
        echo RC_SNUM: $RC_SNUM
        echo RC_KLEV: $RC_KLEV
        echo RC_SLEV: $RC_SLEV
      fi
      for i in $RC_KLEV; do
        echo /etc/rc$i.d/K$RC_KNUM$service
        /usr/sbin/installf -c cswinitsmf $PKGINST /etc/rc$i.d/K$RC_KNUM$service=/etc/init.d/$service s
        /bin/ln -s /etc/init.d/$service /etc/rc$i.d/K$RC_KNUM$service
      done
      for i in $RC_SLEV; do
        echo /etc/rc$i.d/S$RC_SNUM$service
        /usr/sbin/installf -c cswinitsmf $PKGINST /etc/rc$i.d/S$RC_SNUM$service=/etc/init.d/$service s
        /bin/ln -s /etc/init.d/$service /etc/rc$i.d/S$RC_SNUM$service
      done

      # Start service
      AUTOENABLE="yes"
      if [ "`grep '^#AUTOENABLE' $dest`" ]; then
        AUTOENABLE=`grep '^#AUTOENABLE' $dest | awk '{print $2}' | /usr/xpg4/bin/tr -s '[:upper:]' '[:lower:]'`
      fi
      if [ "$AUTOENABLE" != "no" -a "$AUTOENABLE" != "false" ]; then
        echo Starting $service ...
        # fix permissions temporarily since 644 is used until verification
        /usr/bin/chmod 744 /etc/init.d/$service
        /etc/init.d/$service start > /dev/null 2>&1
      fi
    fi
  fi
done

# we delete the smf state file as we don't need it anymore
rm -f "$SMF_STATE_FILE"

/usr/sbin/installf -f $PKGINST

exit 0
