--- gdb-6.8/gdb/auxv.c.orig	Sun Aug  2 13:51:23 2009
+++ gdb-6.8/gdb/auxv.c	Sun Aug  2 13:51:46 2009
@@ -52,9 +52,21 @@
   int fd;
   LONGEST n;
 
+  /*
+   * Solaris pads auxv for 32 bit process out to 64 bits when being read
+   * by a 64 bit process.  gdb expects a 32 bit auxv for 32 bit processes.
+   * We'll remove the padding here.
+   */
+  int solaris_64_32 = TYPE_LENGTH (builtin_type_void_data_ptr) == 4 && sizeof (void *) == 8;
+
   gdb_assert (object == TARGET_OBJECT_AUXV);
   gdb_assert (readbuf || writebuf);
 
+  /*
+   * Adjust offest for the 64/32 case.
+   */
+  if (solaris_64_32) offset *= 2;
+
   pathname = xstrprintf ("/proc/%d/auxv", PIDGET (inferior_ptid));
   fd = open (pathname, writebuf != NULL ? O_WRONLY : O_RDONLY);
   xfree (pathname);
@@ -64,10 +76,54 @@
   if (offset != (ULONGEST) 0
       && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)
     n = -1;
-  else if (readbuf != NULL)
+  else if (readbuf != NULL) {
     n = read (fd, readbuf, len);
-  else
+    /*
+     * Remove the padding for the 64/32 case.
+     */
+    if (solaris_64_32) {
+      /*
+       * Solaris pads auxv for 32 bit process out to 64 bits when being read
+       * by a 64 bit process.  gdb expects a 32 bit auxv for 32 bit processes.
+       */
+      unsigned *from, *to;
+      gdb_assert (n % 4 == 0);
+      from = to = (unsigned *)readbuf;
+      while (from < (unsigned *)(readbuf + n)) {
+        /*
+         * The type is always in the first 4 bytes followed by 4 bytes
+         * of padding on both SPARC and x86.
+         */
+        *to++ = *from;
+        from += 2;
+        /*
+         * The value is before the padding on Intel and after on SPARC.
+         */
+        switch (gdbarch_byte_order (current_gdbarch)) {
+          case BFD_ENDIAN_LITTLE:
+            *to++ = *from;
+            gdb_assert (*(from + 1) == 0);
+            break;
+          case BFD_ENDIAN_BIG:
+            gdb_assert (*from == 0);
+            *to++ = *(from + 1);
+            break;
+          default: gdb_assert (0);
+        }
+        from += 2;
+      }
+      /*
+       * Adjust the length for the 64/32 case.
+       */
+      n /= 2;
+    }
+  } else {
+    /*
+     * Does gdb ever write to auxv?
+     */
+    gdb_assert (!writebuf);
     n = write (fd, writebuf, len);
+  }
 
   (void) close (fd);
 
