diff -uNr openssl-1.0.1c.orig/Configure openssl-1.0.1c/Configure
--- openssl-1.0.1c.orig/Configure	2012-05-11 22:28:08.972569770 +0200
+++ openssl-1.0.1c/Configure	2012-05-11 22:19:17.459525000 +0200
@@ -133,8 +133,8 @@
 
 my $x86_64_asm="x86_64cpuid.o:x86_64-gcc.o x86_64-mont.o x86_64-mont5.o x86_64-gf2m.o modexp512-x86_64.o::aes-x86_64.o vpaes-x86_64.o bsaes-x86_64.o aesni-x86_64.o aesni-sha1-x86_64.o::md5-x86_64.o:sha1-x86_64.o sha256-x86_64.o sha512-x86_64.o::rc4-x86_64.o rc4-md5-x86_64.o:::wp-x86_64.o:cmll-x86_64.o cmll_misc.o:ghash-x86_64.o:";
 my $ia64_asm="ia64cpuid.o:bn-ia64.o ia64-mont.o::aes_core.o aes_cbc.o aes-ia64.o::md5-ia64.o:sha1-ia64.o sha256-ia64.o sha512-ia64.o::rc4-ia64.o rc4_skey.o:::::ghash-ia64.o::void";
-my $sparcv9_asm="sparcv9cap.o sparccpuid.o:bn-sparcv9.o sparcv9-mont.o sparcv9a-mont.o:des_enc-sparc.o fcrypt_b.o:aes_core.o aes_cbc.o aes-sparcv9.o:::sha1-sparcv9.o sha256-sparcv9.o sha512-sparcv9.o:::::::ghash-sparcv9.o::void";
-my $sparcv8_asm=":sparcv8.o:des_enc-sparc.o fcrypt_b.o:::::::::::::void";
+my $sparcv9_asm="sparcv9cap.o sparccpuid.o:bn-sparcv9.o sparcv9-mont.o sparcv9a-mont.o:des_enc-sparc.o fcrypt_b.o t4_des.o:aes_core.o aes_cbc.o aes-sparcv9.o t4_aes.o::t4_md5.o:sha1-sparcv9.o sha256-sparcv9.o sha512-sparcv9.o t4_sha1.o t4_sha2.o:::::::ghash-sparcv9.o::void";
+my $sparcv8_asm=":sparcv8.o:des_enc-sparc.o fcrypt_b.o t4_des.o:t4_aes.o::t4_md5.o:t4_sha1.o t4_sha2.o:::::::::void";
 my $alpha_asm="alphacpuid.o:bn_asm.o alpha-mont.o:::::sha1-alpha.o:::::::ghash-alpha.o::void";
 my $mips32_asm=":bn-mips.o::aes_cbc.o aes-mips.o:::sha1-mips.o sha256-mips.o::::::::";
 my $mips64_asm=":bn-mips.o mips-mont.o::aes_cbc.o aes-mips.o:::sha1-mips.o sha256-mips.o sha512-mips.o::::::::";
@@ -246,9 +246,9 @@
 # SC5.0 note: Compiler common patch 107357-01 or later is required!
 "solaris-sparcv7-cc","cc:-xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${no_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
 "solaris-sparcv8-cc","cc:-xarch=v8 -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
-"solaris-sparcv9-cc","cc:-m32 -xtarget=ultra -xarch=sparc -Qoption cg -xregs=no%appl -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
-"solaris-sparcv9+vis-cc","cc:-m32 -xtarget=ultra -xarch=sparcvis -Qoption cg -xregs=no%appl -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
-"solaris64-sparcv9-cc","cc:-m64 -xtarget=ultra -xarch=sparc -Qoption cg -xregs=no%appl -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-xarch=v9 -G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):/usr/ccs/bin/ar rs::/64",
+"solaris-sparcv9-cc","cc:-m32 -xtarget=ultra -xarch=sparc -Qoption cg -xregs=no%appl -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl -lsoftcrypto:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris-sparcv9+vis-cc","cc:-m32 -xtarget=ultra -xarch=sparcvis -Qoption cg -xregs=no%appl -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl -lsoftcrypto:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris64-sparcv9-cc","cc:-m64 -xtarget=ultra -xarch=sparc -Qoption cg -xregs=no%appl -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl -lsoftcrypto:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-xarch=v9 -G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):/usr/ccs/bin/ar rs::/64",
 ####
 "debug-solaris-sparcv8-cc","cc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG_ALL -xarch=v8 -g -O -xstrconst -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
 "debug-solaris-sparcv9-cc","cc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG_ALL -xtarget=ultra -xarch=v8plus -g -O -xstrconst -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)", 
diff -uNr openssl-1.0.1c.orig/crypto/aes/Makefile openssl-1.0.1c/crypto/aes/Makefile
--- openssl-1.0.1c.orig/crypto/aes/Makefile	2011-11-14 21:42:21.000000000 +0100
+++ openssl-1.0.1c/crypto/aes/Makefile	2012-05-11 22:19:17.481179000 +0200
@@ -17,6 +17,10 @@
 ASFLAGS= $(INCLUDES) $(ASFLAG)
 AFLAGS= $(ASFLAGS)
 
+BITS:=	$(shell if grep '^CFLAG.*=.*-m64' ../../Makefile >/dev/null; \
+		then echo 64; else echo 32; fi)
+ASFLAGSYF= -xregsym=no -K pic -P -xarch=v9v -D_sparcv9 -D_ASM -Dsparc -m$(BITS)
+
 GENERAL=Makefile
 #TEST=aestest.c
 TEST=
@@ -69,6 +73,10 @@
 aes-sparcv9.s: asm/aes-sparcv9.pl
 	$(PERL) asm/aes-sparcv9.pl $(CFLAGS) > $@
 
+t4_aes.o: asm/t4_aes.S
+	as $(ASFLAGSYF) -o $@ asm/t4_aes.S
+	elfedit -e 'cap:hw1 -and -cmp vis vis3' $@
+
 aes-ppc.s:	asm/aes-ppc.pl
 	$(PERL) asm/aes-ppc.pl $(PERLASM_SCHEME) $@
 
diff -uNr openssl-1.0.1c.orig/crypto/aes/asm/t4_aes.S openssl-1.0.1c/crypto/aes/asm/t4_aes.S
--- openssl-1.0.1c.orig/crypto/aes/asm/t4_aes.S	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/aes/asm/t4_aes.S	2012-05-11 21:34:40.438327000 +0200
@@ -0,0 +1,3052 @@
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*LINTLIBRARY*/
+
+#if defined(lint) || defined(__lint)
+
+
+#include <sys/types.h>
+
+/*ARGSUSED*/
+void t4_aes_expand128(uint64_t *rk, const uint32_t *key)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes_expand192(uint64_t *rk, const uint32_t *key)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes_expand256(uint64_t *rk, const uint32_t *key)
+{ return; }
+
+void t4_aes128_load_keys_for_encrypt(uint64_t *ks)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_load_keys_for_encrypt(uint64_t *ks)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_load_keys_for_encrypt(uint64_t *ks)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes128_ecb_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_ecb_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_ecb_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes128_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes128_ctr_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_ctr_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_ctr_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes128_cfb128_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_cfb128_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_cfb128_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+void t4_aes128_load_keys_for_decrypt(uint64_t *ks)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_load_keys_for_decrypt(uint64_t *ks)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_load_keys_for_decrypt(uint64_t *ks)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes128_ecb_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_ecb_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_ecb_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes128_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes128_cfb128_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes192_cfb128_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_aes256_cfb128_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t * asm_out, size_t amount_to_encrypt, uint64_t *iv)
+{ return; }
+
+#else	/* lint || __lint */
+
+#include<sys/asm_linkage.h>
+
+
+	ENTRY(t4_aes_expand128)
+
+!load key
+	ld	[%o1], %f0
+	ld	[%o1 + 0x4], %f1
+	ld	[%o1 + 0x8], %f2
+	ld	[%o1 + 0xc], %f3
+
+!expand the key
+	!aes_kexpand1 %f0, %f2, 0x0, %f4
+	!aes_kexpand2 %f2, %f4, %f6
+	!aes_kexpand1 %f4, %f6, 0x1, %f8
+	!aes_kexpand2 %f6, %f8, %f10
+	!aes_kexpand1 %f8, %f10, 0x2, %f12
+	!aes_kexpand2 %f10, %f12, %f14
+	!aes_kexpand1 %f12, %f14, 0x3, %f16
+	!aes_kexpand2 %f14, %f16, %f18
+	!aes_kexpand1 %f16, %f18, 0x4, %f20
+	!aes_kexpand2 %f18, %f20, %f22
+	!aes_kexpand1 %f20, %f22, 0x5, %f24
+	!aes_kexpand2 %f22, %f24, %f26
+	!aes_kexpand1 %f24, %f26, 0x6, %f28
+	!aes_kexpand2 %f26, %f28, %f30
+	!aes_kexpand1 %f28, %f30, 0x7, %f32
+	!aes_kexpand2 %f30, %f32, %f34
+	!aes_kexpand1 %f32, %f34, 0x8, %f36
+	!aes_kexpand2 %f34, %f36, %f38
+	!aes_kexpand1 %f36, %f38, 0x9, %f40
+	!aes_kexpand2 %f38, %f40, %f42
+	.byte	0x88, 0xc8, 0x01, 0x02
+	.byte	0x8d, 0xb0, 0xa6, 0x24
+	.byte	0x90, 0xc9, 0x03, 0x06
+	.byte	0x95, 0xb1, 0xa6, 0x28
+	.byte	0x98, 0xca, 0x05, 0x0a
+	.byte	0x9d, 0xb2, 0xa6, 0x2c
+	.byte	0xa0, 0xcb, 0x07, 0x0e
+	.byte	0xa5, 0xb3, 0xa6, 0x30
+	.byte	0xa8, 0xcc, 0x09, 0x12
+	.byte	0xad, 0xb4, 0xa6, 0x34
+	.byte	0xb0, 0xcd, 0x0b, 0x16
+	.byte	0xb5, 0xb5, 0xa6, 0x38
+	.byte	0xb8, 0xce, 0x0d, 0x1a
+	.byte	0xbd, 0xb6, 0xa6, 0x3c
+	.byte	0x82, 0xcf, 0x0f, 0x1e
+	.byte	0x87, 0xb7, 0xa6, 0x21
+	.byte	0x8a, 0xc8, 0x51, 0x03
+	.byte	0x8f, 0xb0, 0xe6, 0x25
+	.byte	0x92, 0xc9, 0x53, 0x07
+	.byte	0x97, 0xb1, 0xe6, 0x29
+
+!copy expanded key back into array
+	std	%f4, [%o0]
+	std	%f6, [%o0 + 0x8]
+	std	%f8, [%o0 + 0x10]
+	std	%f10, [%o0 + 0x18]
+	std	%f12, [%o0 + 0x20]
+	std	%f14, [%o0 + 0x28]
+	std	%f16, [%o0 + 0x30]
+	std	%f18, [%o0 + 0x38]
+	std	%f20, [%o0 + 0x40]
+	std	%f22, [%o0 + 0x48]
+	std	%f24, [%o0 + 0x50]
+	std	%f26, [%o0 + 0x58]
+	std	%f28, [%o0 + 0x60]
+	std	%f30, [%o0 + 0x68]
+	std	%f32, [%o0 + 0x70]
+	std	%f34, [%o0 + 0x78]
+	std	%f36, [%o0 + 0x80]
+	std	%f38, [%o0 + 0x88]
+	std	%f40, [%o0 + 0x90]
+	retl
+	std	%f42, [%o0 + 0x98]
+
+	SET_SIZE(t4_aes_expand128)
+
+
+	ENTRY(t4_aes_expand192)
+
+!load key
+	ld	[%o1], %f0
+	ld	[%o1 + 0x4], %f1
+	ld	[%o1 + 0x8], %f2
+	ld	[%o1 + 0xc], %f3
+	ld	[%o1 + 0x10], %f4
+	ld	[%o1 + 0x14], %f5
+
+!expand the key
+	!aes_kexpand1 %f0, %f4, 0x0, %f6
+	!aes_kexpand2 %f2, %f6, %f8
+	!aes_kexpand2 %f4, %f8, %f10
+
+	!aes_kexpand1 %f6, %f10, 0x1, %f12
+	!aes_kexpand2 %f8, %f12, %f14
+	!aes_kexpand2 %f10, %f14, %f16
+
+	!aes_kexpand1 %f12, %f16, 0x2, %f18
+	!aes_kexpand2 %f14, %f18, %f20
+	!aes_kexpand2 %f16, %f20, %f22
+
+	!aes_kexpand1 %f18, %f22, 0x3, %f24
+	!aes_kexpand2 %f20, %f24, %f26
+	!aes_kexpand2 %f22, %f26, %f28
+
+	!aes_kexpand1 %f24, %f28, 0x4, %f30
+	!aes_kexpand2 %f26, %f30, %f32
+	!aes_kexpand2 %f28, %f32, %f34
+
+	!aes_kexpand1 %f30, %f34, 0x5, %f36
+	!aes_kexpand2 %f32, %f36, %f38
+	!aes_kexpand2 %f34, %f38, %f40
+
+	!aes_kexpand1 %f36, %f40, 0x6, %f42
+	!aes_kexpand2 %f38, %f42, %f44
+	!aes_kexpand2 %f40, %f44, %f46
+
+	!aes_kexpand1 %f42, %f46, 0x7, %f48
+	!aes_kexpand2 %f44, %f48, %f50
+	.byte	0x8c, 0xc8, 0x01, 0x04
+	.byte	0x91, 0xb0, 0xa6, 0x26
+	.byte	0x95, 0xb1, 0x26, 0x28
+	.byte	0x98, 0xc9, 0x83, 0x0a
+	.byte	0x9d, 0xb2, 0x26, 0x2c
+	.byte	0xa1, 0xb2, 0xa6, 0x2e
+	.byte	0xa4, 0xcb, 0x05, 0x10
+	.byte	0xa9, 0xb3, 0xa6, 0x32
+	.byte	0xad, 0xb4, 0x26, 0x34
+	.byte	0xb0, 0xcc, 0x87, 0x16
+	.byte	0xb5, 0xb5, 0x26, 0x38
+	.byte	0xb9, 0xb5, 0xa6, 0x3a
+	.byte	0xbc, 0xce, 0x09, 0x1c
+	.byte	0x83, 0xb6, 0xa6, 0x3e
+	.byte	0x87, 0xb7, 0x26, 0x21
+	.byte	0x8a, 0xcf, 0x8b, 0x03
+	.byte	0x8f, 0xb0, 0x66, 0x25
+	.byte	0x93, 0xb0, 0xe6, 0x27
+	.byte	0x96, 0xc9, 0x4d, 0x09
+	.byte	0x9b, 0xb1, 0xe6, 0x2b
+	.byte	0x9f, 0xb2, 0x66, 0x2d
+	.byte	0xa2, 0xca, 0xcf, 0x0f
+	.byte	0xa7, 0xb3, 0x66, 0x31
+
+!copy expanded key back into array
+	std	%f6, [%o0]
+	std	%f8, [%o0 + 0x8]
+	std	%f10, [%o0 + 0x10]
+	std	%f12, [%o0 + 0x18]
+	std	%f14, [%o0 + 0x20]
+	std	%f16, [%o0 + 0x28]
+	std	%f18, [%o0 + 0x30]
+	std	%f20, [%o0 + 0x38]
+	std	%f22, [%o0 + 0x40]
+	std	%f24, [%o0 + 0x48]
+	std	%f26, [%o0 + 0x50]
+	std	%f28, [%o0 + 0x58]
+	std	%f30, [%o0 + 0x60]
+	std	%f32, [%o0 + 0x68]
+	std	%f34, [%o0 + 0x70]
+	std	%f36, [%o0 + 0x78]
+	std	%f38, [%o0 + 0x80]
+	std	%f40, [%o0 + 0x88]
+	std	%f42, [%o0 + 0x90]
+	std	%f44, [%o0 + 0x98]
+	std	%f46, [%o0 + 0xa0]
+	std	%f48, [%o0 + 0xa8]
+	retl
+	std	%f50, [%o0 + 0xb0]
+
+	SET_SIZE(t4_aes_expand192)
+
+
+	ENTRY(t4_aes_expand256)
+
+!load key
+	ld	[%o1], %f0
+	ld	[%o1 + 0x4], %f1
+	ld	[%o1 + 0x8], %f2
+	ld	[%o1 + 0xc], %f3
+	ld	[%o1 + 0x10], %f4
+	ld	[%o1 + 0x14], %f5
+	ld	[%o1 + 0x18], %f6
+	ld	[%o1 + 0x1c], %f7
+
+!expand the key
+	!aes_kexpand1 %f0, %f6, 0x0, %f8
+	!aes_kexpand2 %f2, %f8, %f10
+	!aes_kexpand0 %f4, %f10, %f12
+	!aes_kexpand2 %f6, %f12, %f14
+
+	!aes_kexpand1 %f8, %f14, 0x1, %f16
+	!aes_kexpand2 %f10, %f16, %f18
+	!aes_kexpand0 %f12, %f18, %f20
+	!aes_kexpand2 %f14, %f20, %f22
+
+	!aes_kexpand1 %f16, %f22, 0x2, %f24
+	!aes_kexpand2 %f18, %f24, %f26
+	!aes_kexpand0 %f20, %f26, %f28
+	!aes_kexpand2 %f22, %f28, %f30
+
+	!aes_kexpand1 %f24, %f30, 0x3, %f32
+	!aes_kexpand2 %f26, %f32, %f34
+	!aes_kexpand0 %f28, %f34, %f36
+	!aes_kexpand2 %f30, %f36, %f38
+
+	!aes_kexpand1 %f32, %f38, 0x4, %f40
+	!aes_kexpand2 %f34, %f40, %f42
+	!aes_kexpand0 %f36, %f42, %f44
+	!aes_kexpand2 %f38, %f44, %f46
+
+	!aes_kexpand1 %f40, %f46, 0x5, %f48
+	!aes_kexpand2 %f42, %f48, %f50
+	!aes_kexpand0 %f44, %f50, %f52
+	!aes_kexpand2 %f46, %f52, %f54
+
+	!aes_kexpand1 %f48, %f54, 0x6, %f56
+	!aes_kexpand2 %f50, %f56, %f58
+	.byte	0x90, 0xc8, 0x01, 0x06
+	.byte	0x95, 0xb0, 0xa6, 0x28
+	.byte	0x99, 0xb1, 0x26, 0x0a
+	.byte	0x9d, 0xb1, 0xa6, 0x2c
+	.byte	0xa0, 0xca, 0x03, 0x0e
+	.byte	0xa5, 0xb2, 0xa6, 0x30
+	.byte	0xa9, 0xb3, 0x26, 0x12
+	.byte	0xad, 0xb3, 0xa6, 0x34
+	.byte	0xb0, 0xcc, 0x05, 0x16
+	.byte	0xb5, 0xb4, 0xa6, 0x38
+	.byte	0xb9, 0xb5, 0x26, 0x1a
+	.byte	0xbd, 0xb5, 0xa6, 0x3c
+	.byte	0x82, 0xce, 0x07, 0x1e
+	.byte	0x87, 0xb6, 0xa6, 0x21
+	.byte	0x8b, 0xb7, 0x26, 0x03
+	.byte	0x8f, 0xb7, 0xa6, 0x25
+	.byte	0x92, 0xc8, 0x49, 0x07
+	.byte	0x97, 0xb0, 0xe6, 0x29
+	.byte	0x9b, 0xb1, 0x66, 0x0b
+	.byte	0x9f, 0xb1, 0xe6, 0x2d
+	.byte	0xa2, 0xca, 0x4b, 0x0f
+	.byte	0xa7, 0xb2, 0xe6, 0x31
+	.byte	0xab, 0xb3, 0x66, 0x13
+	.byte	0xaf, 0xb3, 0xe6, 0x35
+	.byte	0xb2, 0xcc, 0x4d, 0x17
+	.byte	0xb7, 0xb4, 0xe6, 0x39
+
+!copy expanded key back into array
+	std	%f8, [%o0]
+	std	%f10, [%o0 + 0x8]
+	std	%f12, [%o0 + 0x10]
+	std	%f14, [%o0 + 0x18]
+	std	%f16, [%o0 + 0x20]
+	std	%f18, [%o0 + 0x28]
+	std	%f20, [%o0 + 0x30]
+	std	%f22, [%o0 + 0x38]
+	std	%f24, [%o0 + 0x40]
+	std	%f26, [%o0 + 0x48]
+	std	%f28, [%o0 + 0x50]
+	std	%f30, [%o0 + 0x58]
+	std	%f32, [%o0 + 0x60]
+	std	%f34, [%o0 + 0x68]
+	std	%f36, [%o0 + 0x70]
+	std	%f38, [%o0 + 0x78]
+	std	%f40, [%o0 + 0x80]
+	std	%f42, [%o0 + 0x88]
+	std	%f44, [%o0 + 0x90]
+	std	%f46, [%o0 + 0x98]
+	std	%f48, [%o0 + 0xa0]
+	std	%f50, [%o0 + 0xa8]
+	std	%f52, [%o0 + 0xb0]
+	std	%f54, [%o0 + 0xb8]
+	std	%f56, [%o0 + 0xc0]
+	retl
+	std	%f58, [%o0 + 0xc8]
+
+	SET_SIZE(t4_aes_expand256)
+
+
+#define	FIRST_TWO_EROUNDS \
+	.byte	0xb2, 0xc8, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xc8, 0xbe, 0x3d ; \
+	.byte	0xba, 0xc9, 0x36, 0x19 ; \
+	.byte	0xbe, 0xc9, 0xb6, 0x39
+	!aes_eround01	%f0, %f60, %f62, %f56 ; \
+	!aes_eround23	%f2, %f60, %f62, %f58 ; \
+	!aes_eround01	%f4, %f56, %f58, %f60 ; \
+	!aes_eround23	%f6, %f56, %f58, %f62
+
+#define	MID_TWO_EROUNDS \
+	.byte	0xb2, 0xca, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xca, 0xbe, 0x3d ; \
+	.byte	0xba, 0xcb, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcb, 0xb6, 0x39
+	!aes_eround01	%f8, %f60, %f62, %f56 ; \
+	!aes_eround23	%f10, %f60, %f62, %f58 ; \
+	!aes_eround01	%f12, %f56, %f58, %f60 ; \
+	!aes_eround23	%f14, %f56, %f58, %f62
+
+#define	MID_TWO_EROUNDS_2 \
+	.byte	0x8c, 0xca, 0x04, 0x00 ; \
+	.byte	0x88, 0xca, 0x84, 0x20 ; \
+	.byte	0xb2, 0xca, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xca, 0xbe, 0x3d ; \
+	.byte	0x80, 0xcb, 0x08, 0x06 ; \
+	.byte	0x84, 0xcb, 0x88, 0x26 ; \
+	.byte	0xba, 0xcb, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcb, 0xb6, 0x39
+	!aes_eround01	%f8, %f0, %f2, %f6 ; \
+	!aes_eround23	%f10, %f0, %f2, %f4 ; \
+	!aes_eround01	%f8, %f60, %f62, %f56 ; \
+	!aes_eround23	%f10, %f60, %f62, %f58 ; \
+	!aes_eround01	%f12, %f6, %f4, %f0 ; \
+	!aes_eround23	%f14, %f6, %f4, %f2 ; \
+	!aes_eround01	%f12, %f56, %f58, %f60 ; \
+	!aes_eround23	%f14, %f56, %f58, %f62
+
+#define	TEN_EROUNDS \
+	.byte	0xb2, 0xcc, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xcc, 0xbe, 0x3d ; \
+	.byte	0xba, 0xcd, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcd, 0xb6, 0x39 ; \
+	.byte	0xb2, 0xce, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xce, 0xbe, 0x3d ; \
+	.byte	0xba, 0xcf, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcf, 0xb6, 0x39 ; \
+	.byte	0xb2, 0xc8, 0x7e, 0x1d ; \
+	.byte	0xb6, 0xc8, 0xfe, 0x3d ; \
+	.byte	0xba, 0xc9, 0x76, 0x19 ; \
+	.byte	0xbe, 0xc9, 0xf6, 0x39 ; \
+	.byte	0xb2, 0xca, 0x7e, 0x1d ; \
+	.byte	0xb6, 0xca, 0xfe, 0x3d ; \
+	.byte	0xba, 0xcb, 0x76, 0x19 ; \
+	.byte	0xbe, 0xcb, 0xf6, 0x39 ; \
+	.byte	0xb2, 0xcc, 0x7e, 0x1d ; \
+	.byte	0xb6, 0xcc, 0xfe, 0x3d ; \
+	.byte	0xba, 0xcd, 0x76, 0x99 ; \
+	.byte	0xbe, 0xcd, 0xf6, 0xb9
+	!aes_eround01	%f16, %f60, %f62, %f56 ; \
+	!aes_eround23	%f18, %f60, %f62, %f58 ; \
+	!aes_eround01	%f20, %f56, %f58, %f60 ; \
+	!aes_eround23	%f22, %f56, %f58, %f62 ; \
+	!aes_eround01	%f24, %f60, %f62, %f56 ; \
+	!aes_eround23	%f26, %f60, %f62, %f58 ; \
+	!aes_eround01	%f28, %f56, %f58, %f60 ; \
+	!aes_eround23	%f30, %f56, %f58, %f62 ; \
+	!aes_eround01	%f32, %f60, %f62, %f56 ; \
+	!aes_eround23	%f34, %f60, %f62, %f58 ; \
+	!aes_eround01	%f36, %f56, %f58, %f60 ; \
+	!aes_eround23	%f38, %f56, %f58, %f62 ; \
+	!aes_eround01	%f40, %f60, %f62, %f56 ; \
+	!aes_eround23	%f42, %f60, %f62, %f58 ; \
+	!aes_eround01	%f44, %f56, %f58, %f60 ; \
+	!aes_eround23	%f46, %f56, %f58, %f62 ; \
+	!aes_eround01	%f48, %f60, %f62, %f56 ; \
+	!aes_eround23	%f50, %f60, %f62, %f58 ; \
+	!aes_eround01_l	%f52, %f56, %f58, %f60 ; \
+	!aes_eround23_l	%f54, %f56, %f58, %f62
+
+#define	TEN_EROUNDS_2 \
+	.byte	0x8c, 0xcc, 0x04, 0x00 ; \
+	.byte	0x88, 0xcc, 0x84, 0x20 ; \
+	.byte	0xb2, 0xcc, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xcc, 0xbe, 0x3d ; \
+	.byte	0x80, 0xcd, 0x08, 0x06 ; \
+	.byte	0x84, 0xcd, 0x88, 0x26 ; \
+	.byte	0xba, 0xcd, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcd, 0xb6, 0x39 ; \
+	.byte	0x8c, 0xce, 0x04, 0x00 ; \
+	.byte	0x88, 0xce, 0x84, 0x20 ; \
+	.byte	0xb2, 0xce, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xce, 0xbe, 0x3d ; \
+	.byte	0x80, 0xcf, 0x08, 0x06 ; \
+	.byte	0x84, 0xcf, 0x88, 0x26 ; \
+	.byte	0xba, 0xcf, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcf, 0xb6, 0x39 ; \
+	.byte	0x8c, 0xc8, 0x44, 0x00 ; \
+	.byte	0x88, 0xc8, 0xc4, 0x20 ; \
+	.byte	0xb2, 0xc8, 0x7e, 0x1d ; \
+	.byte	0xb6, 0xc8, 0xfe, 0x3d ; \
+	.byte	0x80, 0xc9, 0x48, 0x06 ; \
+	.byte	0x84, 0xc9, 0xc8, 0x26 ; \
+	.byte	0xba, 0xc9, 0x76, 0x19 ; \
+	.byte	0xbe, 0xc9, 0xf6, 0x39 ; \
+	.byte	0x8c, 0xca, 0x44, 0x00 ; \
+	.byte	0x88, 0xca, 0xc4, 0x20 ; \
+	.byte	0xb2, 0xca, 0x7e, 0x1d ; \
+	.byte	0xb6, 0xca, 0xfe, 0x3d ; \
+	.byte	0x80, 0xcb, 0x48, 0x06 ; \
+	.byte	0x84, 0xcb, 0xc8, 0x26 ; \
+	.byte	0xba, 0xcb, 0x76, 0x19 ; \
+	.byte	0xbe, 0xcb, 0xf6, 0x39 ; \
+	.byte	0x8c, 0xcc, 0x44, 0x00 ; \
+	.byte	0x88, 0xcc, 0xc4, 0x20 ; \
+	.byte	0xb2, 0xcc, 0x7e, 0x1d ; \
+	.byte	0xb6, 0xcc, 0xfe, 0x3d ; \
+	.byte	0x80, 0xcd, 0x48, 0x86 ; \
+	.byte	0x84, 0xcd, 0xc8, 0xa6 ; \
+	.byte	0xba, 0xcd, 0x76, 0x99 ; \
+	.byte	0xbe, 0xcd, 0xf6, 0xb9
+	!aes_eround01	%f16, %f0, %f2, %f6 ; \
+	!aes_eround23	%f18, %f0, %f2, %f4 ; \
+	!aes_eround01	%f16, %f60, %f62, %f56 ; \
+	!aes_eround23	%f18, %f60, %f62, %f58 ; \
+	!aes_eround01	%f20, %f6, %f4, %f0 ; \
+	!aes_eround23	%f22, %f6, %f4, %f2 ; \
+	!aes_eround01	%f20, %f56, %f58, %f60 ; \
+	!aes_eround23	%f22, %f56, %f58, %f62 ; \
+	!aes_eround01	%f24, %f0, %f2, %f6 ; \
+	!aes_eround23	%f26, %f0, %f2, %f4 ; \
+	!aes_eround01	%f24, %f60, %f62, %f56 ; \
+	!aes_eround23	%f26, %f60, %f62, %f58 ; \
+	!aes_eround01	%f28, %f6, %f4, %f0 ; \
+	!aes_eround23	%f30, %f6, %f4, %f2 ; \
+	!aes_eround01	%f28, %f56, %f58, %f60 ; \
+	!aes_eround23	%f30, %f56, %f58, %f62 ; \
+	!aes_eround01	%f32, %f0, %f2, %f6 ; \
+	!aes_eround23	%f34, %f0, %f2, %f4 ; \
+	!aes_eround01	%f32, %f60, %f62, %f56 ; \
+	!aes_eround23	%f34, %f60, %f62, %f58 ; \
+	!aes_eround01	%f36, %f6, %f4, %f0 ; \
+	!aes_eround23	%f38, %f6, %f4, %f2 ; \
+	!aes_eround01	%f36, %f56, %f58, %f60 ; \
+	!aes_eround23	%f38, %f56, %f58, %f62 ; \
+	!aes_eround01	%f40, %f0, %f2, %f6 ; \
+	!aes_eround23	%f42, %f0, %f2, %f4 ; \
+	!aes_eround01	%f40, %f60, %f62, %f56 ; \
+	!aes_eround23	%f42, %f60, %f62, %f58 ; \
+	!aes_eround01	%f44, %f6, %f4, %f0 ; \
+	!aes_eround23	%f46, %f6, %f4, %f2 ; \
+	!aes_eround01	%f44, %f56, %f58, %f60 ; \
+	!aes_eround23	%f46, %f56, %f58, %f62 ; \
+	!aes_eround01	%f48, %f0, %f2, %f6 ; \
+	!aes_eround23	%f50, %f0, %f2, %f4 ; \
+	!aes_eround01	%f48, %f60, %f62, %f56 ; \
+	!aes_eround23	%f50, %f60, %f62, %f58 ; \
+	!aes_eround01_l	%f52, %f6, %f4, %f0 ; \
+	!aes_eround23_l	%f54, %f6, %f4, %f2 ; \
+	!aes_eround01_l	%f52, %f56, %f58, %f60 ; \
+	!aes_eround23_l	%f54, %f56, %f58, %f62
+
+#define	TWELVE_EROUNDS \
+	MID_TWO_EROUNDS	; \
+	TEN_EROUNDS
+
+#define	TWELVE_EROUNDS_2 \
+	MID_TWO_EROUNDS_2	; \
+	TEN_EROUNDS_2
+
+#define	FOURTEEN_EROUNDS \
+	FIRST_TWO_EROUNDS ; \
+	TWELVE_EROUNDS
+
+#define	FOURTEEN_EROUNDS_2 \
+	.byte	0xb0, 0xc8, 0x2c, 0x14 ; \
+	.byte	0xac, 0xc8, 0xac, 0x34 ; \
+	ldd	[%o0 + 0x60], %f20 ; \
+	.byte	0xb2, 0xc8, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xc8, 0xbe, 0x3d ; \
+	.byte	0x80, 0xc9, 0x2c, 0x18 ; \
+	.byte	0x84, 0xc9, 0xac, 0x38 ;\
+	ldd	[%o0 + 0x68], %f22 ; \
+	.byte	0xba, 0xc9, 0x36, 0x19 ; \
+	ldd	[%o0 + 0x70], %f24 ; \
+	.byte	0xbe, 0xc9, 0xb6, 0x39 ; \
+	.byte	0x8c, 0xca, 0x04, 0x00 ; \
+	.byte	0x88, 0xca, 0x84, 0x20 ; \
+	.byte	0xb2, 0xca, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xca, 0xbe, 0x3d ; \
+	.byte	0x80, 0xcb, 0x08, 0x06 ; \
+	.byte	0x84, 0xcb, 0x88, 0x26 ; \
+	.byte	0xba, 0xcb, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcb, 0xb6, 0x39 ; \
+	.byte	0x8c, 0xcc, 0x04, 0x00 ; \
+	.byte	0x88, 0xcc, 0x84, 0x20 ; \
+	.byte	0xb2, 0xcc, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xcc, 0xbe, 0x3d ; \
+	.byte	0x80, 0xcd, 0x08, 0x06 ; \
+	.byte	0x84, 0xcd, 0x88, 0x26 ; \
+	.byte	0xba, 0xcd, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcd, 0xb6, 0x39 ; \
+	.byte	0x8c, 0xce, 0x04, 0x00 ; \
+	.byte	0x88, 0xce, 0x84, 0x20 ; \
+	.byte	0xb2, 0xce, 0x3e, 0x1d ; \
+	.byte	0xb6, 0xce, 0xbe, 0x3d ; \
+	.byte	0x80, 0xcf, 0x08, 0x06 ; \
+	.byte	0x84, 0xcf, 0x88, 0x26 ; \
+	.byte	0xba, 0xcf, 0x36, 0x19 ; \
+	.byte	0xbe, 0xcf, 0xb6, 0x39 ; \
+	.byte	0x8c, 0xc8, 0x44, 0x00 ; \
+	.byte	0x88, 0xc8, 0xc4, 0x20 ; \
+	.byte	0xb2, 0xc8, 0x7e, 0x1d ; \
+	.byte	0xb6, 0xc8, 0xfe, 0x3d ; \
+	.byte	0x80, 0xc9, 0x48, 0x06 ; \
+	.byte	0x84, 0xc9, 0xc8, 0x26 ; \
+	.byte	0xba, 0xc9, 0x76, 0x19 ; \
+	.byte	0xbe, 0xc9, 0xf6, 0x39 ; \
+	.byte	0x8c, 0xca, 0x44, 0x00 ; \
+	.byte	0x88, 0xca, 0xc4, 0x20 ; \
+	.byte	0xb2, 0xca, 0x7e, 0x1d ; \
+	.byte	0xb6, 0xca, 0xfe, 0x3d ; \
+	.byte	0x80, 0xcb, 0x48, 0x06 ; \
+	.byte	0x84, 0xcb, 0xc8, 0x26 ; \
+	.byte	0xba, 0xcb, 0x76, 0x19 ; \
+	.byte	0xbe, 0xcb, 0xf6, 0x39 ; \
+	.byte	0x8c, 0xcc, 0x44, 0x00 ; \
+	.byte	0x88, 0xcc, 0xc4, 0x20 ; \
+	ldd	[%o0 + 0x10], %f0 ; \
+	.byte	0xb2, 0xcc, 0x7e, 0x1d ; \
+	ldd	[%o0 + 0x18], %f2 ; \
+	.byte	0xb6, 0xcc, 0xfe, 0x3d ; \
+	.byte	0xa8, 0xcd, 0x48, 0x86 ; \
+	.byte	0xac, 0xcd, 0xc8, 0xa6 ; \
+	ldd	[%o0 + 0x20], %f4 ; \
+	.byte	0xba, 0xcd, 0x76, 0x99 ; \
+	ldd	[%o0 + 0x28], %f6 ; \
+	.byte	0xbe, 0xcd, 0xf6, 0xb9
+	!aes_eround01	%f0, %f20, %f22, %f24 ; \
+	!aes_eround23	%f2, %f20, %f22, %f22 ; \
+	!ldd	[%o0 + 0x60], %f20 ; \
+	!aes_eround01	%f0, %f60, %f62, %f56 ; \
+	!aes_eround23	%f2, %f60, %f62, %f58 ; \
+	!aes_eround01	%f4, %f24, %f22, %f0 ; \
+	!aes_eround23	%f6, %f24, %f22, %f2 ; \
+	!ldd	[%o0 + 0x68], %f22 ; \
+	!aes_eround01	%f4, %f56, %f58, %f60 ; \
+	!ldd	[%o0 + 0x70], %f24 ; \
+	!aes_eround23	%f6, %f56, %f58, %f62 ; \
+	!aes_eround01	%f8, %f0, %f2, %f6 ; \
+	!aes_eround23	%f10, %f0, %f2, %f4 ; \
+	!aes_eround01	%f8, %f60, %f62, %f56 ; \
+	!aes_eround23	%f10, %f60, %f62, %f58 ; \
+	!aes_eround01	%f12, %f6, %f4, %f0 ; \
+	!aes_eround23	%f14, %f6, %f4, %f2 ; \
+	!aes_eround01	%f12, %f56, %f58, %f60 ; \
+	!aes_eround23	%f14, %f56, %f58, %f62 ; \
+	!aes_eround01	%f16, %f0, %f2, %f6 ; \
+	!aes_eround23	%f18, %f0, %f2, %f4 ; \
+	!aes_eround01	%f16, %f60, %f62, %f56 ; \
+	!aes_eround23	%f18, %f60, %f62, %f58 ; \
+	!aes_eround01	%f20, %f6, %f4, %f0 ; \
+	!aes_eround23	%f22, %f6, %f4, %f2 ; \
+	!aes_eround01	%f20, %f56, %f58, %f60 ; \
+	!aes_eround23	%f22, %f56, %f58, %f62 ; \
+	!aes_eround01	%f24, %f0, %f2, %f6 ; \
+	!aes_eround23	%f26, %f0, %f2, %f4 ; \
+	!aes_eround01	%f24, %f60, %f62, %f56 ; \
+	!aes_eround23	%f26, %f60, %f62, %f58 ; \
+	!aes_eround01	%f28, %f6, %f4, %f0 ; \
+	!aes_eround23	%f30, %f6, %f4, %f2 ; \
+	!aes_eround01	%f28, %f56, %f58, %f60 ; \
+	!aes_eround23	%f30, %f56, %f58, %f62 ; \
+	!aes_eround01	%f32, %f0, %f2, %f6 ; \
+	!aes_eround23	%f34, %f0, %f2, %f4 ; \
+	!aes_eround01	%f32, %f60, %f62, %f56 ; \
+	!aes_eround23	%f34, %f60, %f62, %f58 ; \
+	!aes_eround01	%f36, %f6, %f4, %f0 ; \
+	!aes_eround23	%f38, %f6, %f4, %f2 ; \
+	!aes_eround01	%f36, %f56, %f58, %f60 ; \
+	!aes_eround23	%f38, %f56, %f58, %f62 ; \
+	!aes_eround01	%f40, %f0, %f2, %f6 ; \
+	!aes_eround23	%f42, %f0, %f2, %f4 ; \
+	!aes_eround01	%f40, %f60, %f62, %f56 ; \
+	!aes_eround23	%f42, %f60, %f62, %f58 ; \
+	!aes_eround01	%f44, %f6, %f4, %f0 ; \
+	!aes_eround23	%f46, %f6, %f4, %f2 ; \
+	!aes_eround01	%f44, %f56, %f58, %f60 ; \
+	!aes_eround23	%f46, %f56, %f58, %f62 ; \
+	!aes_eround01	%f48, %f0, %f2, %f6 ; \
+	!aes_eround23	%f50, %f0, %f2, %f4 ; \
+	!ldd	[%o0 + 0x10], %f0 ; \
+	!aes_eround01	%f48, %f60, %f62, %f56 ; \
+	!ldd	[%o0 + 0x18], %f2 ; \
+	!aes_eround23	%f50, %f60, %f62, %f58 ; \
+	!aes_eround01_l	%f52, %f6, %f4, %f20 ; \
+	!aes_eround23_l	%f54, %f6, %f4, %f22 ; \
+	!ldd	[%o0 + 0x20], %f4 ; \
+	!aes_eround01_l	%f52, %f56, %f58, %f60 ; \
+	!ldd	[%o0 + 0x28], %f6 ; \
+	!aes_eround23_l	%f54, %f56, %f58, %f62
+
+#define	FIRST_TWO_DROUNDS \
+	.byte	0xb2, 0xc8, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xc8, 0xbe, 0x7d ; \
+	.byte	0xba, 0xc9, 0x36, 0x59 ; \
+	.byte	0xbe, 0xc9, 0xb6, 0x79
+	!aes_dround01	%f0, %f60, %f62, %f56 ; \
+	!aes_dround23	%f2, %f60, %f62, %f58 ; \
+	!aes_dround01	%f4, %f56, %f58, %f60 ; \
+	!aes_dround23	%f6, %f56, %f58, %f62
+
+#define	MID_TWO_DROUNDS \
+	.byte	0xb2, 0xca, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xca, 0xbe, 0x7d ; \
+	.byte	0xba, 0xcb, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcb, 0xb6, 0x79
+	!aes_dround01	%f8, %f60, %f62, %f56 ; \
+	!aes_dround23	%f10, %f60, %f62, %f58 ; \
+	!aes_dround01	%f12, %f56, %f58, %f60 ; \
+	!aes_dround23	%f14, %f56, %f58, %f62
+
+#define	MID_TWO_DROUNDS_2 \
+	.byte	0x8c, 0xca, 0x04, 0x40 ; \
+	.byte	0x88, 0xca, 0x84, 0x60 ; \
+	.byte	0xb2, 0xca, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xca, 0xbe, 0x7d ; \
+	.byte	0x80, 0xcb, 0x08, 0x46 ; \
+	.byte	0x84, 0xcb, 0x88, 0x66 ; \
+	.byte	0xba, 0xcb, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcb, 0xb6, 0x79
+	!aes_dround01	%f8, %f0, %f2, %f6 ; \
+	!aes_dround23	%f10, %f0, %f2, %f4 ; \
+	!aes_dround01	%f8, %f60, %f62, %f56 ; \
+	!aes_dround23	%f10, %f60, %f62, %f58 ; \
+	!aes_dround01	%f12, %f6, %f4, %f0 ; \
+	!aes_dround23	%f14, %f6, %f4, %f2 ; \
+	!aes_dround01	%f12, %f56, %f58, %f60 ; \
+	!aes_dround23	%f14, %f56, %f58, %f62
+
+#define	TEN_DROUNDS \
+	.byte	0xb2, 0xcc, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xcc, 0xbe, 0x7d ; \
+	.byte	0xba, 0xcd, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcd, 0xb6, 0x79 ; \
+	.byte	0xb2, 0xce, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xce, 0xbe, 0x7d ; \
+	.byte	0xba, 0xcf, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcf, 0xb6, 0x79 ; \
+	.byte	0xb2, 0xc8, 0x7e, 0x5d ; \
+	.byte	0xb6, 0xc8, 0xfe, 0x7d ; \
+	.byte	0xba, 0xc9, 0x76, 0x59 ; \
+	.byte	0xbe, 0xc9, 0xf6, 0x79 ; \
+	.byte	0xb2, 0xca, 0x7e, 0x5d ; \
+	.byte	0xb6, 0xca, 0xfe, 0x7d ; \
+	.byte	0xba, 0xcb, 0x76, 0x59 ; \
+	.byte	0xbe, 0xcb, 0xf6, 0x79 ; \
+	.byte	0xb2, 0xcc, 0x7e, 0x5d ; \
+	.byte	0xb6, 0xcc, 0xfe, 0x7d ; \
+	.byte	0xba, 0xcd, 0x76, 0xd9 ; \
+	.byte	0xbe, 0xcd, 0xf6, 0xf9
+	!aes_dround01	%f16, %f60, %f62, %f56 ; \
+	!aes_dround23	%f18, %f60, %f62, %f58 ; \
+	!aes_dround01	%f20, %f56, %f58, %f60 ; \
+	!aes_dround23	%f22, %f56, %f58, %f62 ; \
+	!aes_dround01	%f24, %f60, %f62, %f56 ; \
+	!aes_dround23	%f26, %f60, %f62, %f58 ; \
+	!aes_dround01	%f28, %f56, %f58, %f60 ; \
+	!aes_dround23	%f30, %f56, %f58, %f62 ; \
+	!aes_dround01	%f32, %f60, %f62, %f56 ; \
+	!aes_dround23	%f34, %f60, %f62, %f58 ; \
+	!aes_dround01	%f36, %f56, %f58, %f60 ; \
+	!aes_dround23	%f38, %f56, %f58, %f62 ; \
+	!aes_dround01	%f40, %f60, %f62, %f56 ; \
+	!aes_dround23	%f42, %f60, %f62, %f58 ; \
+	!aes_dround01	%f44, %f56, %f58, %f60 ; \
+	!aes_dround23	%f46, %f56, %f58, %f62 ; \
+	!aes_dround01	%f48, %f60, %f62, %f56 ; \
+	!aes_dround23	%f50, %f60, %f62, %f58 ; \
+	!aes_dround01_l	%f52, %f56, %f58, %f60 ; \
+	!aes_dround23_l	%f54, %f56, %f58, %f62
+
+#define	TEN_DROUNDS_2 \
+	.byte	0x8c, 0xcc, 0x04, 0x40 ; \
+	.byte	0x88, 0xcc, 0x84, 0x60 ; \
+	.byte	0xb2, 0xcc, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xcc, 0xbe, 0x7d ; \
+	.byte	0x80, 0xcd, 0x08, 0x46 ; \
+	.byte	0x84, 0xcd, 0x88, 0x66 ; \
+	.byte	0xba, 0xcd, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcd, 0xb6, 0x79 ; \
+	.byte	0x8c, 0xce, 0x04, 0x40 ; \
+	.byte	0x88, 0xce, 0x84, 0x60 ; \
+	.byte	0xb2, 0xce, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xce, 0xbe, 0x7d ; \
+	.byte	0x80, 0xcf, 0x08, 0x46 ; \
+	.byte	0x84, 0xcf, 0x88, 0x66 ; \
+	.byte	0xba, 0xcf, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcf, 0xb6, 0x79 ; \
+	.byte	0x8c, 0xc8, 0x44, 0x40 ; \
+	.byte	0x88, 0xc8, 0xc4, 0x60 ; \
+	.byte	0xb2, 0xc8, 0x7e, 0x5d ; \
+	.byte	0xb6, 0xc8, 0xfe, 0x7d ; \
+	.byte	0x80, 0xc9, 0x48, 0x46 ; \
+	.byte	0x84, 0xc9, 0xc8, 0x66 ; \
+	.byte	0xba, 0xc9, 0x76, 0x59 ; \
+	.byte	0xbe, 0xc9, 0xf6, 0x79 ; \
+	.byte	0x8c, 0xca, 0x44, 0x40 ; \
+	.byte	0x88, 0xca, 0xc4, 0x60 ; \
+	.byte	0xb2, 0xca, 0x7e, 0x5d ; \
+	.byte	0xb6, 0xca, 0xfe, 0x7d ; \
+	.byte	0x80, 0xcb, 0x48, 0x46 ; \
+	.byte	0x84, 0xcb, 0xc8, 0x66 ; \
+	.byte	0xba, 0xcb, 0x76, 0x59 ; \
+	.byte	0xbe, 0xcb, 0xf6, 0x79 ; \
+	.byte	0x8c, 0xcc, 0x44, 0x40 ; \
+	.byte	0x88, 0xcc, 0xc4, 0x60 ; \
+	.byte	0xb2, 0xcc, 0x7e, 0x5d ; \
+	.byte	0xb6, 0xcc, 0xfe, 0x7d ; \
+	.byte	0x80, 0xcd, 0x48, 0xc6 ; \
+	.byte	0x84, 0xcd, 0xc8, 0xe6 ; \
+	.byte	0xba, 0xcd, 0x76, 0xd9 ; \
+	.byte	0xbe, 0xcd, 0xf6, 0xf9
+	!aes_dround01	%f16, %f0, %f2, %f6 ; \
+	!aes_dround23	%f18, %f0, %f2, %f4 ; \
+	!aes_dround01	%f16, %f60, %f62, %f56 ; \
+	!aes_dround23	%f18, %f60, %f62, %f58 ; \
+	!aes_dround01	%f20, %f6, %f4, %f0 ; \
+	!aes_dround23	%f22, %f6, %f4, %f2 ; \
+	!aes_dround01	%f20, %f56, %f58, %f60 ; \
+	!aes_dround23	%f22, %f56, %f58, %f62 ; \
+	!aes_dround01	%f24, %f0, %f2, %f6 ; \
+	!aes_dround23	%f26, %f0, %f2, %f4 ; \
+	!aes_dround01	%f24, %f60, %f62, %f56 ; \
+	!aes_dround23	%f26, %f60, %f62, %f58 ; \
+	!aes_dround01	%f28, %f6, %f4, %f0 ; \
+	!aes_dround23	%f30, %f6, %f4, %f2 ; \
+	!aes_dround01	%f28, %f56, %f58, %f60 ; \
+	!aes_dround23	%f30, %f56, %f58, %f62 ; \
+	!aes_dround01	%f32, %f0, %f2, %f6 ; \
+	!aes_dround23	%f34, %f0, %f2, %f4 ; \
+	!aes_dround01	%f32, %f60, %f62, %f56 ; \
+	!aes_dround23	%f34, %f60, %f62, %f58 ; \
+	!aes_dround01	%f36, %f6, %f4, %f0 ; \
+	!aes_dround23	%f38, %f6, %f4, %f2 ; \
+	!aes_dround01	%f36, %f56, %f58, %f60 ; \
+	!aes_dround23	%f38, %f56, %f58, %f62 ; \
+	!aes_dround01	%f40, %f0, %f2, %f6 ; \
+	!aes_dround23	%f42, %f0, %f2, %f4 ; \
+	!aes_dround01	%f40, %f60, %f62, %f56 ; \
+	!aes_dround23	%f42, %f60, %f62, %f58 ; \
+	!aes_dround01	%f44, %f6, %f4, %f0 ; \
+	!aes_dround23	%f46, %f6, %f4, %f2 ; \
+	!aes_dround01	%f44, %f56, %f58, %f60 ; \
+	!aes_dround23	%f46, %f56, %f58, %f62 ; \
+	!aes_dround01	%f48, %f0, %f2, %f6 ; \
+	!aes_dround23	%f50, %f0, %f2, %f4 ; \
+	!aes_dround01	%f48, %f60, %f62, %f56 ; \
+	!aes_dround23	%f50, %f60, %f62, %f58 ; \
+	!aes_dround01_l	%f52, %f6, %f4, %f0 ; \
+	!aes_dround23_l	%f54, %f6, %f4, %f2 ; \
+	!aes_dround01_l	%f52, %f56, %f58, %f60 ; \
+	!aes_dround23_l	%f54, %f56, %f58, %f62
+
+#define	TWELVE_DROUNDS \
+	MID_TWO_DROUNDS	; \
+	TEN_DROUNDS
+
+#define	TWELVE_DROUNDS_2 \
+	MID_TWO_DROUNDS_2	; \
+	TEN_DROUNDS_2
+
+#define	FOURTEEN_DROUNDS \
+	FIRST_TWO_DROUNDS ; \
+	TWELVE_DROUNDS
+
+#define	FOURTEEN_DROUNDS_2 \
+	.byte	0xb0, 0xc8, 0x2c, 0x54 ; \
+	.byte	0xac, 0xc8, 0xac, 0x74 ; \
+	ldd	[%o0 + 0x80], %f20 ; \
+	.byte	0xb2, 0xc8, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xc8, 0xbe, 0x7d ; \
+	.byte	0x80, 0xc9, 0x2c, 0x58 ; \
+	.byte	0x84, 0xc9, 0xac, 0x78 ; \
+	ldd	[%o0 + 0x88], %f22 ; \
+	.byte	0xba, 0xc9, 0x36, 0x59 ; \
+	ldd	[%o0 + 0x70], %f24 ; \
+	.byte	0xbe, 0xc9, 0xb6, 0x79 ; \
+	.byte	0x8c, 0xca, 0x04, 0x40 ; \
+	.byte	0x88, 0xca, 0x84, 0x60 ; \
+	.byte	0xb2, 0xca, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xca, 0xbe, 0x7d ; \
+	.byte	0x80, 0xcb, 0x08, 0x46 ; \
+	.byte	0x84, 0xcb, 0x88, 0x66 ; \
+	.byte	0xba, 0xcb, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcb, 0xb6, 0x79 ; \
+	.byte	0x8c, 0xcc, 0x04, 0x40 ; \
+	.byte	0x88, 0xcc, 0x84, 0x60 ; \
+	.byte	0xb2, 0xcc, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xcc, 0xbe, 0x7d ; \
+	.byte	0x80, 0xcd, 0x08, 0x46 ; \
+	.byte	0x84, 0xcd, 0x88, 0x66 ; \
+	.byte	0xba, 0xcd, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcd, 0xb6, 0x79 ; \
+	.byte	0x8c, 0xce, 0x04, 0x40 ; \
+	.byte	0x88, 0xce, 0x84, 0x60 ; \
+	.byte	0xb2, 0xce, 0x3e, 0x5d ; \
+	.byte	0xb6, 0xce, 0xbe, 0x7d ; \
+	.byte	0x80, 0xcf, 0x08, 0x46 ; \
+	.byte	0x84, 0xcf, 0x88, 0x66 ; \
+	.byte	0xba, 0xcf, 0x36, 0x59 ; \
+	.byte	0xbe, 0xcf, 0xb6, 0x79 ; \
+	.byte	0x8c, 0xc8, 0x44, 0x40 ; \
+	.byte	0x88, 0xc8, 0xc4, 0x60 ; \
+	.byte	0xb2, 0xc8, 0x7e, 0x5d ; \
+	.byte	0xb6, 0xc8, 0xfe, 0x7d ; \
+	.byte	0x80, 0xc9, 0x48, 0x46 ; \
+	.byte	0x84, 0xc9, 0xc8, 0x66 ; \
+	.byte	0xba, 0xc9, 0x76, 0x59 ; \
+	.byte	0xbe, 0xc9, 0xf6, 0x79 ; \
+	.byte	0x8c, 0xca, 0x44, 0x40 ; \
+	.byte	0x88, 0xca, 0xc4, 0x60 ; \
+	.byte	0xb2, 0xca, 0x7e, 0x5d ; \
+	.byte	0xb6, 0xca, 0xfe, 0x7d ; \
+	.byte	0x80, 0xcb, 0x48, 0x46 ; \
+	.byte	0x84, 0xcb, 0xc8, 0x66 ; \
+	.byte	0xba, 0xcb, 0x76, 0x59 ; \
+	.byte	0xbe, 0xcb, 0xf6, 0x79 ; \
+	.byte	0x8c, 0xcc, 0x44, 0x40 ; \
+	.byte	0x88, 0xcc, 0xc4, 0x60 ; \
+	ldd	[%o0 + 0xd0], %f0 ; \
+	.byte	0xb2, 0xcc, 0x7e, 0x5d ; \
+	ldd	[%o0 + 0xd8], %f2 ; \
+	.byte	0xb6, 0xcc, 0xfe, 0x7d ; \
+	.byte	0xa8, 0xcd, 0x48, 0xc6 ; \
+	.byte	0xac, 0xcd, 0xc8, 0xe6 ; \
+	ldd	[%o0 + 0xc0], %f4 ; \
+	.byte	0xba, 0xcd, 0x76, 0xd9 ; \
+	ldd	[%o0 + 0xc8], %f6 ; \
+	.byte	0xbe, 0xcd, 0xf6, 0xf9
+	!aes_dround01	%f0, %f20, %f22, %f24 ; \
+	!aes_dround23	%f2, %f20, %f22, %f22 ; \
+	!ldd	[%o0 + 0x80], %f20 ; \
+	!aes_dround01	%f0, %f60, %f62, %f56 ; \
+	!aes_dround23	%f2, %f60, %f62, %f58 ; \
+	!aes_dround01	%f4, %f24, %f22, %f0 ; \
+	!aes_dround23	%f6, %f24, %f22, %f2 ; \
+	!ldd	[%o0 + 0x88], %f22 ; \
+	!aes_dround01	%f4, %f56, %f58, %f60 ; \
+	!ldd	[%o0 + 0x70], %f24 ; \
+	!aes_dround23	%f6, %f56, %f58, %f62 ; \
+	!aes_dround01	%f8, %f0, %f2, %f6 ; \
+	!aes_dround23	%f10, %f0, %f2, %f4 ; \
+	!aes_dround01	%f8, %f60, %f62, %f56 ; \
+	!aes_dround23	%f10, %f60, %f62, %f58 ; \
+	!aes_dround01	%f12, %f6, %f4, %f0 ; \
+	!aes_dround23	%f14, %f6, %f4, %f2 ; \
+	!aes_dround01	%f12, %f56, %f58, %f60 ; \
+	!aes_dround23	%f14, %f56, %f58, %f62 ; \
+	!aes_dround01	%f16, %f0, %f2, %f6 ; \
+	!aes_dround23	%f18, %f0, %f2, %f4 ; \
+	!aes_dround01	%f16, %f60, %f62, %f56 ; \
+	!aes_dround23	%f18, %f60, %f62, %f58 ; \
+	!aes_dround01	%f20, %f6, %f4, %f0 ; \
+	!aes_dround23	%f22, %f6, %f4, %f2 ; \
+	!aes_dround01	%f20, %f56, %f58, %f60 ; \
+	!aes_dround23	%f22, %f56, %f58, %f62 ; \
+	!aes_dround01	%f24, %f0, %f2, %f6 ; \
+	!aes_dround23	%f26, %f0, %f2, %f4 ; \
+	!aes_dround01	%f24, %f60, %f62, %f56 ; \
+	!aes_dround23	%f26, %f60, %f62, %f58 ; \
+	!aes_dround01	%f28, %f6, %f4, %f0 ; \
+	!aes_dround23	%f30, %f6, %f4, %f2 ; \
+	!aes_dround01	%f28, %f56, %f58, %f60 ; \
+	!aes_dround23	%f30, %f56, %f58, %f62 ; \
+	!aes_dround01	%f32, %f0, %f2, %f6 ; \
+	!aes_dround23	%f34, %f0, %f2, %f4 ; \
+	!aes_dround01	%f32, %f60, %f62, %f56 ; \
+	!aes_dround23	%f34, %f60, %f62, %f58 ; \
+	!aes_dround01	%f36, %f6, %f4, %f0 ; \
+	!aes_dround23	%f38, %f6, %f4, %f2 ; \
+	!aes_dround01	%f36, %f56, %f58, %f60 ; \
+	!aes_dround23	%f38, %f56, %f58, %f62 ; \
+	!aes_dround01	%f40, %f0, %f2, %f6 ; \
+	!aes_dround23	%f42, %f0, %f2, %f4 ; \
+	!aes_dround01	%f40, %f60, %f62, %f56 ; \
+	!aes_dround23	%f42, %f60, %f62, %f58 ; \
+	!aes_dround01	%f44, %f6, %f4, %f0 ; \
+	!aes_dround23	%f46, %f6, %f4, %f2 ; \
+	!aes_dround01	%f44, %f56, %f58, %f60 ; \
+	!aes_dround23	%f46, %f56, %f58, %f62 ; \
+	!aes_dround01	%f48, %f0, %f2, %f6 ; \
+	!aes_dround23	%f50, %f0, %f2, %f4 ; \
+	!ldd	[%o0 + 0xd0], %f0 ; \
+	!aes_dround01	%f48, %f60, %f62, %f56 ; \
+	!ldd	[%o0 + 0xd8], %f2 ; \
+	!aes_dround23	%f50, %f60, %f62, %f58 ; \
+	!aes_dround01_l	%f52, %f6, %f4, %f20 ; \
+	!aes_dround23_l	%f54, %f6, %f4, %f22 ; \
+	!ldd	[%o0 + 0xc0], %f4 ; \
+	!aes_dround01_l	%f52, %f56, %f58, %f60 ; \
+	!ldd	[%o0 + 0xc8], %f6 ; \
+	!aes_dround23_l	%f54, %f56, %f58, %f62
+
+
+	ENTRY(t4_aes128_load_keys_for_encrypt)
+
+	ldd	[%o0 + 0x10], %f16
+	ldd	[%o0 + 0x18], %f18
+	ldd	[%o0 + 0x20], %f20
+	ldd	[%o0 + 0x28], %f22
+	ldd	[%o0 + 0x30], %f24
+	ldd	[%o0 + 0x38], %f26
+	ldd	[%o0 + 0x40], %f28
+	ldd	[%o0 + 0x48], %f30
+	ldd	[%o0 + 0x50], %f32
+	ldd	[%o0 + 0x58], %f34
+	ldd	[%o0 + 0x60], %f36
+	ldd	[%o0 + 0x68], %f38
+	ldd	[%o0 + 0x70], %f40
+	ldd	[%o0 + 0x78], %f42
+	ldd	[%o0 + 0x80], %f44
+	ldd	[%o0 + 0x88], %f46
+	ldd	[%o0 + 0x90], %f48
+	ldd	[%o0 + 0x98], %f50
+	ldd	[%o0 + 0xa0], %f52
+	retl
+	ldd	[%o0 + 0xa8], %f54
+
+	SET_SIZE(t4_aes128_load_keys_for_encrypt)
+
+
+	ENTRY(t4_aes192_load_keys_for_encrypt)
+
+	ldd	[%o0 + 0x10], %f8
+	ldd	[%o0 + 0x18], %f10
+	ldd	[%o0 + 0x20], %f12
+	ldd	[%o0 + 0x28], %f14
+	ldd	[%o0 + 0x30], %f16
+	ldd	[%o0 + 0x38], %f18
+	ldd	[%o0 + 0x40], %f20
+	ldd	[%o0 + 0x48], %f22
+	ldd	[%o0 + 0x50], %f24
+	ldd	[%o0 + 0x58], %f26
+	ldd	[%o0 + 0x60], %f28
+	ldd	[%o0 + 0x68], %f30
+	ldd	[%o0 + 0x70], %f32
+	ldd	[%o0 + 0x78], %f34
+	ldd	[%o0 + 0x80], %f36
+	ldd	[%o0 + 0x88], %f38
+	ldd	[%o0 + 0x90], %f40
+	ldd	[%o0 + 0x98], %f42
+	ldd	[%o0 + 0xa0], %f44
+	ldd	[%o0 + 0xa8], %f46
+	ldd	[%o0 + 0xb0], %f48
+	ldd	[%o0 + 0xb8], %f50
+	ldd	[%o0 + 0xc0], %f52
+	retl
+	ldd	[%o0 + 0xc8], %f54
+
+	SET_SIZE(t4_aes192_load_keys_for_encrypt)
+
+
+	ENTRY(t4_aes256_load_keys_for_encrypt)
+
+	ldd	[%o0 + 0x10], %f0
+	ldd	[%o0 + 0x18], %f2
+	ldd	[%o0 + 0x20], %f4
+	ldd	[%o0 + 0x28], %f6
+	ldd	[%o0 + 0x30], %f8
+	ldd	[%o0 + 0x38], %f10
+	ldd	[%o0 + 0x40], %f12
+	ldd	[%o0 + 0x48], %f14
+	ldd	[%o0 + 0x50], %f16
+	ldd	[%o0 + 0x58], %f18
+	ldd	[%o0 + 0x60], %f20
+	ldd	[%o0 + 0x68], %f22
+	ldd	[%o0 + 0x70], %f24
+	ldd	[%o0 + 0x78], %f26
+	ldd	[%o0 + 0x80], %f28
+	ldd	[%o0 + 0x88], %f30
+	ldd	[%o0 + 0x90], %f32
+	ldd	[%o0 + 0x98], %f34
+	ldd	[%o0 + 0xa0], %f36
+	ldd	[%o0 + 0xa8], %f38
+	ldd	[%o0 + 0xb0], %f40
+	ldd	[%o0 + 0xb8], %f42
+	ldd	[%o0 + 0xc0], %f44
+	ldd	[%o0 + 0xc8], %f46
+	ldd	[%o0 + 0xd0], %f48
+	ldd	[%o0 + 0xd8], %f50
+	ldd	[%o0 + 0xe0], %f52
+	retl
+	ldd	[%o0 + 0xe8], %f54
+
+	SET_SIZE(t4_aes256_load_keys_for_encrypt)
+
+
+#define	TEST_PARALLEL_ECB_ENCRYPT
+#ifdef	TEST_PARALLEL_ECB_ENCRYPT
+	ENTRY(t4_aes128_ecb_encrypt)
+
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %o4
+	brz	%o4, ecbenc128_loop
+	nop
+
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	TEN_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ecbenc128_loop_end
+	add	%o2, 16, %o2
+
+ecbenc128_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f0
+	movxtod	%g4, %f2
+	ldx	[%o1 + 16], %g3	!input
+	ldx	[%o1 + 24], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	TEN_EROUNDS_2
+
+	std	%f0, [%o2]
+	std	%f2, [%o2 + 8]
+
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ecbenc128_loop
+	add	%o2, 32, %o2
+ecbenc128_loop_end:
+	retl
+	nop
+
+	SET_SIZE(t4_aes128_ecb_encrypt)
+
+
+	ENTRY(t4_aes192_ecb_encrypt)
+
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %o4
+	brz	%o4, ecbenc192_loop
+	nop
+
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	TWELVE_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ecbenc192_loop_end
+	add	%o2, 16, %o2
+
+ecbenc192_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f0
+	movxtod	%g4, %f2
+	ldx	[%o1 + 16], %g3	!input
+	ldx	[%o1 + 24], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	TWELVE_EROUNDS_2
+
+	std	%f0, [%o2]
+	std	%f2, [%o2 + 8]
+
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ecbenc192_loop
+	add	%o2, 32, %o2
+ecbenc192_loop_end:
+	retl
+	nop
+
+	SET_SIZE(t4_aes192_ecb_encrypt)
+
+
+	ENTRY(t4_aes256_ecb_encrypt)
+
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %o4
+	brz	%o4, ecbenc256_loop
+	nop
+
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	FOURTEEN_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ecbenc256_loop_end
+	add	%o2, 16, %o2
+
+ecbenc256_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f20
+	movxtod	%g4, %f22
+	ldx	[%o1 + 16], %g3	!input
+	ldx	[%o1 + 24], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	FOURTEEN_EROUNDS_2
+
+	std	%f20, [%o2]
+	std	%f22, [%o2 + 8]
+
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ecbenc256_loop
+	add	%o2, 32, %o2
+
+	ldd	[%o0 + 0x60], %f20
+	ldd	[%o0 + 0x68], %f22
+
+ecbenc256_loop_end:
+	retl
+	nop
+
+	SET_SIZE(t4_aes256_ecb_encrypt)
+
+#else
+
+	ENTRY(t4_aes128_ecb_encrypt)
+
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+ecbenc128_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	TEN_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ecbenc128_loop
+	add	%o2, 16, %o2
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes128_ecb_encrypt)
+
+
+	ENTRY(t4_aes192_ecb_encrypt)
+
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+ecbenc192_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	TWELVE_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ecbenc192_loop
+	add	%o2, 16, %o2
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes192_ecb_encrypt)
+
+
+	ENTRY(t4_aes256_ecb_encrypt)
+
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+ecbenc256_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f60
+	movxtod	%g4, %f62
+
+	FOURTEEN_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ecbenc256_loop
+	add	%o2, 16, %o2
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes256_ecb_encrypt)
+#endif
+
+
+	ENTRY(t4_aes128_cbc_encrypt)
+
+	ldd	[%o4], %f60	! IV
+	ldd	[%o4 +8], %f62	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cbcenc128_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f56
+	movxtod	%g4, %f58
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	TEN_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cbcenc128_loop
+	add	%o2, 16, %o2
+
+	std	%f60, [%o4]
+	retl
+	std	%f62, [%o4 + 8]
+
+	SET_SIZE(t4_aes128_cbc_encrypt)
+
+
+	ENTRY(t4_aes192_cbc_encrypt)
+
+	ldd	[%o4], %f60	! IV
+	ldd	[%o4 + 8], %f62	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cbcenc192_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f56
+	movxtod	%g4, %f58
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	TWELVE_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cbcenc192_loop
+	add	%o2, 16, %o2
+
+	std	%f60, [%o4]
+	retl
+	std	%f62, [%o4 + 8]
+
+	SET_SIZE(t4_aes192_cbc_encrypt)
+
+
+	ENTRY(t4_aes256_cbc_encrypt)
+
+	ldd	[%o4], %f60	! IV
+	ldd	[%o4 + 8], %f62	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cbcenc256_loop:
+	ldx	[%o1], %g3	!input
+	ldx	[%o1 + 8], %g4	!input
+	xor	%g1, %g3, %g3	!input ^ ks[0-1]
+	xor	%g2, %g4, %g4	!input ^ ks[0-1]
+	movxtod	%g3, %f56
+	movxtod	%g4, %f58
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	FOURTEEN_EROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cbcenc256_loop
+	add	%o2, 16, %o2
+
+	std	%f60, [%o4]
+	retl
+	std	%f62, [%o4 + 8]
+
+	SET_SIZE(t4_aes256_cbc_encrypt)
+
+
+#define	 TEST_PARALLEL_CTR_CRYPT
+#ifdef	TEST_PARALLEL_CTR_CRYPT
+	ENTRY(t4_aes128_ctr_crypt)
+
+	ldx	[%o4], %g3	! IV
+	ldx	[%o4 +8], %g4	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %g5
+	brz, %g5, ctr128_loop
+
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	TEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ctr128_loop_end
+	add	%o2, 16, %o2
+
+ctr128_loop:
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f0
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f2
+	inc	%g4
+
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	TEN_EROUNDS_2
+
+	ldd	[%o1], %f6		!input
+	ldd	[%o1 + 8], %f4		!input
+	ldd	[%o1 + 16], %f56	!input
+	ldd	[%o1 + 24], %f58	!input
+	fxor	%f0, %f6, %f0
+	fxor	%f2, %f4, %f2
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f0, [%o2]
+	std	%f2, [%o2 + 8]
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ctr128_loop
+	add	%o2, 32, %o2
+
+ctr128_loop_end:
+	stx	%g3, [%o4]
+	retl
+	stx	%g4, [%o4 + 8]
+
+	SET_SIZE(t4_aes128_ctr_crypt)
+
+
+	ENTRY(t4_aes192_ctr_crypt)
+
+	ldx	[%o4], %g3	! IV
+	ldx	[%o4 +8], %g4	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %g5
+	brz, %g5, ctr192_loop
+
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	TWELVE_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ctr192_loop_end
+	add	%o2, 16, %o2
+
+ctr192_loop:
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f0
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f2
+	inc	%g4
+
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	TWELVE_EROUNDS_2
+
+	ldd	[%o1], %f6		!input
+	ldd	[%o1 + 8], %f4		!input
+	ldd	[%o1 + 16], %f56	!input
+	ldd	[%o1 + 24], %f58	!input
+	fxor	%f0, %f6, %f0
+	fxor	%f2, %f4, %f2
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f0, [%o2]
+	std	%f2, [%o2 + 8]
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ctr192_loop
+	add	%o2, 32, %o2
+
+ctr192_loop_end:
+	stx	%g3, [%o4]
+	retl
+	stx	%g4, [%o4 + 8]
+
+	SET_SIZE(t4_aes192_ctr_crypt)
+
+
+	ENTRY(t4_aes256_ctr_crypt)
+
+	ldx	[%o4], %g3	! IV
+	ldx	[%o4 +8], %g4	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %g5
+	brz,	%g5, ctr256_loop
+
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	FOURTEEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ctr256_loop_end
+	add	%o2, 16, %o2
+
+ctr256_loop:
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f20
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f22
+	inc	%g4
+
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	FOURTEEN_EROUNDS_2
+
+	ldd	[%o1], %f56		!input
+	ldd	[%o1 + 8], %f58		!input
+	fxor	%f20, %f56, %f20
+	fxor	%f22, %f58, %f22
+	ldd	[%o1 + 16], %f56	!input
+	ldd	[%o1 + 24], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f20, [%o2]
+	std	%f22, [%o2 + 8]
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ctr256_loop
+	add	%o2, 32, %o2
+
+	ldd	[%o0 + 0x60], %f20
+	ldd	[%o0 + 0x68], %f22
+
+ctr256_loop_end:
+	stx	%g3, [%o4]
+	retl
+	stx	%g4, [%o4 + 8]
+
+	SET_SIZE(t4_aes256_ctr_crypt)
+
+#else
+
+	ENTRY(t4_aes128_ctr_crypt)
+
+	ldx	[%o4], %g3	! IV
+	ldx	[%o4 +8], %g4	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+ctr128_loop:
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	TEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ctr128_loop
+	add	%o2, 16, %o2
+
+	stx	%g3, [%o4]
+	retl
+	stx	%g4, [%o4 + 8]
+
+	SET_SIZE(t4_aes128_ctr_crypt)
+
+	ENTRY(t4_aes192_ctr_crypt)
+
+	ldx	[%o4], %g3	! IV
+	ldx	[%o4 +8], %g4	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+ctr192_loop:
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	TWELVE_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ctr192_loop
+	add	%o2, 16, %o2
+
+	stx	%g3, [%o4]
+	retl
+	stx	%g4, [%o4 + 8]
+
+	SET_SIZE(t4_aes192_ctr_crypt)
+
+
+	ENTRY(t4_aes256_ctr_crypt)
+
+	ldx	[%o4], %g3	! IV
+	ldx	[%o4 +8], %g4	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+ctr256_loop:
+	xor	%g1, %g3, %g5
+	movxtod	%g5, %f60
+	xor	%g2, %g4, %g5
+	movxtod	%g5, %f62
+	inc	%g4
+
+	FOURTEEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ctr256_loop
+	add	%o2, 16, %o2
+
+	stx	%g3, [%o4]
+	retl
+	stx	%g4, [%o4 + 8]
+
+	SET_SIZE(t4_aes256_ctr_crypt)
+
+#endif
+
+	ENTRY(t4_aes128_cfb128_encrypt)
+
+	ldd	[%o4], %f60	! IV
+	ldd	[%o4 +8], %f62	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cfb128_128_loop:
+	movxtod	%g1, %f56
+	movxtod	%g2, %f58
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	TEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cfb128_128_loop
+	add	%o2, 16, %o2
+
+	std	%f60, [%o4]
+	retl
+	std	%f62, [%o4 + 8]
+
+	SET_SIZE(t4_aes128_cfb128_encrypt)
+
+
+	ENTRY(t4_aes192_cfb128_encrypt)
+
+	ldd	[%o4], %f60	! IV
+	ldd	[%o4 +8], %f62	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cfb128_192_loop:
+	movxtod	%g1, %f56
+	movxtod	%g2, %f58
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	TWELVE_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cfb128_192_loop
+	add	%o2, 16, %o2
+
+	std	%f60, [%o4]
+	retl
+	std	%f62, [%o4 + 8]
+
+	SET_SIZE(t4_aes192_cfb128_encrypt)
+
+
+	ENTRY(t4_aes256_cfb128_encrypt)
+
+	ldd	[%o4], %f60	! IV
+	ldd	[%o4 +8], %f62	! IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cfb128_256_loop:
+	movxtod	%g1, %f56
+	movxtod	%g2, %f58
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	FOURTEEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cfb128_256_loop
+	add	%o2, 16, %o2
+
+	std	%f60, [%o4]
+	retl
+	std	%f62, [%o4 + 8]
+
+	SET_SIZE(t4_aes256_cfb128_encrypt)
+
+
+	ENTRY(t4_aes128_load_keys_for_decrypt)
+
+	ldd	[%o0], %f52
+	ldd	[%o0 + 0x8], %f54
+	ldd	[%o0 + 0x10], %f48
+	ldd	[%o0 + 0x18], %f50
+	ldd	[%o0 + 0x20], %f44
+	ldd	[%o0 + 0x28], %f46
+	ldd	[%o0 + 0x30], %f40
+	ldd	[%o0 + 0x38], %f42
+	ldd	[%o0 + 0x40], %f36
+	ldd	[%o0 + 0x48], %f38
+	ldd	[%o0 + 0x50], %f32
+	ldd	[%o0 + 0x58], %f34
+	ldd	[%o0 + 0x60], %f28
+	ldd	[%o0 + 0x68], %f30
+	ldd	[%o0 + 0x70], %f24
+	ldd	[%o0 + 0x78], %f26
+	ldd	[%o0 + 0x80], %f20
+	ldd	[%o0 + 0x88], %f22
+	ldd	[%o0 + 0x90], %f16
+	retl
+	ldd	[%o0 + 0x98], %f18
+
+	SET_SIZE(t4_aes128_load_keys_for_decrypt)
+
+
+	ENTRY(t4_aes192_load_keys_for_decrypt)
+
+	ldd	[%o0], %f52
+	ldd	[%o0 + 0x8], %f54
+	ldd	[%o0 + 0x10], %f48
+	ldd	[%o0 + 0x18], %f50
+	ldd	[%o0 + 0x20], %f44
+	ldd	[%o0 + 0x28], %f46
+	ldd	[%o0 + 0x30], %f40
+	ldd	[%o0 + 0x38], %f42
+	ldd	[%o0 + 0x40], %f36
+	ldd	[%o0 + 0x48], %f38
+	ldd	[%o0 + 0x50], %f32
+	ldd	[%o0 + 0x58], %f34
+	ldd	[%o0 + 0x60], %f28
+	ldd	[%o0 + 0x68], %f30
+	ldd	[%o0 + 0x70], %f24
+	ldd	[%o0 + 0x78], %f26
+	ldd	[%o0 + 0x80], %f20
+	ldd	[%o0 + 0x88], %f22
+	ldd	[%o0 + 0x90], %f16
+	ldd	[%o0 + 0x98], %f18
+	ldd	[%o0 + 0xa0], %f12
+	ldd	[%o0 + 0xa8], %f14
+	ldd	[%o0 + 0xb0], %f8
+	retl
+	ldd	[%o0 + 0xb8], %f10
+
+	SET_SIZE(t4_aes192_load_keys_for_decrypt)
+
+
+	ENTRY(t4_aes256_load_keys_for_decrypt)
+
+
+	ldd	[%o0], %f52
+	ldd	[%o0 + 0x8], %f54
+	ldd	[%o0 + 0x10], %f48
+	ldd	[%o0 + 0x18], %f50
+	ldd	[%o0 + 0x20], %f44
+	ldd	[%o0 + 0x28], %f46
+	ldd	[%o0 + 0x30], %f40
+	ldd	[%o0 + 0x38], %f42
+	ldd	[%o0 + 0x40], %f36
+	ldd	[%o0 + 0x48], %f38
+	ldd	[%o0 + 0x50], %f32
+	ldd	[%o0 + 0x58], %f34
+	ldd	[%o0 + 0x60], %f28
+	ldd	[%o0 + 0x68], %f30
+	ldd	[%o0 + 0x70], %f24
+	ldd	[%o0 + 0x78], %f26
+	ldd	[%o0 + 0x80], %f20
+	ldd	[%o0 + 0x88], %f22
+	ldd	[%o0 + 0x90], %f16
+	ldd	[%o0 + 0x98], %f18
+	ldd	[%o0 + 0xa0], %f12
+	ldd	[%o0 + 0xa8], %f14
+	ldd	[%o0 + 0xb0], %f8
+	ldd	[%o0 + 0xb8], %f10
+	ldd	[%o0 + 0xc0], %f4
+	ldd	[%o0 + 0xc8], %f6
+	ldd	[%o0 + 0xd0], %f0
+	retl
+	ldd	[%o0 + 0xd8], %f2
+
+	SET_SIZE(t4_aes256_load_keys_for_decrypt)
+
+
+#define	 TEST_PARALLEL_ECB_DECRYPT
+#ifdef	TEST_PARALLEL_ECB_DECRYPT
+	ENTRY(t4_aes128_ecb_decrypt)
+
+	ldx	[%o0 + 0xa0], %g1	!ks[last-1]
+	ldx	[%o0 + 0xa8], %g2	!ks[last]
+	and	%o3, 16, %o4
+	brz	%o4, ecbdec128_loop
+	nop
+
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	TEN_DROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 0x8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ecbdec128_loop_end
+	add	%o2, 16, %o2
+
+ecbdec128_loop:
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f0
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f2
+	ldx	[%o1 + 16], %o4
+	ldx	[%o1 + 24], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	TEN_DROUNDS_2
+
+	std	%f0, [%o2]
+	std	%f2, [%o2 + 8]
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ecbdec128_loop
+	add	%o2, 32, %o2
+ecbdec128_loop_end:
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes128_ecb_decrypt)
+
+	ENTRY(t4_aes192_ecb_decrypt)
+
+	ldx	[%o0 + 0xc0], %g1	!ks[last-1]
+	ldx	[%o0 + 0xc8], %g2	!ks[last]
+	and	%o3, 16, %o4
+	brz	%o4, ecbdec192_loop
+	nop
+
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	TWELVE_DROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 0x8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ecbdec192_loop_end
+	add	%o2, 16, %o2
+
+ecbdec192_loop:
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f0
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f2
+	ldx	[%o1 + 16], %o4
+	ldx	[%o1 + 24], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	TWELVE_DROUNDS_2
+
+	std	%f0, [%o2]
+	std	%f2, [%o2 + 8]
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ecbdec192_loop
+	add	%o2, 32, %o2
+ecbdec192_loop_end:
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes192_ecb_decrypt)
+
+
+	ENTRY(t4_aes256_ecb_decrypt)
+
+	ldx	[%o0 + 0xe0], %g1	!ks[last-1]
+	ldx	[%o0 + 0xe8], %g2	!ks[last]
+	and	%o3, 16, %o4
+	brz	%o4, ecbdec256_loop
+	nop
+
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	FOURTEEN_DROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 0x8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	ecbdec256_loop_end
+	add	%o2, 16, %o2
+
+ecbdec256_loop:
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f20
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f22
+	ldx	[%o1 + 16], %o4
+	ldx	[%o1 + 24], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	FOURTEEN_DROUNDS_2
+
+	std	%f20, [%o2]
+	std	%f22, [%o2 + 8]
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	ecbdec256_loop
+	add	%o2, 32, %o2
+
+	ldd	[%o0 + 0x80], %f20
+	ldd	[%o0 + 0x88], %f22
+
+ecbdec256_loop_end:
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes256_ecb_decrypt)
+
+#else
+
+	ENTRY(t4_aes128_ecb_decrypt)
+
+	ldx	[%o0 + 0xa0], %g1	!ks[last-1]
+	ldx	[%o0 + 0xa8], %g2	!ks[last]
+
+ecbdec128_loop:
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	TEN_DROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 0x8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ecbdec128_loop
+	add	%o2, 16, %o2
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes128_ecb_decrypt)
+
+
+	ENTRY(t4_aes192_ecb_decrypt)
+
+	ldx	[%o0 + 0xc0], %g1	!ks[last-1]
+	ldx	[%o0 + 0xc8], %g2	!ks[last]
+
+ecbdec192_loop:
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	TWELVE_DROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 0x8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ecbdec192_loop
+	add	%o2, 16, %o2
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes192_ecb_decrypt)
+
+
+	ENTRY(t4_aes256_ecb_decrypt)
+
+	ldx	[%o0 + 0xe0], %g1	!ks[last-1]
+	ldx	[%o0 + 0xe8], %g2	!ks[last]
+
+ecbdec256_loop:
+	ldx	[%o1], %o4
+	ldx	[%o1 + 8], %o5
+	xor	%g1, %o4, %g3	!initial ARK
+	movxtod	%g3, %f60
+	xor	%g2, %o5, %g3	!initial ARK
+	movxtod	%g3, %f62
+
+	FOURTEEN_DROUNDS
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 0x8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	ecbdec256_loop
+	add	%o2, 16, %o2
+
+	retl
+	nop
+
+	SET_SIZE(t4_aes256_ecb_decrypt)
+
+#endif
+
+#define	TEST_PARALLEL_CBC_DECRYPT
+#ifdef	EST_PARALLEL_CBC_DECRYPT
+		ENTRY(t4_aes128_cbc_decrypt)
+
+	save	%sp, -SA(MINFRAME), %sp
+	ldx	[%i4], %o0		!IV
+	ldx	[%i4 + 8], %o1		!IV
+	ldx	[%i0 + 0xa0], %o2	!ks[last-1]
+	ldx	[%i0 + 0xa8], %o3	!ks[last]
+	and	%i3, 16, %o4
+	brz	%o4, cbcdec128_loop
+	nop
+
+	ldx	[%i1], %o4
+	ldx	[%i1 + 8], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	TEN_DROUNDS
+
+	movxtod	%o0, %f56
+	movxtod	%o1, %f58
+	mov	%o4, %o0	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2]
+	std	%f62, [%i2 + 0x8]
+
+	add	%i1, 16, %i1
+	subcc	%i3, 16, %i3
+	be	cbcdec128_loop_end
+	add	%i2, 16, %i2
+
+
+cbcdec128_loop:
+	ldx	[%i1], %g4
+	ldx	[%i1 + 8], %g5
+	xor	%o2, %g4, %g1	!initial ARK
+	movxtod	%g1, %f0
+	xor	%o3, %g5, %g1	!initial ARK
+	movxtod	%g1, %f2
+
+	ldx	[%i1 + 16], %o4
+	ldx	[%i1 + 24], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	TEN_DROUNDS_2
+
+	movxtod	%o0, %f6
+	movxtod	%o1, %f4
+	fxor	%f6, %f0, %f0	!add in previous IV
+	fxor	%f4, %f2, %f2
+
+	std	%f0, [%i2]
+	std	%f2, [%i2 + 8]
+
+	movxtod	%g4, %f56
+	movxtod	%g5, %f58
+	mov	%o4, %o0	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2 + 16]
+	std	%f62, [%i2 + 24]
+
+	add	%i1, 32, %i1
+	subcc	%i3, 32, %i3
+	bne	cbcdec128_loop
+	add	%i2, 32, %i2
+
+cbcdec128_loop_end:
+	stx	%o0, [%i4]
+	stx	%o1, [%i4 + 8]
+	ret
+	restore
+
+	SET_SIZE(t4_aes128_cbc_decrypt)
+
+
+	ENTRY(t4_aes192_cbc_decrypt)
+
+	save	%sp, -SA(MINFRAME), %sp
+	ldx	[%i4], %o0		!IV
+	ldx	[%i4 + 8], %o1		!IV
+	ldx	[%i0 + 0xc0], %o2	!ks[last-1]
+	ldx	[%i0 + 0xc8], %o3	!ks[last]
+	and	%i3, 16, %o4
+	brz	%o4, cbcdec192_loop
+	nop
+
+	ldx	[%i1], %o4
+	ldx	[%i1 + 8], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	TWELVE_DROUNDS
+
+	movxtod	%o0, %f56
+	movxtod	%o1, %f58
+	mov	%o4, %o0	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2]
+	std	%f62, [%i2 + 0x8]
+
+	add	%i1, 16, %i1
+	subcc	%i3, 16, %i3
+	be	cbcdec192_loop_end
+	add	%i2, 16, %i2
+
+
+cbcdec192_loop:
+	ldx	[%i1], %g4
+	ldx	[%i1 + 8], %g5
+	xor	%o2, %g4, %g1	!initial ARK
+	movxtod	%g1, %f0
+	xor	%o3, %g5, %g1	!initial ARK
+	movxtod	%g1, %f2
+
+	ldx	[%i1 + 16], %o4
+	ldx	[%i1 + 24], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	TWELVE_DROUNDS_2
+
+	movxtod	%o0, %f6
+	movxtod	%o1, %f4
+	fxor	%f6, %f0, %f0	!add in previous IV
+	fxor	%f4, %f2, %f2
+
+	std	%f0, [%i2]
+	std	%f2, [%i2 + 8]
+
+	movxtod	%g4, %f56
+	movxtod	%g5, %f58
+	mov	%o4, %o0	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2 + 16]
+	std	%f62, [%i2 + 24]
+
+	add	%i1, 32, %i1
+	subcc	%i3, 32, %i3
+	bne	cbcdec192_loop
+	add	%i2, 32, %i2
+
+cbcdec192_loop_end:
+	stx	%o0, [%i4]
+	stx	%o1, [%i4 + 8]
+	ret
+	restore
+
+	SET_SIZE(t4_aes192_cbc_decrypt)
+
+
+	ENTRY(t4_aes256_cbc_decrypt)
+
+	save	%sp, -SA(MINFRAME), %sp
+	mov	%i0, %o0		!FOURTEEN_DROUNDS uses %o0
+	ldx	[%i4], %g2		!IV
+	ldx	[%i4 + 8], %o1		!IV
+	ldx	[%o0 + 0xe0], %o2	!ks[last-1]
+	ldx	[%o0 + 0xe8], %o3	!ks[last]
+	and	%i3, 16, %o4
+	brz	%o4, cbcdec256_loop
+	nop
+
+	ldx	[%i1], %o4
+	ldx	[%i1 + 8], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	FOURTEEN_DROUNDS
+
+	movxtod	%g2, %f56
+	movxtod	%o1, %f58
+	mov	%o4, %g2	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2]
+	std	%f62, [%i2 + 0x8]
+
+	add	%i1, 16, %i1
+	subcc	%i3, 16, %i3
+	be	cbcdec256_loop_end
+	add	%i2, 16, %i2
+
+
+cbcdec256_loop:
+	ldx	[%i1], %g4
+	ldx	[%i1 + 8], %g5
+	xor	%o2, %g4, %g1	!initial ARK
+	movxtod	%g1, %f20
+	xor	%o3, %g5, %g1	!initial ARK
+	movxtod	%g1, %f22
+
+	ldx	[%i1 + 16], %o4
+	ldx	[%i1 + 24], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	FOURTEEN_DROUNDS_2
+
+	movxtod	%g2, %f56
+	movxtod	%o1, %f58
+	fxor	%f56, %f20, %f20	!add in previous IV
+	fxor	%f58, %f22, %f22
+
+	std	%f20, [%i2]
+	std	%f22, [%i2 + 8]
+
+	movxtod	%g4, %f56
+	movxtod	%g5, %f58
+	mov	%o4, %g2	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2 + 16]
+	std	%f62, [%i2 + 24]
+
+	add	%i1, 32, %i1
+	subcc	%i3, 32, %i3
+	bne	cbcdec256_loop
+	add	%i2, 32, %i2
+
+	ldd	[%o0 + 0x80], %f20
+	ldd	[%o0 + 0x88], %f22
+
+cbcdec256_loop_end:
+	stx	%g2, [%i4]
+	stx	%o1, [%i4 + 8]
+	ret
+	restore
+
+	SET_SIZE(t4_aes256_cbc_decrypt)
+
+#else
+
+	ENTRY(t4_aes128_cbc_decrypt)
+
+	save	%sp, -SA(MINFRAME), %sp
+	ldx	[%i4], %o0		!IV
+	ldx	[%i4 + 8], %o1		!IV
+	ldx	[%i0 + 0xa0], %o2	!ks[last-1]
+	ldx	[%i0 + 0xa8], %o3	!ks[last]
+
+cbcdec128_loop:
+	ldx	[%i1], %o4
+	ldx	[%i1 + 8], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	TEN_DROUNDS
+
+	movxtod	%o0, %f56
+	movxtod	%o1, %f58
+	mov	%o4, %o0	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2]
+	std	%f62, [%i2 + 0x8]
+
+	add	%i1, 16, %i1
+	subcc	%i3, 16, %i3
+	bne	cbcdec128_loop
+	add	%i2, 16, %i2
+
+	stx	%o0, [%i4]
+	stx	%o1, [%i4 + 8]
+	ret
+	restore
+
+	SET_SIZE(t4_aes128_cbc_decrypt)
+
+
+	ENTRY(t4_aes192_cbc_decrypt)
+
+	save	%sp, -SA(MINFRAME), %sp
+	ldx	[%i4], %o0		!IV
+	ldx	[%i4 + 8], %o1		!IV
+	ldx	[%i0 + 0xc0], %o2	!ks[last-1]
+	ldx	[%i0 + 0xc8], %o3	!ks[last]
+
+cbcdec192_loop:
+	ldx	[%i1], %o4
+	ldx	[%i1 + 8], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	TWELVE_DROUNDS
+
+	movxtod	%o0, %f56
+	movxtod	%o1, %f58
+	mov	%o4, %o0	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2]
+	std	%f62, [%i2 + 0x8]
+
+	add	%i1, 16, %i1
+	subcc	%i3, 16, %i3
+	bne	cbcdec192_loop
+	add	%i2, 16, %i2
+
+	stx	%o0, [%i4]
+	stx	%o1, [%i4 + 8]
+	ret
+	restore
+
+	SET_SIZE(t4_aes192_cbc_decrypt)
+
+
+	ENTRY(t4_aes256_cbc_decrypt)
+
+	save	%sp, -SA(MINFRAME), %sp
+	ldx	[%i4], %o0		!IV
+	ldx	[%i4 + 8], %o1		!IV
+	ldx	[%i0 + 0xe0], %o2	!ks[last-1]
+	ldx	[%i0 + 0xe8], %o3	!ks[last]
+
+cbcdec256_loop:
+	ldx	[%i1], %o4
+	ldx	[%i1 + 8], %o5
+	xor	%o2, %o4, %g1	!initial ARK
+	movxtod	%g1, %f60
+	xor	%o3, %o5, %g1	!initial ARK
+	movxtod	%g1, %f62
+
+	FOURTEEN_DROUNDS
+
+	movxtod	%o0, %f56
+	movxtod	%o1, %f58
+	mov	%o4, %o0	!save last block as next IV
+	mov	%o5, %o1
+	fxor	%f56, %f60, %f60	!add in previous IV
+	fxor	%f58, %f62, %f62
+
+	std	%f60, [%i2]
+	std	%f62, [%i2 + 0x8]
+
+	add	%i1, 16, %i1
+	subcc	%i3, 16, %i3
+	bne	cbcdec256_loop
+	add	%i2, 16, %i2
+
+	stx	%o0, [%i4]
+	stx	%o1, [%i4 + 8]
+	ret
+	restore
+
+	SET_SIZE(t4_aes256_cbc_decrypt)
+
+#endif
+
+#define	TEST_PARALLEL_CFB128_DECRYPT
+#ifdef	TEST_PARALLEL_CFB128_DECRYPT
+
+	ENTRY(t4_aes128_cfb128_decrypt)
+
+	ldd	[%o4], %f56	!IV
+	ldd	[%o4 + 8], %f58	!IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %o5
+	brz	%o5, cfb128dec_128_loop
+
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	TEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	cfb128dec_128_loop_end
+	add	%o2, 16, %o2
+
+cfb128dec_128_loop:
+	ldd	[%o1], %f6	!input
+	ldd	[%o1 + 8], %f4	!input
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f6, %f0
+	fxor	%f62, %f4, %f2
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	TEN_EROUNDS_2
+
+	ldd	[%o1], %f6	!input
+	ldd	[%o1 + 8], %f4	!input
+	ldd	[%o1 + 16], %f56	!input
+	ldd	[%o1 + 24], %f58	!input
+
+	fxor	%f60, %f6, %f6
+	fxor	%f62, %f4, %f4
+	fxor	%f0, %f56, %f60
+	fxor	%f2, %f58, %f62
+
+	std	%f6, [%o2]
+	std	%f4, [%o2 + 8]
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	cfb128dec_128_loop
+	add	%o2, 32, %o2
+
+cfb128dec_128_loop_end:
+	std	%f56, [%o4]
+	retl
+	std	%f58, [%o4 + 8]
+
+	SET_SIZE(t4_aes128_cfb128_decrypt)
+
+
+	ENTRY(t4_aes192_cfb128_decrypt)
+
+	ldd	[%o4], %f56	!IV
+	ldd	[%o4 + 8], %f58	!IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %o5
+	brz	%o5, cfb128dec_192_loop
+
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	TWELVE_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	cfb128dec_192_loop_end
+	add	%o2, 16, %o2
+
+cfb128dec_192_loop:
+	ldd	[%o1], %f6	!input
+	ldd	[%o1 + 8], %f4	!input
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f6, %f0
+	fxor	%f62, %f4, %f2
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	TWELVE_EROUNDS_2
+
+	ldd	[%o1], %f6	!input
+	ldd	[%o1 + 8], %f4	!input
+	ldd	[%o1 + 16], %f56	!input
+	ldd	[%o1 + 24], %f58	!input
+
+	fxor	%f60, %f6, %f6
+	fxor	%f62, %f4, %f4
+	fxor	%f0, %f56, %f60
+	fxor	%f2, %f58, %f62
+
+	std	%f6, [%o2]
+	std	%f4, [%o2 + 8]
+	std	%f60, [%o2 + 16]
+	std	%f62, [%o2 + 24]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	cfb128dec_192_loop
+	add	%o2, 32, %o2
+
+cfb128dec_192_loop_end:
+	std	%f56, [%o4]
+	retl
+	std	%f58, [%o4 + 8]
+
+	SET_SIZE(t4_aes192_cfb128_decrypt)
+
+
+	ENTRY(t4_aes256_cfb128_decrypt)
+
+	ldd	[%o4], %f56	!IV
+	ldd	[%o4 + 8], %f58	!IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+	and	%o3, 16, %o5
+	brz	%o5, cfb128dec_256_loop
+
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	FOURTEEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	be	cfb128dec_256_loop_end
+	add	%o2, 16, %o2
+
+cfb128dec_256_loop:
+	ldd	[%o1], %f20	!input
+	ldd	[%o1 + 8], %f22	!input
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f20, %f20
+	fxor	%f62, %f22, %f22
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	FOURTEEN_EROUNDS_2
+
+	ldd	[%o1 + 16], %f56	!input
+	ldd	[%o1 + 24], %f58	!input
+	fxor	%f20, %f56, %f20
+	fxor	%f22, %f58, %f22
+	std	%f20, [%o2 + 16]
+	std	%f22, [%o2 + 24]
+
+	ldd	[%o1], %f20	!input
+	ldd	[%o1 + 8], %f22	!input
+
+	fxor	%f60, %f20, %f20
+	fxor	%f62, %f22, %f22
+
+	std	%f20, [%o2]
+	std	%f22, [%o2 + 8]
+
+	add	%o1, 32, %o1
+	subcc	%o3, 32, %o3
+	bne	cfb128dec_256_loop
+	add	%o2, 32, %o2
+
+	ldd	[%o0 + 0x60], %f20
+	ldd	[%o0 + 0x68], %f22
+
+cfb128dec_256_loop_end:
+	std	%f56, [%o4]
+	retl
+	std	%f58, [%o4 + 8]
+
+	SET_SIZE(t4_aes256_cfb128_decrypt)
+
+#else
+	ENTRY(t4_aes128_cfb128_decrypt)
+
+	ldd	[%o4], %f56	!IV
+	ldd	[%o4 + 8], %f58	!IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cfb128dec_128_loop:
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	TEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cfb128dec_128_loop
+	add	%o2, 16, %o2
+
+	std	%f56, [%o4]
+	retl
+	std	%f58, [%o4 + 8]
+
+	SET_SIZE(t4_aes128_cfb128_decrypt)
+
+
+	ENTRY(t4_aes192_cfb128_decrypt)
+
+	ldd	[%o4], %f56	!IV
+	ldd	[%o4 + 8], %f58	!IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cfb128dec_192_loop:
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	TWELVE_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cfb128dec_192_loop
+	add	%o2, 16, %o2
+
+	std	%f56, [%o4]
+	retl
+	std	%f58, [%o4 + 8]
+
+	SET_SIZE(t4_aes192_cfb128_decrypt)
+
+
+	ENTRY(t4_aes256_cfb128_decrypt)
+
+	ldd	[%o4], %f56	!IV
+	ldd	[%o4 + 8], %f58	!IV
+	ldx	[%o0], %g1	! ks[0]
+	ldx	[%o0 + 8], %g2	! ks[1]
+
+cfb128dec_256_loop:
+	movxtod	%g1, %f60
+	movxtod	%g2, %f62
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	/* CFB mode uses encryption for the decrypt operation */
+	FOURTEEN_EROUNDS
+
+	ldd	[%o1], %f56	!input
+	ldd	[%o1 + 8], %f58	!input
+	fxor	%f60, %f56, %f60
+	fxor	%f62, %f58, %f62
+
+	std	%f60, [%o2]
+	std	%f62, [%o2 + 8]
+
+	add	%o1, 16, %o1
+	subcc	%o3, 16, %o3
+	bne	cfb128dec_256_loop
+	add	%o2, 16, %o2
+
+	std	%f56, [%o4]
+	retl
+	std	%f58, [%o4 + 8]
+
+	SET_SIZE(t4_aes256_cfb128_decrypt)
+
+#endif
+
+#endif	/* lint || __lint */
diff -uNr openssl-1.0.1c.orig/crypto/des/Makefile openssl-1.0.1c/crypto/des/Makefile
--- openssl-1.0.1c.orig/crypto/des/Makefile	2011-08-14 15:46:47.000000000 +0200
+++ openssl-1.0.1c/crypto/des/Makefile	2012-05-11 22:19:17.483690000 +0200
@@ -17,6 +17,10 @@
 ASFLAGS= $(INCLUDES) $(ASFLAG)
 AFLAGS= $(ASFLAGS)
 
+BITS:=	$(shell if grep '^CFLAG.*=.*-m64' ../../Makefile >/dev/null; \
+		then echo 64; else echo 32; fi)
+ASFLAGSYF= -xregsym=no -K pic -P -xarch=v9v -D_sparcv9 -D_ASM -Dsparc -m$(BITS)
+
 GENERAL=Makefile
 TEST=destest.c
 APPS=
@@ -62,6 +66,10 @@
 des_enc-sparc.S:	asm/des_enc.m4
 	m4 -B 8192 asm/des_enc.m4 > des_enc-sparc.S
 
+t4_des.o: asm/t4_des.S
+	as $(ASFLAGSYF) -o $@ asm/t4_des.S
+	elfedit -e 'cap:hw1 -and -cmp vis vis3' $@
+
 des-586.s:	asm/des-586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
 	$(PERL) asm/des-586.pl $(PERLASM_SCHEME) $(CFLAGS) > $@
 crypt586.s:	asm/crypt586.pl ../perlasm/x86asm.pl ../perlasm/cbc.pl
diff -uNr openssl-1.0.1c.orig/crypto/des/asm/t4_des.S openssl-1.0.1c/crypto/des/asm/t4_des.S
--- openssl-1.0.1c.orig/crypto/des/asm/t4_des.S	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/des/asm/t4_des.S	2012-05-11 21:34:39.694955000 +0200
@@ -0,0 +1,786 @@
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*LINTLIBRARY*/
+
+#if defined(lint) || defined(__lint)
+
+#include <sys/types.h>
+#include "../engine/eng_t4_des_asm.h"
+
+/*ARGSUSED*/
+void t4_des_expand(uint64_t *rk, const uint32_t *key)
+{ return; }
+
+/*ARGSUSED*/
+void t4_des_encrypt(const uint64_t *rk, const uint64_t *pt, uint64_t *ct)
+{ return; }
+
+
+/*ARGSUSED*/
+void t4_des_load_keys(uint64_t *ks)
+{ return; }
+
+/*ARGSUSED*/
+void t4_des_ecb_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_des_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_des_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_des3_load_keys(uint64_t *ks)
+{ return; }
+
+/*ARGSUSED*/
+void t4_des3_ecb_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_des3_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv)
+{ return; }
+
+/*ARGSUSED*/
+void t4_des3_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv)
+{ return; }
+
+#else	/* lint || __lint */
+
+#include <sys/asm_linkage.h>
+
+
+	ENTRY(t4_des_expand)
+
+!load key
+	ld	[%o1], %f0
+	ld	[%o1 + 0x4], %f1
+
+!expand the key
+	!des_kexpand %f0, 0, %f0
+	!des_kexpand %f0, 1, %f2
+	!des_kexpand %f2, 3, %f6
+	!des_kexpand %f2, 2, %f4
+	!des_kexpand %f6, 3, %f10
+	!des_kexpand %f6, 2, %f8
+	!des_kexpand %f10, 3, %f14
+	!des_kexpand %f10, 2, %f12
+	!des_kexpand %f14, 1, %f16
+	!des_kexpand %f16, 3, %f20
+	!des_kexpand %f16, 2, %f18
+	!des_kexpand %f20, 3, %f24
+	!des_kexpand %f20, 2, %f22
+	!des_kexpand %f24, 3, %f28
+	!des_kexpand %f24, 2, %f26
+	!des_kexpand %f28, 1, %f30
+	.byte	0x81, 0xb0, 0x26, 0xc0
+	.byte	0x85, 0xb0, 0x26, 0xc1
+	.byte	0x8d, 0xb0, 0xa6, 0xc3
+	.byte	0x89, 0xb0, 0xa6, 0xc2
+	.byte	0x95, 0xb1, 0xa6, 0xc3
+	.byte	0x91, 0xb1, 0xa6, 0xc2
+	.byte	0x9d, 0xb2, 0xa6, 0xc3
+	.byte	0x99, 0xb2, 0xa6, 0xc2
+	.byte	0xa1, 0xb3, 0xa6, 0xc1
+	.byte	0xa9, 0xb4, 0x26, 0xc3
+	.byte	0xa5, 0xb4, 0x26, 0xc2
+	.byte	0xb1, 0xb5, 0x26, 0xc3
+	.byte	0xad, 0xb5, 0x26, 0xc2
+	.byte	0xb9, 0xb6, 0x26, 0xc3
+	.byte	0xb5, 0xb6, 0x26, 0xc2
+	.byte	0xbd, 0xb7, 0x26, 0xc1
+
+!copy expanded key back into array
+	std	%f0, [%o0]
+	std	%f2, [%o0 + 0x8]
+	std	%f4, [%o0 + 0x10]
+	std	%f6, [%o0 + 0x18]
+	std	%f8, [%o0 + 0x20]
+	std	%f10, [%o0 + 0x28]
+	std	%f12, [%o0 + 0x30]
+	std	%f14, [%o0 + 0x38]
+	std	%f16, [%o0 + 0x40]
+	std	%f18, [%o0 + 0x48]
+	std	%f20, [%o0 + 0x50]
+	std	%f22, [%o0 + 0x58]
+	std	%f24, [%o0 + 0x60]
+	std	%f26, [%o0 + 0x68]
+	std	%f28, [%o0 + 0x70]
+	retl
+	std	%f30, [%o0 + 0x78]
+
+	SET_SIZE(t4_des_expand)
+
+
+	ENTRY(t4_des_encrypt)
+
+!load expanded key
+	ldd	[%o0], %f0
+	ldd	[%o0 + 0x8], %f2
+	ldd	[%o0 + 0x10], %f4
+	ldd	[%o0 + 0x18], %f6
+	ldd	[%o0 + 0x20], %f8
+	ldd	[%o0 + 0x28], %f10
+	ldd	[%o0 + 0x30], %f12
+	ldd	[%o0 + 0x38], %f14
+	ldd	[%o0 + 0x40], %f16
+	ldd	[%o0 + 0x48], %f18
+	ldd	[%o0 + 0x50], %f20
+	ldd	[%o0 + 0x58], %f22
+	ldd	[%o0 + 0x60], %f24
+	ldd	[%o0 + 0x68], %f26
+	ldd	[%o0 + 0x70], %f28
+	ldd	[%o0 + 0x78], %f30
+
+!load input
+	ldd	[%o1], %f32
+
+!perform the cipher transformation
+	!des_ip	%f32, %f32
+	!des_round %f0,  %f2,  %f32, %f32
+	!des_round %f4,  %f6,  %f32, %f32
+	!des_round %f8,  %f10, %f32, %f32
+	!des_round %f12, %f14, %f32, %f32
+	!des_round %f16, %f18, %f32, %f32
+	!des_round %f20, %f22, %f32, %f32
+	!des_round %f24, %f26, %f32, %f32
+	!des_round %f28, %f30, %f32, %f32
+	!des_iip	%f32, %f32
+	.byte	0x83, 0xb0, 0x66, 0x80
+	.byte	0x82, 0xc8, 0x03, 0x22
+	.byte	0x82, 0xc9, 0x03, 0x26
+	.byte	0x82, 0xca, 0x03, 0x2a
+	.byte	0x82, 0xcb, 0x03, 0x2e
+	.byte	0x82, 0xcc, 0x03, 0x32
+	.byte	0x82, 0xcd, 0x03, 0x36
+	.byte	0x82, 0xce, 0x03, 0x3a
+	.byte	0x82, 0xcf, 0x03, 0x3e
+	.byte	0x83, 0xb0, 0x66, 0xa0
+
+!copy output back to array
+	retl
+	std	%f32, [%o2]
+
+	SET_SIZE(t4_des_encrypt)
+
+	ENTRY(t4_des_load_keys)
+
+!load expanded key
+	ldd	[%o0], %f0
+	ldd	[%o0 + 0x8], %f2
+	ldd	[%o0 + 0x10], %f4
+	ldd	[%o0 + 0x18], %f6
+	ldd	[%o0 + 0x20], %f8
+	ldd	[%o0 + 0x28], %f10
+	ldd	[%o0 + 0x30], %f12
+	ldd	[%o0 + 0x38], %f14
+	ldd	[%o0 + 0x40], %f16
+	ldd	[%o0 + 0x48], %f18
+	ldd	[%o0 + 0x50], %f20
+	ldd	[%o0 + 0x58], %f22
+	ldd	[%o0 + 0x60], %f24
+	ldd	[%o0 + 0x68], %f26
+	ldd	[%o0 + 0x70], %f28
+	retl
+	ldd	[%o0 + 0x78], %f30
+
+	SET_SIZE(t4_des_load_keys)
+
+	ENTRY(t4_des3_load_keys)
+
+!load first 30 pieces of the expanded key
+	ldd	[%o0], %f0
+	ldd	[%o0 + 0x8], %f2
+	ldd	[%o0 + 0x10], %f4
+	ldd	[%o0 + 0x18], %f6
+	ldd	[%o0 + 0x20], %f8
+	ldd	[%o0 + 0x28], %f10
+	ldd	[%o0 + 0x30], %f12
+	ldd	[%o0 + 0x38], %f14
+	ldd	[%o0 + 0x40], %f16
+	ldd	[%o0 + 0x48], %f18
+	ldd	[%o0 + 0x50], %f20
+	ldd	[%o0 + 0x58], %f22
+	ldd	[%o0 + 0x60], %f24
+	ldd	[%o0 + 0x68], %f26
+	ldd	[%o0 + 0x70], %f28
+	ldd	[%o0 + 0x78], %f30
+	ldd	[%o0 + 0x80], %f32
+	ldd	[%o0 + 0x88], %f34
+	ldd	[%o0 + 0x90], %f36
+	ldd	[%o0 + 0x98], %f38
+	ldd	[%o0 + 0xa0], %f40
+	ldd	[%o0 + 0xa8], %f42
+	ldd	[%o0 + 0xb0], %f44
+	ldd	[%o0 + 0xb8], %f46
+	ldd	[%o0 + 0xc0], %f48
+	ldd	[%o0 + 0xc8], %f50
+	ldd	[%o0 + 0xd0], %f52
+	ldd	[%o0 + 0xd8], %f54
+	ldd	[%o0 + 0xe0], %f56
+	retl
+	ldd	[%o0 + 0xe8], %f58
+
+	SET_SIZE(t4_des3_load_keys)
+
+	ENTRY(t4_des_ecb_crypt)
+
+des_ecb_loop:
+!load input
+	ldd	[%o1], %f62
+
+!perform the cipher transformation
+	!des_ip	%f62, %f62
+	!des_round %f0,  %f2,  %f62, %f62
+	!des_round %f4,  %f6,  %f62, %f62
+	!des_round %f8,  %f10, %f62, %f62
+	!des_round %f12, %f14, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	!des_round %f20, %f22, %f62, %f62
+	!des_round %f24, %f26, %f62, %f62
+	!des_round %f28, %f30, %f62, %f62
+	!des_iip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+
+!copy output back to array
+	std	%f62, [%o2]
+	sub	%o3, 8, %o3
+	add	%o1, 8, %o1
+	brnz	%o3, des_ecb_loop
+	add	%o2, 8, %o2
+
+	retl
+	nop
+
+	SET_SIZE(t4_des_ecb_crypt)
+
+
+	ENTRY(t4_des_cbc_encrypt)
+
+	ldd	[%o4], %f60
+des_cbc_encrypt_loop:
+!load input
+	ldd	[%o1], %f58
+	fxor	%f58, %f60, %f62
+
+!perform the cipher transformation
+	!des_ip	%f62, %f62
+	!des_round %f0,  %f2,  %f62, %f62
+	!des_round %f4,  %f6,  %f62, %f62
+	!des_round %f8,  %f10, %f62, %f62
+	!des_round %f12, %f14, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	!des_round %f20, %f22, %f62, %f62
+	!des_round %f24, %f26, %f62, %f62
+	!des_round %f28, %f30, %f62, %f62
+	!des_iip	%f62, %f60
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	.byte	0xbb, 0xb7, 0xe6, 0xa0
+
+!copy output back to array
+	std	%f60, [%o2]
+	sub	%o3, 8, %o3
+	add	%o1, 8, %o1
+	brnz	%o3, des_cbc_encrypt_loop
+	add	%o2, 8, %o2
+
+	retl
+	std	%f60, [%o4]
+
+	SET_SIZE(t4_des_cbc_encrypt)
+
+
+
+	ENTRY(t4_des_cbc_decrypt)
+
+	ldd	[%o4], %f60
+des_cbc_decrypt_loop:
+!load input
+	ldd	[%o1], %f62
+	ldx	[%o1], %o5
+
+!perform the cipher transformation
+	!des_ip	%f62, %f62
+	!des_round %f0,  %f2,  %f62, %f62
+	!des_round %f4,  %f6,  %f62, %f62
+	!des_round %f8,  %f10, %f62, %f62
+	!des_round %f12, %f14, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	!des_round %f20, %f22, %f62, %f62
+	!des_round %f24, %f26, %f62, %f62
+	!des_round %f28, %f30, %f62, %f62
+	!des_iip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+	fxor	%f60, %f62, %f62
+	movxtod	%o5, %f60
+
+!copy output back to array
+	std	%f62, [%o2]
+	sub	%o3, 8, %o3
+	add	%o1, 8, %o1
+	brnz	%o3, des_cbc_decrypt_loop
+	add	%o2, 8, %o2
+
+	retl
+	std	%f60, [%o4]
+
+	SET_SIZE(t4_des_cbc_decrypt)
+
+
+
+	ENTRY(t4_des3_ecb_crypt)
+
+des3_ecb_loop:
+!load input
+	ldd	[%o1], %f62
+
+!perform the cipher transformation
+	!des_ip	%f62, %f62
+	!des_round %f0,  %f2,  %f62, %f62
+	!des_round %f4,  %f6,  %f62, %f62
+	!des_round %f8,  %f10, %f62, %f62
+	!des_round %f12, %f14, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+
+	ldd	[%o0 + 0xf0], %f16
+	ldd	[%o0 + 0xf8], %f18
+	!des_round %f20, %f22, %f62, %f62
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	ldd	[%o0 + 0x100], %f20
+	ldd	[%o0 + 0x108], %f22
+	!des_round %f24, %f26, %f62, %f62
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	ldd	[%o0 + 0x110], %f24
+	ldd	[%o0 + 0x118], %f26
+	!des_round %f28, %f30, %f62, %f62
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	ldd	[%o0 + 0x120], %f28
+	ldd	[%o0 + 0x128], %f30
+
+	!des_iip	%f62, %f62
+	!des_ip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+
+	!des_round %f32, %f34, %f62, %f62
+	.byte	0xbe, 0xc8, 0x7f, 0x23
+	ldd	[%o0 + 0x130], %f0
+	ldd	[%o0 + 0x138], %f2
+	!des_round %f36, %f38,  %f62, %f62
+	.byte	0xbe, 0xc9, 0x7f, 0x27
+	ldd	[%o0 + 0x140], %f4
+	ldd	[%o0 + 0x148], %f6
+	!des_round %f40, %f42, %f62, %f62
+	.byte	0xbe, 0xca, 0x7f, 0x2b
+	ldd	[%o0 + 0x150], %f8
+	ldd	[%o0 + 0x158], %f10
+	!des_round %f44, %f46, %f62, %f62
+	.byte	0xbe, 0xcb, 0x7f, 0x2f
+	ldd	[%o0 + 0x160], %f12
+	ldd	[%o0 + 0x168], %f14
+	!des_round %f48, %f50, %f62, %f62
+	!des_round %f52, %f54, %f62, %f62
+	!des_round %f56, %f58, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbe, 0xcc, 0x7f, 0x33
+	.byte	0xbe, 0xcd, 0x7f, 0x37
+	.byte	0xbe, 0xce, 0x7f, 0x3b
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	ldd	[%o0 + 0x170], %f16
+	ldd	[%o0 + 0x178], %f18
+
+	!des_iip	%f62, %f62
+	!des_ip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+
+	!des_round %f20, %f22, %f62, %f62
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	ldd	[%o0 + 0x50], %f20
+	ldd	[%o0 + 0x58], %f22
+	!des_round %f24, %f26, %f62, %f62
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	ldd	[%o0 + 0x60], %f24
+	ldd	[%o0 + 0x68], %f26
+	!des_round %f28, %f30, %f62, %f62
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	ldd	[%o0 + 0x70], %f28
+	ldd	[%o0 + 0x78], %f30
+	!des_round %f0,  %f2,  %f62, %f62
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	ldd	[%o0], %f0
+	ldd	[%o0 + 0x8], %f2
+	!des_round %f4,  %f6,  %f62, %f62
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+
+	ldd	[%o0 + 0x10], %f4
+	ldd	[%o0 + 0x18], %f6
+	!des_round %f8,  %f10, %f62, %f62
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	ldd	[%o0 + 0x20], %f8
+	ldd	[%o0 + 0x28], %f10
+	!des_round %f12, %f14, %f62, %f62
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	ldd	[%o0 + 0x30], %f12
+	ldd	[%o0 + 0x38], %f14
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	ldd	[%o0 + 0x40], %f16
+	ldd	[%o0 + 0x48], %f18
+
+	!des_iip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+
+!copy output back to array
+	std	%f62, [%o2]
+	sub	%o3, 8, %o3
+	add	%o1, 8, %o1
+	brnz	%o3, des3_ecb_loop
+	add	%o2, 8, %o2
+
+	retl
+	nop
+
+	SET_SIZE(t4_des3_ecb_crypt)
+
+
+	ENTRY(t4_des3_cbc_encrypt)
+
+	ldd	[%o4], %f62
+des3_cbc_encrypt_loop:
+!load input
+	ldd	[%o1], %f60
+	fxor	%f60, %f62, %f62
+
+!perform the cipher transformation
+	!des_ip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+	!des_round %f0,  %f2,  %f62, %f62
+	!des_round %f4,  %f6,  %f62, %f62
+	!des_round %f8,  %f10, %f62, %f62
+	!des_round %f12, %f14, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	ldd	[%o0 + 0xf0], %f16
+	ldd	[%o0 + 0xf8], %f18
+	!des_round %f20, %f22, %f62, %f62
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	ldd	[%o0 + 0x100], %f20
+	ldd	[%o0 + 0x108], %f22
+	!des_round %f24, %f26, %f62, %f62
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	ldd	[%o0 + 0x110], %f24
+	ldd	[%o0 + 0x118], %f26
+	!des_round %f28, %f30, %f62, %f62
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	ldd	[%o0 + 0x120], %f28
+	ldd	[%o0 + 0x128], %f30
+
+	!des_iip	%f62, %f62
+	!des_ip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+
+	!des_round %f32, %f34, %f62, %f62
+	.byte	0xbe, 0xc8, 0x7f, 0x23
+	ldd	[%o0 + 0x130], %f0
+	ldd	[%o0 + 0x138], %f2
+	!des_round %f36, %f38,  %f62, %f62
+	.byte	0xbe, 0xc9, 0x7f, 0x27
+	ldd	[%o0 + 0x140], %f4
+	ldd	[%o0 + 0x148], %f6
+	!des_round %f40, %f42, %f62, %f62
+	.byte	0xbe, 0xca, 0x7f, 0x2b
+	ldd	[%o0 + 0x150], %f8
+	ldd	[%o0 + 0x158], %f10
+	!des_round %f44, %f46, %f62, %f62
+	.byte	0xbe, 0xcb, 0x7f, 0x2f
+	ldd	[%o0 + 0x160], %f12
+	ldd	[%o0 + 0x168], %f14
+	!des_round %f48, %f50, %f62, %f62
+	!des_round %f52, %f54, %f62, %f62
+	!des_round %f56, %f58, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbe, 0xcc, 0x7f, 0x33
+	.byte	0xbe, 0xcd, 0x7f, 0x37
+	.byte	0xbe, 0xce, 0x7f, 0x3b
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	ldd	[%o0 + 0x170], %f16
+	ldd	[%o0 + 0x178], %f18
+
+	!des_iip	%f62, %f62
+	!des_ip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+
+	!des_round %f20, %f22, %f62, %f62
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	ldd	[%o0 + 0x50], %f20
+	ldd	[%o0 + 0x58], %f22
+	!des_round %f24, %f26, %f62, %f62
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	ldd	[%o0 + 0x60], %f24
+	ldd	[%o0 + 0x68], %f26
+	!des_round %f28, %f30, %f62, %f62
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	ldd	[%o0 + 0x70], %f28
+	ldd	[%o0 + 0x78], %f30
+	!des_round %f0,  %f2,  %f62, %f62
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	ldd	[%o0], %f0
+	ldd	[%o0 + 0x8], %f2
+	!des_round %f4,  %f6,  %f62, %f62
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+	ldd	[%o0 + 0x10], %f4
+	ldd	[%o0 + 0x18], %f6
+	!des_round %f8,  %f10, %f62, %f62
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	ldd	[%o0 + 0x20], %f8
+	ldd	[%o0 + 0x28], %f10
+	!des_round %f12, %f14, %f62, %f62
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	ldd	[%o0 + 0x30], %f12
+	ldd	[%o0 + 0x38], %f14
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	ldd	[%o0 + 0x40], %f16
+	ldd	[%o0 + 0x48], %f18
+
+	!des_iip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+
+!copy output back to array
+	std	%f62, [%o2]
+	sub	%o3, 8, %o3
+	add	%o1, 8, %o1
+	brnz	%o3, des3_cbc_encrypt_loop
+	add	%o2, 8, %o2
+
+	retl
+	std	%f62, [%o4]
+
+	SET_SIZE(t4_des3_cbc_encrypt)
+
+
+	ENTRY(t4_des3_cbc_decrypt)
+
+	ldd	[%o4], %f60
+des3_cbc_decrypt_loop:
+!load input
+	ldx	[%o1], %o5
+	movxtod	%o5, %f62
+
+!perform the cipher transformation
+	!des_ip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+	!des_round %f0,  %f2,  %f62, %f62
+	!des_round %f4,  %f6,  %f62, %f62
+	!des_round %f8,  %f10, %f62, %f62
+	!des_round %f12, %f14, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	ldd	[%o0 + 0xf0], %f16
+	ldd	[%o0 + 0xf8], %f18
+	!des_round %f20, %f22, %f62, %f62
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	ldd	[%o0 + 0x100], %f20
+	ldd	[%o0 + 0x108], %f22
+	!des_round %f24, %f26, %f62, %f62
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	ldd	[%o0 + 0x110], %f24
+	ldd	[%o0 + 0x118], %f26
+	!des_round %f28, %f30, %f62, %f62
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	ldd	[%o0 + 0x120], %f28
+	ldd	[%o0 + 0x128], %f30
+
+	!des_iip	%f62, %f62
+	!des_ip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+
+	!des_round %f32, %f34, %f62, %f62
+	.byte	0xbe, 0xc8, 0x7f, 0x23
+	ldd	[%o0 + 0x130], %f0
+	ldd	[%o0 + 0x138], %f2
+	!des_round %f36, %f38,  %f62, %f62
+	.byte	0xbe, 0xc9, 0x7f, 0x27
+	ldd	[%o0 + 0x140], %f4
+	ldd	[%o0 + 0x148], %f6
+	!des_round %f40, %f42, %f62, %f62
+	.byte	0xbe, 0xca, 0x7f, 0x2b
+	ldd	[%o0 + 0x150], %f8
+	ldd	[%o0 + 0x158], %f10
+	!des_round %f44, %f46, %f62, %f62
+	.byte	0xbe, 0xcb, 0x7f, 0x2f
+	ldd	[%o0 + 0x160], %f12
+	ldd	[%o0 + 0x168], %f14
+	!des_round %f48, %f50, %f62, %f62
+	!des_round %f52, %f54, %f62, %f62
+	!des_round %f56, %f58, %f62, %f62
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbe, 0xcc, 0x7f, 0x33
+	.byte	0xbe, 0xcd, 0x7f, 0x37
+	.byte	0xbe, 0xce, 0x7f, 0x3b
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	ldd	[%o0 + 0x170], %f16
+	ldd	[%o0 + 0x178], %f18
+
+	!des_iip	%f62, %f62
+	!des_ip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+	.byte	0xbf, 0xb7, 0xe6, 0x80
+
+	!des_round %f20, %f22, %f62, %f62
+	.byte	0xbe, 0xcd, 0x3f, 0x36
+	ldd	[%o0 + 0x50], %f20
+	ldd	[%o0 + 0x58], %f22
+	!des_round %f24, %f26, %f62, %f62
+	.byte	0xbe, 0xce, 0x3f, 0x3a
+	ldd	[%o0 + 0x60], %f24
+	ldd	[%o0 + 0x68], %f26
+	!des_round %f28, %f30, %f62, %f62
+	.byte	0xbe, 0xcf, 0x3f, 0x3e
+	ldd	[%o0 + 0x70], %f28
+	ldd	[%o0 + 0x78], %f30
+	!des_round %f0,  %f2,  %f62, %f62
+	.byte	0xbe, 0xc8, 0x3f, 0x22
+	ldd	[%o0], %f0
+	ldd	[%o0 + 0x8], %f2
+	!des_round %f4,  %f6,  %f62, %f62
+	.byte	0xbe, 0xc9, 0x3f, 0x26
+	ldd	[%o0 + 0x10], %f4
+	ldd	[%o0 + 0x18], %f6
+	!des_round %f8,  %f10, %f62, %f62
+	.byte	0xbe, 0xca, 0x3f, 0x2a
+	ldd	[%o0 + 0x20], %f8
+	ldd	[%o0 + 0x28], %f10
+	!des_round %f12, %f14, %f62, %f62
+	.byte	0xbe, 0xcb, 0x3f, 0x2e
+	ldd	[%o0 + 0x30], %f12
+	ldd	[%o0 + 0x38], %f14
+	!des_round %f16, %f18, %f62, %f62
+	.byte	0xbe, 0xcc, 0x3f, 0x32
+	ldd	[%o0 + 0x40], %f16
+	ldd	[%o0 + 0x48], %f18
+
+	!des_iip	%f62, %f62
+	.byte	0xbf, 0xb7, 0xe6, 0xa0
+	fxor	%f60, %f62, %f62
+	movxtod	%o5, %f60
+
+!copy output back to array
+	std	%f62, [%o2]
+	sub	%o3, 8, %o3
+	add	%o1, 8, %o1
+	brnz	%o3, des3_cbc_decrypt_loop
+	add	%o2, 8, %o2
+
+	retl
+	stx	%o5, [%o4]
+
+	SET_SIZE(t4_des3_cbc_decrypt)
+
+
+#endif  /* lint || __lint */
diff -uNr openssl-1.0.1c.orig/crypto/engine/Makefile openssl-1.0.1c/crypto/engine/Makefile
--- openssl-1.0.1c.orig/crypto/engine/Makefile	2012-05-11 22:28:08.979830665 +0200
+++ openssl-1.0.1c/crypto/engine/Makefile	2012-05-11 22:19:17.486992000 +0200
@@ -23,6 +23,8 @@
 	tb_cipher.c tb_digest.c tb_pkmeth.c tb_asnmth.c \
 	eng_openssl.c eng_cnf.c eng_dyn.c eng_cryptodev.c \
 	eng_rsax.c eng_rdrand.c \
+	eng_t4.c eng_t4_des.c eng_t4_md5.c \
+	eng_t4_sha1.c eng_t4_sha256.c eng_t4_sha512.c eng_t4_montmul.c \
 	hw_pk11.c hw_pk11_pub.c hw_pk11_uri.c
 LIBOBJ= eng_err.o eng_lib.o eng_list.o eng_init.o eng_ctrl.o \
 	eng_table.o eng_pkey.o eng_fat.o eng_all.o \
@@ -30,6 +32,8 @@
 	tb_cipher.o tb_digest.o tb_pkmeth.o tb_asnmth.o \
 	eng_openssl.o eng_cnf.o eng_dyn.o eng_cryptodev.o \
 	eng_rsax.o eng_rdrand.o \
+	eng_t4.o eng_t4_des.o eng_t4_md5.o \
+	eng_t4_sha1.o eng_t4_sha256.o eng_t4_sha512.o eng_t4_montmul.o \
 	hw_pk11.o hw_pk11_pub.o hw_pk11_uri.o
 
 SRC= $(LIBSRC)
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_all.c openssl-1.0.1c/crypto/engine/eng_all.c
--- openssl-1.0.1c.orig/crypto/engine/eng_all.c	2012-05-11 22:28:08.983934887 +0200
+++ openssl-1.0.1c/crypto/engine/eng_all.c	2012-05-11 22:19:17.491465000 +0200
@@ -79,6 +79,10 @@
 #ifndef OPENSSL_NO_RDRAND
 	ENGINE_load_rdrand();
 #endif
+#if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_T4)
+	ENGINE_load_t4();
+	ENGINE_register_all_complete();
+#endif
 	ENGINE_load_dynamic();
 #ifndef OPENSSL_NO_HW_PKCS11
 	ENGINE_load_pk11();
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4.c openssl-1.0.1c/crypto/engine/eng_t4.c
--- openssl-1.0.1c.orig/crypto/engine/eng_t4.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4.c	2012-05-11 21:34:43.158979000 +0200
@@ -0,0 +1,1187 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * This engine supports SPARC microprocessors that provide AES and other
+ * cipher and hash instructions, such as the T4 microprocessor.
+ */
+
+#include <openssl/opensslconf.h>
+
+#if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_AES_T4) && \
+	!defined(OPENSSL_NO_AES)
+#include <sys/types.h>
+#include <sys/auxv.h>	/* getisax() */
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <errno.h>
+#include <openssl/aes.h>
+#include <openssl/engine.h>
+#include "eng_t4_aes_asm.h"
+
+#define	T4_LIB_NAME "SPARC T4 engine"
+#include "eng_t4_err.c"
+
+/* Copied from Solaris aes_impl.h */
+#ifndef	MAX_AES_NR
+#define	MAX_AES_NR		14 /* Maximum number of rounds */
+#endif
+#ifndef	MAX_AES_NB
+#define	MAX_AES_NB		4  /* Number of columns comprising a state */
+#endif
+
+/* Index for the supported ciphers */
+typedef enum {
+	T4_AES_128_CBC,
+	T4_AES_192_CBC,
+	T4_AES_256_CBC,
+#ifndef	SOLARIS_NO_AES_CFB128
+	T4_AES_128_CFB128,
+	T4_AES_192_CFB128,
+	T4_AES_256_CFB128,
+#endif	/* !SOLARIS_NO_AES_CFB128 */
+#ifndef	SOLARIS_NO_AES_CTR
+	T4_AES_128_CTR,
+	T4_AES_192_CTR,
+	T4_AES_256_CTR,
+#endif
+	T4_AES_128_ECB,
+	T4_AES_192_ECB,
+	T4_AES_256_ECB,
+	T4_CIPHER_MAX
+} t4_cipher_id;
+
+/* T4 cipher context; must be 8-byte aligned (last field must be uint64_t)  */
+typedef struct t4_cipher_ctx {
+	t4_cipher_id	index;
+	uint64_t	*iv;
+	uint64_t	aligned_iv_buffer[2]; /* use if original IV unaligned */
+	/* Encryption and decryption key schedule are the same: */
+	uint64_t	t4_ks[((MAX_AES_NR) + 1) * (MAX_AES_NB)];
+} t4_cipher_ctx_t;
+
+typedef struct t4_cipher {
+	t4_cipher_id	id;
+	int		nid;
+	int		iv_len;
+	int		min_key_len;
+	int		max_key_len;
+	unsigned long	flags;
+} t4_cipher_t;
+
+/* Constants used when creating the ENGINE */
+static const char *ENGINE_T4_ID = "t4";
+static const char *ENGINE_T4_NAME = "SPARC T4 engine support";
+static const char *ENGINE_NO_T4_NAME = "SPARC T4 engine support (no T4)";
+
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && !defined(OPENSSL_NO_ASM)
+#define	COMPILE_HW_T4
+static int t4_bind_helper(ENGINE *e, const char *id);
+#pragma inline(t4_bind_helper)
+#endif
+
+/*
+ * This makes the engine "built-in" with OpenSSL.
+ * On non-T4 CPUs this just returns.
+ * Called by ENGINE_load_builtin_engines().
+ */
+void
+ENGINE_load_t4(void)
+{
+#ifdef	COMPILE_HW_T4
+	ENGINE *toadd = ENGINE_new();
+	if (toadd != NULL) {
+		if (t4_bind_helper(toadd, ENGINE_T4_ID) != 0) {
+			(void) ENGINE_add(toadd);
+			(void) ENGINE_free(toadd);
+			ERR_clear_error();
+		} else {
+			(void) ENGINE_free(toadd);
+		}
+	}
+#endif
+}
+
+
+#ifdef	COMPILE_HW_T4
+static int t4_bind(ENGINE *e);
+#ifndef	DYNAMIC_ENGINE
+#pragma inline(t4_bind)
+#endif
+static t4_cipher_id get_cipher_index_by_nid(int nid);
+#pragma inline(get_cipher_index_by_nid)
+static void t4_instructions_present(_Bool *aes_present, _Bool *des_present,
+    _Bool *digest_present, _Bool *montmul_present);
+#pragma inline(t4_instructions_present)
+
+/* Digest registration function. Called by ENGINE_set_ciphers() */
+int t4_get_all_digests(ENGINE *e, const EVP_MD **digest,
+    const int **nids, int nid);
+
+/* RSA_METHOD structure used by ENGINE_set_RSA() */
+extern RSA_METHOD *t4_RSA(void);
+
+/* DH_METHOD structure used by ENGINE_set_DH() */
+extern DH_METHOD *t4_DH(void);
+
+/* DSA_METHOD structure used by ENGINE_set_DSA() */
+extern DSA_METHOD *t4_DSA(void);
+
+#ifndef	SOLARIS_NO_AES_CTR
+/*
+ * NIDs for AES counter mode that will be defined during the engine
+ * initialization (because OpenSSL doesn't support CTR mode).
+ */
+static int NID_t4_aes_128_ctr = NID_undef;
+static int NID_t4_aes_192_ctr = NID_undef;
+static int NID_t4_aes_256_ctr = NID_undef;
+
+static int t4_add_NID(char *sn, char *ln);
+static int t4_add_aes_ctr_NIDs(void);
+#pragma inline(t4_add_aes_ctr_NIDs)
+static void t4_free_aes_ctr_NIDs(void);
+#define	T4_FREE_AES_CTR_NIDS	t4_free_aes_ctr_NIDs()
+#else
+#define	T4_FREE_AES_CTR_NIDS
+#endif	/* !SOLARIS_NO_AES_CTR */
+
+/* Static variables */
+/* This can't be const as NID*ctr is inserted when the engine is initialized */
+static int t4_cipher_nids[] = {
+	NID_aes_128_cbc, NID_aes_192_cbc, NID_aes_256_cbc,
+#ifndef	SOLARIS_NO_AES_CFB128
+	NID_aes_128_cfb128, NID_aes_192_cfb128, NID_aes_256_cfb128,
+#endif
+#ifndef	SOLARIS_NO_AES_CTR
+	/* NID_t4_aes_128_ctr, NID_t4_aes_192, NID_t4_aes_256 */
+	NID_undef, NID_undef, NID_undef,
+#endif
+	NID_aes_128_ecb, NID_aes_192_ecb, NID_aes_256_ecb,
+#ifndef	OPENSSL_NO_DES
+	/* Must be at end of list (see t4_des_cipher_count in t4_bind() */
+	NID_des_cbc, NID_des_ede3_cbc, NID_des_ecb, NID_des_ede3_ecb,
+#endif
+};
+static const int t4_des_cipher_count = 4;
+static int t4_cipher_count =
+	(sizeof (t4_cipher_nids) / sizeof (t4_cipher_nids[0]));
+
+/*
+ * Cipher Table for all supported symmetric ciphers.
+ * Must be in same order as t4_cipher_id.
+ */
+static t4_cipher_t t4_cipher_table[] = {
+	/* ID			NID			IV min- max-key flags */
+	{T4_AES_128_CBC,	NID_aes_128_cbc,	16, 16, 16, 0},
+	{T4_AES_192_CBC,	NID_aes_192_cbc,	16, 24, 24, 0},
+	{T4_AES_256_CBC,	NID_aes_256_cbc,	16, 32, 32, 0},
+#ifndef	SOLARIS_NO_AES_CFB128
+	{T4_AES_128_CFB128,	NID_aes_128_cfb128,	16, 16, 16,
+							EVP_CIPH_NO_PADDING},
+	{T4_AES_192_CFB128,	NID_aes_192_cfb128,	16, 24, 24,
+							EVP_CIPH_NO_PADDING},
+	{T4_AES_256_CFB128,	NID_aes_256_cfb128,	16, 32, 32,
+							EVP_CIPH_NO_PADDING},
+#endif
+#ifndef	SOLARIS_NO_AES_CTR
+	/* We don't know the correct NIDs until the engine is initialized */
+	{T4_AES_128_CTR,	NID_undef,		16, 16, 16,
+							EVP_CIPH_NO_PADDING},
+	{T4_AES_192_CTR,	NID_undef,		16, 24, 24,
+							EVP_CIPH_NO_PADDING},
+	{T4_AES_256_CTR,	NID_undef,		16, 32, 32,
+							EVP_CIPH_NO_PADDING},
+#endif
+	{T4_AES_128_ECB,	NID_aes_128_ecb,	0, 16, 16, 0},
+	{T4_AES_192_ECB,	NID_aes_192_ecb,	0, 24, 24, 0},
+	{T4_AES_256_ECB,	NID_aes_256_ecb,	0, 32, 32, 0},
+};
+
+
+/* Formal declaration for functions in EVP_CIPHER structure */
+static int t4_cipher_init_aes(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+    const unsigned char *iv, int enc);
+
+static int t4_cipher_do_aes_128_cbc(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_aes_192_cbc(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_aes_256_cbc(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+#ifndef	SOLARIS_NO_AES_CFB128
+static int t4_cipher_do_aes_128_cfb128(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_aes_192_cfb128(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_aes_256_cfb128(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+#endif
+#ifndef	SOLARIS_NO_AES_CTR
+static int t4_cipher_do_aes_128_ctr(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_aes_192_ctr(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_aes_256_ctr(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+#endif	/* !SOLARIS_NO_AES_CTR */
+static int t4_cipher_do_aes_128_ecb(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_aes_192_ecb(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_aes_256_ecb(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+
+
+/*
+ * Cipher Algorithms
+ *
+ * OpenSSL's libcrypto EVP stuff. This is how this engine gets wired to EVP.
+ * EVP_CIPHER is defined in evp.h.  To maintain binary compatibility the
+ * definition cannot be modified.
+ * Stuff specific to the t4 engine is kept in t4_cipher_ctx_t, which is
+ * pointed to by cipher_data or md_data
+ *
+ * Fields: nid, block_size, key_len, iv_len, flags,
+ *	init(), do_cipher(), cleanup(),
+ *	ctx_size,
+ *	set_asn1_parameters(), get_asn1_parameters(), ctrl(), app_data
+ */
+
+static const EVP_CIPHER t4_aes_128_cbc = {
+	NID_aes_128_cbc,
+	16, 16, 16,
+	EVP_CIPH_CBC_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_128_cbc, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+static const EVP_CIPHER t4_aes_192_cbc = {
+	NID_aes_192_cbc,
+	16, 24, 16,
+	EVP_CIPH_CBC_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_192_cbc, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+static const EVP_CIPHER t4_aes_256_cbc = {
+	NID_aes_256_cbc,
+	16, 32, 16,
+	EVP_CIPH_CBC_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_256_cbc, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+
+#ifndef	SOLARIS_NO_AES_CFB128
+static const EVP_CIPHER t4_aes_128_cfb128 = {
+	NID_aes_128_cfb128,
+	16, 16, 16,
+	EVP_CIPH_CFB_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_128_cfb128, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+static const EVP_CIPHER t4_aes_192_cfb128 = {
+	NID_aes_192_cfb128,
+	16, 24, 16,
+	EVP_CIPH_CFB_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_192_cfb128, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+static const EVP_CIPHER t4_aes_256_cfb128 = {
+	NID_aes_256_cfb128,
+	16, 32, 16,
+	EVP_CIPH_CFB_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_256_cfb128, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+#endif	/* !SOLARIS_NO_AES_CFB128 */
+
+#ifndef	SOLARIS_NO_AES_CTR
+/*
+ * Counter mode is not defined in OpenSSL.
+ * NID_undef's will be changed to AES counter mode NIDs as soon as they are
+ * created in t4_add_aes_ctr_NIDs() when the engine is initialized.
+ * Note that the need to change these structures during initialization is the
+ * reason why we don't define them with the const keyword.
+ */
+static EVP_CIPHER t4_aes_128_ctr = {
+	NID_undef,
+	16, 16, 16,
+	EVP_CIPH_CBC_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_128_ctr, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+static EVP_CIPHER t4_aes_192_ctr = {
+	NID_undef,
+	16, 24, 16,
+	EVP_CIPH_CBC_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_192_ctr, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+static EVP_CIPHER t4_aes_256_ctr = {
+	NID_undef,
+	16, 32, 16,
+	EVP_CIPH_CBC_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_256_ctr, NULL,
+	sizeof (t4_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+#endif	/* !SOLARIS_NO_AES_CTR */
+
+/*
+ * ECB modes don't use an Initial Vector, so that's why set_asn1_parameters,
+ * get_asn1_parameters, and cleanup fields are set to NULL.
+ */
+static const EVP_CIPHER t4_aes_128_ecb = {
+	NID_aes_128_ecb,
+	16, 16, 0,
+	EVP_CIPH_ECB_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_128_ecb, NULL,
+	sizeof (t4_cipher_ctx_t),
+	NULL, NULL, NULL, NULL
+};
+static const EVP_CIPHER t4_aes_192_ecb = {
+	NID_aes_192_ecb,
+	16, 24, 0,
+	EVP_CIPH_ECB_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_192_ecb, NULL,
+	sizeof (t4_cipher_ctx_t),
+	NULL, NULL, NULL, NULL
+};
+static const EVP_CIPHER t4_aes_256_ecb = {
+	NID_aes_256_ecb,
+	16, 32, 0,
+	EVP_CIPH_ECB_MODE,
+	t4_cipher_init_aes, t4_cipher_do_aes_256_ecb, NULL,
+	sizeof (t4_cipher_ctx_t),
+	NULL, NULL, NULL, NULL
+};
+
+#ifndef	OPENSSL_NO_DES
+extern const EVP_CIPHER t4_des_cbc;
+extern const EVP_CIPHER t4_des3_cbc;
+extern const EVP_CIPHER t4_des_ecb;
+extern const EVP_CIPHER t4_des3_ecb;
+#endif	/* OPENSSL_NO_DES */
+
+
+/*
+ * Message Digest variables
+ */
+static const int t4_digest_nids[] = {
+#ifndef	OPENSSL_NO_MD5
+	NID_md5,
+#endif
+#ifndef	OPENSSL_NO_SHA
+#ifndef	OPENSSL_NO_SHA1
+	NID_sha1,
+#endif
+#ifndef	OPENSSL_NO_SHA256
+	NID_sha224,
+	NID_sha256,
+#endif
+#ifndef	OPENSSL_NO_SHA512
+	NID_sha384,
+	NID_sha512,
+#endif
+#endif	/* !OPENSSL_NO_SHA */
+};
+static const int t4_digest_count =
+	(sizeof (t4_digest_nids) / sizeof (t4_digest_nids[0]));
+
+#ifndef	OPENSSL_NO_MD5
+extern const EVP_MD t4_md5;
+#endif
+#ifndef	OPENSSL_NO_SHA
+#ifndef	OPENSSL_NO_SHA1
+extern const EVP_MD t4_sha1;
+#endif
+#ifndef	OPENSSL_NO_SHA256
+extern const EVP_MD t4_sha224;
+extern const EVP_MD t4_sha256;
+#endif
+#ifndef	OPENSSL_NO_SHA512
+extern const EVP_MD t4_sha384;
+extern const EVP_MD t4_sha512;
+#endif
+#endif	/* !OPENSSL_NO_SHA */
+
+/*
+ * Message Digest functions
+ */
+
+/*
+ * Registered by the ENGINE with ENGINE_set_digests().
+ * Finds out how to deal with a particular digest NID in the ENGINE.
+ */
+/* ARGSUSED */
+int
+t4_get_all_digests(ENGINE *e, const EVP_MD **digest,
+    const int **nids, int nid)
+{
+	if (digest == NULL) { /* return a list of all supported digests */
+		*nids = (t4_digest_count > 0) ? t4_digest_nids : NULL;
+		return (t4_digest_count);
+	}
+
+	switch (nid) {
+#ifndef	OPENSSL_NO_MD5
+	case NID_md5:
+		*digest = &t4_md5;
+		break;
+#endif
+#ifndef	OPENSSL_NO_SHA
+#ifndef	OPENSSL_NO_SHA1
+	/*
+	 * A special case. For "openssl dgst -dss1 ...",
+	 * OpenSSL calls EVP_get_digestbyname() on "dss1" which ends up
+	 * calling t4_get_all_digests() for NID_dsa. Internally, if an
+	 * engine is not used, OpenSSL uses SHA1_Init() as expected for
+	 * DSA. So, we must return t4_sha1 for NID_dsa as well. Note
+	 * that this must have changed between 0.9.8 and 1.0.0 since we
+	 * did not have the problem with the 0.9.8 version.
+	 */
+	case NID_dsa:
+	case NID_sha1:
+		*digest = &t4_sha1;
+		break;
+#endif
+#ifndef	OPENSSL_NO_SHA256
+	case NID_sha224:
+		*digest = &t4_sha224;
+		break;
+	case NID_sha256:
+		*digest = &t4_sha256;
+		break;
+#endif
+#ifndef	OPENSSL_NO_SHA512
+	case NID_sha384:
+		*digest = &t4_sha384;
+		break;
+	case NID_sha512:
+		*digest = &t4_sha512;
+		break;
+#endif
+#endif	/* !OPENSSL_NO_SHA */
+	default:
+		/* digest not supported */
+		*digest = NULL;
+		return (0);
+	}
+
+	return (1);
+}
+
+
+/*
+ * Utility Functions
+ */
+
+/*
+ * Set aes_present, des_present, digest_present and montmul_present
+ * to B_FALSE or B_TRUE depending on
+ * whether the current SPARC processor supports AES, DES,
+ * MD5/SHA1/SHA256/SHA512 and MONTMUL, respectively.
+ */
+static void
+t4_instructions_present(_Bool *aes_present, _Bool *des_present,
+    _Bool *digest_present, _Bool *montmul_present)
+{
+#ifdef	OPENSSL_NO_DES
+#undef	AV_SPARC_DES
+#define	AV_SPARC_DES	0
+#endif
+#ifdef	OPENSSL_NO_MD5
+#undef	AV_SPARC_MD5
+#define	AV_SPARC_MD5	0
+#endif
+#ifndef	OPENSSL_NO_SHA
+#ifdef	OPENSSL_NO_SHA1
+#undef	AV_SPARC_SHA1
+#define	AV_SPARC_SHA1	0
+#endif
+#ifdef	OPENSSL_NO_SHA256
+#undef	AV_SPARC_SHA256
+#define	AV_SPARC_SHA256	0
+#endif
+#ifdef	OPENSSL_NO_SHA512
+#undef	AV_SPARC_SHA512
+#define	AV_SPARC_SHA512	0
+#endif
+#else
+#undef	AV_SPARC_SHA1
+#undef	AV_SPARC_SHA256
+#undef	AV_SPARC_SHA512
+#define	AV_SPARC_SHA1	0
+#define	AV_SPARC_SHA256	0
+#define	AV_SPARC_SHA512	0
+#endif	/* !OPENSSL_NO_SHA */
+
+#define	DIGEST_MASK	(AV_SPARC_MD5 | AV_SPARC_SHA1 | AV_SPARC_SHA256 | \
+	AV_SPARC_SHA512)
+	uint_t		ui;
+
+	(void) getisax(&ui, 1);
+	*aes_present = ((ui & AV_SPARC_AES) != 0);
+	*des_present = ((ui & AV_SPARC_DES) != 0);
+	*digest_present = ((ui & DIGEST_MASK) == DIGEST_MASK);
+	*montmul_present = ((ui & AV_SPARC_MONT) != 0);
+}
+
+
+#ifndef	SOLARIS_NO_AES_CTR
+/* Create a new NID when we have no OID for that mechanism */
+static int
+t4_add_NID(char *sn, char *ln)
+{
+	ASN1_OBJECT	*o;
+	int		nid;
+
+	if ((o = ASN1_OBJECT_create(OBJ_new_nid(1), (unsigned char *)"",
+	    1, sn, ln)) == NULL) {
+		T4err(T4_F_ADD_NID, T4_R_ASN1_OBJECT_CREATE);
+		return (0);
+	}
+
+	/* Will return NID_undef on error */
+	nid = OBJ_add_object(o);
+	ASN1_OBJECT_free(o);
+
+	return (nid);
+}
+
+
+/*
+ * Create new NIDs for AES counter mode.
+ * OpenSSL doesn't support them now so we have to help ourselves here.
+ */
+static int
+t4_add_aes_ctr_NIDs(void)
+{
+	/* Are we already set? */
+	if (NID_t4_aes_256_ctr != NID_undef)
+		return (1);
+
+	/*
+	 * There are no official names for AES counter modes yet so we just
+	 * follow the format of those that exist.
+	 */
+
+	/* Initialize NID_t4_aes_*_ctr and t4_cipher_table[] variables */
+	if ((NID_t4_aes_128_ctr = t4_add_NID("AES-128-CTR", "aes-128-ctr")) ==
+	    NID_undef)
+		return (0);
+	t4_cipher_table[T4_AES_128_CTR].nid =
+	    t4_aes_128_ctr.nid = NID_t4_aes_128_ctr;
+
+	if ((NID_t4_aes_192_ctr = t4_add_NID("AES-192-CTR", "aes-192-ctr")) ==
+	    NID_undef)
+		return (0);
+	t4_cipher_table[T4_AES_192_CTR].nid =
+	    t4_aes_192_ctr.nid = NID_t4_aes_192_ctr;
+
+	if ((NID_t4_aes_256_ctr = t4_add_NID("AES-256-CTR", "aes-256-ctr")) ==
+	    NID_undef)
+		return (0);
+	t4_cipher_table[T4_AES_256_CTR].nid =
+	    t4_aes_256_ctr.nid = NID_t4_aes_256_ctr;
+
+	/* Initialize t4_cipher_nids[] */
+	for (int i = 0; i < t4_cipher_count; ++i) {
+		if (t4_cipher_nids[i] == NID_undef) { /* found */
+			t4_cipher_nids[i] = NID_t4_aes_128_ctr;
+			t4_cipher_nids[++i] = NID_t4_aes_192_ctr;
+			t4_cipher_nids[++i] = NID_t4_aes_256_ctr;
+			break;
+		}
+	}
+
+	return (1);
+}
+
+
+static void
+t4_free_aes_ctr_NIDs(void)
+{
+	ASN1_OBJECT *o = NULL;
+
+	/* Clear entries in t4_cipher_nids[] */
+	for (int i = 0; i < t4_cipher_count; ++i) {
+		if (t4_cipher_nids[i] == NID_t4_aes_128_ctr) {
+			t4_cipher_nids[i] = NID_undef;
+		} else if (t4_cipher_nids[i] == NID_t4_aes_192_ctr) {
+			t4_cipher_nids[i] = NID_undef;
+		} else if (t4_cipher_nids[i] == NID_t4_aes_256_ctr) {
+			t4_cipher_nids[i] = NID_undef;
+		}
+	}
+
+	/* Clear NID_t4_aes_*_ctr and t4_cipher_table[] variables */
+	if (NID_t4_aes_128_ctr != NID_undef) {
+		o = OBJ_nid2obj(NID_t4_aes_128_ctr);
+		if (o != NULL)
+			ASN1_OBJECT_free(o);
+		NID_t4_aes_128_ctr = NID_undef;
+		t4_cipher_table[T4_AES_128_CTR].nid =
+		    t4_aes_128_ctr.nid = NID_undef;
+	}
+
+	if (NID_t4_aes_192_ctr != NID_undef) {
+		o = OBJ_nid2obj(NID_t4_aes_192_ctr);
+		if (o != NULL)
+			ASN1_OBJECT_free(o);
+		NID_t4_aes_192_ctr = NID_undef;
+		t4_cipher_table[T4_AES_192_CTR].nid =
+		    t4_aes_192_ctr.nid = NID_undef;
+	}
+
+	if (NID_t4_aes_256_ctr != NID_undef) {
+		o = OBJ_nid2obj(NID_t4_aes_256_ctr);
+		if (o != NULL)
+		ASN1_OBJECT_free(o);
+		NID_t4_aes_256_ctr = NID_undef;
+		t4_cipher_table[T4_AES_256_CTR].nid =
+		    t4_aes_256_ctr.nid = NID_undef;
+	}
+}
+#endif	/* !SOLARIS_NO_AES_CTR */
+
+
+/*
+ * Cipher functions
+ */
+
+
+/*
+ * Registered by the ENGINE with ENGINE_set_ciphers().
+ * Finds out how to deal with a particular cipher NID in the ENGINE.
+ */
+/* ARGSUSED */
+static int
+t4_get_all_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
+    const int **nids, int nid)
+{
+	if (cipher == NULL) { /* return a list of all supported ciphers */
+		*nids = (t4_cipher_count > 0) ? t4_cipher_nids : NULL;
+		return (t4_cipher_count);
+	}
+
+	switch (nid) {
+	case NID_aes_128_cbc:
+		*cipher = &t4_aes_128_cbc;
+		break;
+	case NID_aes_192_cbc:
+		*cipher = &t4_aes_192_cbc;
+		break;
+	case NID_aes_256_cbc:
+		*cipher = &t4_aes_256_cbc;
+		break;
+	case NID_aes_128_ecb:
+		*cipher = &t4_aes_128_ecb;
+		break;
+	case NID_aes_192_ecb:
+		*cipher = &t4_aes_192_ecb;
+		break;
+	case NID_aes_256_ecb:
+		*cipher = &t4_aes_256_ecb;
+		break;
+#ifndef	SOLARIS_NO_AES_CFB128
+	case NID_aes_128_cfb128:
+		*cipher = &t4_aes_128_cfb128;
+		break;
+	case NID_aes_192_cfb128:
+		*cipher = &t4_aes_192_cfb128;
+		break;
+	case NID_aes_256_cfb128:
+		*cipher = &t4_aes_256_cfb128;
+		break;
+#endif	/* !SOLARIS_NO_AES_CFB128 */
+#ifndef	OPENSSL_NO_DES
+	case NID_des_cbc:
+		*cipher = &t4_des_cbc;
+		break;
+	case NID_des_ede3_cbc:
+		*cipher = &t4_des3_cbc;
+		break;
+	case NID_des_ecb:
+		*cipher = &t4_des_ecb;
+		break;
+	case NID_des_ede3_ecb:
+		*cipher = &t4_des3_ecb;
+		break;
+#endif	/* !OPENSSL_NO_DES */
+
+	default:
+#ifndef	SOLARIS_NO_AES_CTR
+		/* These NIDs cannot be const, so must be tested with "if" */
+		if (nid == NID_t4_aes_128_ctr) {
+			*cipher = &t4_aes_128_ctr;
+			break;
+		} else if (nid == NID_t4_aes_192_ctr) {
+			*cipher = &t4_aes_192_ctr;
+			break;
+		} else if (nid == NID_t4_aes_256_ctr) {
+			*cipher = &t4_aes_256_ctr;
+			break;
+		} else
+#endif	/* !SOLARIS_NO_AES_CTR */
+		{
+			/* cipher not supported */
+			*cipher = NULL;
+			return (0);
+		}
+	}
+
+	return (1);
+}
+
+
+/* Called by t4_cipher_init_aes() */
+static t4_cipher_id
+get_cipher_index_by_nid(int nid)
+{
+	t4_cipher_id i;
+
+	for (i = (t4_cipher_id)0; i < T4_CIPHER_MAX; ++i)
+		if (t4_cipher_table[i].nid == nid)
+			return (i);
+	return (T4_CIPHER_MAX);
+}
+
+
+/* ARGSUSED2 */
+static int
+t4_cipher_init_aes(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+    const unsigned char *iv, int enc)
+{
+	t4_cipher_ctx_t	*tctx = ctx->cipher_data;
+	uint64_t	*t4_ks = tctx->t4_ks;
+	t4_cipher_t	*t4_cipher;
+	t4_cipher_id	index;
+	int		key_len = ctx->key_len;
+	uint64_t	aligned_key_buffer[4]; /* 16, 24, or 32 bytes long */
+	uint64_t	*aligned_key;
+
+	if (key == NULL) {
+		T4err(T4_F_CIPHER_INIT_AES, T4_R_CIPHER_KEY);
+		return (0);
+	}
+
+	/* Get the cipher entry index in t4_cipher_table from nid */
+	index = get_cipher_index_by_nid(ctx->cipher->nid);
+	if (index >= T4_CIPHER_MAX) {
+		T4err(T4_F_CIPHER_INIT_AES, T4_R_CIPHER_NID);
+		return (0); /* Error */
+	}
+	t4_cipher = &t4_cipher_table[index];
+
+	/* Check key size and iv size */
+	if (ctx->cipher->iv_len < t4_cipher->iv_len) {
+		T4err(T4_F_CIPHER_INIT_AES, T4_R_IV_LEN_INCORRECT);
+		return (0); /* Error */
+	}
+	if ((key_len < t4_cipher->min_key_len) ||
+	    (key_len > t4_cipher->max_key_len)) {
+		T4err(T4_F_CIPHER_INIT_AES, T4_R_KEY_LEN_INCORRECT);
+		return (0); /* Error */
+	}
+
+	/* Set cipher flags, if any */
+	ctx->flags |= t4_cipher->flags;
+
+	/* Align the key */
+	if (((unsigned long)key & 0x7) == 0) /* already aligned */
+		aligned_key = (uint64_t *)key;
+	else { /* key is not 8-byte aligned */
+#ifdef	DEBUG_T4
+		(void) fprintf(stderr, "T4: key is not 8 byte aligned\n");
+#endif
+		(void) memcpy(aligned_key_buffer, key, key_len);
+		aligned_key = aligned_key_buffer;
+	}
+
+
+	/*
+	 * Expand the key schedule.
+	 * Copy original key to start of t4_ks key schedule. Note that the
+	 * encryption and decryption key schedule are the same for T4.
+	 */
+	switch (key_len) {
+		case 16:
+			t4_aes_expand128(&t4_ks[2],
+			    (const uint32_t *)aligned_key);
+			t4_ks[0] = aligned_key[0];
+			t4_ks[1] = aligned_key[1];
+			break;
+		case 24:
+			t4_aes_expand192(&t4_ks[3],
+			    (const uint32_t *)aligned_key);
+			t4_ks[0] = aligned_key[0];
+			t4_ks[1] = aligned_key[1];
+			t4_ks[2] = aligned_key[2];
+			break;
+		case 32:
+			t4_aes_expand256(&t4_ks[4],
+			    (const uint32_t *)aligned_key);
+			t4_ks[0] = aligned_key[0];
+			t4_ks[1] = aligned_key[1];
+			t4_ks[2] = aligned_key[2];
+			t4_ks[3] = aligned_key[3];
+			break;
+		default:
+			T4err(T4_F_CIPHER_INIT_AES, T4_R_CIPHER_KEY);
+			return (0);
+	}
+
+	/* Save index to cipher */
+	tctx->index = index;
+
+	/* Align IV, if needed */
+	if (t4_cipher->iv_len <= 0) { /* no IV (such as with ECB mode) */
+		tctx->iv = NULL;
+	} else if (((unsigned long)ctx->iv & 0x7) == 0) { /* already aligned */
+		tctx->iv = (uint64_t *)ctx->iv;
+	} else {
+		/* IV is not 8 byte aligned */
+		(void) memcpy(tctx->aligned_iv_buffer, ctx->iv,
+		    ctx->cipher->iv_len);
+		tctx->iv = tctx->aligned_iv_buffer;
+#ifdef	DEBUG_T4
+		(void) fprintf(stderr,
+		    "t4_cipher_init_aes: IV is not 8 byte aligned\n");
+		(void) fprintf(stderr,
+		    "t4_cipher_init_aes: ctx->cipher->iv_len =%d\n",
+		    ctx->cipher->iv_len);
+		(void) fprintf(stderr, "t4_cipher_init_aes: after "
+		    "re-alignment, tctx->iv = %p\n", (void *)tctx->iv);
+#endif	/* DEBUG_T4 */
+	}
+
+	return (1);
+}
+
+
+/*
+ * ENCRYPT_UPDATE or DECRYPT_UPDATE
+ */
+#define	T4_CIPHER_DO_AES(t4_cipher_do_aes, t4_aes_load_keys_for_encrypt, \
+    t4_aes_encrypt, t4_aes_load_keys_for_decrypt, t4_aes_decrypt, iv)	\
+static int								\
+t4_cipher_do_aes(EVP_CIPHER_CTX *ctx, unsigned char *out,		\
+    const unsigned char *in, size_t inl)				\
+{									\
+	t4_cipher_ctx_t	*tctx = ctx->cipher_data;			\
+	uint64_t	*t4_ks = tctx->t4_ks;				\
+	unsigned long	outl = inl;					\
+	unsigned char	*bufin_alloc = NULL, *bufout_alloc = NULL;	\
+	unsigned char	*bufin, *bufout;				\
+									\
+	/* "in" and "out" must be 8 byte aligned */			\
+	if (((unsigned long)in & 0x7) == 0) { /* already aligned */	\
+		bufin = (unsigned char *)in;				\
+	} else { /* "in" is not 8 byte aligned */			\
+		if (((unsigned long)out & 0x7) == 0) { /* aligned */	\
+			/* use output buffer for input */		\
+			bufin = out;					\
+		} else {						\
+			bufin = bufin_alloc = OPENSSL_malloc(inl);	\
+			if (bufin_alloc == NULL)			\
+				return (0); /* error */			\
+		}							\
+		(void) memcpy(bufin, in, inl);				\
+	}								\
+									\
+	if (((unsigned long)out & 0x7) == 0) { /* already aligned */	\
+		bufout = out;						\
+	} else { /* "out" is not 8 byte aligned */			\
+		if (bufin_alloc != NULL) {				\
+			/* use allocated input buffer for output */	\
+			bufout = bufin_alloc;				\
+		} else {						\
+			bufout = bufout_alloc = OPENSSL_malloc(outl);	\
+			if (bufout_alloc == NULL) {			\
+				OPENSSL_free(bufin_alloc);		\
+				return (0); /* error */			\
+			}						\
+		}							\
+	}								\
+									\
+	/* Data length must be an even multiple of block size. */	\
+	if ((inl & 0xf) != 0) {						\
+		OPENSSL_free(bufout_alloc);				\
+		OPENSSL_free(bufin_alloc);				\
+		T4err(T4_F_CIPHER_DO_AES, T4_R_NOT_BLOCKSIZE_LENGTH);	\
+		return (0);						\
+	}								\
+									\
+	if (ctx->encrypt) {						\
+		t4_aes_load_keys_for_encrypt(t4_ks);			\
+		t4_aes_encrypt(t4_ks, (uint64_t *)bufin,		\
+		    (uint64_t *)bufout, (size_t)inl, iv);		\
+	} else { /* decrypt */						\
+		t4_aes_load_keys_for_decrypt(t4_ks);			\
+		t4_aes_decrypt(t4_ks, (uint64_t *)bufin,		\
+		    (uint64_t *)bufout, (size_t)inl, iv);		\
+	}								\
+									\
+	/* Cleanup */							\
+	if (bufin_alloc != NULL) {					\
+		if (bufout == bufin_alloc)				\
+			(void) memcpy(out, bufout, outl);		\
+		OPENSSL_free(bufin_alloc);				\
+	}								\
+	if (bufout_alloc != NULL) {					\
+		(void) memcpy(out, bufout_alloc, outl);			\
+		OPENSSL_free(bufout_alloc);				\
+	}								\
+									\
+	return (1);							\
+}
+
+
+/* AES CBC mode. */
+T4_CIPHER_DO_AES(t4_cipher_do_aes_128_cbc,
+	t4_aes128_load_keys_for_encrypt, t4_aes128_cbc_encrypt,
+	t4_aes128_load_keys_for_decrypt, t4_aes128_cbc_decrypt, tctx->iv)
+T4_CIPHER_DO_AES(t4_cipher_do_aes_192_cbc,
+	t4_aes192_load_keys_for_encrypt, t4_aes192_cbc_encrypt,
+	t4_aes192_load_keys_for_decrypt, t4_aes192_cbc_decrypt, tctx->iv)
+T4_CIPHER_DO_AES(t4_cipher_do_aes_256_cbc,
+	t4_aes256_load_keys_for_encrypt, t4_aes256_cbc_encrypt,
+	t4_aes256_load_keys_for_decrypt, t4_aes256_cbc_decrypt, tctx->iv)
+
+/*
+ * AES CFB128 mode.
+ * CFB128 decrypt uses load_keys_for_encrypt() as the mode uses
+ * the raw AES encrypt operation for the decryption, too.
+ */
+#ifndef	SOLARIS_NO_AES_CFB128
+T4_CIPHER_DO_AES(t4_cipher_do_aes_128_cfb128,
+	t4_aes128_load_keys_for_encrypt, t4_aes128_cfb128_encrypt,
+	t4_aes128_load_keys_for_encrypt, t4_aes128_cfb128_decrypt, tctx->iv)
+T4_CIPHER_DO_AES(t4_cipher_do_aes_192_cfb128,
+	t4_aes192_load_keys_for_encrypt, t4_aes192_cfb128_encrypt,
+	t4_aes192_load_keys_for_encrypt, t4_aes192_cfb128_decrypt, tctx->iv)
+T4_CIPHER_DO_AES(t4_cipher_do_aes_256_cfb128,
+	t4_aes256_load_keys_for_encrypt, t4_aes256_cfb128_encrypt,
+	t4_aes256_load_keys_for_encrypt, t4_aes256_cfb128_decrypt, tctx->iv)
+#endif	/* !SOLARIS_NO_AES_CFB128 */
+
+/* AES CTR mode. */
+#ifndef	SOLARIS_NO_AES_CTR
+T4_CIPHER_DO_AES(t4_cipher_do_aes_128_ctr,
+	t4_aes128_load_keys_for_encrypt, t4_aes128_ctr_crypt,
+	t4_aes128_load_keys_for_decrypt, t4_aes128_ctr_crypt, tctx->iv)
+T4_CIPHER_DO_AES(t4_cipher_do_aes_192_ctr,
+	t4_aes192_load_keys_for_encrypt, t4_aes192_ctr_crypt,
+	t4_aes192_load_keys_for_decrypt, t4_aes192_ctr_crypt, tctx->iv)
+T4_CIPHER_DO_AES(t4_cipher_do_aes_256_ctr,
+	t4_aes256_load_keys_for_encrypt, t4_aes256_ctr_crypt,
+	t4_aes256_load_keys_for_decrypt, t4_aes256_ctr_crypt, tctx->iv)
+#endif	/* !SOLARIS_NO_AES_CTR */
+
+/* AES ECB mode. */
+T4_CIPHER_DO_AES(t4_cipher_do_aes_128_ecb,
+	t4_aes128_load_keys_for_encrypt, t4_aes128_ecb_encrypt,
+	t4_aes128_load_keys_for_decrypt, t4_aes128_ecb_decrypt, NULL)
+T4_CIPHER_DO_AES(t4_cipher_do_aes_192_ecb,
+	t4_aes192_load_keys_for_encrypt, t4_aes192_ecb_encrypt,
+	t4_aes192_load_keys_for_decrypt, t4_aes192_ecb_decrypt, NULL)
+T4_CIPHER_DO_AES(t4_cipher_do_aes_256_ecb,
+	t4_aes256_load_keys_for_encrypt, t4_aes256_ecb_encrypt,
+	t4_aes256_load_keys_for_decrypt, t4_aes256_ecb_decrypt, NULL)
+
+
+/*
+ * Is the t4 engine available?
+ * Passed to ENGINE_set_init_function().
+ */
+/* ARGSUSED */
+static int
+t4_init(ENGINE *e)
+{
+	return (1);
+}
+
+
+/* Passed to ENGINE_set_destroy_function(). */
+/* ARGSUSED */
+static int
+t4_destroy(ENGINE *e)
+{
+	T4_FREE_AES_CTR_NIDS;
+	ERR_unload_t4_strings();
+	return (1);
+}
+
+
+/*
+ * Called by t4_bind_helper().
+ * Note: too early to use T4err() functions on errors.
+ */
+/* ARGSUSED */
+static int
+t4_bind(ENGINE *e)
+{
+	_Bool aes_engage, digest_engage, des_engage, montmul_engage;
+
+	t4_instructions_present(&aes_engage, &des_engage, &digest_engage,
+	    &montmul_engage);
+#ifdef	DEBUG_T4
+	(void) fprintf(stderr,
+	    "t4_bind: engage aes=%d, des=%d, digest=%d\n",
+	    aes_engage, des_engage, digest_engage);
+#endif
+#ifndef	OPENSSL_NO_DES
+	if (!des_engage) { /* Remove DES ciphers from list */
+		t4_cipher_count -= t4_des_cipher_count;
+	}
+#endif
+
+#ifndef	SOLARIS_NO_AES_CTR
+	/*
+	 * We must do this before we start working with slots since we need all
+	 * NIDs there.
+	 */
+	if (aes_engage) {
+		if (t4_add_aes_ctr_NIDs() == 0) {
+			T4_FREE_AES_CTR_NIDS;
+			return (0);
+		}
+	}
+#endif	/* !SOLARIS_NO_AES_CTR */
+
+#ifdef	DEBUG_T4
+	(void) fprintf(stderr, "t4_cipher_count = %d; t4_cipher_nids[] =\n",
+	    t4_cipher_count);
+	for (int i = 0; i < t4_cipher_count; ++i) {
+		(void) fprintf(stderr, " %d", t4_cipher_nids[i]);
+	}
+	(void) fprintf(stderr, "\n");
+#endif	/* DEBUG_T4 */
+
+	/* Register T4 engine ID, name, and functions */
+	if (!ENGINE_set_id(e, ENGINE_T4_ID) ||
+	    !ENGINE_set_name(e,
+	    aes_engage ? ENGINE_T4_NAME: ENGINE_NO_T4_NAME) ||
+	    !ENGINE_set_init_function(e, t4_init) ||
+	    (aes_engage && !ENGINE_set_ciphers(e, t4_get_all_ciphers)) ||
+	    (digest_engage && !ENGINE_set_digests(e, t4_get_all_digests)) ||
+#ifndef OPENSSL_NO_RSA
+	    (montmul_engage && !ENGINE_set_RSA(e, t4_RSA())) ||
+#endif	/* OPENSSL_NO_RSA */
+#ifndef OPENSSL_NO_DH
+	    (montmul_engage && !ENGINE_set_DH(e, t4_DH())) ||
+#endif	/* OPENSSL_NO_DH */
+#ifndef OPENSSL_NO_DSA
+	    (montmul_engage && !ENGINE_set_DSA(e, t4_DSA())) ||
+#endif	/* OPENSSL_NO_DSA */
+	    !ENGINE_set_destroy_function(e, t4_destroy)) {
+		T4_FREE_AES_CTR_NIDS;
+		return (0);
+	}
+
+	return (1);
+}
+
+
+/*
+ * Called by ENGINE_load_t4().
+ * Note: too early to use T4err() functions on errors.
+ */
+static int
+t4_bind_helper(ENGINE *e, const char *id)
+{
+	if (id != NULL && (strcmp(id, ENGINE_T4_ID) != 0)) {
+		(void) fprintf(stderr, "T4: bad t4 engine ID\n");
+		return (0);
+	}
+	if (!t4_bind(e)) {
+		(void) fprintf(stderr,
+		    "T4: failed to bind t4 engine\n");
+		return (0);
+	}
+
+	return (1);
+}
+
+
+#ifdef	DYNAMIC_ENGINE
+IMPLEMENT_DYNAMIC_CHECK_FN()
+IMPLEMENT_DYNAMIC_BIND_FN(t4_bind_helper)
+#endif	/* DYNAMIC_ENGINE */
+#endif	/* COMPILE_HW_T4 */
+#endif	/* !OPENSSL_NO_HW && !OPENSSL_NO_HW_AES_T4 && !OPENSSL_NO_AES */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_aes_asm.h openssl-1.0.1c/crypto/engine/eng_t4_aes_asm.h
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_aes_asm.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_aes_asm.h	2012-05-11 21:34:42.739239000 +0200
@@ -0,0 +1,147 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1999-2007 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef	ENG_T4_AES_ASM_H
+#define	ENG_T4_AES_ASM_H
+
+/*
+ * SPARC AES assembly language functions.
+ *
+ * Based on Solaris file aes_impl.h.
+ */
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && ! defined(OPENSSL_NO_ASM)
+
+extern void t4_aes_expand128(uint64_t *rk, const uint32_t *key);
+extern void t4_aes_expand192(uint64_t *rk, const uint32_t *key);
+extern void t4_aes_expand256(uint64_t *rk, const uint32_t *key);
+extern void t4_aes_encrypt128(const uint64_t *rk, const uint32_t *pt,
+    uint32_t *ct);
+extern void t4_aes_encrypt192(const uint64_t *rk, const uint32_t *pt,
+    uint32_t *ct);
+extern void t4_aes_encrypt256(const uint64_t *rk, const uint32_t *pt,
+    uint32_t *ct);
+extern void t4_aes_decrypt128(const uint64_t *rk, const uint32_t *ct,
+    uint32_t *pt);
+extern void t4_aes_decrypt192(const uint64_t *rk, const uint32_t *ct,
+    uint32_t *pt);
+extern void t4_aes_decrypt256(const uint64_t *rk, const uint32_t *ct,
+    uint32_t *pt);
+extern void t4_aes128_load_keys_for_encrypt(uint64_t *ks);
+extern void t4_aes192_load_keys_for_encrypt(uint64_t *ks);
+extern void t4_aes256_load_keys_for_encrypt(uint64_t *ks);
+extern void t4_aes128_ecb_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *dummy);
+extern void t4_aes192_ecb_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *dummy);
+extern void t4_aes256_ecb_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *dummy);
+extern void t4_aes128_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes192_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes256_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes128_ctr_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes192_ctr_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes256_ctr_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes128_cfb128_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes192_cfb128_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes256_cfb128_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_encrypt, uint64_t *iv);
+extern void t4_aes128_load_keys_for_decrypt(uint64_t *ks);
+extern void t4_aes192_load_keys_for_decrypt(uint64_t *ks);
+extern void t4_aes256_load_keys_for_decrypt(uint64_t *ks);
+extern void t4_aes128_ecb_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *dummy);
+extern void t4_aes192_ecb_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *dummy);
+extern void t4_aes256_ecb_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *dummy);
+extern void t4_aes128_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *iv);
+extern void t4_aes192_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *iv);
+extern void t4_aes256_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *iv);
+extern void t4_aes128_cfb128_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *iv);
+extern void t4_aes192_cfb128_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *iv);
+extern void t4_aes256_cfb128_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_decrypt, uint64_t *iv);
+
+#endif	/* (sun4v||__sparv9||__sparcv8plus||__sparvc8) && !OPENSSL_NO_ASM */
+
+#ifdef	__cplusplus
+}
+#endif
+#endif	/* ENG_T4_AES_ASM_H */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_bignum.h openssl-1.0.1c/crypto/engine/eng_t4_bignum.h
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_bignum.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_bignum.h	2012-05-11 21:34:42.560704000 +0200
@@ -0,0 +1,287 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1999-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * This file is a copy of the ON gate's usr/src/common/bignum/bignum.h file
+ */
+
+#ifndef _BIGNUM_H
+#define	_BIGNUM_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+#if defined(__sparcv9) || defined(__amd64) || defined(__sparc)
+						/* 64-bit chunk size */
+#ifndef UMUL64
+#define	UMUL64	/* 64-bit multiplication results are supported */
+#endif
+#else
+#define	BIGNUM_CHUNK_32
+#endif
+
+
+#define	BITSINBYTE	8
+
+/* Bignum "digits" (aka "chunks" or "words") are either 32- or 64-bits */
+#ifdef BIGNUM_CHUNK_32
+#define	BIG_CHUNK_SIZE		32
+#define	BIG_CHUNK_TYPE		uint32_t
+#define	BIG_CHUNK_TYPE_SIGNED	int32_t
+#define	BIG_CHUNK_HIGHBIT	0x80000000
+#define	BIG_CHUNK_ALLBITS	0xffffffff
+#define	BIG_CHUNK_LOWHALFBITS	0xffff
+#define	BIG_CHUNK_HALF_HIGHBIT	0x8000
+
+#else
+#define	BIG_CHUNK_SIZE		64
+#define	BIG_CHUNK_TYPE		uint64_t
+#define	BIG_CHUNK_TYPE_SIGNED	int64_t
+#define	BIG_CHUNK_HIGHBIT	0x8000000000000000ULL
+#define	BIG_CHUNK_ALLBITS	0xffffffffffffffffULL
+#define	BIG_CHUNK_LOWHALFBITS	0xffffffffULL
+#define	BIG_CHUNK_HALF_HIGHBIT	0x80000000ULL
+#endif
+
+#define	BITLEN2BIGNUMLEN(x)	((x) > 0 ? \
+				((((x) - 1) / BIG_CHUNK_SIZE) + 1) : 0)
+#define	CHARLEN2BIGNUMLEN(x)	((x) > 0 ? \
+				((((x) - 1) / sizeof (BIG_CHUNK_TYPE)) + 1) : 0)
+
+#define	BIGNUM_WORDSIZE	(BIG_CHUNK_SIZE / BITSINBYTE)  /* word size in bytes */
+#define	BIG_CHUNKS_FOR_160BITS	BITLEN2BIGNUMLEN(160)
+
+
+/*
+ * leading 0's are permitted
+ * 0 should be represented by size>=1, size>=len>=1, sign=1,
+ * value[i]=0 for 0<i<len
+ */
+typedef struct {
+	/* size and len in units of BIG_CHUNK_TYPE words  */
+	uint32_t	size;	/* size of memory allocated for value  */
+	uint32_t	len;	/* number of valid data words in value */
+	int		sign;	/* 1 for nonnegative, -1 for negative  */
+	int		malloced; /* 1 if value was malloced, 0 if not */
+	BIG_CHUNK_TYPE *value;
+} BIGNUM;
+
+#define	BIGTMPSIZE 65
+
+#define	BIG_TRUE 1
+#define	BIG_FALSE 0
+
+typedef int BIG_ERR_CODE;
+
+/* error codes */
+#define	BIG_OK 0
+#define	BIG_NO_MEM -1
+#define	BIG_INVALID_ARGS -2
+#define	BIG_DIV_BY_0 -3
+#define	BIG_NO_RANDOM -4
+#define	BIG_GENERAL_ERR	-5
+#define	BIG_TEST_FAILED -6
+#define	BIG_BUFFER_TOO_SMALL -7
+
+/*
+ * this is not an error code, but should be different from possible error codes
+ */
+#define	RND_TEST_VALUE_SUPPLIED	-8
+
+
+#define	arraysize(x) (sizeof (x) / sizeof (x[0]))
+
+typedef BIG_ERR_CODE (*big_modexp_ncp_func_ptr)(BIGNUM *result,
+    BIGNUM *ma, BIGNUM *e, BIGNUM *n,
+    BIGNUM *tmp, BIG_CHUNK_TYPE n0, void *ncp, void *req);
+
+typedef struct {
+	big_modexp_ncp_func_ptr	func;
+	void			*ncp;
+	void 			*reqp;
+} big_modexp_ncp_info_t;
+
+#ifdef YF_MODEXP
+BIG_ERR_CODE big_modexp_ncp_yf(BIGNUM *result, BIGNUM *ma, BIGNUM *e, BIGNUM *n,
+    BIGNUM *tmp, BIG_CHUNK_TYPE n0);
+#endif
+
+#ifdef YF_MONTMUL
+BIG_ERR_CODE big_mont_mul_yf(BIGNUM *ret,
+    BIGNUM *a, BIGNUM *b, BIGNUM *n, BIG_CHUNK_TYPE n0);
+#endif
+
+#ifdef YF_MPMUL
+BIG_ERR_CODE big_mp_mul_yf(BIGNUM *ret, BIGNUM *a, BIGNUM *b);
+void mpmul_arr_yf(uint64_t *res, uint64_t *m1, uint64_t *m2, int len);
+#endif
+
+#ifdef USE_FLOATING_POINT
+void conv_d16_to_i32(uint32_t *i32, double *d16, int64_t *tmp, int ilen);
+void conv_i32_to_d32(double *d32, uint32_t *i32, int len);
+void conv_i32_to_d16(double *d16, uint32_t *i32, int len);
+void conv_i32_to_d32_and_d16(double *d32, double *d16,
+    uint32_t *i32, int len);
+void mont_mulf_noconv(uint32_t *result, double *dm1, double *dm2, double *dt,
+    double *dn, uint32_t *nint, int nlen, double dn0);
+#endif /* USE_FLOATING_POINT */
+
+extern BIGNUM big_One;
+extern BIGNUM big_Two;
+
+void printbignum(char *aname, BIGNUM *a);
+
+BIG_ERR_CODE big_init(BIGNUM *number, int size);
+BIG_ERR_CODE big_extend(BIGNUM *number, int size);
+void big_finish(BIGNUM *number);
+void bytestring2bignum(BIGNUM *bn, uchar_t *kn, size_t len);
+void bignum2bytestring(uchar_t *kn, BIGNUM *bn, size_t len);
+BIG_ERR_CODE big_mont_rr(BIGNUM *result, BIGNUM *n);
+BIG_ERR_CODE big_modexp(BIGNUM *result, BIGNUM *a, BIGNUM *e,
+    BIGNUM *n, BIGNUM *n_rr);
+BIG_ERR_CODE big_modexp_ext(BIGNUM *result, BIGNUM *a, BIGNUM *e,
+    BIGNUM *n, BIGNUM *n_rr, big_modexp_ncp_info_t *info);
+BIG_ERR_CODE big_modexp_crt(BIGNUM *result, BIGNUM *a, BIGNUM *dmodpminus1,
+    BIGNUM *dmodqminus1, BIGNUM *p, BIGNUM *q, BIGNUM *pinvmodq,
+    BIGNUM *p_rr, BIGNUM *q_rr);
+BIG_ERR_CODE big_modexp_crt_ext(BIGNUM *result, BIGNUM *a, BIGNUM *dmodpminus1,
+    BIGNUM *dmodqminus1, BIGNUM *p, BIGNUM *q, BIGNUM *pinvmodq,
+    BIGNUM *p_rr, BIGNUM *q_rr, big_modexp_ncp_info_t *info);
+int big_cmp_abs(BIGNUM *a, BIGNUM *b);
+BIG_ERR_CODE big_random(BIGNUM *r, size_t length,
+    int (*rfunc)(void *, size_t), boolean_t precise);
+BIG_ERR_CODE big_div_pos(BIGNUM *result, BIGNUM *remainder,
+    BIGNUM *aa, BIGNUM *bb);
+BIG_ERR_CODE big_ext_gcd_pos(BIGNUM *gcd, BIGNUM *cm, BIGNUM *ce,
+    BIGNUM *m, BIGNUM *e);
+BIG_ERR_CODE big_add(BIGNUM *result, BIGNUM *aa, BIGNUM *bb);
+BIG_ERR_CODE big_add_abs(BIGNUM *result, BIGNUM *aa, BIGNUM *bb);
+void big_mul_arr_64(uint64_t *result, uint64_t *a, uint64_t *b, int alen);
+BIG_ERR_CODE big_mul(BIGNUM *result, BIGNUM *aa, BIGNUM *bb);
+void big_shiftright(BIGNUM *result, BIGNUM *aa, int offs);
+BIG_ERR_CODE big_nextprime_pos(BIGNUM *result, BIGNUM *n);
+BIG_ERR_CODE big_nextprime_pos_ext(BIGNUM *result, BIGNUM *n,
+    big_modexp_ncp_info_t *info);
+BIG_ERR_CODE big_sub_pos(BIGNUM *result, BIGNUM *aa, BIGNUM *bb);
+BIG_ERR_CODE big_copy(BIGNUM *dest, BIGNUM *src);
+BIG_ERR_CODE big_sub(BIGNUM *result, BIGNUM *aa, BIGNUM *bb);
+int big_bitlength(BIGNUM *n);
+BIG_ERR_CODE big_init1(BIGNUM *number, int size,
+    BIG_CHUNK_TYPE *buf, int bufsize);
+BIG_ERR_CODE big_mont_mul(BIGNUM *ret,
+    BIGNUM *a, BIGNUM *b, BIGNUM *n, BIG_CHUNK_TYPE n0);
+int big_is_zero(BIGNUM *n);
+BIG_CHUNK_TYPE big_n0(BIG_CHUNK_TYPE n);
+
+
+/*
+ * Kernel bignum module: module integrity test
+ */
+extern int	bignum_fips_check(void);
+
+#if defined(HWCAP)
+
+#if (BIG_CHUNK_SIZE != 32)
+#error HWCAP works only with 32-bit bignum chunks
+#endif
+
+#define	BIG_MUL_SET_VEC(r, a, len, digit) \
+	(*big_mul_set_vec_impl)(r, a, len, digit)
+#define	BIG_MUL_ADD_VEC(r, a, len, digit) \
+	(*big_mul_add_vec_impl)(r, a, len, digit)
+#define	BIG_MUL_VEC(r, a, alen, b, blen) \
+	(*big_mul_vec_impl)(r, a, alen, b, blen)
+#define	BIG_SQR_VEC(r, a, len) \
+	(*big_sqr_vec_impl)(r, a, len)
+
+extern BIG_CHUNK_TYPE (*big_mul_set_vec_impl)
+	(BIG_CHUNK_TYPE *r, BIG_CHUNK_TYPE *a, int len, BIG_CHUNK_TYPE digit);
+extern BIG_CHUNK_TYPE (*big_mul_add_vec_impl)
+	(BIG_CHUNK_TYPE *r, BIG_CHUNK_TYPE *a, int len, BIG_CHUNK_TYPE digit);
+extern void (*big_mul_vec_impl)
+	(BIG_CHUNK_TYPE *r, BIG_CHUNK_TYPE *a, int alen, BIG_CHUNK_TYPE *b,
+	    int blen);
+extern void (*big_sqr_vec_impl)
+	(BIG_CHUNK_TYPE *r, BIG_CHUNK_TYPE *a, int len);
+
+#else /* ! HWCAP */
+
+#define	BIG_MUL_SET_VEC(r, a, len, digit) big_mul_set_vec(r, a, len, digit)
+#define	BIG_MUL_ADD_VEC(r, a, len, digit) big_mul_add_vec(r, a, len, digit)
+#define	BIG_MUL_VEC(r, a, alen, b, blen) big_mul_vec(r, a, alen, b, blen)
+#define	BIG_SQR_VEC(r, a, len) big_sqr_vec(r, a, len)
+
+extern BIG_CHUNK_TYPE big_mul_set_vec(BIG_CHUNK_TYPE *r, BIG_CHUNK_TYPE *a,
+    int len, BIG_CHUNK_TYPE d);
+extern BIG_CHUNK_TYPE big_mul_add_vec(BIG_CHUNK_TYPE *r,
+    BIG_CHUNK_TYPE *a, int len, BIG_CHUNK_TYPE d);
+extern void big_mul_vec(BIG_CHUNK_TYPE *r, BIG_CHUNK_TYPE *a, int alen,
+    BIG_CHUNK_TYPE *b, int blen);
+extern void big_sqr_vec(BIG_CHUNK_TYPE *r, BIG_CHUNK_TYPE *a, int len);
+
+#endif /* HWCAP */
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _BIGNUM_H */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_des.c openssl-1.0.1c/crypto/engine/eng_t4_des.c
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_des.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_des.c	2012-05-11 21:34:42.358289000 +0200
@@ -0,0 +1,486 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * This engine supports SPARC microprocessors that provide DES and other
+ * cipher and hash instructions, such as the T4 microprocessor.
+ *
+ * This file implements the DES and DES3 cipher operations.
+ */
+
+#include <openssl/opensslconf.h>
+
+#if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_DES_T4) && \
+	!defined(OPENSSL_NO_DES)
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <openssl/engine.h>
+#include "eng_t4_des_asm.h"
+
+#include "eng_t4_err.c"
+
+/* Index for the supported DES ciphers */
+typedef enum {
+	T4_DES_CBC,
+	T4_DES3_CBC,
+	T4_DES_ECB,
+	T4_DES3_ECB,
+	T4_DES_MAX
+} t4_des_cipher_id;
+
+/* From Solaris file usr/src/common/crypto/des/des_impl.c */
+typedef struct {
+	uint64_t ksch_encrypt[16];
+	uint64_t ksch_decrypt[16];
+} t4_keysched_t;
+
+typedef struct {
+	uint64_t ksch_encrypt[16 * 3];
+	uint64_t ksch_decrypt[16 * 3];
+} t4_keysched3_t;
+
+/* T4 cipher context; must be 8-byte aligned (last field must be uint64_t)  */
+typedef struct t4_des_cipher_ctx {
+	t4_des_cipher_id	index;
+	uint64_t		*iv;
+	uint64_t		aligned_iv_buffer; /* use if IV unaligned */
+	union {
+		t4_keysched_t	des;
+		t4_keysched3_t	des3;
+	} ks;
+} t4_des_cipher_ctx_t;
+
+typedef struct t4_cipher {
+	t4_des_cipher_id	id;
+	int			nid;
+	int			iv_len;
+	int			min_key_len;
+	int			max_key_len;
+} t4_des_cipher_t;
+
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && !defined(OPENSSL_NO_ASM)
+#define	COMPILE_HW_T4
+#endif
+
+#ifdef	COMPILE_HW_T4
+static t4_des_cipher_id get_des_cipher_index_by_nid(int nid);
+#pragma inline(get_des_cipher_index_by_nid)
+
+
+/*
+ * Cipher Table for all supported symmetric ciphers.
+ * Must be in same order as t4_des_cipher_id.
+ */
+static t4_des_cipher_t t4_des_cipher_table[] = {
+	/* ID			NID		IV	min-key	max-key */
+	{T4_DES_CBC,	NID_des_cbc,		8,	8,	8},
+	{T4_DES3_CBC,	NID_des_ede3_cbc,	8,	24,	24},
+	{T4_DES_ECB,	NID_des_ecb,		0,	8,	8},
+	{T4_DES3_ECB,	NID_des_ede3_ecb,	0,	24,	24},
+};
+
+
+/* Formal declaration for functions in EVP_CIPHER structure */
+static int t4_cipher_init_des(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+    const unsigned char *iv, int enc);
+
+static int t4_cipher_do_des_cbc(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_des3_cbc(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_des_ecb(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+static int t4_cipher_do_des3_ecb(EVP_CIPHER_CTX *ctx, unsigned char *out,
+    const unsigned char *in, size_t inl);
+
+
+/*
+ * Cipher Algorithms
+ *
+ * OpenSSL's libcrypto EVP stuff. This is how this engine gets wired to EVP.
+ * EVP_CIPHER is defined in evp.h.  To maintain binary compatibility the
+ * definition cannot be modified.
+ * Stuff specific to the t4 engine is kept in t4_des_cipher_ctx_t, which is
+ * pointed to by cipher_data or md_data
+ *
+ * Fields: nid, block_size, key_len, iv_len, flags,
+ *	init(), do_cipher(), cleanup(),
+ *	ctx_size,
+ *	set_asn1_parameters(), get_asn1_parameters(), ctrl(), app_data
+ */
+
+const EVP_CIPHER t4_des_cbc = {
+	NID_des_cbc,
+	8, 8, 8,
+	EVP_CIPH_CBC_MODE,
+	t4_cipher_init_des, t4_cipher_do_des_cbc, NULL,
+	sizeof (t4_des_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+const EVP_CIPHER t4_des3_cbc = {
+	NID_des_ede3_cbc,
+	8, 24, 8,
+	EVP_CIPH_CBC_MODE,
+	t4_cipher_init_des, t4_cipher_do_des3_cbc, NULL,
+	sizeof (t4_des_cipher_ctx_t),
+	EVP_CIPHER_set_asn1_iv, EVP_CIPHER_get_asn1_iv,
+	NULL, NULL
+};
+
+/*
+ * ECB modes don't use an Initial Vector, so that's why set_asn1_parameters,
+ * get_asn1_parameters, and cleanup fields are set to NULL.
+ */
+const EVP_CIPHER t4_des_ecb = {
+	NID_des_ecb,
+	8, 8, 8,
+	EVP_CIPH_ECB_MODE,
+	t4_cipher_init_des, t4_cipher_do_des_ecb, NULL,
+	sizeof (t4_des_cipher_ctx_t),
+	NULL, NULL, NULL, NULL
+};
+const EVP_CIPHER t4_des3_ecb = {
+	NID_des_ede3_ecb,
+	8, 24, 8,
+	EVP_CIPH_ECB_MODE,
+	t4_cipher_init_des, t4_cipher_do_des3_ecb, NULL,
+	sizeof (t4_des_cipher_ctx_t),
+	NULL, NULL, NULL, NULL
+};
+
+
+/*
+ * DES Cipher functions
+ */
+
+/* Called by t4_cipher_init_des() */
+static t4_des_cipher_id
+get_des_cipher_index_by_nid(int nid)
+{
+	t4_des_cipher_id i;
+
+	for (i = (t4_des_cipher_id)0; i < T4_DES_MAX; ++i)
+		if (t4_des_cipher_table[i].nid == nid)
+			return (i);
+	return (T4_DES_MAX);
+}
+
+
+/*
+ * Initialize encryption and decryption key schedules for DES or DES3.
+ * Called by t4_cipher_init_des().
+ *
+ * Modified from Solaris DES function des_init_keysched().
+ */
+static int
+t4_des_init_keysched(const unsigned char *cipherKey,
+    unsigned int keysize, void *ks)
+{
+	uint64_t *encryption_ks, *decryption_ks;
+	uint64_t keysched[16 * 3];	/* 128 or 384 bytes for DES or DES3 */
+	uint64_t key_uint64[3];		/* 8 or 24 bytes for DES or DES3 */
+	uint64_t *aligned_key;
+	uint64_t tmp;
+	uint_t	i, j;
+
+	switch (keysize) {
+	case 8: /* DES */
+		encryption_ks = ((t4_keysched_t *)ks)->ksch_encrypt;
+		decryption_ks = ((t4_keysched_t *)ks)->ksch_decrypt;
+		break;
+	case 24: /* DES3 */
+		encryption_ks = ((t4_keysched3_t *)ks)->ksch_encrypt;
+		decryption_ks = ((t4_keysched3_t *)ks)->ksch_decrypt;
+		break;
+	default:
+		T4err(T4_F_CIPHER_INIT_DES, T4_R_CIPHER_KEY);
+		return (0);
+	}
+
+	/* Align key, if needed */
+	if (((unsigned long)cipherKey & 0x7) == 0) { /* aligned */
+		/* LINTED: pointer alignment */
+		aligned_key = (uint64_t *)cipherKey;
+	} else { /* unaligned--copy byte-by-byte */
+		for (i = 0, j = 0; j < keysize; ++i, j += 8) {
+			key_uint64[i] = (((uint64_t)cipherKey[j] << 56) |
+			    ((uint64_t)cipherKey[j + 1] << 48) |
+			    ((uint64_t)cipherKey[j + 2] << 40) |
+			    ((uint64_t)cipherKey[j + 3] << 32) |
+			    ((uint64_t)cipherKey[j + 4] << 24) |
+			    ((uint64_t)cipherKey[j + 5] << 16) |
+			    ((uint64_t)cipherKey[j + 6] << 8) |
+			    (uint64_t)cipherKey[j + 7]);
+		}
+		aligned_key = key_uint64;
+	}
+
+	/* Expand key schedule */
+	switch (keysize) {
+	case 8: /* DES */
+		t4_des_expand(keysched, (const uint32_t *)aligned_key);
+		break;
+
+	case 24: /* DES3 */
+		t4_des_expand(keysched, (const uint32_t *)aligned_key);
+		t4_des_expand(keysched + 16,
+		    (const uint32_t *)&aligned_key[1]);
+		for (i = 0; i < 8; ++i) {
+			tmp = keysched[16 + i];
+			keysched[16 + i] = keysched[31 - i];
+			keysched[31 - i] = tmp;
+		}
+		t4_des_expand(keysched + 32,
+		    (const uint32_t *)&aligned_key[2]);
+		break;
+
+	default:
+		T4err(T4_F_CIPHER_INIT_DES, T4_R_CIPHER_KEY);
+		return (0);
+	}
+
+	/* Save encryption key schedule */
+	memcpy(encryption_ks, keysched, keysize * 16);
+
+	/* Reverse key schedule */
+	for (i = 0; i < keysize; ++i) {
+		tmp = keysched[i];
+		keysched[i] = keysched[2 * keysize - 1 - i];
+		keysched[2 * keysize -1 -i] = tmp;
+	}
+
+	/* Save decryption key schedule */
+	memcpy(decryption_ks, keysched, keysize * 16);
+
+	return (1);
+}
+
+
+/* ARGSUSED2 */
+static int
+t4_cipher_init_des(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+    const unsigned char *iv, int enc)
+{
+	t4_des_cipher_ctx_t	*tctx = ctx->cipher_data;
+	uint64_t		*encryption_ks, *decryption_ks;
+	t4_des_cipher_t		*t4_cipher;
+	t4_des_cipher_id	index;
+	unsigned int		key_len = ctx->key_len;
+	uint64_t		aligned_key_buffer[3]; /* 8 or 24 bytes long */
+	uint64_t		*aligned_key;
+
+	if (key == NULL) {
+		T4err(T4_F_CIPHER_INIT_DES, T4_R_CIPHER_KEY);
+		return (0);
+	}
+
+	/* Get the cipher entry index in t4_des_cipher_table from nid */
+	index = get_des_cipher_index_by_nid(ctx->cipher->nid);
+	if (index >= T4_DES_MAX) {
+		T4err(T4_F_CIPHER_INIT_DES, T4_R_CIPHER_NID);
+		return (0); /* Error */
+	}
+	t4_cipher = &t4_des_cipher_table[index];
+
+	/* Check key size and iv size */
+	if (ctx->cipher->iv_len < t4_cipher->iv_len) {
+		T4err(T4_F_CIPHER_INIT_DES, T4_R_IV_LEN_INCORRECT);
+		return (0); /* Error */
+	}
+	if ((key_len < t4_cipher->min_key_len) ||
+	    (key_len > t4_cipher->max_key_len)) {
+		T4err(T4_F_CIPHER_INIT_DES, T4_R_KEY_LEN_INCORRECT);
+		return (0); /* Error */
+	}
+
+	/* Expand key schedule */
+	if (t4_des_init_keysched(key, key_len, &tctx->ks) == 0)
+		return (0); /* Error */
+
+	/* Save index to cipher */
+	tctx->index = index;
+
+	/* Align IV, if needed */
+	if (t4_cipher->iv_len <= 0) { /* no IV (such as with ECB mode) */
+		tctx->iv = NULL;
+	} else if (((unsigned long)ctx->iv & 0x7) == 0) { /* already aligned */
+		tctx->iv = (uint64_t *)ctx->iv;
+	} else {
+		/* IV is not 8 byte aligned */
+		(void) memcpy(&tctx->aligned_iv_buffer, ctx->iv,
+		    ctx->cipher->iv_len);
+		tctx->iv = &tctx->aligned_iv_buffer;
+#ifdef	DEBUG_T4
+		(void) fprintf(stderr,
+		    "t4_cipher_init_des: IV is not 8 byte aligned\n");
+		(void) fprintf(stderr,
+		    "t4_cipher_init_des: ctx->cipher->iv_len =%d\n",
+		    ctx->cipher->iv_len);
+		(void) fprintf(stderr, "t4_cipher_init_des: after "
+		    "re-alignment, tctx->iv = %p\n", (void *)tctx->iv);
+#endif	/* DEBUG_T4 */
+	}
+
+	return (1);
+}
+
+
+/*
+ * ENCRYPT_UPDATE or DECRYPT_UPDATE
+ */
+#define	T4_CIPHER_DO_DES(t4_cipher_do_des, t4_des_load_keys,		\
+    t4_des_encrypt, t4_des_decrypt, ksched_encrypt, ksched_decrypt, iv)	\
+static int								\
+t4_cipher_do_des(EVP_CIPHER_CTX *ctx, unsigned char *out,		\
+    const unsigned char *in, size_t inl)				\
+{									\
+	t4_des_cipher_ctx_t	*tctx = ctx->cipher_data;		\
+	unsigned long	outl = inl;					\
+	unsigned char	*bufin_alloc = NULL, *bufout_alloc = NULL;	\
+	unsigned char	*bufin, *bufout;				\
+									\
+	/* "in" and "out" must be 8 byte aligned */			\
+	if (((unsigned long)in & 0x7) == 0) { /* already aligned */	\
+		bufin = (unsigned char *)in;				\
+	} else { /* "in" is not 8 byte aligned */			\
+		if (((unsigned long)out & 0x7) == 0) { /* aligned */	\
+			/* use output buffer for input */		\
+			bufin = out;					\
+		} else {						\
+			bufin = bufin_alloc = OPENSSL_malloc(inl);	\
+			if (bufin_alloc == NULL)			\
+				return (0); /* error */			\
+		}							\
+		(void) memcpy(bufin, in, inl);				\
+	}								\
+									\
+	/* Data length must be an even multiple of block size. */	\
+	if ((inl & 0x7) != 0) {						\
+		OPENSSL_free(bufout_alloc);				\
+		OPENSSL_free(bufin_alloc);				\
+		T4err(T4_F_CIPHER_DO_DES, T4_R_NOT_BLOCKSIZE_LENGTH);	\
+		return (0);						\
+	}								\
+									\
+	if (((unsigned long)out & 0x7) == 0) { /* already aligned */	\
+		bufout = out;						\
+	} else { /* "out" is not 8 byte aligned */			\
+		if (bufin_alloc != NULL) {				\
+			/* use allocated input buffer for output */	\
+			bufout = bufin_alloc;				\
+		} else {						\
+			bufout = bufout_alloc = OPENSSL_malloc(outl);	\
+			if (bufout_alloc == NULL) {			\
+				OPENSSL_free(bufin_alloc);		\
+				return (0); /* error */			\
+			}						\
+		}							\
+	}								\
+									\
+	if (ctx->encrypt) {						\
+		uint64_t	*ksch_encrypt = ksched_encrypt;		\
+		t4_des_load_keys(ksch_encrypt);				\
+		t4_des_encrypt(ksch_encrypt, (uint64_t *)bufin,		\
+		    (uint64_t *)bufout, (size_t)inl, iv);		\
+	} else { /* decrypt */						\
+		uint64_t	*ksch_decrypt = ksched_decrypt;		\
+		t4_des_load_keys(ksch_decrypt);				\
+		t4_des_decrypt(ksch_decrypt, (uint64_t *)bufin,		\
+		    (uint64_t *)bufout, (size_t)inl, iv);		\
+	}								\
+									\
+	/* Cleanup */							\
+	if (bufin_alloc != NULL) {					\
+		if (bufout == bufin_alloc)				\
+			(void) memcpy(out, bufout, outl);		\
+		OPENSSL_free(bufin_alloc);				\
+	}								\
+	if (bufout_alloc != NULL) {					\
+		(void) memcpy(out, bufout_alloc, outl);			\
+		OPENSSL_free(bufout_alloc);				\
+	}								\
+									\
+	return (1);							\
+}
+
+
+/* DES CBC mode. */
+T4_CIPHER_DO_DES(t4_cipher_do_des_cbc, t4_des_load_keys,
+	t4_des_cbc_encrypt, t4_des_cbc_decrypt,
+	tctx->ks.des.ksch_encrypt, tctx->ks.des.ksch_decrypt, tctx->iv)
+T4_CIPHER_DO_DES(t4_cipher_do_des3_cbc, t4_des3_load_keys,
+	t4_des3_cbc_encrypt, t4_des3_cbc_decrypt,
+	tctx->ks.des3.ksch_encrypt, tctx->ks.des3.ksch_decrypt, tctx->iv)
+
+/* DES ECB mode. */
+T4_CIPHER_DO_DES(t4_cipher_do_des_ecb, t4_des_load_keys,
+	t4_des_ecb_crypt, t4_des_ecb_crypt,
+	tctx->ks.des.ksch_encrypt, tctx->ks.des.ksch_decrypt, NULL)
+T4_CIPHER_DO_DES(t4_cipher_do_des3_ecb, t4_des3_load_keys,
+	t4_des3_ecb_crypt, t4_des3_ecb_crypt,
+	tctx->ks.des3.ksch_encrypt, tctx->ks.des3.ksch_decrypt, NULL)
+
+
+#endif	/* COMPILE_HW_T4 */
+#endif	/* !OPENSSL_NO_HW && !OPENSSL_NO_HW_DES_T4 && !OPENSSL_NO_DES */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_des_asm.h openssl-1.0.1c/crypto/engine/eng_t4_des_asm.h
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_des_asm.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_des_asm.h	2012-05-11 21:34:42.108476000 +0200
@@ -0,0 +1,98 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef	ENG_T4_DES_ASM_H
+#define	ENG_T4_DES_ASM_H
+
+/* SPARC DES assembly language functions.  */
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && ! defined(OPENSSL_NO_ASM)
+
+extern void t4_des_expand(uint64_t *rk, const uint32_t *key);
+extern void t4_des_encrypt(const uint64_t *rk, const uint64_t *pt,
+    uint64_t *ct);
+extern void t4_des_load_keys(uint64_t *ks);
+void t4_des_ecb_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv);
+extern void t4_des_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv);
+extern void t4_des_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv);
+extern void t4_des3_load_keys(uint64_t *ks);
+extern void t4_des3_ecb_crypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv);
+extern void t4_des3_cbc_encrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv);
+extern void t4_des3_cbc_decrypt(uint64_t *ks, uint64_t *asm_in,
+    uint64_t *asm_out, size_t amount_to_crypt, uint64_t *iv);
+
+
+#endif	/* (sun4v||__sparv9||__sparcv8plus||__sparvc8) && !OPENSSL_NO_ASM */
+
+#ifdef	__cplusplus
+}
+#endif
+#endif	/* ENG_T4_DES_ASM_H */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_err.c openssl-1.0.1c/crypto/engine/eng_t4_err.c
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_err.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_err.c	2012-05-11 21:34:41.956986000 +0200
@@ -0,0 +1,157 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#include <openssl/err.h>
+#include "eng_t4_err.h"
+
+/* BEGIN ERROR CODES */
+
+#ifndef	OPENSSL_NO_ERR
+
+#define	ERR_FUNC(func)		ERR_PACK(0, func, 0)
+#define	ERR_REASON(reason)	ERR_PACK(0, 0, reason)
+
+static ERR_STRING_DATA t4_str_functs[] = {
+	{ERR_FUNC(T4_F_INIT),			"T4_INIT"},
+	{ERR_FUNC(T4_F_DESTROY),		"T4_DESTROY"},
+	{ERR_FUNC(T4_F_FINISH),			"T4_FINISH"},
+	{ERR_FUNC(T4_F_CIPHER_INIT_AES),	"T4_CIPHER_INIT_AES"},
+	{ERR_FUNC(T4_F_ADD_NID),		"T4_ADD_NID"},
+	{ERR_FUNC(T4_F_GET_ALL_CIPHERS),	"T4_GET_ALL_CIPHERS"},
+	{ERR_FUNC(T4_F_CIPHER_DO_AES),		"T4_CIPHER_DO_AES"},
+	{ERR_FUNC(T4_F_CIPHER_CLEANUP),		"T4_CIPHER_CLEANUP"},
+	{ERR_FUNC(T4_F_CIPHER_INIT_DES),	"T4_CIPHER_INIT_DES"},
+	{ERR_FUNC(T4_F_CIPHER_DO_DES),		"T4_CIPHER_DO_DES"},
+	{0, NULL}
+};
+
+static ERR_STRING_DATA t4_str_reasons[] = {
+	{ERR_REASON(T4_R_CIPHER_KEY),		"invalid cipher key"},
+	{ERR_REASON(T4_R_CIPHER_NID),		"invalid cipher NID"},
+	{ERR_REASON(T4_R_IV_LEN_INCORRECT),	"IV length incorrect"},
+	{ERR_REASON(T4_R_KEY_LEN_INCORRECT),	"key length incorrect"},
+	{ERR_REASON(T4_R_ASN1_OBJECT_CREATE),	"ASN1_OBJECT_create failed"},
+	{ERR_REASON(T4_R_NOT_BLOCKSIZE_LENGTH),	"blocksize length not even"},
+	{0, NULL}
+};
+#endif	/* OPENSSL_NO_ERR */
+
+
+#ifdef T4_LIB_NAME
+static ERR_STRING_DATA T4_lib_name[] = {
+	{0, T4_LIB_NAME},
+	{0, NULL}
+};
+#endif
+
+static int t4_error_code = 0;
+static int t4_error_init = 1;
+
+
+static void
+ERR_load_t4_strings(void)
+{
+	if (t4_error_code == 0)
+		t4_error_code = ERR_get_next_error_library();
+
+	if (t4_error_init != 0) {
+		t4_error_init = 0;
+
+#ifndef OPENSSL_NO_ERR
+		ERR_load_strings(t4_error_code, t4_str_functs);
+		ERR_load_strings(t4_error_code, t4_str_reasons);
+#endif
+
+#ifdef T4_LIB_NAME
+		T4_lib_name->error =
+		    ERR_PACK(t4_error_code, 0, 0);
+		ERR_load_strings(0, T4_lib_name);
+#endif
+	}
+}
+
+
+static void
+ERR_unload_t4_strings(void)
+{
+	if (t4_error_init == 0) {
+#ifndef OPENSSL_NO_ERR
+		ERR_unload_strings(t4_error_code, t4_str_functs);
+		ERR_unload_strings(t4_error_code, t4_str_reasons);
+#endif
+
+#ifdef T4_LIB_NAME
+		ERR_unload_strings(0, T4_lib_name);
+#endif
+		t4_error_init = 1;
+	}
+}
+
+
+static void
+ERR_t4_error(int function, int reason, char *file, int line)
+{
+	if (t4_error_init != 0) {
+		ERR_load_t4_strings();
+	}
+
+	if (t4_error_code == 0)
+		t4_error_code = ERR_get_next_error_library();
+	ERR_PUT_error(t4_error_code, function, reason, file, line);
+}
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_err.h openssl-1.0.1c/crypto/engine/eng_t4_err.h
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_err.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_err.h	2012-05-11 21:34:41.799811000 +0200
@@ -0,0 +1,97 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef	ENG_T4_ERR_H
+#define	ENG_T4_ERR_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+static void ERR_unload_t4_strings(void);
+#pragma inline(ERR_unload_t4_strings)
+static void ERR_t4_error(int function, int reason, char *file, int line);
+
+#define	T4err(f, r)	ERR_t4_error((f), (r), __FILE__, __LINE__)
+
+/* Function codes */
+#define	T4_F_INIT 				100
+#define	T4_F_DESTROY 				101
+#define	T4_F_FINISH				102
+#define	T4_F_CIPHER_INIT_AES			103
+#define	T4_F_ADD_NID				104
+#define	T4_F_GET_ALL_CIPHERS			105
+#define	T4_F_CIPHER_DO_AES			106
+#define	T4_F_CIPHER_CLEANUP			107
+#define	T4_F_CIPHER_INIT_DES			108
+#define	T4_F_CIPHER_DO_DES			109
+
+/* Reason codes */
+#define	T4_R_CIPHER_KEY				100
+#define	T4_R_CIPHER_NID				101
+#define	T4_R_IV_LEN_INCORRECT			102
+#define	T4_R_KEY_LEN_INCORRECT			103
+#define	T4_R_ASN1_OBJECT_CREATE			104
+#define	T4_R_NOT_BLOCKSIZE_LENGTH		105
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* ENG_T4_ERR_H */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_md5.c openssl-1.0.1c/crypto/engine/eng_t4_md5.c
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_md5.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_md5.c	2012-05-11 21:34:41.653669000 +0200
@@ -0,0 +1,207 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/). This
+ * product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * This engine supports SPARC microprocessors that provide AES and other
+ * cipher and hash instructions, such as the T4 microprocessor.
+ *
+ * This file implements the MD5 message digest operations.
+ */
+
+#include <openssl/opensslconf.h>
+
+#if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_MD_T4)
+#ifndef	OPENSSL_NO_MD5
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include <openssl/aes.h>
+#include <openssl/engine.h>
+/*
+ * Solaris sys/md5.h and OpenSSL openssl/md5.h both define MD5_CTX.
+ * The OpenSSL MD5_CTX has an extra "num" field at the end.
+ */
+#include <openssl/md5.h>
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && !defined(OPENSSL_NO_ASM)
+#define	COMPILE_HW_T4
+#endif
+
+#ifdef	COMPILE_HW_T4
+
+/* Assembly language function; replaces C function md5_block_data_order(): */
+extern void t4_md5_multiblock(MD5_CTX *ctx, const uint8_t *input,
+    unsigned int input_length_in_blocks);
+
+/* Formal declaration for functions in EVP_MD structure */
+int t4_digest_init_md5(EVP_MD_CTX *ctx);
+int t4_digest_update_md5(EVP_MD_CTX *ctx, const void *data, size_t count);
+int t4_digest_final_md5(EVP_MD_CTX *ctx, unsigned char *md);
+int t4_digest_copy_md5(EVP_MD_CTX *to, const EVP_MD_CTX *from);
+
+
+/*
+ * MD5 Message Digests
+ *
+ * OpenSSL's libcrypto EVP stuff. This is how this engine gets wired to EVP.
+ * EVP_MD is defined in evp.h.  To maintain binary compatibility the
+ * definition cannot be modified.
+ * Stuff specific to the t4 engine is kept in t4_cipher_ctx_t, which is
+ * pointed to by the last field, app_data.
+ *
+ * Fields: type, pkey_type, md_size, flags,
+ *	init(), update(), final(),
+ *	copy(), cleanup(), sign(), verify(),
+ *	required_pkey_type, block_size, ctx_size, md5_ctrl()
+ */
+const EVP_MD t4_md5 = {
+	NID_md5, NID_md5WithRSAEncryption, MD5_DIGEST_LENGTH,
+	0,
+	t4_digest_init_md5, t4_digest_update_md5, t4_digest_final_md5,
+	t4_digest_copy_md5, NULL,
+	EVP_PKEY_RSA_method, MD5_CBLOCK,
+	sizeof (MD5_CTX), NULL
+	};
+
+/* These functions are implemented in md32_common.h: */
+static int t4_md5_update(MD5_CTX *c, const void *data_, size_t len);
+static void t4_md5_transform(MD5_CTX *c, const unsigned char *data);
+static int t4_md5_final(unsigned char *md, MD5_CTX *c);
+#pragma inline(t4_md5_update, t4_md5_transform, t4_md5_final)
+
+#define	DATA_ORDER_IS_LITTLE_ENDIAN
+/* HASH_LONG/MD5_LONG is a 32-bit unsigned: */
+#define	HASH_LONG		MD5_LONG
+#define	HASH_CTX		MD5_CTX
+#define	HASH_CBLOCK		MD5_CBLOCK
+#define	HASH_UPDATE		t4_md5_update
+#define	HASH_TRANSFORM		t4_md5_transform
+#define	HASH_FINAL		t4_md5_final
+#define	HASH_BLOCK_DATA_ORDER	t4_md5_multiblock
+/* HOST_l2c_t4: Hash is already byte-swapped as Little Endian for SPARC T4: */
+#define	HOST_l2c_t4(l, c)	(*((unsigned int *)(c)) = (l), (c) += 4, l)
+#define	HASH_MAKE_STRING(c, s)	do {	\
+		unsigned int ll;		\
+		ll = (c)->A; HOST_l2c_t4(ll, (s));	\
+		ll = (c)->B; HOST_l2c_t4(ll, (s));	\
+		ll = (c)->C; HOST_l2c_t4(ll, (s));	\
+		ll = (c)->D; HOST_l2c_t4(ll, (s));	\
+	} while (0)
+
+/* This defines HASH_UPDATE, HASH_TRANSFORM, HASH_FINAL functions: */
+#include "md32_common.h"
+
+
+/*
+ * MD5 functions (RFC 1321 The MD5 Message-Digest Algorithm)
+ */
+
+int
+t4_digest_init_md5(EVP_MD_CTX *ctx)
+{
+	MD5_CTX	*c = (MD5_CTX *)ctx->md_data;
+
+	/* Optimization: don't call memset(c, 0,...) or initialize c->data[] */
+	c->Nl = c->Nh = c->num = 0;
+
+	/* Big Endian for T4 */
+	c->A = 0x01234567U;
+	c->B = 0x89abcdefU;
+	c->C = 0xfedcba98U;
+	c->D = 0x76543210U;
+
+	return (1);
+}
+
+/*
+ * Continue MD5 digest operation, using the message block to update context.
+ * MD5 crunches in 64-byte blocks.
+ */
+int
+t4_digest_update_md5(EVP_MD_CTX *ctx, const void *data, size_t len)
+{
+	return (t4_md5_update((MD5_CTX *)ctx->md_data, data, len));
+}
+
+/* End MD5 digest operation, finalizing message digest and zeroing context. */
+int
+t4_digest_final_md5(EVP_MD_CTX *ctx, unsigned char *md)
+{
+	return (t4_md5_final(md, (MD5_CTX *)ctx->md_data));
+}
+
+/* Required for Engine API */
+int
+t4_digest_copy_md5(EVP_MD_CTX *to, const EVP_MD_CTX *from)
+{
+	if ((to->md_data != NULL) && (from->md_data != NULL)) {
+		(void) memcpy(to->md_data, from->md_data, sizeof (MD5_CTX));
+	}
+	return (1);
+}
+
+#endif	/* COMPILE_HW_T4 */
+#endif	/* !OPENSSL_NO_MD5 */
+#endif	/* !OPENSSL_NO_HW && !OPENSSL_NO_HW_MD_T4 */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_montmul.c openssl-1.0.1c/crypto/engine/eng_t4_montmul.c
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_montmul.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_montmul.c	2012-05-11 21:34:41.476308000 +0200
@@ -0,0 +1,459 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1999-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * This engine supports SPARC microprocessors that provide AES and other
+ * cipher and hash instructions, such as the T4 microprocessor.
+ *
+ * This file implements the RSA, DSA, and DH operations.
+ */
+
+#include <openssl/opensslconf.h>
+
+#define	BIGNUM SOLARIS_BIGNUM
+#include "eng_t4_bignum.h"
+#undef BIGNUM
+
+
+#if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_MONTMUL_T4)
+#include <sys/types.h>
+#include <sys/auxv.h>		/* getisax() */
+#include <sys/sysmacros.h>	/* IS_P2ALIGNED() */
+#include <sys/byteorder.h>	/* htonl() and friends */
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#ifndef OPENSSL_NO_RSA
+#include <openssl/rsa.h>
+#endif	/* !OPENSSL_NO_RSA */
+
+#ifndef OPENSSL_NO_DSA
+#include <openssl/dsa.h>
+#endif	/* !OPENSSL_NO_DSA */
+
+#ifndef OPENSSL_NO_DH
+#include <openssl/dh.h>
+#endif	/* !OPENSSL_NO_DH */
+
+#include <openssl/bio.h>
+#include <openssl/aes.h>
+#include <openssl/engine.h>
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && !defined(OPENSSL_NO_ASM)
+#define	COMPILE_HW_T4
+#endif
+
+#ifdef	COMPILE_HW_T4
+
+#if !(defined(OPENSSL_NO_RSA) && defined(OPENSSL_NO_DSA) && \
+	defined(OPENSSL_NO_DH))
+
+
+/*
+ * Convert OpenSSL's BIGNUM to Solaris's BIGNUM....
+ * It assumes that the Solaris BIGNUM has enough space
+ */
+static void
+bn2solbn(const BIGNUM *src, SOLARIS_BIGNUM *dst)
+{
+	int	i, j;
+
+	if (BN_BITS2 < BIG_CHUNK_SIZE) {
+		for (i = 0, j = 0; i < src->top; i++) {
+			if ((i & 1) == 0) {
+				dst->value[j] = src->d[i];
+			} else {
+				dst->value[j] += ((uint64_t)(src->d[i])) << 32;
+				j++;
+			}
+		}
+		dst->len = (src->top + 1) / 2;
+		dst->sign = (src->neg == 1) ? -1 : 1;
+	} else if (BN_BITS2 == BIG_CHUNK_SIZE) {
+		(void) memcpy(dst->value, src->d, src->top);
+		dst->len = src->top;
+		dst->sign = (src->neg == 1) ? -1 : 1;
+	} else { /* BN_BITS2 > BIG_CHUNK_SIZE */
+		for (i = 0, j = 0; i < src->top; i++) {
+			dst->value[j++] = src->d[i] & 0xffffffffULL;
+			dst->value[j++] = ((uint64_t)(src->d[i])) >> 32;
+		}
+		dst->len = src->top * 2;
+		if (dst->value[dst->len - 1] == 0) {
+			dst->len--;
+		}
+		dst->sign = (src->neg == 1) ? -1 : 1;
+	}
+}
+
+/*
+ * It assumes that OpenSSL's BIGNUM has enough space.
+ */
+static void
+solbn2bn(const SOLARIS_BIGNUM *src, BIGNUM *dst)
+{
+	int	i, j;
+
+	if (BN_BITS2 < BIG_CHUNK_SIZE) {
+		for (i = 0, j = 0; i < src->len; i++) {
+			dst->d[j++] = src->value[i] & 0xffffffffULL;
+			dst->d[j++] = ((uint64_t)(src->value[i])) >> 32;
+		}
+		dst->top = src->len * 2;
+		if (dst->d[dst->top - 1] == 0) {
+			dst->top--;
+		}
+		dst->neg = (src->sign == -1) ? 1 : 0;
+	} else if (BN_BITS2 == BIG_CHUNK_SIZE) {
+		(void) memcpy(src->value, dst->d, src->len);
+		dst->top = src->len;
+		dst->neg = (src->sign == -1) ? 1 : 0;
+	} else { /* BN_BITS2 > BIG_CHUNK_SIZE */
+		for (i = 0, j = 0; i < src->len; i++) {
+			if ((i & 1) == 0) {
+				dst->d[j] = src->value[i];
+			} else {
+				dst->d[j] += ((uint64_t)(src->value[i])) << 32;
+				j++;
+			}
+		}
+		dst->top = (src->len + 1) / 2;
+		dst->neg =  (src->sign == -1) ? 1 : 0;
+	}
+}
+
+
+
+static int
+t4_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
+    BN_CTX *ctx, BN_MONT_CTX *m_ctx)
+{
+	int		rv = 0;
+	SOLARIS_BIGNUM	sol_r = {0};
+	SOLARIS_BIGNUM	sol_a = {0};
+	SOLARIS_BIGNUM	sol_p = {0};
+	SOLARIS_BIGNUM	sol_m = {0};
+
+	if (big_init(&sol_r, (m->top + 3) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_a, (a->top + 1) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_p, (p->top + 1) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_m, (m->top + 1) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+
+	bn2solbn(a, &sol_a);
+	bn2solbn(p, &sol_p);
+	bn2solbn(m, &sol_m);
+
+	/* calls libsoftcrypto's big_modexp() routine */
+	if (big_modexp(&sol_r, &sol_a, &sol_p, &sol_m, NULL) != BIG_OK) {
+		goto cleanup;
+	}
+
+	if (bn_wexpand(r, m->top + 2) == NULL) {
+		goto cleanup;
+	}
+	solbn2bn(&sol_r, r);
+
+	rv = 1;
+
+cleanup:
+
+	big_finish(&sol_m);
+	big_finish(&sol_p);
+	big_finish(&sol_a);
+	big_finish(&sol_r);
+
+	return (rv);
+}
+
+#endif	/* !(OPENSSL_NO_RSA && OPENSSL_NO_DSA) */
+
+#ifndef OPENSSL_NO_RSA
+
+/* Our internal RSA_METHOD that we provide pointers to */
+static RSA_METHOD t4_rsa =
+{
+	"Oracle T4 RSA method",
+	NULL,			/* rsa_pub_encrypt */
+	NULL,			/* rsa_pub_decrypt */
+	NULL,			/* rsa_priv_encrypt */
+	NULL,			/* rsa_priv_decrypt */
+	NULL,			/* rsa_mod_exp */
+	t4_bn_mod_exp,		/* bn_mod_exp */
+	NULL,			/* init */
+	NULL,			/* finish */
+	RSA_FLAG_CACHE_PUBLIC | RSA_FLAG_CACHE_PRIVATE | RSA_FLAG_NO_BLINDING,
+				/* flags  */
+	NULL,			/* app_data */
+	NULL,			/* rsa_sign */
+	NULL,			/* rsa_verify */
+	/* Internal rsa_keygen will be used if this is NULL. */
+	NULL			/* rsa_keygen */
+};
+
+RSA_METHOD *
+t4_RSA(void)
+{
+	const RSA_METHOD *meth1;
+
+	meth1 = RSA_PKCS1_SSLeay();
+	t4_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
+	t4_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
+	t4_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
+	t4_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
+	t4_rsa.rsa_mod_exp = meth1->rsa_mod_exp;
+	t4_rsa.finish = meth1->finish;
+
+	return (&t4_rsa);
+}
+
+#endif /* !OPENSSL_NO_RSA */
+
+
+#ifndef OPENSSL_NO_DSA
+
+static int
+t4_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,
+    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
+{
+	return (t4_bn_mod_exp(r, a, p, m, ctx, m_ctx));
+}
+
+
+static int
+t4_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,
+    BIGNUM *a2, BIGNUM *p2, BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
+{
+	int		rv = 0;
+	SOLARIS_BIGNUM	sol_rr = {0};
+	SOLARIS_BIGNUM	sol_a1 = {0};
+	SOLARIS_BIGNUM	sol_p1 = {0};
+	SOLARIS_BIGNUM	sol_a2 = {0};
+	SOLARIS_BIGNUM	sol_p2 = {0};
+	SOLARIS_BIGNUM	sol_m = {0};
+	SOLARIS_BIGNUM	sol_tmp = {0};
+
+	if (big_init(&sol_rr, (m->top + 3) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_a1, (a1->top + 1) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_p1, (p1->top + 1) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_a2, (a2->top + 1) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_p2, (p2->top + 1) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_m, (m->top + 1) * BN_BITS2 / BIG_CHUNK_SIZE) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+	if (big_init(&sol_tmp, 2 * sol_m.len + 1) != BIG_OK) {
+		goto cleanup;
+	}
+
+	if (big_init(&sol_tmp, 2 * sol_m.len + 1) != BIG_OK) {
+		goto cleanup;
+	}
+
+	bn2solbn(a1, &sol_a1);
+	bn2solbn(p1, &sol_p1);
+	bn2solbn(a2, &sol_a2);
+	bn2solbn(p2, &sol_p2);
+	bn2solbn(m, &sol_m);
+
+
+	/* calls libsoftcrypto's big_modexp() routine */
+	if (big_modexp(&sol_rr, &sol_a1, &sol_p1, &sol_m, NULL) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+
+	if (big_modexp(&sol_tmp, &sol_a2, &sol_p2, &sol_m, NULL) !=
+	    BIG_OK) {
+		goto cleanup;
+	}
+
+	if (big_mul(&sol_tmp, &sol_rr, &sol_tmp) != BIG_OK) {
+		goto cleanup;
+	}
+
+	if (big_div_pos(NULL, &sol_rr, &sol_tmp, &sol_m) != BIG_OK) {
+		goto cleanup;
+	}
+
+	if (bn_wexpand(rr, m->top + 2) == NULL) {
+		goto cleanup;
+	}
+	solbn2bn(&sol_rr, rr);
+
+	rv = 1;
+
+cleanup:
+
+	big_finish(&sol_tmp);
+	big_finish(&sol_m);
+	big_finish(&sol_p2);
+	big_finish(&sol_a2);
+	big_finish(&sol_p1);
+	big_finish(&sol_a1);
+	big_finish(&sol_rr);
+
+	return (rv);
+}
+
+/* Our internal DSA_METHOD that we provide pointers to */
+static DSA_METHOD t4_dsa =
+{
+	"Oracle T4 DSA method",	/* name */
+	NULL,			/* dsa_do_sign */
+	NULL,			/* dsa_sign_setup */
+	NULL,			/* dsa_do_verify */
+	t4_dsa_mod_exp,		/* dsa_mod_exp, */
+	t4_dsa_bn_mod_exp,	/* bn_mod_exp, */
+	NULL,			/* init */
+	NULL,			/* finish */
+	NULL,			/* flags */
+	NULL,			/* app_data */
+	NULL,			/* dsa_paramgen */
+	NULL			/* dsa_keygen */
+};
+
+DSA_METHOD *
+t4_DSA(void)
+{
+	const DSA_METHOD *meth1;
+
+	meth1 = DSA_OpenSSL();
+	t4_dsa.dsa_do_sign = meth1->dsa_do_sign;
+	t4_dsa.dsa_sign_setup = meth1->dsa_sign_setup;
+	t4_dsa.dsa_do_verify = meth1->dsa_do_verify;
+	t4_dsa.finish = meth1->finish;
+
+	return (&t4_dsa);
+}
+
+#endif /* !OPENSSL_NO_DSA */
+
+
+#ifndef OPENSSL_NO_DH
+
+static int
+t4_dh_bn_mod_exp(const DH *dh, BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
+{
+	return (t4_bn_mod_exp(r, a, p, m, ctx, m_ctx));
+}
+
+
+
+/* Our internal DH_METHOD that we provide pointers to */
+static DH_METHOD t4_dh =
+{
+	"Oracle T4 DH method",	/* name */
+	NULL,			/* generate_key */
+	NULL,			/* compute_key */
+	t4_dh_bn_mod_exp,	/* bn_mod_exp, */
+	NULL,			/* init */
+	NULL,			/* finish */
+	NULL,			/* flags */
+	NULL			/* app_data */
+};
+
+DH_METHOD *
+t4_DH(void)
+{
+	const DH_METHOD *meth1;
+
+	meth1 = DH_OpenSSL();
+	t4_dh.generate_key = meth1->generate_key;
+	t4_dh.compute_key = meth1->compute_key;
+	t4_dh.finish = meth1->finish;
+
+	return (&t4_dh);
+}
+
+#endif /* !OPENSSL_NO_DH */
+
+#endif	/* COMPILE_HW_T4 */
+
+#endif	/* !OPENSSL_NO_HW && !OPENSSL_NO_HW_MONTMUL_T4 */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_sha1.c openssl-1.0.1c/crypto/engine/eng_t4_sha1.c
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_sha1.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_sha1.c	2012-05-11 21:34:41.169880000 +0200
@@ -0,0 +1,197 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/). This
+ * product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * This engine supports SPARC microprocessors that provide AES and other
+ * cipher and hash instructions, such as the T4 microprocessor.
+ *
+ * This file implements the SHA-1 message digest operations.
+ */
+
+#include <openssl/opensslconf.h>
+
+#if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_MD_T4)
+#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+/*
+ * For SHA1, OpenSSL SHA_CTX has an extra num field at the end,
+ * while the Solaris SHA1_CTX does not have this field.
+ */
+#include <openssl/engine.h>
+#include <openssl/sha.h>
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && !defined(OPENSSL_NO_ASM)
+#define	COMPILE_HW_T4
+#endif
+
+#ifdef	COMPILE_HW_T4
+
+/* Assembly language function; replaces C function sha1_block_data_order(): */
+extern void t4_sha1_multiblock(SHA_CTX *ctx, const void *input, size_t num);
+
+/* Formal declaration for functions in EVP_MD structure */
+static int t4_digest_init_sha1(EVP_MD_CTX *ctx);
+static int t4_digest_update_sha1(EVP_MD_CTX *ctx, const void *data,
+    size_t len);
+static int t4_digest_final_sha1(EVP_MD_CTX *ctx, unsigned char *md);
+static int t4_digest_copy_sha1(EVP_MD_CTX *to, const EVP_MD_CTX *from);
+
+/*
+ * OpenSSL's libcrypto EVP stuff. This is how this engine gets wired to EVP.
+ * EVP_MD is defined in evp.h.  To maintain binary compatibility the
+ * definition cannot be modified.
+ * Stuff specific to the t4 engine is kept in t4_cipher_ctx_t, which is
+ * pointed to by the last field, app_data.
+ *
+ * Fields: type, pkey_type, md_size, flags,
+ *	init(), update(), final(),
+ *	copy(), cleanup(), sign(), verify(),
+ *	required_pkey_type, block_size, ctx_size, md5_ctrl()
+ */
+const EVP_MD t4_sha1 = {
+	NID_sha1, NID_sha1WithRSAEncryption, SHA_DIGEST_LENGTH,
+	EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+	t4_digest_init_sha1, t4_digest_update_sha1, t4_digest_final_sha1,
+	t4_digest_copy_sha1, NULL,
+	EVP_PKEY_RSA_method, SHA_CBLOCK,
+	sizeof (SHA_CTX), NULL
+	};
+
+/* These functions are defined in md32_common.h: */
+static int t4_sha1_update(SHA_CTX *c, const void *data_, size_t len);
+static void t4_sha1_transform(SHA_CTX *c, const unsigned char *data);
+static int t4_sha1_final(unsigned char *md, SHA_CTX *c);
+#pragma inline(t4_sha1_update, t4_sha1_transform, t4_sha1_final)
+
+#define	DATA_ORDER_IS_BIG_ENDIAN
+/* HASH_LONG/SHA_LONG is unsigned int (32 bits): */
+#define	HASH_LONG			SHA_LONG
+#define	HASH_CTX			SHA_CTX
+#define	HASH_CBLOCK			SHA_CBLOCK
+#define	HASH_UPDATE			t4_sha1_update
+#define	HASH_TRANSFORM			t4_sha1_transform
+#define	HASH_FINAL			t4_sha1_final
+#define	HASH_BLOCK_DATA_ORDER		t4_sha1_multiblock
+#define	HASH_MAKE_STRING(c, s)   do {	\
+		unsigned int ll;		\
+		ll = (c)->h0; HOST_l2c(ll, (s));	\
+		ll = (c)->h1; HOST_l2c(ll, (s));	\
+		ll = (c)->h2; HOST_l2c(ll, (s));	\
+		ll = (c)->h3; HOST_l2c(ll, (s));	\
+		ll = (c)->h4; HOST_l2c(ll, (s));	\
+	} while (0)
+
+/* This defines HASH_UPDATE, HASH_TRANSFORM, HASH_FINAL functions: */
+#include "md32_common.h"
+
+
+/*
+ * SHA-1 functions (FIPS 180-1 Secure Hash Standard)
+ */
+
+static int
+t4_digest_init_sha1(EVP_MD_CTX *ctx)
+{
+	SHA_CTX	*c = (SHA_CTX *)ctx->md_data;
+
+	/* Optimization: don't call memset(c, 0,...) or initialize c->data[] */
+	c->Nl = c->Nh = c->num = 0;
+	c->h0 = 0x67452301U;
+	c->h1 = 0xefcdab89U;
+	c->h2 = 0x98badcfeU;
+	c->h3 = 0x10325476U;
+	c->h4 = 0xc3d2e1f0U;
+
+	return (1);
+}
+
+/* Continue SHA1 digest operation, using the message block to update context. */
+static int
+t4_digest_update_sha1(EVP_MD_CTX *ctx, const void *data, size_t len)
+{
+	return (t4_sha1_update((SHA_CTX *)ctx->md_data, data, len));
+}
+
+/* End SHA1 digest operation, finalizing message digest and zeroing context. */
+static int
+t4_digest_final_sha1(EVP_MD_CTX *ctx, unsigned char *md)
+{
+	return (t4_sha1_final(md, (SHA_CTX *)ctx->md_data));
+}
+
+/* Required for Engine API */
+static int
+t4_digest_copy_sha1(EVP_MD_CTX *to, const EVP_MD_CTX *from)
+{
+	if ((to->md_data != NULL) && (from->md_data != NULL)) {
+		(void) memcpy(to->md_data, from->md_data, sizeof (SHA_CTX));
+	}
+	return (1);
+}
+
+#endif	/* COMPILE_HW_T4 */
+#endif	/* !OPENSSL_NO_SHA && !OPENSSL_NO_SHA1 */
+#endif	/* !OPENSSL_NO_HW && !OPENSSL_NO_HW_MD_T4 */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_sha256.c openssl-1.0.1c/crypto/engine/eng_t4_sha256.c
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_sha256.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_sha256.c	2012-05-11 21:34:40.992395000 +0200
@@ -0,0 +1,246 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/). This
+ * product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * This engine supports SPARC microprocessors that provide AES and other
+ * cipher and hash instructions, such as the T4 microprocessor.
+ *
+ * This file implements the SHA-256 message digest operations.
+ */
+
+#include <openssl/opensslconf.h>
+
+#if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_MD_T4)
+#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA256)
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <openssl/engine.h>
+/*
+ * Solaris sys/sha2.h and OpenSSL openssl/sha.h both define
+ * SHA256_CTX, SHA512_CTX, SHA256, SHA384, and SHA512.
+ * For SHA2, OpenSSL SHA256_CTX has extra num and md_len fields at
+ * the end and Solaris SHA2_CTX has an extra algotype field at the beginning.
+ */
+#include "eng_t4_sha2_asm.h"
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && !defined(OPENSSL_NO_ASM)
+#define	COMPILE_HW_T4
+#endif
+
+#ifdef	COMPILE_HW_T4
+
+/* Formal declaration for functions in EVP_MD structure */
+static int t4_digest_init_sha256(EVP_MD_CTX *ctx);
+static int t4_digest_init_sha224(EVP_MD_CTX *ctx);
+static int t4_digest_update_sha256(EVP_MD_CTX *ctx, const void *data,
+    size_t len);
+static int t4_digest_final_sha256(EVP_MD_CTX *ctx, unsigned char *md);
+static int t4_digest_copy_sha256(EVP_MD_CTX *to, const EVP_MD_CTX *from);
+
+
+/*
+ * OpenSSL's libcrypto EVP stuff. This is how this engine gets wired to EVP.
+ * EVP_MD is defined in evp.h.  To maintain binary compatibility the
+ * definition cannot be modified.
+ * Stuff specific to the t4 engine is kept in t4_cipher_ctx_t, which is
+ * pointed to by the last field, app_data.
+ *
+ * Fields: type, pkey_type, md_size, flags,
+ *	init(), update(), final(),
+ *	copy(), cleanup(), sign(), verify(),
+ *	required_pkey_type, block_size, ctx_size, md5_ctrl()
+ */
+const EVP_MD t4_sha256 = {
+	NID_sha256, NID_sha256WithRSAEncryption, SHA256_DIGEST_LENGTH,
+	EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+	t4_digest_init_sha256, t4_digest_update_sha256, t4_digest_final_sha256,
+	t4_digest_copy_sha256, NULL,
+	EVP_PKEY_RSA_method, SHA256_CBLOCK,
+	sizeof (T4_SHA256_CTX), NULL
+	};
+/* SHA-224 uses the same context, cblock size, & update function as SHA-256: */
+const EVP_MD t4_sha224 = {
+	NID_sha224, NID_sha224WithRSAEncryption, SHA224_DIGEST_LENGTH,
+	EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+	t4_digest_init_sha224, t4_digest_update_sha256, t4_digest_final_sha256,
+	t4_digest_copy_sha256, NULL,
+	EVP_PKEY_RSA_method, SHA256_CBLOCK,
+	sizeof (T4_SHA256_CTX), NULL
+	};
+
+/* These functions are defined in md32_common.h: */
+static int t4_sha256_update(T4_SHA256_CTX *c, const void *data_, size_t len);
+static void t4_sha256_transform(T4_SHA256_CTX *c, const unsigned char *data);
+static int t4_sha256_final(unsigned char *md, T4_SHA256_CTX *c);
+#pragma inline(t4_sha256_update, t4_sha256_transform, t4_sha256_final)
+
+#define	DATA_ORDER_IS_BIG_ENDIAN
+/* HASH_LONG/SHA_LONG is unsigned int (32 bits): */
+#define	HASH_LONG			SHA_LONG
+#define	HASH_CTX			T4_SHA256_CTX
+#define	HASH_CBLOCK			SHA_CBLOCK
+#define	HASH_UPDATE			t4_sha256_update
+#define	HASH_TRANSFORM			t4_sha256_transform
+#define	HASH_FINAL			t4_sha256_final
+#define	HASH_BLOCK_DATA_ORDER		t4_sha256_multiblock
+#define	HASH_MAKE_STRING(c, s) 						\
+	do {								\
+		unsigned int ll, nn;					\
+		switch ((c)->md_len) {					\
+		case SHA256_DIGEST_LENGTH:				\
+			for (nn = 0; nn < SHA256_DIGEST_LENGTH / 4; nn++) { \
+				ll = (c)->h[nn]; HOST_l2c(ll, (s)); }	\
+			break;						\
+		case SHA224_DIGEST_LENGTH:				\
+			for (nn = 0; nn < SHA224_DIGEST_LENGTH / 4; nn++) { \
+				ll = (c)->h[nn]; HOST_l2c(ll, (s)); }	\
+			break;						\
+		default:						\
+			if ((c)->md_len > SHA256_DIGEST_LENGTH)		\
+			    return (0);					\
+			for (nn = 0; nn < (c)->md_len / 4; nn++) {	\
+				ll = (c)->h[nn]; HOST_l2c(ll, (s)); }	\
+			break;						\
+		}							\
+	} while (0)
+
+/* This defines HASH_UPDATE, HASH_TRANSFORM, HASH_FINAL functions: */
+#include "md32_common.h"
+
+
+/*
+ * SHA256 functions (part of FIPS 180-2 Secure Hash Standard)
+ */
+
+static int
+t4_digest_init_sha256(EVP_MD_CTX *ctx)
+{
+	T4_SHA256_CTX	*c = (T4_SHA256_CTX *)ctx->md_data;
+
+	/* Optimization: don't call memset(c, 0,...) or initialize c->data[] */
+	c->Nl = c->Nh = c->num = 0;
+	c->h[0] = 0x6a09e667U;
+	c->h[1] = 0xbb67ae85U;
+	c->h[2] = 0x3c6ef372U;
+	c->h[3] = 0xa54ff53aU;
+	c->h[4] = 0x510e527fU;
+	c->h[5] = 0x9b05688cU;
+	c->h[6] = 0x1f83d9abU;
+	c->h[7] = 0x5be0cd19U;
+	c->md_len = SHA256_DIGEST_LENGTH;
+	return (1);
+}
+
+
+static int
+t4_digest_init_sha224(EVP_MD_CTX *ctx)
+{
+	T4_SHA256_CTX	*c = (T4_SHA256_CTX *)ctx->md_data;
+
+	/* Optimization: don't call memset(c, 0,...) or initialize c->data[] */
+	c->Nl = c->Nh = c->num = 0;
+	c->h[0] = 0xc1059ed8UL;
+	c->h[1] = 0x367cd507UL;
+	c->h[2] = 0x3070dd17UL;
+	c->h[3] = 0xf70e5939UL;
+	c->h[4] = 0xffc00b31UL;
+	c->h[5] = 0x68581511UL;
+	c->h[6] = 0x64f98fa7UL;
+	c->h[7] = 0xbefa4fa4UL;
+	c->md_len = SHA224_DIGEST_LENGTH;
+	return (1);
+}
+
+/* Continue SHA256 digest operation, using message block to update context. */
+static int
+t4_digest_update_sha256(EVP_MD_CTX *ctx, const void *data, size_t len)
+{
+	T4_SHA256_CTX	*sha256_ctx = (T4_SHA256_CTX *)ctx->md_data;
+
+	return (t4_sha256_update((T4_SHA256_CTX *)ctx->md_data, data, len));
+}
+
+/* End SHA256 digest operation, finalizing message digest and zeroing context */
+static int
+t4_digest_final_sha256(EVP_MD_CTX *ctx, unsigned char *md)
+{
+	T4_SHA256_CTX	*sha256_ctx = (T4_SHA256_CTX *)ctx->md_data;
+
+	return (t4_sha256_final(md, (T4_SHA256_CTX *)ctx->md_data));
+}
+
+/* Required for Engine API */
+static int
+t4_digest_copy_sha256(EVP_MD_CTX *to, const EVP_MD_CTX *from)
+{
+	if ((to->md_data != NULL) && (from->md_data != NULL)) {
+		(void) memcpy(to->md_data, from->md_data,
+		    sizeof (T4_SHA256_CTX));
+	}
+	return (1);
+}
+
+#endif	/* COMPILE_HW_T4 */
+#endif	/* !OPENSSL_NO_SHA && !OPENSSL_NO_SHA256 */
+#endif	/* !OPENSSL_NO_HW && !OPENSSL_NO_HW_MD_T4 */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_sha2_asm.h openssl-1.0.1c/crypto/engine/eng_t4_sha2_asm.h
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_sha2_asm.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_sha2_asm.h	2012-05-11 21:34:40.802032000 +0200
@@ -0,0 +1,135 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/). This
+ * product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+#ifndef	ENG_T4_SHA2_ASM_H
+#define	ENG_T4_SHA2_ASM_H
+
+/*
+ * SPARC T4 SHA2 (SHA256/SHA512) assembly language functions and context.
+ * The context must match that used by the Solaris SPARC T4 assembly
+ * (except for OpenSSL-specific fields num and md_len that aren't in Solaris).
+ *
+ * Based on OpenSSL file openssl/sha.h and Solaris file sys/sha2.h.
+ */
+
+#include <stddef.h>
+#include <sys/types.h>
+#include <openssl/sha.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#ifndef OPENSSL_NO_SHA256
+/*
+ * The contents of this structure are a private interface between the
+ * Init/Update/Multiblock/Final functions.
+ * Callers must never attempt to read or write any of the fields
+ * in this structure directly.
+ */
+typedef struct t4_SHA256state_st {
+	uint32_t algotype;		/* Solaris-only field; unused here */
+	uint32_t algotype_pad;		/* Pad to align next field 0 mod 8 */
+	uint32_t h[8];			/* State (ABCDEFGH) */
+	uint32_t h_pad[8];		/* Pad fields to match T4_SHA512_CTX */
+	uint32_t Nl, Nh;		/* Number of bits, module 2^64 */
+	uint32_t Nl_pad, Nh_pad;	/* Pad fields to match T4_SHA512_CTX */
+	uint32_t data[SHA_LBLOCK];	/* Input */
+	unsigned int num, md_len;	/* Fields unused by Solaris assembly */
+} T4_SHA256_CTX;
+#endif	/* !OPENSSL_NO_SHA256 */
+
+
+#ifndef OPENSSL_NO_SHA512
+/*
+ * The contents of this structure are a private interface between the
+ * Init/Update/Multiblock/Final functions.
+ * Callers must never attempt to read or write any of the fields
+ * in this structure directly.
+ */
+typedef struct t4_SHA512state_st {
+	uint32_t algotype;		/* Solaris-only field; unused here */
+	uint64_t h[8];			/* State (ABCDEFGH) */
+	uint64_t Nl, Nh;		/* Number of bits, module 2^128 */
+	union {
+		uint64_t	d[SHA_LBLOCK];
+		unsigned char	p[SHA512_CBLOCK];
+	} u;				/* Input */
+	unsigned int num, md_len;	/* Fields unused by Solaris assembly */
+} T4_SHA512_CTX;
+#endif	/* !OPENSSL_NO_SHA512 */
+
+/*
+ * SPARC T4 assembly language functions
+ */
+#ifndef	OPENSSL_NO_SHA256
+extern void t4_sha256_multiblock(T4_SHA256_CTX *c, const void *input,
+	size_t num);
+#endif
+#ifndef	OPENSSL_NO_SHA512
+extern void t4_sha512_multiblock(T4_SHA512_CTX *c, const void *input,
+	size_t num);
+#endif
+
+#ifdef	__cplusplus
+}
+#endif
+#endif	/* ENG_T4_SHA2_ASM_H */
diff -uNr openssl-1.0.1c.orig/crypto/engine/eng_t4_sha512.c openssl-1.0.1c/crypto/engine/eng_t4_sha512.c
--- openssl-1.0.1c.orig/crypto/engine/eng_t4_sha512.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/engine/eng_t4_sha512.c	2012-05-11 21:34:40.643995000 +0200
@@ -0,0 +1,325 @@
+/*
+ * This product includes cryptographic software developed by the OpenSSL
+ * Project for use in the OpenSSL Toolkit (http://www.openssl.org/). This
+ * product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).
+ */
+
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*
+ * This engine supports SPARC microprocessors that provide AES and other
+ * cipher and hash instructions, such as the T4 microprocessor.
+ *
+ * This file implements the SHA-512 message digest operations.
+ */
+
+#include <openssl/opensslconf.h>
+
+#if !defined(OPENSSL_NO_HW) && !defined(OPENSSL_NO_HW_MD_T4)
+#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA512)
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <openssl/engine.h>
+/*
+ * Solaris sys/sha2.h and OpenSSL openssl/sha.h both define
+ * SHA512_CTX, SHA512_CTX, SHA512, SHA384, and SHA512.
+ * For SHA2, OpenSSL SHA512_CTX has extra num and md_len fields at
+ * the end and Solaris SHA2_CTX has an extra algotype field at the beginning.
+ */
+#include "eng_t4_sha2_asm.h"
+
+#if (defined(sun4v) || defined(__sparcv9) || defined(__sparcv8plus) || \
+	defined(__sparcv8)) && !defined(OPENSSL_NO_ASM)
+#define	COMPILE_HW_T4
+#endif
+
+#ifdef	COMPILE_HW_T4
+
+/* Formal declaration for functions in EVP_MD structure */
+static int t4_digest_init_sha384(EVP_MD_CTX *ctx);
+static int t4_digest_init_sha512(EVP_MD_CTX *ctx);
+static int t4_digest_update_sha512(EVP_MD_CTX *ctx, const void *data,
+    size_t len);
+static int t4_digest_final_sha512(EVP_MD_CTX *ctx, unsigned char *md);
+static int t4_digest_copy_sha512(EVP_MD_CTX *to, const EVP_MD_CTX *from);
+
+
+/*
+ * OpenSSL's libcrypto EVP stuff. This is how this engine gets wired to EVP.
+ * EVP_MD is defined in evp.h.  To maintain binary compatibility the
+ * definition cannot be modified.
+ * Stuff specific to the t4 engine is kept in t4_cipher_ctx_t, which is
+ * pointed to by the last field, app_data.
+ *
+ * Fields: type, pkey_type, md_size, flags,
+ *	init(), update(), final(),
+ *	copy(), cleanup(), sign(), verify(),
+ *	required_pkey_type, block_size, ctx_size, md5_ctrl()
+ */
+
+const EVP_MD t4_sha512 = {
+	NID_sha512, NID_sha512WithRSAEncryption, SHA512_DIGEST_LENGTH,
+	EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+	t4_digest_init_sha512, t4_digest_update_sha512, t4_digest_final_sha512,
+	t4_digest_copy_sha512, NULL,
+	EVP_PKEY_RSA_method, SHA512_CBLOCK,
+	sizeof (T4_SHA512_CTX), NULL
+	};
+/* SHA-384 uses the same context, cblock size, & update function as SHA-512: */
+const EVP_MD t4_sha384 = {
+	NID_sha384, NID_sha384WithRSAEncryption, SHA384_DIGEST_LENGTH,
+	EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+	t4_digest_init_sha384, t4_digest_update_sha512, t4_digest_final_sha512,
+	t4_digest_copy_sha512, NULL,
+	EVP_PKEY_RSA_method, SHA512_CBLOCK,
+	sizeof (T4_SHA512_CTX), NULL
+	};
+
+
+/*
+ * SHA512 functions (part of FIPS 180-2 Secure Hash Standard)
+ */
+
+static int
+t4_digest_init_sha512(EVP_MD_CTX *ctx)
+{
+	T4_SHA512_CTX	*c = (T4_SHA512_CTX *)ctx->md_data;
+
+	c->Nl = c->Nh = c->num = 0;
+	c->h[0] = 0x6a09e667f3bcc908ULL;
+	c->h[1] = 0xbb67ae8584caa73bULL;
+	c->h[2] = 0x3c6ef372fe94f82bULL;
+	c->h[3] = 0xa54ff53a5f1d36f1ULL;
+	c->h[4] = 0x510e527fade682d1ULL;
+	c->h[5] = 0x9b05688c2b3e6c1fULL;
+	c->h[6] = 0x1f83d9abfb41bd6bULL;
+	c->h[7] = 0x5be0cd19137e2179ULL;
+	c->md_len = SHA512_DIGEST_LENGTH;
+
+	return (1);
+}
+
+
+static int
+t4_digest_init_sha384(EVP_MD_CTX *ctx)
+{
+	T4_SHA512_CTX	*c = (T4_SHA512_CTX *)ctx->md_data;
+
+	c->Nl = c->Nh = c->num = 0;
+	c->h[0] = 0xcbbb9d5dc1059ed8ULL;
+	c->h[1] = 0x629a292a367cd507ULL;
+	c->h[2] = 0x9159015a3070dd17ULL;
+	c->h[3] = 0x152fecd8f70e5939ULL;
+	c->h[4] = 0x67332667ffc00b31ULL;
+	c->h[5] = 0x8eb44a8768581511ULL;
+	c->h[6] = 0xdb0c2e0d64f98fa7ULL;
+	c->h[7] = 0x47b5481dbefa4fa4ULL;
+	c->md_len = SHA384_DIGEST_LENGTH;
+
+	return (1);
+}
+
+
+/*
+ * Continue SHA512 or SHA384 digest operation, using the message block to
+ * update context.
+ * Modified from SHA512_Update() in OpenSSL crypto/sha/sha512.c.
+ */
+static int
+t4_digest_update_sha512(EVP_MD_CTX *ctx, const void *_data, size_t len)
+{
+	T4_SHA512_CTX	*c = (T4_SHA512_CTX *)ctx->md_data;
+	SHA_LONG64	l;
+	unsigned char	*p = c->u.p;
+	const unsigned char *data = (const unsigned char *)_data;
+
+	if (len == 0)
+		return (1);
+
+	l = (c->Nl + (((SHA_LONG64)len) << 3)) & 0xffffffffffffffffULL;
+	if (l < c->Nl)
+		c->Nh++;
+	if (sizeof (len) >= 8) {
+		c->Nh += (((SHA_LONG64)len) >> 61);
+	}
+	c->Nl = l;
+
+	if (c->num != 0) {
+		size_t n = sizeof (c->u) - c->num;
+
+		if (len < n) {
+			memcpy(p + c->num, data, len);
+			c->num += (unsigned int)len;
+			return (1);
+		} else	{
+			memcpy(p + c->num, data, n);
+			c->num = 0;
+			len -= n;
+			data += n;
+			t4_sha512_multiblock(c, p, 1);
+		}
+	}
+
+	if (len >= sizeof (c->u)) {
+		if ((size_t)data % sizeof (c->u.d[0]) != 0) {
+			/* Align unaligned data one block-at-a-time */
+			while (len >= sizeof (c->u)) {
+				memcpy(p, data, sizeof (c->u));
+				t4_sha512_multiblock(c, p, 1);
+				len  -= sizeof (c->u);
+				data += sizeof (c->u);
+			}
+		} else {
+			t4_sha512_multiblock(c, data, len / sizeof (c->u));
+			data += len;
+			len  %= sizeof (c->u);
+			data -= len;
+		}
+	}
+
+	if (len != 0) {
+		memcpy(p, data, len);
+		c->num = (int)len;
+	}
+
+	return (1);
+}
+
+
+/*
+ * End SHA-512 or SHA-384 digest operation, finalizing message digest and
+ * zeroing context.
+ * Modified from SHA512_Final() in OpenSSL crypto/sha/sha512.c.
+ */
+static int
+t4_digest_final_sha512(EVP_MD_CTX *ctx, unsigned char *md)
+{
+	T4_SHA512_CTX	*c = (T4_SHA512_CTX *)ctx->md_data;
+	unsigned char	*p = (unsigned char *)c->u.p;
+	size_t		n = c->num;
+
+	p[n] = 0x80;	/* There always is a room for one */
+	n++;
+	if (n > (sizeof (c->u) - 16)) {
+		memset(p + n, 0, sizeof (c->u) - n);
+		n = 0;
+		t4_sha512_multiblock(c, p, 1);
+	}
+
+	memset(p+n, 0, sizeof (c->u) - 16 - n);
+	c->u.d[SHA_LBLOCK - 2] = c->Nh;
+	c->u.d[SHA_LBLOCK - 1] = c->Nl;
+
+	t4_sha512_multiblock(c, p, 1);
+
+	if (md == 0)
+		return (0);
+
+	switch (c->md_len) {
+		/* Let compiler decide if it's appropriate to unroll... */
+		case SHA384_DIGEST_LENGTH:
+			for (n = 0; n < SHA384_DIGEST_LENGTH / 8; n++) {
+				SHA_LONG64 t = c->h[n];
+
+				*(md++)	= (unsigned char)(t >> 56);
+				*(md++)	= (unsigned char)(t >> 48);
+				*(md++)	= (unsigned char)(t >> 40);
+				*(md++)	= (unsigned char)(t >> 32);
+				*(md++)	= (unsigned char)(t >> 24);
+				*(md++)	= (unsigned char)(t >> 16);
+				*(md++)	= (unsigned char)(t >> 8);
+				*(md++)	= (unsigned char)(t);
+			}
+			break;
+		case SHA512_DIGEST_LENGTH:
+			for (n = 0; n < SHA512_DIGEST_LENGTH / 8; n++) {
+				SHA_LONG64 t = c->h[n];
+
+				*(md++)	= (unsigned char)(t >> 56);
+				*(md++)	= (unsigned char)(t >> 48);
+				*(md++)	= (unsigned char)(t >> 40);
+				*(md++)	= (unsigned char)(t >> 32);
+				*(md++)	= (unsigned char)(t >> 24);
+				*(md++)	= (unsigned char)(t >> 16);
+				*(md++)	= (unsigned char)(t >> 8);
+				*(md++)	= (unsigned char)(t);
+			}
+			break;
+		/* ... as well as make sure md_len is not abused. */
+		default:
+			return (0);
+	}
+
+	return (1);
+}
+
+
+/* Required for Engine API */
+static int
+t4_digest_copy_sha512(EVP_MD_CTX *to, const EVP_MD_CTX *from)
+{
+	if ((to->md_data != NULL) && (from->md_data != NULL)) {
+		(void) memcpy(to->md_data, from->md_data,
+		    sizeof (T4_SHA512_CTX));
+	}
+	return (1);
+}
+
+#endif	/* COMPILE_HW_T4 */
+#endif	/* !OPENSSL_NO_SHA && !OPENSSL_NO_SHA512 */
+#endif	/* !OPENSSL_NO_HW && !OPENSSL_NO_HW_MD_T4 */
diff -uNr openssl-1.0.1c.orig/crypto/engine/engine.h openssl-1.0.1c/crypto/engine/engine.h
--- openssl-1.0.1c.orig/crypto/engine/engine.h	2012-05-11 22:28:08.987623273 +0200
+++ openssl-1.0.1c/crypto/engine/engine.h	2012-05-11 22:19:17.493886000 +0200
@@ -351,6 +351,7 @@
 #endif
 #endif
 void ENGINE_load_cryptodev(void);
+void ENGINE_load_t4(void);
 void ENGINE_load_pk11(void);
 void ENGINE_load_rsax(void);
 void ENGINE_load_rdrand(void);
diff -uNr openssl-1.0.1c.orig/crypto/md5/Makefile openssl-1.0.1c/crypto/md5/Makefile
--- openssl-1.0.1c.orig/crypto/md5/Makefile	2011-08-14 15:47:28.000000000 +0200
+++ openssl-1.0.1c/crypto/md5/Makefile	2012-05-11 22:19:17.502594000 +0200
@@ -17,6 +17,10 @@
 ASFLAGS= $(INCLUDES) $(ASFLAG)
 AFLAGS= $(ASFLAGS)
 
+BITS:=	$(shell if grep '^CFLAG.*=.*-m64' ../../Makefile >/dev/null; \
+		then echo 64; else echo 32; fi)
+ASFLAGSYF= -xregsym=no -K pic -P -xarch=v9v -D_sparcv9 -D_ASM -Dsparc -m$(BITS)
+
 GENERAL=Makefile
 TEST=md5test.c
 APPS=
@@ -52,6 +56,10 @@
 	$(CC) $(CFLAGS) -E asm/md5-ia64.S | \
 	$(PERL) -ne 's/;\s+/;\n/g; print;' > $@
 
+t4_md5.o: asm/t4_md5.S
+	as $(ASFLAGSYF) -o $@ asm/t4_md5.S
+	elfedit -e 'cap:hw1 -and -cmp vis vis3' $@
+
 files:
 	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
 
diff -uNr openssl-1.0.1c.orig/crypto/md5/asm/t4_md5.S openssl-1.0.1c/crypto/md5/asm/t4_md5.S
--- openssl-1.0.1c.orig/crypto/md5/asm/t4_md5.S	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/md5/asm/t4_md5.S	2012-05-11 21:34:39.401291000 +0200
@@ -0,0 +1,151 @@
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*LINTLIBRARY*/
+
+#if defined(lint) || defined(__lint)
+
+#include <sys/types.h>
+#include <openssl/md5.h>
+
+/*ARGSUSED*/
+void
+t4_md5_multiblock(MD5_CTX *ctx, const uint8_t *input,
+    unsigned int input_length_in_blocks)
+{ return; }
+
+#else	/* lint || __lint */
+
+#include<sys/asm_linkage.h>
+
+	ENTRY(t4_md5_multiblock)
+
+!load result from previous digest (stored in ctx)
+	ld	[%o0], %f0
+	ld	[%o0 + 0x4], %f1
+	ld	[%o0 + 0x8], %f2
+	ld	[%o0 + 0xc], %f3
+
+	and	%o1, 7, %o3
+	brnz	%o3, md5_unaligned_input
+	nop
+
+md5_loop:
+
+!load 64 bytes of data
+	ldd	[%o1], %f8		!load 8 bytes of data
+	ldd	[%o1 + 0x8], %f10	!load 8 bytes of data
+	ldd	[%o1 + 0x10], %f12	!load 8 bytes of data
+	ldd	[%o1 + 0x18], %f14	!load 8 bytes of data
+	ldd	[%o1 + 0x20], %f16	!load 8 bytes of data
+	ldd	[%o1 + 0x28], %f18	!load 8 bytes of data
+	ldd	[%o1 + 0x30], %f20	!load 8 bytes of data
+	ldd	[%o1 + 0x38], %f22	!load 8 bytes of data
+
+!perform crypto instruction here
+	!md5
+	.byte	0x81, 0xb0, 0x28, 0x00
+
+	dec	%o2
+	brnz	%o2, md5_loop
+	add	%o1, 0x40, %o1
+
+!copy digest back into ctx
+	st	%f0, [%o0]
+	st	%f1, [%o0 + 0x4]
+	st	%f2, [%o0 + 0x8]
+	retl
+	st	%f3, [%o0 + 0xc]
+
+md5_unaligned_input:
+	alignaddr %o1, %g0, %g0		! generate %gsr
+	andn	%o1, 7, %o1
+
+md5_unaligned_input_loop:
+	ldd	[%o1], %f8		!load 8 bytes of data
+	ldd	[%o1 + 0x8], %f10	!load 8 bytes of data
+	ldd	[%o1 + 0x10], %f12	!load 8 bytes of data
+	ldd	[%o1 + 0x18], %f14	!load 8 bytes of data
+	ldd	[%o1 + 0x20], %f16	!load 8 bytes of data
+	ldd	[%o1 + 0x28], %f18	!load 8 bytes of data
+	ldd	[%o1 + 0x30], %f20	!load 8 bytes of data
+	ldd	[%o1 + 0x38], %f22	!load 8 bytes of data
+	ldd	[%o1 + 0x40], %f24	!load 8 bytes of data
+	faligndata %f8, %f10, %f8
+	faligndata %f10, %f12, %f10
+	faligndata %f12, %f14, %f12
+	faligndata %f14, %f16, %f14
+	faligndata %f16, %f18, %f16
+	faligndata %f18, %f20, %f18
+	faligndata %f20, %f22, %f20
+	faligndata %f22, %f24, %f22
+
+!perform crypto instruction here
+	!md5
+	.byte	0x81, 0xb0, 0x28, 0x00
+
+	dec	%o2
+	brnz	%o2, md5_unaligned_input_loop
+	add	%o1, 0x40, %o1
+
+!copy digest back into ctx
+	st	%f0, [%o0]
+	st	%f1, [%o0 + 0x4]
+	st	%f2, [%o0 + 0x8]
+	retl
+	st	%f3, [%o0 + 0xc]
+
+	SET_SIZE(t4_md5_multiblock)
+
+#endif  /* lint || __lint */
diff -uNr openssl-1.0.1c.orig/crypto/sha/Makefile openssl-1.0.1c/crypto/sha/Makefile
--- openssl-1.0.1c.orig/crypto/sha/Makefile	2011-11-14 21:42:22.000000000 +0100
+++ openssl-1.0.1c/crypto/sha/Makefile	2012-05-11 22:19:17.504824000 +0200
@@ -17,6 +17,10 @@
 ASFLAGS= $(INCLUDES) $(ASFLAG)
 AFLAGS= $(ASFLAGS)
 
+BITS:=	$(shell if grep '^CFLAG.*=.*-m64' ../../Makefile >/dev/null; \
+		then echo 64; else echo 32; fi)
+ASFLAGSYF= -xregsym=no -K pic -P -xarch=v9v -D_sparcv9 -D_ASM -Dsparc -m$(BITS)
+
 GENERAL=Makefile
 TEST=shatest.c sha1test.c sha256t.c sha512t.c
 APPS=
@@ -91,6 +95,14 @@
 sha256-armv4.o:		sha256-armv4.S
 sha512-armv4.o:		sha512-armv4.S
 
+t4_sha1.o: asm/t4_sha1.S
+	as $(ASFLAGSYF) -o $@ asm/t4_sha1.S
+	elfedit -e 'cap:hw1 -and -cmp vis vis3' $@
+
+t4_sha2.o: asm/t4_sha2.S
+	as $(ASFLAGSYF) -o $@ asm/t4_sha2.S
+	elfedit -e 'cap:hw1 -and -cmp vis vis3' $@
+
 files:
 	$(PERL) $(TOP)/util/files.pl Makefile >> $(TOP)/MINFO
 
diff -uNr openssl-1.0.1c.orig/crypto/sha/asm/t4_sha1.S openssl-1.0.1c/crypto/sha/asm/t4_sha1.S
--- openssl-1.0.1c.orig/crypto/sha/asm/t4_sha1.S	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/sha/asm/t4_sha1.S	2012-05-11 21:34:39.248299000 +0200
@@ -0,0 +1,153 @@
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*LINTLIBRARY*/
+
+#if defined(lint) || defined(__lint)
+
+#include <sys/types.h>
+#include <openssl/sha.h>
+
+/*ARGSUSED*/
+void
+t4_sha1_multiblock(SHA_CTX *ctx, const void *input, size_t num)
+{ return; }
+
+#else	/* lint || __lint */
+
+#include<sys/asm_linkage.h>
+
+	ENTRY(t4_sha1_multiblock)
+
+!load result from previous digest (stored in ctx)
+	ld	[%o0], %f0
+	ld	[%o0 + 0x4], %f1
+	ld	[%o0 + 0x8], %f2
+	ld	[%o0 + 0xc], %f3
+	ld	[%o0 + 0x10], %f4
+
+	and	%o1, 7, %o3
+	brnz	%o3, sha1_unaligned_input
+	nop
+
+sha1_loop:
+
+!load 64 bytes of data
+	ldd	[%o1], %f8		!load 8 bytes of data
+	ldd	[%o1 + 0x8], %f10	!load 8 bytes of data
+	ldd	[%o1 + 0x10], %f12	!load 8 bytes of data
+	ldd	[%o1 + 0x18], %f14	!load 8 bytes of data
+	ldd	[%o1 + 0x20], %f16	!load 8 bytes of data
+	ldd	[%o1 + 0x28], %f18	!load 8 bytes of data
+	ldd	[%o1 + 0x30], %f20	!load 8 bytes of data
+	ldd	[%o1 + 0x38], %f22	!load 8 bytes of data
+
+!perform crypto instruction here
+	!sha1
+	.byte	0x81, 0xb0, 0x28, 0x20
+
+	dec	%o2
+	brnz	%o2, sha1_loop
+	add	%o1, 0x40, %o1
+
+!copy digest back into ctx
+	st	%f0, [%o0]
+	st	%f1, [%o0 + 0x4]
+	st	%f2, [%o0 + 0x8]
+	st	%f3, [%o0 + 0xc]
+	retl
+	st	%f4, [%o0 + 0x10]
+
+sha1_unaligned_input:
+	alignaddr %o1, %g0, %g0		! generate %gsr
+	andn	%o1, 7, %o1
+
+sha1_unaligned_input_loop:
+	ldd	[%o1], %f8		!load 8 bytes of data
+	ldd	[%o1 + 0x8], %f10	!load 8 bytes of data
+	ldd	[%o1 + 0x10], %f12	!load 8 bytes of data
+	ldd	[%o1 + 0x18], %f14	!load 8 bytes of data
+	ldd	[%o1 + 0x20], %f16	!load 8 bytes of data
+	ldd	[%o1 + 0x28], %f18	!load 8 bytes of data
+	ldd	[%o1 + 0x30], %f20	!load 8 bytes of data
+	ldd	[%o1 + 0x38], %f22	!load 8 bytes of data
+	ldd	[%o1 + 0x40], %f24	!load 8 bytes of data
+	faligndata %f8, %f10, %f8
+	faligndata %f10, %f12, %f10
+	faligndata %f12, %f14, %f12
+	faligndata %f14, %f16, %f14
+	faligndata %f16, %f18, %f16
+	faligndata %f18, %f20, %f18
+	faligndata %f20, %f22, %f20
+	faligndata %f22, %f24, %f22
+
+!perform crypto instruction here
+	!sha1
+	.byte	0x81, 0xb0, 0x28, 0x20
+
+	dec	%o2
+	brnz	%o2, sha1_unaligned_input_loop
+	add	%o1, 0x40, %o1
+
+!copy digest back into ctx
+	st	%f0, [%o0]
+	st	%f1, [%o0 + 0x4]
+	st	%f2, [%o0 + 0x8]
+	st	%f3, [%o0 + 0xc]
+	retl
+	st	%f4, [%o0 + 0x10]
+
+	SET_SIZE(t4_sha1_multiblock)
+
+#endif  /* lint || __lint */
diff -uNr openssl-1.0.1c.orig/crypto/sha/asm/t4_sha2.S openssl-1.0.1c/crypto/sha/asm/t4_sha2.S
--- openssl-1.0.1c.orig/crypto/sha/asm/t4_sha2.S	1970-01-01 01:00:00.000000000 +0100
+++ openssl-1.0.1c/crypto/sha/asm/t4_sha2.S	2012-05-11 21:34:39.095354000 +0200
@@ -0,0 +1,314 @@
+/*
+ * ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ */
+
+/*LINTLIBRARY*/
+
+#if defined(lint) || defined(__lint)
+
+#include <sys/types.h>
+#include <openssl/sha.h>
+#include "../engine/eng_t4_sha2_asm.h"
+
+/*ARGSUSED*/
+void
+t4_sha256_multiblock(T4_SHA256_CTX *c, const void *input,
+	size_t num)
+{ return; }
+
+/*ARGSUSED*/
+void
+t4_sha512_multiblock(T4_SHA512_CTX *c, const void *input,
+	size_t num)
+{ return; }
+
+#else	/* lint || __lint */
+
+#include<sys/asm_linkage.h>
+
+	ENTRY(t4_sha256_multiblock)
+
+	add	%o0, 0x8, %o0		!skip over first field in ctx
+
+!load result from previous digest (stored in ctx)
+	ld	[%o0], %f0
+	ld	[%o0 + 0x4], %f1
+	ld	[%o0 + 0x8], %f2
+	ld	[%o0 + 0xc], %f3
+	ld	[%o0 + 0x10], %f4
+	ld	[%o0 + 0x14], %f5
+	ld	[%o0 + 0x18], %f6
+	ld	[%o0 + 0x1c], %f7
+
+	and	%o1, 7, %o3
+	brnz	%o3, sha256_unaligned_input
+	nop
+
+sha256_loop:
+
+!load 64 bytes of data
+	ldd	[%o1], %f8		!load 8 bytes of data
+	ldd	[%o1 + 0x8], %f10	!load 8 bytes of data
+	ldd	[%o1 + 0x10], %f12	!load 8 bytes of data
+	ldd	[%o1 + 0x18], %f14	!load 8 bytes of data
+	ldd	[%o1 + 0x20], %f16	!load 8 bytes of data
+	ldd	[%o1 + 0x28], %f18	!load 8 bytes of data
+	ldd	[%o1 + 0x30], %f20	!load 8 bytes of data
+	ldd	[%o1 + 0x38], %f22	!load 8 bytes of data
+
+!perform crypto instruction here
+	!sha256
+	.byte	0x81, 0xb0, 0x28, 0x40
+
+	dec	%o2
+	brnz	%o2, sha256_loop
+	add	%o1, 0x40, %o1
+
+!copy digest back into ctx
+	st	%f0, [%o0]
+	st	%f1, [%o0 + 0x4]
+	st	%f2, [%o0 + 0x8]
+	st	%f3, [%o0 + 0xc]
+	st	%f4, [%o0 + 0x10]
+	st	%f5, [%o0 + 0x14]
+	st	%f6, [%o0 + 0x18]
+	retl
+	st	%f7, [%o0 + 0x1c]
+
+sha256_unaligned_input:
+	alignaddr %o1, %g0, %g0		! generate %gsr
+	andn	%o1, 7, %o1
+
+sha256_unaligned_input_loop:
+	ldd	[%o1], %f8		!load 8 bytes of data
+	ldd	[%o1 + 0x8], %f10	!load 8 bytes of data
+	ldd	[%o1 + 0x10], %f12	!load 8 bytes of data
+	ldd	[%o1 + 0x18], %f14	!load 8 bytes of data
+	ldd	[%o1 + 0x20], %f16	!load 8 bytes of data
+	ldd	[%o1 + 0x28], %f18	!load 8 bytes of data
+	ldd	[%o1 + 0x30], %f20	!load 8 bytes of data
+	ldd	[%o1 + 0x38], %f22	!load 8 bytes of data
+	ldd	[%o1 + 0x40], %f24	!load 8 bytes of data
+	faligndata %f8, %f10, %f8
+	faligndata %f10, %f12, %f10
+	faligndata %f12, %f14, %f12
+	faligndata %f14, %f16, %f14
+	faligndata %f16, %f18, %f16
+	faligndata %f18, %f20, %f18
+	faligndata %f20, %f22, %f20
+	faligndata %f22, %f24, %f22
+
+!perform crypto instruction here
+	!sha256
+	.byte	0x81, 0xb0, 0x28, 0x40
+
+	dec	%o2
+	brnz	%o2, sha256_unaligned_input_loop
+	add	%o1, 0x40, %o1
+
+!copy digest back into ctx
+	st	%f0, [%o0]
+	st	%f1, [%o0 + 0x4]
+	st	%f2, [%o0 + 0x8]
+	st	%f3, [%o0 + 0xc]
+	st	%f4, [%o0 + 0x10]
+	st	%f5, [%o0 + 0x14]
+	st	%f6, [%o0 + 0x18]
+	retl
+	st	%f7, [%o0 + 0x1c]
+
+	SET_SIZE(t4_sha256_multiblock)
+
+
+	ENTRY(t4_sha512_multiblock)
+
+	add	%o0, 0x8, %o0		!skip over first field in ctx
+
+!load result from previous digest (stored in ctx)
+	ld	[%o0], %f0
+	ld	[%o0 + 0x4], %f1
+	ld	[%o0 + 0x8], %f2
+	ld	[%o0 + 0xc], %f3
+	ld	[%o0 + 0x10], %f4
+	ld	[%o0 + 0x14], %f5
+	ld	[%o0 + 0x18], %f6
+	ld	[%o0 + 0x1c], %f7
+	ld	[%o0 + 0x20], %f8
+	ld	[%o0 + 0x24], %f9
+	ld	[%o0 + 0x28], %f10
+	ld	[%o0 + 0x2c], %f11
+	ld	[%o0 + 0x30], %f12
+	ld	[%o0 + 0x34], %f13
+	ld	[%o0 + 0x38], %f14
+	ld	[%o0 + 0x3c], %f15
+
+	and	%o1, 7, %o3
+	brnz	%o3, sha512_unaligned_input
+	nop
+
+sha512_loop:
+
+!load 128 bytes of data
+	ldd	[%o1], %f16		!load 8 bytes of data
+	ldd	[%o1 + 0x8], %f18	!load 8 bytes of data
+	ldd	[%o1 + 0x10], %f20	!load 8 bytes of data
+	ldd	[%o1 + 0x18], %f22	!load 8 bytes of data
+	ldd	[%o1 + 0x20], %f24	!load 8 bytes of data
+	ldd	[%o1 + 0x28], %f26	!load 8 bytes of data
+	ldd	[%o1 + 0x30], %f28	!load 8 bytes of data
+	ldd	[%o1 + 0x38], %f30	!load 8 bytes of data
+	ldd	[%o1 + 0x40], %f32	!load 8 bytes of data
+	ldd	[%o1 + 0x48], %f34	!load 8 bytes of data
+	ldd	[%o1 + 0x50], %f36	!load 8 bytes of data
+	ldd	[%o1 + 0x58], %f38	!load 8 bytes of data
+	ldd	[%o1 + 0x60], %f40	!load 8 bytes of data
+	ldd	[%o1 + 0x68], %f42	!load 8 bytes of data
+	ldd	[%o1 + 0x70], %f44	!load 8 bytes of data
+	ldd	[%o1 + 0x78], %f46	!load 8 bytes of data
+
+!perform crypto instruction here
+	!sha512
+	.byte	0x81, 0xb0, 0x28, 0x60
+
+	dec	%o2
+	brnz	%o2, sha512_loop
+	add	%o1, 0x80, %o1
+
+!copy digest back into ctx
+	st	%f0, [%o0]
+	st	%f1, [%o0 + 0x4]
+	st	%f2, [%o0 + 0x8]
+	st	%f3, [%o0 + 0xc]
+	st	%f4, [%o0 + 0x10]
+	st	%f5, [%o0 + 0x14]
+	st	%f6, [%o0 + 0x18]
+	st	%f7, [%o0+ 0x1c]
+	st	%f8, [%o0+ 0x20]
+	st	%f9, [%o0+ 0x24]
+	st	%f10, [%o0+ 0x28]
+	st	%f11, [%o0+ 0x2c]
+	st	%f12, [%o0+ 0x30]
+	st	%f13, [%o0+ 0x34]
+	st	%f14, [%o0+ 0x38]
+	retl
+	st	%f15, [%o0+ 0x3c]
+
+sha512_unaligned_input:
+	alignaddr %o1, %g0, %g0		! generate %gsr
+	andn	%o1, 7, %o1
+
+sha512_unaligned_input_loop:
+	ldd	[%o1], %f16		!load 8 bytes of data
+	ldd	[%o1 + 0x8], %f18	!load 8 bytes of data
+	ldd	[%o1 + 0x10], %f20	!load 8 bytes of data
+	ldd	[%o1 + 0x18], %f22	!load 8 bytes of data
+	ldd	[%o1 + 0x20], %f24	!load 8 bytes of data
+	ldd	[%o1 + 0x28], %f26	!load 8 bytes of data
+	ldd	[%o1 + 0x30], %f28	!load 8 bytes of data
+	ldd	[%o1 + 0x38], %f30	!load 8 bytes of data
+	ldd	[%o1 + 0x40], %f32	!load 8 bytes of data
+	ldd	[%o1 + 0x48], %f34	!load 8 bytes of data
+	ldd	[%o1 + 0x50], %f36	!load 8 bytes of data
+	ldd	[%o1 + 0x58], %f38	!load 8 bytes of data
+	ldd	[%o1 + 0x60], %f40	!load 8 bytes of data
+	ldd	[%o1 + 0x68], %f42	!load 8 bytes of data
+	ldd	[%o1 + 0x70], %f44	!load 8 bytes of data
+	ldd	[%o1 + 0x78], %f46	!load 8 bytes of data
+	ldd	[%o1 + 0x80], %f48	!load 8 bytes of data
+	faligndata %f16, %f18, %f16
+	faligndata %f18, %f20, %f18
+	faligndata %f20, %f22, %f20
+	faligndata %f22, %f24, %f22
+	faligndata %f24, %f26, %f24
+	faligndata %f26, %f28, %f26
+	faligndata %f28, %f30, %f28
+	faligndata %f30, %f32, %f30
+	faligndata %f32, %f34, %f32
+	faligndata %f34, %f36, %f34
+	faligndata %f36, %f38, %f36
+	faligndata %f38, %f40, %f38
+	faligndata %f40, %f42, %f40
+	faligndata %f42, %f44, %f42
+	faligndata %f44, %f46, %f44
+	faligndata %f46, %f48, %f46
+
+!perform crypto instruction here
+	!sha512
+	.byte	0x81, 0xb0, 0x28, 0x60
+
+	dec	%o2
+	brnz	%o2, sha512_unaligned_input_loop
+	add	%o1, 0x80, %o1
+
+!copy digest back into ctx
+	st	%f0, [%o0]
+	st	%f1, [%o0 + 0x4]
+	st	%f2, [%o0 + 0x8]
+	st	%f3, [%o0 + 0xc]
+	st	%f4, [%o0 + 0x10]
+	st	%f5, [%o0 + 0x14]
+	st	%f6, [%o0 + 0x18]
+	st	%f7, [%o0+ 0x1c]
+	st	%f8, [%o0+ 0x20]
+	st	%f9, [%o0+ 0x24]
+	st	%f10, [%o0+ 0x28]
+	st	%f11, [%o0+ 0x2c]
+	st	%f12, [%o0+ 0x30]
+	st	%f13, [%o0+ 0x34]
+	st	%f14, [%o0+ 0x38]
+	retl
+	st	%f15, [%o0+ 0x3c]
+
+	SET_SIZE(t4_sha512_multiblock)
+
+#endif  /* lint || __lint */
diff -uNr openssl-1.0.1c.orig/util/libeay.num openssl-1.0.1c/util/libeay.num
--- openssl-1.0.1c.orig/util/libeay.num	2011-12-25 15:48:44.000000000 +0100
+++ openssl-1.0.1c/util/libeay.num	2012-05-11 22:19:17.508123000 +0200
@@ -4178,6 +4178,7 @@
 UI_method_set_prompt_constructor        4551	EXIST:!VMS:FUNCTION:
 UI_method_set_prompt_constructr         4551	EXIST:VMS:FUNCTION:
 EVP_read_pw_string_min                  4552	EXIST::FUNCTION:
+ENGINE_load_t4                          4553	EXIST::FUNCTION:ENGINE
 CRYPTO_cts128_encrypt                   4553	EXIST::FUNCTION:
 CRYPTO_cts128_decrypt_block             4554	EXIST::FUNCTION:
 CRYPTO_cfb128_1_encrypt                 4555	EXIST::FUNCTION:
