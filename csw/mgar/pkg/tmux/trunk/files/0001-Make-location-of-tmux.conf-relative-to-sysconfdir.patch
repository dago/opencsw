From 5547c378f07ecb7b64e2c0f8a0fec345c75873c4 Mon Sep 17 00:00:00 2001
From: Dagobert Michelsen <dam@opencsw.org>
Date: Sun, 21 Apr 2013 10:24:49 +0200
Subject: [PATCH] Make location of tmux.conf relative to sysconfdir

---
 configure.ac |    2 +
 tmux.1       | 3808 ----------------------------------------------------------
 tmux.1.in    | 3808 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 tmux.h       | 2352 ------------------------------------
 tmux.h.in    | 2352 ++++++++++++++++++++++++++++++++++++
 5 files changed, 6162 insertions(+), 6160 deletions(-)
 delete mode 100644 tmux.1
 create mode 100644 tmux.1.in
 delete mode 100644 tmux.h
 create mode 100644 tmux.h.in

diff --git a/configure.ac b/configure.ac
index f00937f..0163450 100644
--- a/configure.ac
+++ b/configure.ac
@@ -479,3 +479,5 @@ AM_CONDITIONAL(IS_UNKNOWN, test "x$PLATFORM" = xunknown)
 
 # autoconf should create a Makefile. A shock!
 AC_OUTPUT(Makefile)
+AC_OUTPUT(tmux.1)
+AC_OUTPUT(tmux.h)
diff --git a/tmux.1 b/tmux.1
deleted file mode 100644
index 98bf957..0000000
--- a/tmux.1
+++ /dev/null
@@ -1,3808 +0,0 @@
-.\" $Id$
-.\"
-.\" Copyright (c) 2007 Nicholas Marriott <nicm@users.sourceforge.net>
-.\"
-.\" Permission to use, copy, modify, and distribute this software for any
-.\" purpose with or without fee is hereby granted, provided that the above
-.\" copyright notice and this permission notice appear in all copies.
-.\"
-.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-.\" WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
-.\" IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
-.\" OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-.\"
-.Dd $Mdocdate: March 25 2013 $
-.Dt TMUX 1
-.Os
-.Sh NAME
-.Nm tmux
-.Nd terminal multiplexer
-.Sh SYNOPSIS
-.Nm tmux
-.Bk -words
-.Op Fl 28lCquvV
-.Op Fl c Ar shell-command
-.Op Fl f Ar file
-.Op Fl L Ar socket-name
-.Op Fl S Ar socket-path
-.Op Ar command Op Ar flags
-.Ek
-.Sh DESCRIPTION
-.Nm
-is a terminal multiplexer:
-it enables a number of terminals to be created, accessed, and
-controlled from a single screen.
-.Nm
-may be detached from a screen
-and continue running in the background,
-then later reattached.
-.Pp
-When
-.Nm
-is started it creates a new
-.Em session
-with a single
-.Em window
-and displays it on screen.
-A status line at the bottom of the screen
-shows information on the current session
-and is used to enter interactive commands.
-.Pp
-A session is a single collection of
-.Em pseudo terminals
-under the management of
-.Nm .
-Each session has one or more
-windows linked to it.
-A window occupies the entire screen
-and may be split into rectangular panes,
-each of which is a separate pseudo terminal
-(the
-.Xr pty 4
-manual page documents the technical details of pseudo terminals).
-Any number of
-.Nm
-instances may connect to the same session,
-and any number of windows may be present in the same session.
-Once all sessions are killed,
-.Nm
-exits.
-.Pp
-Each session is persistent and will survive accidental disconnection
-(such as
-.Xr ssh 1
-connection timeout) or intentional detaching (with the
-.Ql C-b d
-key strokes).
-.Nm
-may be reattached using:
-.Pp
-.Dl $ tmux attach
-.Pp
-In
-.Nm ,
-a session is displayed on screen by a
-.Em client
-and all sessions are managed by a single
-.Em server .
-The server and each client are separate processes which communicate through a
-socket in
-.Pa /tmp .
-.Pp
-The options are as follows:
-.Bl -tag -width "XXXXXXXXXXXX"
-.It Fl 2
-Force
-.Nm
-to assume the terminal supports 256 colours.
-.It Fl C
-Start in control mode.
-Given twice
-.Xo ( Fl CC ) Xc
-disables echo.
-.It Fl c Ar shell-command
-Execute
-.Ar shell-command
-using the default shell.
-If necessary, the
-.Nm
-server will be started to retrieve the
-.Ic default-shell
-option.
-This option is for compatibility with
-.Xr sh 1
-when
-.Nm
-is used as a login shell.
-.It Fl f Ar file
-Specify an alternative configuration file.
-By default,
-.Nm
-loads the system configuration file from
-.Pa /etc/tmux.conf ,
-if present, then looks for a user configuration file at
-.Pa ~/.tmux.conf .
-.Pp
-The configuration file is a set of
-.Nm
-commands which are executed in sequence when the server is first started.
-.Nm
-loads configuration files once when the server process has started.
-The
-.Ic source-file
-command may be used to load a file later.
-.Pp
-.Nm
-shows any error messages from commands in configuration files in the first
-session created, and continues to process the rest of the configuration file.
-.It Fl L Ar socket-name
-.Nm
-stores the server socket in a directory under
-.Ev TMUX_TMPDIR ,
-.Ev TMPDIR
-if it is unset, or
-.Pa /tmp
-if both are unset.
-The default socket is named
-.Em default .
-This option allows a different socket name to be specified, allowing several
-independent
-.Nm
-servers to be run.
-Unlike
-.Fl S
-a full path is not necessary: the sockets are all created in the same
-directory.
-.Pp
-If the socket is accidentally removed, the
-.Dv SIGUSR1
-signal may be sent to the
-.Nm
-server process to recreate it.
-.It Fl l
-Behave as a login shell.
-This flag currently has no effect and is for compatibility with other shells
-when using tmux as a login shell.
-.It Fl q
-Set the
-.Ic quiet
-server option to prevent the server sending various informational messages.
-.It Fl S Ar socket-path
-Specify a full alternative path to the server socket.
-If
-.Fl S
-is specified, the default socket directory is not used and any
-.Fl L
-flag is ignored.
-.It Fl u
-.Nm
-attempts to guess if the terminal is likely to support UTF-8 by checking the
-first of the
-.Ev LC_ALL ,
-.Ev LC_CTYPE
-and
-.Ev LANG
-environment variables to be set for the string "UTF-8".
-This is not always correct: the
-.Fl u
-flag explicitly informs
-.Nm
-that UTF-8 is supported.
-.Pp
-If the server is started from a client passed
-.Fl u
-or where UTF-8 is detected, the
-.Ic utf8
-and
-.Ic status-utf8
-options are enabled in the global window and session options respectively.
-.It Fl v
-Request verbose logging.
-This option may be specified multiple times for increasing verbosity.
-Log messages will be saved into
-.Pa tmux-client-PID.log
-and
-.Pa tmux-server-PID.log
-files in the current directory, where
-.Em PID
-is the PID of the server or client process.
-.It Fl V
-Report the
-.Nm
-version.
-.It Ar command Op Ar flags
-This specifies one of a set of commands used to control
-.Nm ,
-as described in the following sections.
-If no commands are specified, the
-.Ic new-session
-command is assumed.
-.El
-.Sh KEY BINDINGS
-.Nm
-may be controlled from an attached client by using a key combination of a
-prefix key,
-.Ql C-b
-(Ctrl-b) by default, followed by a command key.
-.Pp
-The default command key bindings are:
-.Pp
-.Bl -tag -width "XXXXXXXXXX" -offset indent -compact
-.It C-b
-Send the prefix key (C-b) through to the application.
-.It C-o
-Rotate the panes in the current window forwards.
-.It C-z
-Suspend the
-.Nm
-client.
-.It !
-Break the current pane out of the window.
-.It \&"
-Split the current pane into two, top and bottom.
-.It #
-List all paste buffers.
-.It $
-Rename the current session.
-.It %
-Split the current pane into two, left and right.
-.It &
-Kill the current window.
-.It '
-Prompt for a window index to select.
-.It ,
-Rename the current window.
-.It -
-Delete the most recently copied buffer of text.
-.It .
-Prompt for an index to move the current window.
-.It 0 to 9
-Select windows 0 to 9.
-.It :
-Enter the
-.Nm
-command prompt.
-.It ;
-Move to the previously active pane.
-.It =
-Choose which buffer to paste interactively from a list.
-.It \&?
-List all key bindings.
-.It D
-Choose a client to detach.
-.It \&[
-Enter copy mode to copy text or view the history.
-.It \&]
-Paste the most recently copied buffer of text.
-.It c
-Create a new window.
-.It d
-Detach the current client.
-.It f
-Prompt to search for text in open windows.
-.It i
-Display some information about the current window.
-.It l
-Move to the previously selected window.
-.It n
-Change to the next window.
-.It o
-Select the next pane in the current window.
-.It p
-Change to the previous window.
-.It q
-Briefly display pane indexes.
-.It r
-Force redraw of the attached client.
-.It s
-Select a new session for the attached client interactively.
-.It L
-Switch the attached client back to the last session.
-.It t
-Show the time.
-.It w
-Choose the current window interactively.
-.It x
-Kill the current pane.
-.It {
-Swap the current pane with the previous pane.
-.It }
-Swap the current pane with the next pane.
-.It ~
-Show previous messages from
-.Nm ,
-if any.
-.It Page Up
-Enter copy mode and scroll one page up.
-.It Up, Down
-.It Left, Right
-Change to the pane above, below, to the left, or to the right of the current
-pane.
-.It M-1 to M-5
-Arrange panes in one of the five preset layouts: even-horizontal,
-even-vertical, main-horizontal, main-vertical, or tiled.
-.It M-n
-Move to the next window with a bell or activity marker.
-.It M-o
-Rotate the panes in the current window backwards.
-.It M-p
-Move to the previous window with a bell or activity marker.
-.It C-Up, C-Down
-.It C-Left, C-Right
-Resize the current pane in steps of one cell.
-.It M-Up, M-Down
-.It M-Left, M-Right
-Resize the current pane in steps of five cells.
-.El
-.Pp
-Key bindings may be changed with the
-.Ic bind-key
-and
-.Ic unbind-key
-commands.
-.Sh COMMANDS
-This section contains a list of the commands supported by
-.Nm .
-Most commands accept the optional
-.Fl t
-argument with one of
-.Ar target-client ,
-.Ar target-session
-.Ar target-window ,
-or
-.Ar target-pane .
-These specify the client, session, window or pane which a command should affect.
-.Ar target-client
-is the name of the
-.Xr pty 4
-file to which the client is connected, for example either of
-.Pa /dev/ttyp1
-or
-.Pa ttyp1
-for the client attached to
-.Pa /dev/ttyp1 .
-If no client is specified, the current client is chosen, if possible, or an
-error is reported.
-Clients may be listed with the
-.Ic list-clients
-command.
-.Pp
-.Ar target-session
-is the session id prefixed with a $, the name of a session (as listed by the
-.Ic list-sessions
-command), or the name of a client with the same syntax as
-.Ar target-client ,
-in which case the session attached to the client is used.
-When looking for the session name,
-.Nm
-initially searches for an exact match; if none is found, the session names
-are checked for any for which
-.Ar target-session
-is a prefix or for which it matches as an
-.Xr fnmatch 3
-pattern.
-If a single match is found, it is used as the target session; multiple matches
-produce an error.
-If a session is omitted, the current session is used if available; if no
-current session is available, the most recently used is chosen.
-.Pp
-.Ar target-window
-specifies a window in the form
-.Em session Ns \&: Ns Em window .
-.Em session
-follows the same rules as for
-.Ar target-session ,
-and
-.Em window
-is looked for in order: as a window index, for example mysession:1;
-as a window ID, such as @1;
-as an exact window name, such as mysession:mywindow; then as an
-.Xr fnmatch 3
-pattern or the start of a window name, such as mysession:mywin* or
-mysession:mywin.
-An empty window name specifies the next unused index if appropriate (for
-example the
-.Ic new-window
-and
-.Ic link-window
-commands)
-otherwise the current window in
-.Em session
-is chosen.
-The special character
-.Ql \&!
-uses the last (previously current) window,
-.Ql ^
-selects the highest numbered window,
-.Ql $
-selects the lowest numbered window, and
-.Ql +
-and
-.Ql -
-select the next window or the previous window by number.
-When the argument does not contain a colon,
-.Nm
-first attempts to parse it as window; if that fails, an attempt is made to
-match a session.
-.Pp
-.Ar target-pane
-takes a similar form to
-.Ar target-window
-but with the optional addition of a period followed by a pane index, for
-example: mysession:mywindow.1.
-If the pane index is omitted, the currently active pane in the specified
-window is used.
-If neither a colon nor period appears,
-.Nm
-first attempts to use the argument as a pane index; if that fails, it is looked
-up as for
-.Ar target-window .
-A
-.Ql +
-or
-.Ql -
-indicate the next or previous pane index, respectively.
-One of the strings
-.Em top ,
-.Em bottom ,
-.Em left ,
-.Em right ,
-.Em top-left ,
-.Em top-right ,
-.Em bottom-left
-or
-.Em bottom-right
-may be used instead of a pane index.
-.Pp
-The special characters
-.Ql +
-and
-.Ql -
-may be followed by an offset, for example:
-.Bd -literal -offset indent
-select-window -t:+2
-.Ed
-.Pp
-When dealing with a session that doesn't contain sequential window indexes,
-they will be correctly skipped.
-.Pp
-.Nm
-also gives each pane created in a server an identifier consisting of a
-.Ql %
-and a number, starting from zero.
-A pane's identifier is unique for the life of the
-.Nm
-server and is passed to the child process of the pane in the
-.Ev TMUX_PANE
-environment variable.
-It may be used alone to target a pane or the window containing it.
-.Pp
-.Ar shell-command
-arguments are
-.Xr sh 1
-commands.
-These must be passed as a single item, which typically means quoting them, for
-example:
-.Bd -literal -offset indent
-new-window 'vi /etc/passwd'
-.Ed
-.Pp
-.Ar command
-.Op Ar arguments
-refers to a
-.Nm
-command, passed with the command and arguments separately, for example:
-.Bd -literal -offset indent
-bind-key F1 set-window-option force-width 81
-.Ed
-.Pp
-Or if using
-.Xr sh 1 :
-.Bd -literal -offset indent
-$ tmux bind-key F1 set-window-option force-width 81
-.Ed
-.Pp
-Multiple commands may be specified together as part of a
-.Em command sequence .
-Each command should be separated by spaces and a semicolon;
-commands are executed sequentially from left to right and
-lines ending with a backslash continue on to the next line,
-except when escaped by another backslash.
-A literal semicolon may be included by escaping it with a backslash (for
-example, when specifying a command sequence to
-.Ic bind-key ) .
-.Pp
-Example
-.Nm
-commands include:
-.Bd -literal -offset indent
-refresh-client -t/dev/ttyp2
-
-rename-session -tfirst newname
-
-set-window-option -t:0 monitor-activity on
-
-new-window ; split-window -d
-
-bind-key R source-file ~/.tmux.conf \e; \e
-	display-message "source-file done"
-.Ed
-.Pp
-Or from
-.Xr sh 1 :
-.Bd -literal -offset indent
-$ tmux kill-window -t :1
-
-$ tmux new-window \e; split-window -d
-
-$ tmux new-session -d 'vi /etc/passwd' \e; split-window -d \e; attach
-.Ed
-.Sh CLIENTS AND SESSIONS
-The
-.Nm
-server manages clients, sessions, windows and panes.
-Clients are attached to sessions to interact with them, either
-when they are created with the
-.Ic new-session
-command, or later with the
-.Ic attach-session
-command.
-Each session has one or more windows
-.Em linked
-into it.
-Windows may be linked to multiple sessions and are made up of one or
-more panes,
-each of which contains a pseudo terminal.
-Commands for creating, linking and otherwise manipulating windows
-are covered
-in the
-.Sx WINDOWS AND PANES
-section.
-.Pp
-The following commands are available to manage clients and sessions:
-.Bl -tag -width Ds
-.It Xo Ic attach-session
-.Op Fl dr
-.Op Fl t Ar target-session
-.Xc
-.D1 (alias: Ic attach )
-If run from outside
-.Nm ,
-create a new client in the current terminal and attach it to
-.Ar target-session .
-If used from inside, switch the current client.
-If
-.Fl d
-is specified, any other clients attached to the session are detached.
-.Fl r
-signifies the client is read-only (only keys bound to the
-.Ic detach-client
-or
-.Ic switch-client
-commands have any effect)
-.Pp
-If no server is started,
-.Ic attach-session
-will attempt to start it; this will fail unless sessions are created in the
-configuration file.
-.Pp
-The
-.Ar target-session
-rules for
-.Ic attach-session
-are slightly adjusted: if
-.Nm
-needs to select the most recently used session, it will prefer the most
-recently used
-.Em unattached
-session.
-.It Xo Ic detach-client
-.Op Fl P
-.Op Fl a
-.Op Fl s Ar target-session
-.Op Fl t Ar target-client
-.Xc
-.D1 (alias: Ic detach )
-Detach the current client if bound to a key, the client specified with
-.Fl t ,
-or all clients currently attached to the session specified by
-.Fl s .
-The
-.Fl a
-option kills all but the client given with
-.Fl t .
-If
-.Fl P
-is given, send SIGHUP to the parent process of the client, typically causing it
-to exit.
-.It Ic has-session Op Fl t Ar target-session
-.D1 (alias: Ic has )
-Report an error and exit with 1 if the specified session does not exist.
-If it does exist, exit with 0.
-.It Ic kill-server
-Kill the
-.Nm
-server and clients and destroy all sessions.
-.It Ic kill-session
-.Op Fl a
-.Op Fl t Ar target-session
-Destroy the given session, closing any windows linked to it and no other
-sessions, and detaching all clients attached to it.
-If
-.Fl a
-is given, all sessions but the specified one is killed.
-.It Xo Ic list-clients
-.Op Fl F Ar format
-.Op Fl t Ar target-session
-.Xc
-.D1 (alias: Ic lsc )
-List all clients attached to the server.
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-If
-.Ar target-session
-is specified, list only clients connected to that session.
-.It Ic list-commands
-.D1 (alias: Ic lscm )
-List the syntax of all commands supported by
-.Nm .
-.It Ic list-sessions Op Fl F Ar format
-.D1 (alias: Ic ls )
-List all sessions managed by the server.
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-.It Ic lock-client Op Fl t Ar target-client
-.D1 (alias: Ic lockc )
-Lock
-.Ar target-client ,
-see the
-.Ic lock-server
-command.
-.It Ic lock-session Op Fl t Ar target-session
-.D1 (alias: Ic locks )
-Lock all clients attached to
-.Ar target-session .
-.It Xo Ic new-session
-.Op Fl AdDP
-.Op Fl F Ar format
-.Op Fl n Ar window-name
-.Op Fl s Ar session-name
-.Op Fl t Ar target-session
-.Op Fl x Ar width
-.Op Fl y Ar height
-.Op Ar shell-command
-.Xc
-.D1 (alias: Ic new )
-Create a new session with name
-.Ar session-name .
-.Pp
-The new session is attached to the current terminal unless
-.Fl d
-is given.
-.Ar window-name
-and
-.Ar shell-command
-are the name of and shell command to execute in the initial window.
-If
-.Fl d
-is used,
-.Fl x
-and
-.Fl y
-specify the size of the initial window (80 by 24 if not given).
-.Pp
-If run from a terminal, any
-.Xr termios 4
-special characters are saved and used for new windows in the new session.
-.Pp
-The
-.Fl A
-flag makes
-.Ic new-session
-behave like
-.Ic attach-session
-if
-.Ar session-name
-already exists; in the case,
-.Fl D
-behaves like
-.Fl d
-to
-.Ic attach-session .
-.Pp
-If
-.Fl t
-is given, the new session is
-.Em grouped
-with
-.Ar target-session .
-This means they share the same set of windows - all windows from
-.Ar target-session
-are linked to the new session and any subsequent new windows or windows being
-closed are applied to both sessions.
-The current and previous window and any session options remain independent and
-either session may be killed without affecting the other.
-Giving
-.Fl n
-or
-.Ar shell-command
-are invalid if
-.Fl t
-is used.
-.Pp
-The
-.Fl P
-option prints information about the new session after it has been created.
-By default, it uses the format
-.Ql #{session_name}:
-but a different format may be specified with
-.Fl F .
-.It Xo Ic refresh-client
-.Op Fl S
-.Op Fl t Ar target-client
-.Xc
-.D1 (alias: Ic refresh )
-Refresh the current client if bound to a key, or a single client if one is given
-with
-.Fl t .
-If
-.Fl S
-is specified, only update the client's status bar.
-.It Xo Ic rename-session
-.Op Fl t Ar target-session
-.Ar new-name
-.Xc
-.D1 (alias: Ic rename )
-Rename the session to
-.Ar new-name .
-.It Xo Ic show-messages
-.Op Fl t Ar target-client
-.Xc
-.D1 (alias: Ic showmsgs )
-Any messages displayed on the status line are saved in a per-client message
-log, up to a maximum of the limit set by the
-.Ar message-limit
-session option for the session attached to that client.
-This command displays the log for
-.Ar target-client .
-.It Ic source-file Ar path
-.D1 (alias: Ic source )
-Execute commands from
-.Ar path .
-.It Ic start-server
-.D1 (alias: Ic start )
-Start the
-.Nm
-server, if not already running, without creating any sessions.
-.It Xo Ic suspend-client
-.Op Fl t Ar target-client
-.Xc
-.D1 (alias: Ic suspendc )
-Suspend a client by sending
-.Dv SIGTSTP
-(tty stop).
-.It Xo Ic switch-client
-.Op Fl lnpr
-.Op Fl c Ar target-client
-.Op Fl t Ar target-session
-.Xc
-.D1 (alias: Ic switchc )
-Switch the current session for client
-.Ar target-client
-to
-.Ar target-session .
-If
-.Fl l ,
-.Fl n
-or
-.Fl p
-is used, the client is moved to the last, next or previous session
-respectively.
-.Fl r
-toggles whether a client is read-only (see the
-.Ic attach-session
-command).
-.El
-.Sh WINDOWS AND PANES
-A
-.Nm
-window may be in one of several modes.
-The default permits direct access to the terminal attached to the window.
-The other is copy mode, which permits a section of a window or its
-history to be copied to a
-.Em paste buffer
-for later insertion into another window.
-This mode is entered with the
-.Ic copy-mode
-command, bound to
-.Ql \&[
-by default.
-It is also entered when a command that produces output, such as
-.Ic list-keys ,
-is executed from a key binding.
-.Pp
-The keys available depend on whether emacs or vi mode is selected
-(see the
-.Ic mode-keys
-option).
-The following keys are supported as appropriate for the mode:
-.Bl -column "FunctionXXXXXXXXXXXXXXXXX" "viXXXXXXXXXX" "emacs" -offset indent
-.It Sy "Function" Ta Sy "vi" Ta Sy "emacs"
-.It Li "Back to indentation" Ta "^" Ta "M-m"
-.It Li "Bottom of history" Ta "G" Ta "M-<"
-.It Li "Clear selection" Ta "Escape" Ta "C-g"
-.It Li "Copy selection" Ta "Enter" Ta "M-w"
-.It Li "Cursor down" Ta "j" Ta "Down"
-.It Li "Cursor left" Ta "h" Ta "Left"
-.It Li "Cursor right" Ta "l" Ta "Right"
-.It Li "Cursor to bottom line" Ta "L" Ta ""
-.It Li "Cursor to middle line" Ta "M" Ta "M-r"
-.It Li "Cursor to top line" Ta "H" Ta "M-R"
-.It Li "Cursor up" Ta "k" Ta "Up"
-.It Li "Delete entire line" Ta "d" Ta "C-u"
-.It Li "Delete/Copy to end of line" Ta "D" Ta "C-k"
-.It Li "End of line" Ta "$" Ta "C-e"
-.It Li "Go to line" Ta ":" Ta "g"
-.It Li "Half page down" Ta "C-d" Ta "M-Down"
-.It Li "Half page up" Ta "C-u" Ta "M-Up"
-.It Li "Jump forward" Ta "f" Ta "f"
-.It Li "Jump to forward" Ta "t" Ta ""
-.It Li "Jump backward" Ta "F" Ta "F"
-.It Li "Jump to backward" Ta "T" Ta ""
-.It Li "Jump again" Ta ";" Ta ";"
-.It Li "Jump again in reverse" Ta "," Ta ","
-.It Li "Next page" Ta "C-f" Ta "Page down"
-.It Li "Next space" Ta "W" Ta ""
-.It Li "Next space, end of word" Ta "E" Ta ""
-.It Li "Next word" Ta "w" Ta ""
-.It Li "Next word end" Ta "e" Ta "M-f"
-.It Li "Paste buffer" Ta "p" Ta "C-y"
-.It Li "Previous page" Ta "C-b" Ta "Page up"
-.It Li "Previous word" Ta "b" Ta "M-b"
-.It Li "Previous space" Ta "B" Ta ""
-.It Li "Quit mode" Ta "q" Ta "Escape"
-.It Li "Rectangle toggle" Ta "v" Ta "R"
-.It Li "Scroll down" Ta "C-Down or C-e" Ta "C-Down"
-.It Li "Scroll up" Ta "C-Up or C-y" Ta "C-Up"
-.It Li "Search again" Ta "n" Ta "n"
-.It Li "Search again in reverse" Ta "N" Ta "N"
-.It Li "Search backward" Ta "?" Ta "C-r"
-.It Li "Search forward" Ta "/" Ta "C-s"
-.It Li "Start of line" Ta "0" Ta "C-a"
-.It Li "Start selection" Ta "Space" Ta "C-Space"
-.It Li "Top of history" Ta "g" Ta "M->"
-.It Li "Transpose characters" Ta "" Ta "C-t"
-.El
-.Pp
-The next and previous word keys use space and the
-.Ql - ,
-.Ql _
-and
-.Ql @
-characters as word delimiters by default, but this can be adjusted by
-setting the
-.Em word-separators
-session option.
-Next word moves to the start of the next word, next word end to the end of the
-next word and previous word to the start of the previous word.
-The three next and previous space keys work similarly but use a space alone as
-the word separator.
-.Pp
-The jump commands enable quick movement within a line.
-For instance, typing
-.Ql f
-followed by
-.Ql /
-will move the cursor to the next
-.Ql /
-character on the current line.
-A
-.Ql \&;
-will then jump to the next occurrence.
-.Pp
-Commands in copy mode may be prefaced by an optional repeat count.
-With vi key bindings, a prefix is entered using the number keys; with
-emacs, the Alt (meta) key and a number begins prefix entry.
-For example, to move the cursor forward by ten words, use
-.Ql M-1 0 M-f
-in emacs mode, and
-.Ql 10w
-in vi.
-.Pp
-When copying the selection, the repeat count indicates the buffer index to
-replace, if used.
-.Pp
-Mode key bindings are defined in a set of named tables:
-.Em vi-edit
-and
-.Em emacs-edit
-for keys used when line editing at the command prompt;
-.Em vi-choice
-and
-.Em emacs-choice
-for keys used when choosing from lists (such as produced by the
-.Ic choose-window
-command); and
-.Em vi-copy
-and
-.Em emacs-copy
-used in copy mode.
-The tables may be viewed with the
-.Ic list-keys
-command and keys modified or removed with
-.Ic bind-key
-and
-.Ic unbind-key .
-One command accepts an argument,
-.Ic copy-pipe ,
-which copies the selection and pipes it to a command.
-For example the following will bind
-.Ql C-q
-to copy the selection into
-.Pa /tmp
-as well as the paste buffer:
-.Bd -literal -offset indent
-bind-key -temacs-copy C-q copy-pipe "cat >/tmp/out"
-.Ed
-.Pp
-The paste buffer key pastes the first line from the top paste buffer on the
-stack.
-.Pp
-The synopsis for the
-.Ic copy-mode
-command is:
-.Bl -tag -width Ds
-.It Xo Ic copy-mode
-.Op Fl u
-.Op Fl t Ar target-pane
-.Xc
-Enter copy mode.
-The
-.Fl u
-option scrolls one page up.
-.El
-.Pp
-Each window displayed by
-.Nm
-may be split into one or more
-.Em panes ;
-each pane takes up a certain area of the display and is a separate terminal.
-A window may be split into panes using the
-.Ic split-window
-command.
-Windows may be split horizontally (with the
-.Fl h
-flag) or vertically.
-Panes may be resized with the
-.Ic resize-pane
-command (bound to
-.Ql C-up ,
-.Ql C-down
-.Ql C-left
-and
-.Ql C-right
-by default), the current pane may be changed with the
-.Ic select-pane
-command and the
-.Ic rotate-window
-and
-.Ic swap-pane
-commands may be used to swap panes without changing their position.
-Panes are numbered beginning from zero in the order they are created.
-.Pp
-A number of preset
-.Em layouts
-are available.
-These may be selected with the
-.Ic select-layout
-command or cycled with
-.Ic next-layout
-(bound to
-.Ql Space
-by default); once a layout is chosen, panes within it may be moved and resized
-as normal.
-.Pp
-The following layouts are supported:
-.Bl -tag -width Ds
-.It Ic even-horizontal
-Panes are spread out evenly from left to right across the window.
-.It Ic even-vertical
-Panes are spread evenly from top to bottom.
-.It Ic main-horizontal
-A large (main) pane is shown at the top of the window and the remaining panes
-are spread from left to right in the leftover space at the bottom.
-Use the
-.Em main-pane-height
-window option to specify the height of the top pane.
-.It Ic main-vertical
-Similar to
-.Ic main-horizontal
-but the large pane is placed on the left and the others spread from top to
-bottom along the right.
-See the
-.Em main-pane-width
-window option.
-.It Ic tiled
-Panes are spread out as evenly as possible over the window in both rows and
-columns.
-.El
-.Pp
-In addition,
-.Ic select-layout
-may be used to apply a previously used layout - the
-.Ic list-windows
-command displays the layout of each window in a form suitable for use with
-.Ic select-layout .
-For example:
-.Bd -literal -offset indent
-$ tmux list-windows
-0: ksh [159x48]
-    layout: bb62,159x48,0,0{79x48,0,0,79x48,80,0}
-$ tmux select-layout bb62,159x48,0,0{79x48,0,0,79x48,80,0}
-.Ed
-.Pp
-.Nm
-automatically adjusts the size of the layout for the current window size.
-Note that a layout cannot be applied to a window with more panes than that
-from which the layout was originally defined.
-.Pp
-Commands related to windows and panes are as follows:
-.Bl -tag -width Ds
-.It Xo Ic break-pane
-.Op Fl dP
-.Op Fl F Ar format
-.Op Fl t Ar target-pane
-.Xc
-.D1 (alias: Ic breakp )
-Break
-.Ar target-pane
-off from its containing window to make it the only pane in a new window.
-If
-.Fl d
-is given, the new window does not become the current window.
-The
-.Fl P
-option prints information about the new window after it has been created.
-By default, it uses the format
-.Ql #{session_name}:#{window_index}
-but a different format may be specified with
-.Fl F .
-.It Xo Ic capture-pane
-.Op Fl aepPq
-.Op Fl b Ar buffer-index
-.Op Fl E Ar end-line
-.Op Fl S Ar start-line
-.Op Fl t Ar target-pane
-.Xc
-.D1 (alias: Ic capturep )
-Capture the contents of a pane.
-If
-.Fl p
-is given, the output goes to stdout, otherwise to the buffer specified with
-.Fl b
-or a new buffer if omitted.
-If
-.Fl a
-is given, the alternate screen is used, and the history is not accessible.
-If no alternate screen exists, an error will be returned unless
-.Fl q
-is given.
-If
-.Fl e
-is given, the output includes escape sequences for text and background
-attributes.
-.Fl C
-also escapes non-printable characters as octal \exxx.
-.Fl J
-joins wrapped lines and preserves trailing spaces at each line's end.
-.Fl P
-captures only any output that the pane has received that is the beginning of an
-as-yet incomplete escape sequence.
-.Pp
-.Fl S
-and
-.Fl E
-specify the starting and ending line numbers, zero is the first line of the
-visible pane and negative numbers are lines in the history.
-The default is to capture only the visible contents of the pane.
-.It Xo
-.Ic choose-client
-.Op Fl F Ar format
-.Op Fl t Ar target-window
-.Op Ar template
-.Xc
-Put a window into client choice mode, allowing a client to be selected
-interactively from a list.
-After a client is chosen,
-.Ql %%
-is replaced by the client
-.Xr pty 4
-path in
-.Ar template
-and the result executed as a command.
-If
-.Ar template
-is not given, "detach-client -t '%%'" is used.
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-This command works only if at least one client is attached.
-.It Xo
-.Ic choose-list
-.Op Fl l Ar items
-.Op Fl t Ar target-window
-.Op Ar template
-.Xc
-Put a window into list choice mode, allowing
-.Ar items
-to be selected.
-.Ar items
-can be a comma-separated list to display more than one item.
-If an item has spaces, that entry must be quoted.
-After an item is chosen,
-.Ql %%
-is replaced by the chosen item in the
-.Ar template
-and the result is executed as a command.
-If
-.Ar template
-is not given, "run-shell '%%'" is used.
-.Ar items
-also accepts format specifiers.
-For the meaning of this see the
-.Sx FORMATS
-section.
-This command works only if at least one client is attached.
-.It Xo
-.Ic choose-session
-.Op Fl F Ar format
-.Op Fl t Ar target-window
-.Op Ar template
-.Xc
-Put a window into session choice mode, where a session may be selected
-interactively from a list.
-When one is chosen,
-.Ql %%
-is replaced by the session name in
-.Ar template
-and the result executed as a command.
-If
-.Ar template
-is not given, "switch-client -t '%%'" is used.
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-This command works only if at least one client is attached.
-.It Xo
-.Ic choose-tree
-.Op Fl suw
-.Op Fl b Ar session-template
-.Op Fl c Ar window-template
-.Op Fl S Ar format
-.Op Fl W Ar format
-.Op Fl t Ar target-window
-.Xc
-Put a window into tree choice mode, where either sessions or windows may be
-selected interactively from a list.
-By default, windows belonging to a session are indented to show their
-relationship to a session.
-.Pp
-Note that the
-.Ic choose-window
-and
-.Ic choose-session
-commands are wrappers around
-.Ic choose-tree .
-.Pp
-If
-.Fl s
-is given, will show sessions.
-If
-.Fl w
-is given, will show windows.
-.Pp
-By default, the tree is collapsed and sessions must be expanded to windows
-with the right arrow key.
-The
-.Fl u
-option will start with all sessions expanded instead.
-.Pp
-If
-.Fl b
-is given, will override the default session command.
-Note that
-.Ql %%
-can be used and will be replaced with the session name.
-The default option if not specified is "switch-client -t '%%'".
-If
-.Fl c
-is given, will override the default window command.
-Like
-.Fl b ,
-.Ql %%
-can be used and will be replaced with the session name and window index.
-When a window is chosen from the list, the session command is run before the
-window command.
-.Pp
-If
-.Fl S
-is given will display the specified format instead of the default session
-format.
-If
-.Fl W
-is given will display the specified format instead of the default window
-format.
-For the meaning of the
-.Fl s
-and
-.Fl w
-options, see the
-.Sx FORMATS
-section.
-.Pp
-This command works only if at least one client is attached.
-.It Xo
-.Ic choose-window
-.Op Fl F Ar format
-.Op Fl t Ar target-window
-.Op Ar template
-.Xc
-Put a window into window choice mode, where a window may be chosen
-interactively from a list.
-After a window is selected,
-.Ql %%
-is replaced by the session name and window index in
-.Ar template
-and the result executed as a command.
-If
-.Ar template
-is not given, "select-window -t '%%'" is used.
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-This command works only if at least one client is attached.
-.It Ic display-panes Op Fl t Ar target-client
-.D1 (alias: Ic displayp)
-Display a visible indicator of each pane shown by
-.Ar target-client .
-See the
-.Ic display-panes-time ,
-.Ic display-panes-colour ,
-and
-.Ic display-panes-active-colour
-session options.
-While the indicator is on screen, a pane may be selected with the
-.Ql 0
-to
-.Ql 9
-keys.
-.It Xo Ic find-window
-.Op Fl CNT
-.Op Fl F Ar format
-.Op Fl t Ar target-window
-.Ar match-string
-.Xc
-.D1 (alias: Ic findw )
-Search for the
-.Xr fnmatch 3
-pattern
-.Ar match-string
-in window names, titles, and visible content (but not history).
-The flags control matching behavior:
-.Fl C
-matches only visible window contents,
-.Fl N
-matches only the window name and
-.Fl T
-matches only the window title.
-The default is
-.Fl CNT .
-If only one window is matched, it'll be automatically selected,
-otherwise a choice list is shown.
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-This command works only if at least one client is attached.
-.It Xo Ic join-pane
-.Op Fl bdhv
-.Oo Fl l
-.Ar size |
-.Fl p Ar percentage Oc
-.Op Fl s Ar src-pane
-.Op Fl t Ar dst-pane
-.Xc
-.D1 (alias: Ic joinp )
-Like
-.Ic split-window ,
-but instead of splitting
-.Ar dst-pane
-and creating a new pane, split it and move
-.Ar src-pane
-into the space.
-This can be used to reverse
-.Ic break-pane .
-The
-.Fl b
-option causes
-.Ar src-pane
-to be joined to left of or above
-.Ar dst-pane .
-.It Xo Ic kill-pane
-.Op Fl a
-.Op Fl t Ar target-pane
-.Xc
-.D1 (alias: Ic killp )
-Destroy the given pane.
-If no panes remain in the containing window, it is also destroyed.
-The
-.Fl a
-option kills all but the pane given with
-.Fl t .
-.It Xo Ic kill-window
-.Op Fl a
-.Op Fl t Ar target-window
-.Xc
-.D1 (alias: Ic killw )
-Kill the current window or the window at
-.Ar target-window ,
-removing it from any sessions to which it is linked.
-The
-.Fl a
-option kills all but the window given with
-.Fl t .
-.It Ic last-pane Op Fl t Ar target-window
-.D1 (alias: Ic lastp )
-Select the last (previously selected) pane.
-.It Ic last-window Op Fl t Ar target-session
-.D1 (alias: Ic last )
-Select the last (previously selected) window.
-If no
-.Ar target-session
-is specified, select the last window of the current session.
-.It Xo Ic link-window
-.Op Fl dk
-.Op Fl s Ar src-window
-.Op Fl t Ar dst-window
-.Xc
-.D1 (alias: Ic linkw )
-Link the window at
-.Ar src-window
-to the specified
-.Ar dst-window .
-If
-.Ar dst-window
-is specified and no such window exists, the
-.Ar src-window
-is linked there.
-If
-.Fl k
-is given and
-.Ar dst-window
-exists, it is killed, otherwise an error is generated.
-If
-.Fl d
-is given, the newly linked window is not selected.
-.It Xo Ic list-panes
-.Op Fl as
-.Op Fl F Ar format
-.Op Fl t Ar target
-.Xc
-.D1 (alias: Ic lsp )
-If
-.Fl a
-is given,
-.Ar target
-is ignored and all panes on the server are listed.
-If
-.Fl s
-is given,
-.Ar target
-is a session (or the current session).
-If neither is given,
-.Ar target
-is a window (or the current window).
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-.It Xo Ic list-windows
-.Op Fl a
-.Op Fl F Ar format
-.Op Fl t Ar target-session
-.Xc
-.D1 (alias: Ic lsw )
-If
-.Fl a
-is given, list all windows on the server.
-Otherwise, list windows in the current session or in
-.Ar target-session .
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-.It Xo Ic move-pane
-.Op Fl bdhv
-.Oo Fl l
-.Ar size |
-.Fl p Ar percentage Oc
-.Op Fl s Ar src-pane
-.Op Fl t Ar dst-pane
-.Xc
-.D1 (alias: Ic movep )
-Like
-.Ic join-pane ,
-but
-.Ar src-pane
-and
-.Ar dst-pane
-may belong to the same window.
-.It Xo Ic move-window
-.Op Fl rdk
-.Op Fl s Ar src-window
-.Op Fl t Ar dst-window
-.Xc
-.D1 (alias: Ic movew )
-This is similar to
-.Ic link-window ,
-except the window at
-.Ar src-window
-is moved to
-.Ar dst-window .
-With
-.Fl r ,
-all windows in the session are renumbered in sequential order, respecting
-the
-.Ic base-index
-option.
-.It Xo Ic new-window
-.Op Fl adkP
-.Op Fl c Ar start-directory
-.Op Fl F Ar format
-.Op Fl n Ar window-name
-.Op Fl t Ar target-window
-.Op Ar shell-command
-.Xc
-.D1 (alias: Ic neww )
-Create a new window.
-With
-.Fl a ,
-the new window is inserted at the next index up from the specified
-.Ar target-window ,
-moving windows up if necessary,
-otherwise
-.Ar target-window
-is the new window location.
-.Pp
-If
-.Fl d
-is given, the session does not make the new window the current window.
-.Ar target-window
-represents the window to be created; if the target already exists an error is
-shown, unless the
-.Fl k
-flag is used, in which case it is destroyed.
-.Ar shell-command
-is the command to execute.
-If
-.Ar shell-command
-is not specified, the value of the
-.Ic default-command
-option is used.
-.Fl c
-specifies the working directory in which the new window is created.
-It may have an absolute path or one of the following values (or a subdirectory):
-.Bl -column "XXXXXXXXXXXX" "XXXXXXXXXXXXXXXXXXXXXXXX" -offset indent
-.It Li "Empty string" Ta "Current pane's directory"
-.It Li "~" Ta "User's home directory"
-.It Li "-" Ta "Where session was started"
-.It Li "." Ta "Where server was started"
-.El
-.Pp
-When the shell command completes, the window closes.
-See the
-.Ic remain-on-exit
-option to change this behaviour.
-.Pp
-The
-.Ev TERM
-environment variable must be set to
-.Dq screen
-for all programs running
-.Em inside
-.Nm .
-New windows will automatically have
-.Dq TERM=screen
-added to their environment, but care must be taken not to reset this in shell
-start-up files.
-.Pp
-The
-.Fl P
-option prints information about the new window after it has been created.
-By default, it uses the format
-.Ql #{session_name}:#{window_index}
-but a different format may be specified with
-.Fl F .
-.It Ic next-layout Op Fl t Ar target-window
-.D1 (alias: Ic nextl )
-Move a window to the next layout and rearrange the panes to fit.
-.It Xo Ic next-window
-.Op Fl a
-.Op Fl t Ar target-session
-.Xc
-.D1 (alias: Ic next )
-Move to the next window in the session.
-If
-.Fl a
-is used, move to the next window with an alert.
-.It Xo Ic pipe-pane
-.Op Fl o
-.Op Fl t Ar target-pane
-.Op Ar shell-command
-.Xc
-.D1 (alias: Ic pipep )
-Pipe any output sent by the program in
-.Ar target-pane
-to a shell command.
-A pane may only be piped to one command at a time, any existing pipe is
-closed before
-.Ar shell-command
-is executed.
-The
-.Ar shell-command
-string may contain the special character sequences supported by the
-.Ic status-left
-option.
-If no
-.Ar shell-command
-is given, the current pipe (if any) is closed.
-.Pp
-The
-.Fl o
-option only opens a new pipe if no previous pipe exists, allowing a pipe to
-be toggled with a single key, for example:
-.Bd -literal -offset indent
-bind-key C-p pipe-pane -o 'cat >>~/output.#I-#P'
-.Ed
-.It Xo Ic previous-layout
-.Op Fl t Ar target-window
-.Xc
-.D1 (alias: Ic prevl )
-Move to the previous layout in the session.
-.It Xo Ic previous-window
-.Op Fl a
-.Op Fl t Ar target-session
-.Xc
-.D1 (alias: Ic prev )
-Move to the previous window in the session.
-With
-.Fl a ,
-move to the previous window with an alert.
-.It Xo Ic rename-window
-.Op Fl t Ar target-window
-.Ar new-name
-.Xc
-.D1 (alias: Ic renamew )
-Rename the current window, or the window at
-.Ar target-window
-if specified, to
-.Ar new-name .
-.It Xo Ic resize-pane
-.Op Fl DLRUZ
-.Op Fl t Ar target-pane
-.Op Fl x Ar width
-.Op Fl y Ar height
-.Op Ar adjustment
-.Xc
-.D1 (alias: Ic resizep )
-Resize a pane, up, down, left or right by
-.Ar adjustment
-with
-.Fl U ,
-.Fl D ,
-.Fl L
-or
-.Fl R ,
-or
-to an absolute size
-with
-.Fl x
-or
-.Fl y .
-The
-.Ar adjustment
-is given in lines or cells (the default is 1).
-.Pp
-With
-.Fl Z ,
-the active pane is toggled between zoomed (occupying the whole of the window)
-and unzoomed (its normal position in the layout).
-.It Xo Ic respawn-pane
-.Op Fl k
-.Op Fl t Ar target-pane
-.Op Ar shell-command
-.Xc
-.D1 (alias: Ic respawnp )
-Reactivate a pane in which the command has exited (see the
-.Ic remain-on-exit
-window option).
-If
-.Ar shell-command
-is not given, the command used when the pane was created is executed.
-The pane must be already inactive, unless
-.Fl k
-is given, in which case any existing command is killed.
-.It Xo Ic respawn-window
-.Op Fl k
-.Op Fl t Ar target-window
-.Op Ar shell-command
-.Xc
-.D1 (alias: Ic respawnw )
-Reactivate a window in which the command has exited (see the
-.Ic remain-on-exit
-window option).
-If
-.Ar shell-command
-is not given, the command used when the window was created is executed.
-The window must be already inactive, unless
-.Fl k
-is given, in which case any existing command is killed.
-.It Xo Ic rotate-window
-.Op Fl DU
-.Op Fl t Ar target-window
-.Xc
-.D1 (alias: Ic rotatew )
-Rotate the positions of the panes within a window, either upward (numerically
-lower) with
-.Fl U
-or downward (numerically higher).
-.It Xo Ic select-layout
-.Op Fl np
-.Op Fl t Ar target-window
-.Op Ar layout-name
-.Xc
-.D1 (alias: Ic selectl )
-Choose a specific layout for a window.
-If
-.Ar layout-name
-is not given, the last preset layout used (if any) is reapplied.
-.Fl n
-and
-.Fl p
-are equivalent to the
-.Ic next-layout
-and
-.Ic previous-layout
-commands.
-.It Xo Ic select-pane
-.Op Fl lDLRU
-.Op Fl t Ar target-pane
-.Xc
-.D1 (alias: Ic selectp )
-Make pane
-.Ar target-pane
-the active pane in window
-.Ar target-window .
-If one of
-.Fl D ,
-.Fl L ,
-.Fl R ,
-or
-.Fl U
-is used, respectively the pane below, to the left, to the right, or above the
-target pane is used.
-.Fl l
-is the same as using the
-.Ic last-pane
-command.
-.It Xo Ic select-window
-.Op Fl lnpT
-.Op Fl t Ar target-window
-.Xc
-.D1 (alias: Ic selectw )
-Select the window at
-.Ar target-window .
-.Fl l ,
-.Fl n
-and
-.Fl p
-are equivalent to the
-.Ic last-window ,
-.Ic next-window
-and
-.Ic previous-window
-commands.
-If
-.Fl T
-is given and the selected window is already the current window,
-the command behaves like
-.Ic last-window .
-.It Xo Ic split-window
-.Op Fl dhvP
-.Op Fl c Ar start-directory
-.Oo Fl l
-.Ar size |
-.Fl p Ar percentage Oc
-.Op Fl t Ar target-pane
-.Op Ar shell-command
-.Op Fl F Ar format
-.Xc
-.D1 (alias: Ic splitw )
-Create a new pane by splitting
-.Ar target-pane :
-.Fl h
-does a horizontal split and
-.Fl v
-a vertical split; if neither is specified,
-.Fl v
-is assumed.
-The
-.Fl l
-and
-.Fl p
-options specify the size of the new pane in lines (for vertical split) or in
-cells (for horizontal split), or as a percentage, respectively.
-All other options have the same meaning as for the
-.Ic new-window
-command.
-.It Xo Ic swap-pane
-.Op Fl dDU
-.Op Fl s Ar src-pane
-.Op Fl t Ar dst-pane
-.Xc
-.D1 (alias: Ic swapp )
-Swap two panes.
-If
-.Fl U
-is used and no source pane is specified with
-.Fl s ,
-.Ar dst-pane
-is swapped with the previous pane (before it numerically);
-.Fl D
-swaps with the next pane (after it numerically).
-.Fl d
-instructs
-.Nm
-not to change the active pane.
-.It Xo Ic swap-window
-.Op Fl d
-.Op Fl s Ar src-window
-.Op Fl t Ar dst-window
-.Xc
-.D1 (alias: Ic swapw )
-This is similar to
-.Ic link-window ,
-except the source and destination windows are swapped.
-It is an error if no window exists at
-.Ar src-window .
-.It Xo Ic unlink-window
-.Op Fl k
-.Op Fl t Ar target-window
-.Xc
-.D1 (alias: Ic unlinkw )
-Unlink
-.Ar target-window .
-Unless
-.Fl k
-is given, a window may be unlinked only if it is linked to multiple sessions -
-windows may not be linked to no sessions;
-if
-.Fl k
-is specified and the window is linked to only one session, it is unlinked and
-destroyed.
-.El
-.Sh KEY BINDINGS
-.Nm
-allows a command to be bound to most keys, with or without a prefix key.
-When specifying keys, most represent themselves (for example
-.Ql A
-to
-.Ql Z ) .
-Ctrl keys may be prefixed with
-.Ql C-
-or
-.Ql ^ ,
-and Alt (meta) with
-.Ql M- .
-In addition, the following special key names are accepted:
-.Em Up ,
-.Em Down ,
-.Em Left ,
-.Em Right ,
-.Em BSpace ,
-.Em BTab ,
-.Em DC
-(Delete),
-.Em End ,
-.Em Enter ,
-.Em Escape ,
-.Em F1
-to
-.Em F20 ,
-.Em Home ,
-.Em IC
-(Insert),
-.Em NPage/PageDown/PgDn ,
-.Em PPage/PageUp/PgUp ,
-.Em Space ,
-and
-.Em Tab .
-Note that to bind the
-.Ql \&"
-or
-.Ql '
-keys, quotation marks are necessary, for example:
-.Bd -literal -offset indent
-bind-key '"' split-window
-bind-key "'" new-window
-.Ed
-.Pp
-Commands related to key bindings are as follows:
-.Bl -tag -width Ds
-.It Xo Ic bind-key
-.Op Fl cnr
-.Op Fl t Ar key-table
-.Ar key Ar command Op Ar arguments
-.Xc
-.D1 (alias: Ic bind )
-Bind key
-.Ar key
-to
-.Ar command .
-By default (without
-.Fl t )
-the primary key bindings are modified (those normally activated with the prefix
-key); in this case, if
-.Fl n
-is specified, it is not necessary to use the prefix key,
-.Ar command
-is bound to
-.Ar key
-alone.
-The
-.Fl r
-flag indicates this key may repeat, see the
-.Ic repeat-time
-option.
-.Pp
-If
-.Fl t
-is present,
-.Ar key
-is bound in
-.Ar key-table :
-the binding for command mode with
-.Fl c
-or for normal mode without.
-To view the default bindings and possible commands, see the
-.Ic list-keys
-command.
-.It Ic list-keys Op Fl t Ar key-table
-.D1 (alias: Ic lsk )
-List all key bindings.
-Without
-.Fl t
-the primary key bindings - those executed when preceded by the prefix key -
-are printed.
-.Pp
-With
-.Fl t ,
-the key bindings in
-.Ar key-table
-are listed; this may be one of:
-.Em vi-edit ,
-.Em emacs-edit ,
-.Em vi-choice ,
-.Em emacs-choice ,
-.Em vi-copy
-or
-.Em emacs-copy .
-.It Xo Ic send-keys
-.Op Fl lR
-.Op Fl t Ar target-pane
-.Ar key Ar ...
-.Xc
-.D1 (alias: Ic send )
-Send a key or keys to a window.
-Each argument
-.Ar key
-is the name of the key (such as
-.Ql C-a
-or
-.Ql npage
-) to send; if the string is not recognised as a key, it is sent as a series of
-characters.
-The
-.Fl l
-flag disables key name lookup and sends the keys literally.
-All arguments are sent sequentially from first to last.
-The
-.Fl R
-flag causes the terminal state to be reset.
-.It Xo Ic send-prefix
-.Op Fl 2
-.Op Fl t Ar target-pane
-.Xc
-Send the prefix key, or with
-.Fl 2
-the secondary prefix key, to a window as if it was pressed.
-.It Xo Ic unbind-key
-.Op Fl acn
-.Op Fl t Ar key-table
-.Ar key
-.Xc
-.D1 (alias: Ic unbind )
-Unbind the command bound to
-.Ar key .
-Without
-.Fl t
-the primary key bindings are modified; in this case, if
-.Fl n
-is specified, the command bound to
-.Ar key
-without a prefix (if any) is removed.
-If
-.Fl a
-is present, all key bindings are removed.
-.Pp
-If
-.Fl t
-is present,
-.Ar key
-in
-.Ar key-table
-is unbound: the binding for command mode with
-.Fl c
-or for normal mode without.
-.El
-.Sh OPTIONS
-The appearance and behaviour of
-.Nm
-may be modified by changing the value of various options.
-There are three types of option:
-.Em server options ,
-.Em session options
-and
-.Em window options .
-.Pp
-The
-.Nm
-server has a set of global options which do not apply to any particular
-window or session.
-These are altered with the
-.Ic set-option
-.Fl s
-command, or displayed with the
-.Ic show-options
-.Fl s
-command.
-.Pp
-In addition, each individual session may have a set of session options, and
-there is a separate set of global session options.
-Sessions which do not have a particular option configured inherit the value
-from the global session options.
-Session options are set or unset with the
-.Ic set-option
-command and may be listed with the
-.Ic show-options
-command.
-The available server and session options are listed under the
-.Ic set-option
-command.
-.Pp
-Similarly, a set of window options is attached to each window, and there is
-a set of global window options from which any unset options are inherited.
-Window options are altered with the
-.Ic set-window-option
-command and can be listed with the
-.Ic show-window-options
-command.
-All window options are documented with the
-.Ic set-window-option
-command.
-.Pp
-.Nm
-also supports user options which are prefixed with a
-.Ql \&@ .
-User options may have any name, so long as they are prefixed with
-.Ql \&@ ,
-and be set to any string.
-For example
-.Bd -literal -offset indent
-$ tmux setw -q @foo "abc123"
-$ tmux showw -v @foo
-abc123
-.Ed
-.Pp
-Commands which set options are as follows:
-.Bl -tag -width Ds
-.It Xo Ic set-option
-.Op Fl agoqsuw
-.Op Fl t Ar target-session | Ar target-window
-.Ar option Ar value
-.Xc
-.D1 (alias: Ic set )
-Set a window option with
-.Fl w
-(equivalent to the
-.Ic set-window-option
-command),
-a server option with
-.Fl s ,
-otherwise a session option.
-.Pp
-If
-.Fl g
-is specified, the global session or window option is set.
-With
-.Fl a ,
-and if the option expects a string,
-.Ar value
-is appended to the existing setting.
-The
-.Fl u
-flag unsets an option, so a session inherits the option from the global
-options.
-It is not possible to unset a global option.
-.Pp
-The
-.Fl o
-flag prevents setting an option that is already set.
-.Pp
-The
-.Fl q
-flag suppresses the informational message (as if the
-.Ic quiet
-server option was set).
-.Pp
-Available window options are listed under
-.Ic set-window-option .
-.Pp
-.Ar value
-depends on the option and may be a number, a string, or a flag (on, off, or
-omitted to toggle).
-.Pp
-Available server options are:
-.Bl -tag -width Ds
-.It Ic buffer-limit Ar number
-Set the number of buffers; as new buffers are added to the top of the stack,
-old ones are removed from the bottom if necessary to maintain this maximum
-length.
-.It Ic escape-time Ar time
-Set the time in milliseconds for which
-.Nm
-waits after an escape is input to determine if it is part of a function or meta
-key sequences.
-The default is 500 milliseconds.
-.It Xo Ic exit-unattached
-.Op Ic on | off
-.Xc
-If enabled, the server will exit when there are no attached clients.
-.It Xo Ic quiet
-.Op Ic on | off
-.Xc
-Enable or disable the display of various informational messages (see also the
-.Fl q
-command line flag).
-.It Xo Ic set-clipboard
-.Op Ic on | off
-.Xc
-Attempt to set the terminal clipboard content using the
-\ee]52;...\e007
-.Xr xterm 1
-escape sequences.
-This option is on by default if there is an
-.Em \&Ms
-entry in the
-.Xr terminfo 5
-description for the client terminal.
-Note that this feature needs to be enabled in
-.Xr xterm 1
-by setting the resource:
-.Bd -literal -offset indent
-disallowedWindowOps: 20,21,SetXprop
-.Ed
-.Pp
-Or changing this property from the
-.Xr xterm 1
-interactive menu when required.
-.El
-.Pp
-Available session options are:
-.Bl -tag -width Ds
-.It Ic assume-paste-time Ar milliseconds
-If keys are entered faster than one in
-.Ar milliseconds ,
-they are assumed to have been pasted rather than typed and
-.Nm
-key bindings are not processed.
-The default is one millisecond and zero disables.
-.It Ic base-index Ar index
-Set the base index from which an unused index should be searched when a new
-window is created.
-The default is zero.
-.It Xo Ic bell-action
-.Op Ic any | none | current
-.Xc
-Set action on window bell.
-.Ic any
-means a bell in any window linked to a session causes a bell in the current
-window of that session,
-.Ic none
-means all bells are ignored and
-.Ic current
-means only bells in windows other than the current window are ignored.
-.It Xo Ic bell-on-alert
-.Op Ic on | off
-.Xc
-If on, ring the terminal bell when an alert
-occurs.
-.It Ic default-command Ar shell-command
-Set the command used for new windows (if not specified when the window is
-created) to
-.Ar shell-command ,
-which may be any
-.Xr sh 1
-command.
-The default is an empty string, which instructs
-.Nm
-to create a login shell using the value of the
-.Ic default-shell
-option.
-.It Ic default-path Ar path
-Set the default working directory for new panes.
-If empty (the default), the working directory is determined from the process
-running in the active pane, from the command line environment or from the
-working directory where the session was created.
-Otherwise the same options are available as for the
-.Fl c
-flag to
-.Ic new-window .
-.It Ic default-shell Ar path
-Specify the default shell.
-This is used as the login shell for new windows when the
-.Ic default-command
-option is set to empty, and must be the full path of the executable.
-When started
-.Nm
-tries to set a default value from the first suitable of the
-.Ev SHELL
-environment variable, the shell returned by
-.Xr getpwuid 3 ,
-or
-.Pa /bin/sh .
-This option should be configured when
-.Nm
-is used as a login shell.
-.It Ic default-terminal Ar terminal
-Set the default terminal for new windows created in this session - the
-default value of the
-.Ev TERM
-environment variable.
-For
-.Nm
-to work correctly, this
-.Em must
-be set to
-.Ql screen
-or a derivative of it.
-.It Xo Ic destroy-unattached
-.Op Ic on | off
-.Xc
-If enabled and the session is no longer attached to any clients, it is
-destroyed.
-.It Xo Ic detach-on-destroy
-.Op Ic on | off
-.Xc
-If on (the default), the client is detached when the session it is attached to
-is destroyed.
-If off, the client is switched to the most recently active of the remaining
-sessions.
-.It Ic display-panes-active-colour Ar colour
-Set the colour used by the
-.Ic display-panes
-command to show the indicator for the active pane.
-.It Ic display-panes-colour Ar colour
-Set the colour used by the
-.Ic display-panes
-command to show the indicators for inactive panes.
-.It Ic display-panes-time Ar time
-Set the time in milliseconds for which the indicators shown by the
-.Ic display-panes
-command appear.
-.It Ic display-time Ar time
-Set the amount of time for which status line messages and other on-screen
-indicators are displayed.
-.Ar time
-is in milliseconds.
-.It Ic history-limit Ar lines
-Set the maximum number of lines held in window history.
-This setting applies only to new windows - existing window histories are not
-resized and retain the limit at the point they were created.
-.It Ic lock-after-time Ar number
-Lock the session (like the
-.Ic lock-session
-command) after
-.Ar number
-seconds of inactivity, or the entire server (all sessions) if the
-.Ic lock-server
-option is set.
-The default is not to lock (set to 0).
-.It Ic lock-command Ar shell-command
-Command to run when locking each client.
-The default is to run
-.Xr lock 1
-with
-.Fl np .
-.It Xo Ic lock-server
-.Op Ic on | off
-.Xc
-If this option is
-.Ic on
-(the default),
-instead of each session locking individually as each has been
-idle for
-.Ic lock-after-time ,
-the entire server will lock after
-.Em all
-sessions would have locked.
-This has no effect as a session option; it must be set as a global option.
-.It Ic message-attr Ar attributes
-Set status line message attributes, where
-.Ar attributes
-is either
-.Ic none
-or a comma-delimited list of one or more of:
-.Ic bright
-(or
-.Ic bold ) ,
-.Ic dim ,
-.Ic underscore ,
-.Ic blink ,
-.Ic reverse ,
-.Ic hidden ,
-or
-.Ic italics .
-.It Ic message-bg Ar colour
-Set status line message background colour, where
-.Ar colour
-is one of:
-.Ic black ,
-.Ic red ,
-.Ic green ,
-.Ic yellow ,
-.Ic blue ,
-.Ic magenta ,
-.Ic cyan ,
-.Ic white ,
-aixterm bright variants (if supported:
-.Ic brightred ,
-.Ic brightgreen ,
-and so on),
-.Ic colour0
-to
-.Ic colour255
-from the 256-colour set,
-.Ic default ,
-or a hexadecimal RGB string such as
-.Ql #ffffff ,
-which chooses the closest match from the default 256-colour set.
-.It Ic message-command-attr Ar attributes
-Set status line message attributes when in command mode.
-.It Ic message-command-bg Ar colour
-Set status line message background colour when in command mode.
-.It Ic message-command-fg Ar colour
-Set status line message foreground colour when in command mode.
-.It Ic message-fg Ar colour
-Set status line message foreground colour.
-.It Ic message-limit Ar number
-Set the number of error or information messages to save in the message log for
-each client.
-The default is 20.
-.It Xo Ic mouse-resize-pane
-.Op Ic on | off
-.Xc
-If on,
-.Nm
-captures the mouse and allows panes to be resized by dragging on their borders.
-.It Xo Ic mouse-select-pane
-.Op Ic on | off
-.Xc
-If on,
-.Nm
-captures the mouse and when a window is split into multiple panes the mouse may
-be used to select the current pane.
-The mouse click is also passed through to the application as normal.
-.It Xo Ic mouse-select-window
-.Op Ic on | off
-.Xc
-If on, clicking the mouse on a window name in the status line will select that
-window.
-.It Xo Ic mouse-utf8
-.Op Ic on | off
-.Xc
-If enabled, request mouse input as UTF-8 on UTF-8 terminals.
-.It Ic pane-active-border-bg Ar colour
-.It Ic pane-active-border-fg Ar colour
-Set the pane border colour for the currently active pane.
-.It Ic pane-border-bg Ar colour
-.It Ic pane-border-fg Ar colour
-Set the pane border colour for panes aside from the active pane.
-.It Ic prefix Ar key
-Set the key accepted as a prefix key.
-.It Ic prefix2 Ar key
-Set a secondary key accepted as a prefix key.
-.It Xo Ic renumber-windows
-.Op Ic on | off
-.Xc
-If on, when a window is closed in a session, automatically renumber the other
-windows in numerical order.
-This respects the
-.Ic base-index
-option if it has been set.
-If off, do not renumber the windows.
-.It Ic repeat-time Ar time
-Allow multiple commands to be entered without pressing the prefix-key again
-in the specified
-.Ar time
-milliseconds (the default is 500).
-Whether a key repeats may be set when it is bound using the
-.Fl r
-flag to
-.Ic bind-key .
-Repeat is enabled for the default keys bound to the
-.Ic resize-pane
-command.
-.It Xo Ic set-remain-on-exit
-.Op Ic on | off
-.Xc
-Set the
-.Ic remain-on-exit
-window option for any windows first created in this session.
-When this option is true, windows in which the running program has
-exited do not close, instead remaining open but inactivate.
-Use the
-.Ic respawn-window
-command to reactivate such a window, or the
-.Ic kill-window
-command to destroy it.
-.It Xo Ic set-titles
-.Op Ic on | off
-.Xc
-Attempt to set the client terminal title using the
-.Em tsl
-and
-.Em fsl
-.Xr terminfo 5
-entries if they exist.
-.Nm
-automatically sets these to the \ee]2;...\e007 sequence if
-the terminal appears to be an xterm.
-This option is off by default.
-Note that elinks
-will only attempt to set the window title if the STY environment
-variable is set.
-.It Ic set-titles-string Ar string
-String used to set the window title if
-.Ic set-titles
-is on.
-Character sequences are replaced as for the
-.Ic status-left
-option.
-.It Xo Ic status
-.Op Ic on | off
-.Xc
-Show or hide the status line.
-.It Ic status-attr Ar attributes
-Set status line attributes.
-.It Ic status-bg Ar colour
-Set status line background colour.
-.It Ic status-fg Ar colour
-Set status line foreground colour.
-.It Ic status-interval Ar interval
-Update the status bar every
-.Ar interval
-seconds.
-By default, updates will occur every 15 seconds.
-A setting of zero disables redrawing at interval.
-.It Xo Ic status-justify
-.Op Ic left | centre | right
-.Xc
-Set the position of the window list component of the status line: left, centre
-or right justified.
-.It Xo Ic status-keys
-.Op Ic vi | emacs
-.Xc
-Use vi or emacs-style
-key bindings in the status line, for example at the command prompt.
-The default is emacs, unless the
-.Ev VISUAL
-or
-.Ev EDITOR
-environment variables are set and contain the string
-.Ql vi .
-.It Ic status-left Ar string
-Display
-.Ar string
-to the left of the status bar.
-.Ar string
-will be passed through
-.Xr strftime 3
-before being used.
-By default, the session name is shown.
-.Ar string
-may contain any of the following special character sequences:
-.Bl -column "Character pair" "Replaced with" -offset indent
-.It Sy "Character pair" Ta Sy "Replaced with"
-.It Li "#(shell-command)" Ta "First line of the command's output"
-.It Li "#[attributes]" Ta "Colour or attribute change"
-.It Li "#H" Ta "Hostname of local host"
-.It Li "#h" Ta "Hostname of local host without the domain name"
-.It Li "#F" Ta "Current window flag"
-.It Li "#I" Ta "Current window index"
-.It Li "#D" Ta "Current pane unique identifier"
-.It Li "#P" Ta "Current pane index"
-.It Li "#S" Ta "Session name"
-.It Li "#T" Ta "Current pane title"
-.It Li "#W" Ta "Current window name"
-.It Li "##" Ta "A literal" Ql #
-.El
-.Pp
-The #(shell-command) form executes
-.Ql shell-command
-and inserts the first line of its output.
-Note that shell commands are only executed once at the interval specified by
-the
-.Ic status-interval
-option: if the status line is redrawn in the meantime, the previous result is
-used.
-Shell commands are executed with the
-.Nm
-global environment set (see the
-.Sx ENVIRONMENT
-section).
-.Pp
-For details on how the names and titles can be set see the
-.Sx "NAMES AND TITLES"
-section.
-.Pp
-#[attributes] allows a comma-separated list of attributes to be specified,
-these may be
-.Ql fg=colour
-to set the foreground colour,
-.Ql bg=colour
-to set the background colour, the name of one of the attributes (listed under
-the
-.Ic message-attr
-option) to turn an attribute on, or an attribute prefixed with
-.Ql no
-to turn one off, for example
-.Ic nobright .
-Examples are:
-.Bd -literal -offset indent
-#(sysctl vm.loadavg)
-#[fg=yellow,bold]#(apm -l)%%#[default] [#S]
-.Ed
-.Pp
-Where appropriate, special character sequences may be prefixed with a number to
-specify the maximum length, for example
-.Ql #24T .
-.Pp
-By default, UTF-8 in
-.Ar string
-is not interpreted, to enable UTF-8, use the
-.Ic status-utf8
-option.
-.It Ic status-left-attr Ar attributes
-Set the attribute of the left part of the status line.
-.It Ic status-left-bg Ar colour
-Set the background colour of the left part of the status line.
-.It Ic status-left-fg Ar colour
-Set the foreground colour of the left part of the status line.
-.It Ic status-left-length Ar length
-Set the maximum
-.Ar length
-of the left component of the status bar.
-The default is 10.
-.It Xo Ic status-position
-.Op Ic top | bottom
-.Xc
-Set the position of the status line.
-.It Ic status-right Ar string
-Display
-.Ar string
-to the right of the status bar.
-By default, the current window title in double quotes, the date and the time
-are shown.
-As with
-.Ic status-left ,
-.Ar string
-will be passed to
-.Xr strftime 3 ,
-character pairs are replaced, and UTF-8 is dependent on the
-.Ic status-utf8
-option.
-.It Ic status-right-attr Ar attributes
-Set the attribute of the right part of the status line.
-.It Ic status-right-bg Ar colour
-Set the background colour of the right part of the status line.
-.It Ic status-right-fg Ar colour
-Set the foreground colour of the right part of the status line.
-.It Ic status-right-length Ar length
-Set the maximum
-.Ar length
-of the right component of the status bar.
-The default is 40.
-.It Xo Ic status-utf8
-.Op Ic on | off
-.Xc
-Instruct
-.Nm
-to treat top-bit-set characters in the
-.Ic status-left
-and
-.Ic status-right
-strings as UTF-8; notably, this is important for wide characters.
-This option defaults to off.
-.It Ic terminal-overrides Ar string
-Contains a list of entries which override terminal descriptions read using
-.Xr terminfo 5 .
-.Ar string
-is a comma-separated list of items each a colon-separated string made up of a
-terminal type pattern (matched using
-.Xr fnmatch 3 )
-and a set of
-.Em name=value
-entries.
-.Pp
-For example, to set the
-.Ql clear
-.Xr terminfo 5
-entry to
-.Ql \ee[H\ee[2J
-for all terminal types and the
-.Ql dch1
-entry to
-.Ql \ee[P
-for the
-.Ql rxvt
-terminal type, the option could be set to the string:
-.Bd -literal -offset indent
-"*:clear=\ee[H\ee[2J,rxvt:dch1=\ee[P"
-.Ed
-.Pp
-The terminal entry value is passed through
-.Xr strunvis 3
-before interpretation.
-The default value forcibly corrects the
-.Ql colors
-entry for terminals which support 88 or 256 colours:
-.Bd -literal -offset indent
-"*88col*:colors=88,*256col*:colors=256,xterm*:XT"
-.Ed
-.It Ic update-environment Ar variables
-Set a space-separated string containing a list of environment variables to be
-copied into the session environment when a new session is created or an
-existing session is attached.
-Any variables that do not exist in the source environment are set to be
-removed from the session environment (as if
-.Fl r
-was given to the
-.Ic set-environment
-command).
-The default is
-"DISPLAY SSH_ASKPASS SSH_AUTH_SOCK SSH_AGENT_PID SSH_CONNECTION WINDOWID
-XAUTHORITY".
-.It Xo Ic visual-activity
-.Op Ic on | off
-.Xc
-If on, display a status line message when activity occurs in a window
-for which the
-.Ic monitor-activity
-window option is enabled.
-.It Xo Ic visual-bell
-.Op Ic on | off
-.Xc
-If this option is on, a message is shown on a bell instead of it being passed
-through to the terminal (which normally makes a sound).
-Also see the
-.Ic bell-action
-option.
-.It Xo Ic visual-content
-.Op Ic on | off
-.Xc
-Like
-.Ic visual-activity ,
-display a message when content is present in a window
-for which the
-.Ic monitor-content
-window option is enabled.
-.It Xo Ic visual-silence
-.Op Ic on | off
-.Xc
-If
-.Ic monitor-silence
-is enabled, prints a message after the interval has expired on a given window.
-.It Ic word-separators Ar string
-Sets the session's conception of what characters are considered word
-separators, for the purposes of the next and previous word commands in
-copy mode.
-The default is
-.Ql \ -_@ .
-.El
-.It Xo Ic set-window-option
-.Op Fl agoqu
-.Op Fl t Ar target-window
-.Ar option Ar value
-.Xc
-.D1 (alias: Ic setw )
-Set a window option.
-The
-.Fl a ,
-.Fl g ,
-.Fl o ,
-.Fl q
-and
-.Fl u
-flags work similarly to the
-.Ic set-option
-command.
-.Pp
-Supported window options are:
-.Pp
-.Bl -tag -width Ds -compact
-.It Xo Ic aggressive-resize
-.Op Ic on | off
-.Xc
-Aggressively resize the chosen window.
-This means that
-.Nm
-will resize the window to the size of the smallest session for which it is the
-current window, rather than the smallest session to which it is attached.
-The window may resize when the current window is changed on another sessions;
-this option is good for full-screen programs which support
-.Dv SIGWINCH
-and poor for interactive programs such as shells.
-.Pp
-.It Xo Ic allow-rename
-.Op Ic on | off
-.Xc
-Allow programs to change the window name using a terminal escape
-sequence (\\033k...\\033\\\\).
-The default is on.
-.Pp
-.It Xo Ic alternate-screen
-.Op Ic on | off
-.Xc
-This option configures whether programs running inside
-.Nm
-may use the terminal alternate screen feature, which allows the
-.Em smcup
-and
-.Em rmcup
-.Xr terminfo 5
-capabilities.
-The alternate screen feature preserves the contents of the window when an
-interactive application starts and restores it on exit, so that any output
-visible before the application starts reappears unchanged after it exits.
-The default is on.
-.Pp
-.It Xo Ic automatic-rename
-.Op Ic on | off
-.Xc
-Control automatic window renaming.
-When this setting is enabled,
-.Nm
-will attempt - on supported platforms - to rename the window to reflect the
-command currently running in it.
-This flag is automatically disabled for an individual window when a name
-is specified at creation with
-.Ic new-window
-or
-.Ic new-session ,
-or later with
-.Ic rename-window ,
-or with a terminal escape sequence.
-It may be switched off globally with:
-.Bd -literal -offset indent
-set-window-option -g automatic-rename off
-.Ed
-.Pp
-.It Ic c0-change-interval Ar interval
-.It Ic c0-change-trigger Ar trigger
-These two options configure a simple form of rate limiting for a pane.
-If
-.Nm
-sees more than
-.Ar trigger
-C0 sequences that modify the screen (for example, carriage returns, linefeeds
-or backspaces) in one millisecond, it will stop updating the pane immediately and
-instead redraw it entirely every
-.Ar interval
-milliseconds.
-This helps to prevent fast output (such as
-.Xr yes 1
-overwhelming the terminal).
-The default is a trigger of 250 and an interval of 100.
-A trigger of zero disables the rate limiting.
-.Pp
-.It Ic clock-mode-colour Ar colour
-Set clock colour.
-.Pp
-.It Xo Ic clock-mode-style
-.Op Ic 12 | 24
-.Xc
-Set clock hour format.
-.Pp
-.It Ic force-height Ar height
-.It Ic force-width Ar width
-Prevent
-.Nm
-from resizing a window to greater than
-.Ar width
-or
-.Ar height .
-A value of zero restores the default unlimited setting.
-.Pp
-.It Ic main-pane-height Ar height
-.It Ic main-pane-width Ar width
-Set the width or height of the main (left or top) pane in the
-.Ic main-horizontal
-or
-.Ic main-vertical
-layouts.
-.Pp
-.It Ic mode-attr Ar attributes
-Set window modes attributes.
-.Pp
-.It Ic mode-bg Ar colour
-Set window modes background colour.
-.Pp
-.It Ic mode-fg Ar colour
-Set window modes foreground colour.
-.Pp
-.It Xo Ic mode-keys
-.Op Ic vi | emacs
-.Xc
-Use vi or emacs-style key bindings in copy and choice modes.
-As with the
-.Ic status-keys
-option, the default is emacs, unless
-.Ev VISUAL
-or
-.Ev EDITOR
-contains
-.Ql vi .
-.Pp
-.It Xo Ic mode-mouse
-.Op Ic on | off | copy-mode
-.Xc
-Mouse state in modes.
-If on, the mouse may be used to enter copy mode and copy a selection by
-dragging, to enter copy mode and scroll with the mouse wheel, or to select an
-option in choice mode.
-If set to
-.Em copy-mode ,
-the mouse behaves as set to on, but cannot be used to enter copy
-mode.
-.Pp
-.It Xo Ic monitor-activity
-.Op Ic on | off
-.Xc
-Monitor for activity in the window.
-Windows with activity are highlighted in the status line.
-.Pp
-.It Ic monitor-content Ar match-string
-Monitor content in the window.
-When
-.Xr fnmatch 3
-pattern
-.Ar match-string
-appears in the window, it is highlighted in the status line.
-.Pp
-.It Xo Ic monitor-silence
-.Op Ic interval
-.Xc
-Monitor for silence (no activity) in the window within
-.Ic interval
-seconds.
-Windows that have been silent for the interval are highlighted in the
-status line.
-An interval of zero disables the monitoring.
-.Pp
-.It Ic other-pane-height Ar height
-Set the height of the other panes (not the main pane) in the
-.Ic main-horizontal
-layout.
-If this option is set to 0 (the default), it will have no effect.
-If both the
-.Ic main-pane-height
-and
-.Ic other-pane-height
-options are set, the main pane will grow taller to make the other panes the
-specified height, but will never shrink to do so.
-.Pp
-.It Ic other-pane-width Ar width
-Like
-.Ic other-pane-height ,
-but set the width of other panes in the
-.Ic main-vertical
-layout.
-.Pp
-.It Ic pane-base-index Ar index
-Like
-.Ic base-index ,
-but set the starting index for pane numbers.
-.Pp
-.It Xo Ic remain-on-exit
-.Op Ic on | off
-.Xc
-A window with this flag set is not destroyed when the program running in it
-exits.
-The window may be reactivated with the
-.Ic respawn-window
-command.
-.Pp
-.It Xo Ic synchronize-panes
-.Op Ic on | off
-.Xc
-Duplicate input to any pane to all other panes in the same window (only
-for panes that are not in any special mode).
-.Pp
-.It Xo Ic utf8
-.Op Ic on | off
-.Xc
-Instructs
-.Nm
-to expect UTF-8 sequences to appear in this window.
-.Pp
-.It Ic window-status-bell-attr Ar attributes
-Set status line attributes for windows which have a bell alert.
-.Pp
-.It Ic window-status-bell-bg Ar colour
-Set status line background colour for windows with a bell alert.
-.Pp
-.It Ic window-status-bell-fg Ar colour
-Set status line foreground colour for windows with a bell alert.
-.Pp
-.It Ic window-status-content-attr Ar attributes
-Set status line attributes for windows which have a content alert.
-.Pp
-.It Ic window-status-content-bg Ar colour
-Set status line background colour for windows with a content alert.
-.Pp
-.It Ic window-status-content-fg Ar colour
-Set status line foreground colour for windows with a content alert.
-.Pp
-.It Ic window-status-activity-attr Ar attributes
-Set status line attributes for windows which have an activity (or silence) alert.
-.Pp
-.It Ic window-status-activity-bg Ar colour
-Set status line background colour for windows with an activity alert.
-.Pp
-.It Ic window-status-activity-fg Ar colour
-Set status line foreground colour for windows with an activity alert.
-.Pp
-.It Ic window-status-attr Ar attributes
-Set status line attributes for a single window.
-.Pp
-.It Ic window-status-bg Ar colour
-Set status line background colour for a single window.
-.Pp
-.It Ic window-status-current-attr Ar attributes
-Set status line attributes for the currently active window.
-.Pp
-.It Ic window-status-current-bg Ar colour
-Set status line background colour for the currently active window.
-.Pp
-.It Ic window-status-current-fg Ar colour
-Set status line foreground colour for the currently active window.
-.Pp
-.It Ic window-status-current-format Ar string
-Like
-.Ar window-status-format ,
-but is the format used when the window is the current window.
-.Pp
-.It Ic window-status-last-attr Ar attributes
-Set status line attributes for the last active window.
-.Pp
-.It Ic window-status-last-bg Ar colour
-Set status line background colour for the last active window.
-.Pp
-.It Ic window-status-last-fg Ar colour
-Set status line foreground colour for the last active window.
-.Pp
-.It Ic window-status-fg Ar colour
-Set status line foreground colour for a single window.
-.Pp
-.It Ic window-status-format Ar string
-Set the format in which the window is displayed in the status line window list.
-See the
-.Ar status-left
-option for details of special character sequences available.
-The default is
-.Ql #I:#W#F .
-.Pp
-.It Ic window-status-separator Ar string
-Sets the separator drawn between windows in the status line.
-The default is a single space character.
-.Pp
-.It Xo Ic xterm-keys
-.Op Ic on | off
-.Xc
-If this option is set,
-.Nm
-will generate
-.Xr xterm 1 -style
-function key sequences; these have a number included to indicate modifiers such
-as Shift, Alt or Ctrl.
-The default is off.
-.Pp
-.It Xo Ic wrap-search
-.Op Ic on | off
-.Xc
-If this option is set, searches will wrap around the end of the pane contents.
-The default is on.
-.El
-.It Xo Ic show-options
-.Op Fl gqsvw
-.Op Fl t Ar target-session | Ar target-window
-.Op Ar option
-.Xc
-.D1 (alias: Ic show )
-Show the window options (or a single window option if given) with
-.Fl w
-(equivalent to
-.Ic show-window-options ) ,
-the server options with
-.Fl s ,
-otherwise the session options for
-.Ar target session .
-Global session or window options are listed if
-.Fl g
-is used.
-.Fl v
-shows only the option value, not the name.
-If
-.Fl q
-is set, no error will be returned if
-.Ar option
-is unset.
-.It Xo Ic show-window-options
-.Op Fl gv
-.Op Fl t Ar target-window
-.Op Ar option
-.Xc
-.D1 (alias: Ic showw )
-List the window options or a single option for
-.Ar target-window ,
-or the global window options if
-.Fl g
-is used.
-.Fl v
-shows only the option value, not the name.
-.El
-.Sh FORMATS
-Certain commands accept the
-.Fl F
-flag with a
-.Ar format
-argument.
-This is a string which controls the output format of the command.
-Special character sequences are replaced as documented under the
-.Ic status-left
-option and an additional long form is accepted.
-Replacement variables are enclosed in
-.Ql #{
-and
-.Ql } ,
-for example
-.Ql #{session_name}
-is equivalent to
-.Ql #S .
-Conditionals are also accepted by prefixing with
-.Ql \&?
-and separating two alternatives with a comma;
-if the specified variable exists and is not zero, the first alternative
-is chosen, otherwise the second is used.
-For example
-.Ql #{?session_attached,attached,not attached}
-will include the string
-.Ql attached
-if the session is attached and the string
-.Ql not attached
-if it is unattached.
-.Pp
-The following variables are available, where appropriate:
-.Bl -column "session_created_string" "Replaced with" -offset indent
-.It Sy "Variable name" Ta Sy "Replaced with"
-.It Li "alternate_on" Ta "If pane is in alternate screen"
-.It Li "alternate_saved_x" Ta "Saved cursor X in alternate screen"
-.It Li "alternate_saved_y" Ta "Saved cursor Y in alternate screen"
-.It Li "buffer_sample" Ta "First 50 characters from the specified buffer"
-.It Li "buffer_size" Ta "Size of the specified buffer in bytes"
-.It Li "client_activity" Ta "Integer time client last had activity"
-.It Li "client_activity_string" Ta "String time client last had activity"
-.It Li "client_created" Ta "Integer time client created"
-.It Li "client_created_string" Ta "String time client created"
-.It Li "client_cwd" Ta "Working directory of client"
-.It Li "client_height" Ta "Height of client"
-.It Li "client_last_session" Ta "Name of the client's last session"
-.It Li "client_prefix" Ta "1 if prefix key has been pressed"
-.It Li "client_readonly" Ta "1 if client is readonly"
-.It Li "client_session" Ta "Name of the client's session"
-.It Li "client_termname" Ta "Terminal name of client"
-.It Li "client_tty" Ta "Pseudo terminal of client"
-.It Li "client_utf8" Ta "1 if client supports utf8"
-.It Li "client_width" Ta "Width of client"
-.It Li "cursor_flag" Ta "Pane cursor flag"
-.It Li "cursor_x" Ta "Cursor X position in pane"
-.It Li "cursor_y" Ta "Cursor Y position in pane"
-.It Li "history_bytes" Ta "Number of bytes in window history"
-.It Li "history_limit" Ta "Maximum window history lines"
-.It Li "history_size" Ta "Size of history in bytes"
-.It Li "host" Ta "Hostname of local host"
-.It Li "insert_flag" Ta "Pane insert flag"
-.It Li "keypad_cursor_flag" Ta "Pane keypad cursor flag"
-.It Li "keypad_flag" Ta "Pane keypad flag"
-.It Li "line" Ta "Line number in the list"
-.It Li "mouse_any_flag" Ta "Pane mouse any flag"
-.It Li "mouse_button_flag" Ta "Pane mouse button flag"
-.It Li "mouse_standard_flag" Ta "Pane mouse standard flag"
-.It Li "mouse_utf8_flag" Ta "Pane mouse UTF-8 flag"
-.It Li "pane_active" Ta "1 if active pane"
-.It Li "pane_current_command" Ta "Current command if available"
-.It Li "pane_current_path" Ta "Current path if available"
-.It Li "pane_dead" Ta "1 if pane is dead"
-.It Li "pane_height" Ta "Height of pane"
-.It Li "pane_id" Ta "Unique pane ID"
-.It Li "pane_in_mode" Ta "If pane is in a mode"
-.It Li "pane_index" Ta "Index of pane"
-.It Li "pane_pid" Ta "PID of first process in pane"
-.It Li "pane_start_command" Ta "Command pane started with"
-.It Li "pane_start_path" Ta "Path pane started with"
-.It Li "pane_tabs" Ta "Pane tab positions"
-.It Li "pane_title" Ta "Title of pane"
-.It Li "pane_tty" Ta "Pseudo terminal of pane"
-.It Li "pane_width" Ta "Width of pane"
-.It Li "saved_cursor_x" Ta "Saved cursor X in pane"
-.It Li "saved_cursor_y" Ta "Saved cursor Y in pane"
-.It Li "scroll_region_lower" Ta "Bottom of scroll region in pane"
-.It Li "scroll_region_upper" Ta "Top of scroll region in pane"
-.It Li "session_attached" Ta "1 if session attached"
-.It Li "session_created" Ta "Integer time session created"
-.It Li "session_created_string" Ta "String time session created"
-.It Li "session_group" Ta "Number of session group"
-.It Li "session_grouped" Ta "1 if session in a group"
-.It Li "session_height" Ta "Height of session"
-.It Li "session_id" Ta "Unique session ID"
-.It Li "session_name" Ta "Name of session"
-.It Li "session_width" Ta "Width of session"
-.It Li "session_windows" Ta "Number of windows in session"
-.It Li "window_active" Ta "1 if window active"
-.It Li "window_find_matches" Ta "Matched data from the find-window command if available"
-.It Li "window_flags" Ta "Window flags"
-.It Li "window_height" Ta "Height of window"
-.It Li "window_id" Ta "Unique window ID"
-.It Li "window_index" Ta "Index of window"
-.It Li "window_layout" Ta "Window layout description"
-.It Li "window_name" Ta "Name of window"
-.It Li "window_panes" Ta "Number of panes in window"
-.It Li "window_width" Ta "Width of window"
-.It Li "wrap_flag" Ta "Pane wrap flag"
-.El
-.Sh NAMES AND TITLES
-.Nm
-distinguishes between names and titles.
-Windows and sessions have names, which may be used to specify them in targets
-and are displayed in the status line and various lists: the name is the
-.Nm
-identifier for a window or session.
-Only panes have titles.
-A pane's title is typically set by the program running inside the pane and
-is not modified by
-.Nm .
-It is the same mechanism used to set for example the
-.Xr xterm 1
-window title in an
-.Xr X 7
-window manager.
-Windows themselves do not have titles - a window's title is the title of its
-active pane.
-.Nm
-itself may set the title of the terminal in which the client is running, see
-the
-.Ic set-titles
-option.
-.Pp
-A session's name is set with the
-.Ic new-session
-and
-.Ic rename-session
-commands.
-A window's name is set with one of:
-.Bl -enum -width Ds
-.It
-A command argument (such as
-.Fl n
-for
-.Ic new-window
-or
-.Ic new-session ) .
-.It
-An escape sequence:
-.Bd -literal -offset indent
-$ printf '\e033kWINDOW_NAME\e033\e\e'
-.Ed
-.It
-Automatic renaming, which sets the name to the active command in the window's
-active pane.
-See the
-.Ic automatic-rename
-option.
-.El
-.Pp
-When a pane is first created, its title is the hostname.
-A pane's title can be set via the OSC title setting sequence, for example:
-.Bd -literal -offset indent
-$ printf '\e033]2;My Title\e033\e\e'
-.Ed
-.Sh ENVIRONMENT
-When the server is started,
-.Nm
-copies the environment into the
-.Em global environment ;
-in addition, each session has a
-.Em session environment .
-When a window is created, the session and global environments are merged.
-If a variable exists in both, the value from the session environment is used.
-The result is the initial environment passed to the new process.
-.Pp
-The
-.Ic update-environment
-session option may be used to update the session environment from the client
-when a new session is created or an old reattached.
-.Nm
-also initialises the
-.Ev TMUX
-variable with some internal information to allow commands to be executed
-from inside, and the
-.Ev TERM
-variable with the correct terminal setting of
-.Ql screen .
-.Pp
-Commands to alter and view the environment are:
-.Bl -tag -width Ds
-.It Xo Ic set-environment
-.Op Fl gru
-.Op Fl t Ar target-session
-.Ar name Op Ar value
-.Xc
-.D1 (alias: Ic setenv )
-Set or unset an environment variable.
-If
-.Fl g
-is used, the change is made in the global environment; otherwise, it is applied
-to the session environment for
-.Ar target-session .
-The
-.Fl u
-flag unsets a variable.
-.Fl r
-indicates the variable is to be removed from the environment before starting a
-new process.
-.It Xo Ic show-environment
-.Op Fl g
-.Op Fl t Ar target-session
-.Op Ar variable
-.Xc
-.D1 (alias: Ic showenv )
-Display the environment for
-.Ar target-session
-or the global environment with
-.Fl g .
-If
-.Ar variable
-is omitted, all variables are shown.
-Variables removed from the environment are prefixed with
-.Ql - .
-.El
-.Sh STATUS LINE
-.Nm
-includes an optional status line which is displayed in the bottom line of each
-terminal.
-By default, the status line is enabled (it may be disabled with the
-.Ic status
-session option) and contains, from left-to-right: the name of the current
-session in square brackets; the window list; the title of the active pane
-in double quotes; and the time and date.
-.Pp
-The status line is made of three parts: configurable left and right sections
-(which may contain dynamic content such as the time or output from a shell
-command, see the
-.Ic status-left ,
-.Ic status-left-length ,
-.Ic status-right ,
-and
-.Ic status-right-length
-options below), and a central window list.
-By default, the window list shows the index, name and (if any) flag of the
-windows present in the current session in ascending numerical order.
-It may be customised with the
-.Ar window-status-format
-and
-.Ar window-status-current-format
-options.
-The flag is one of the following symbols appended to the window name:
-.Bl -column "Symbol" "Meaning" -offset indent
-.It Sy "Symbol" Ta Sy "Meaning"
-.It Li "*" Ta "Denotes the current window."
-.It Li "-" Ta "Marks the last window (previously selected)."
-.It Li "#" Ta "Window is monitored and activity has been detected."
-.It Li "!" Ta "A bell has occurred in the window."
-.It Li "+" Ta "Window is monitored for content and it has appeared."
-.It Li "~" Ta "The window has been silent for the monitor-silence interval."
-.It Li "Z" Ta "The window's active pane is zoomed."
-.El
-.Pp
-The # symbol relates to the
-.Ic monitor-activity
-and + to the
-.Ic monitor-content
-window options.
-The window name is printed in inverted colours if an alert (bell, activity or
-content) is present.
-.Pp
-The colour and attributes of the status line may be configured, the entire
-status line using the
-.Ic status-attr ,
-.Ic status-fg
-and
-.Ic status-bg
-session options and individual windows using the
-.Ic window-status-attr ,
-.Ic window-status-fg
-and
-.Ic window-status-bg
-window options.
-.Pp
-The status line is automatically refreshed at interval if it has changed, the
-interval may be controlled with the
-.Ic status-interval
-session option.
-.Pp
-Commands related to the status line are as follows:
-.Bl -tag -width Ds
-.It Xo Ic command-prompt
-.Op Fl I Ar inputs
-.Op Fl p Ar prompts
-.Op Fl t Ar target-client
-.Op Ar template
-.Xc
-Open the command prompt in a client.
-This may be used from inside
-.Nm
-to execute commands interactively.
-.Pp
-If
-.Ar template
-is specified, it is used as the command.
-If present,
-.Fl I
-is a comma-separated list of the initial text for each prompt.
-If
-.Fl p
-is given,
-.Ar prompts
-is a comma-separated list of prompts which are displayed in order; otherwise
-a single prompt is displayed, constructed from
-.Ar template
-if it is present, or
-.Ql \&:
-if not.
-.Pp
-Both
-.Ar inputs
-and
-.Ar prompts
-may contain the special character sequences supported by the
-.Ic status-left
-option.
-.Pp
-Before the command is executed, the first occurrence of the string
-.Ql %%
-and all occurrences of
-.Ql %1
-are replaced by the response to the first prompt, the second
-.Ql %%
-and all
-.Ql %2
-are replaced with the response to the second prompt, and so on for further
-prompts.
-Up to nine prompt responses may be replaced
-.Po
-.Ql %1
-to
-.Ql %9
-.Pc .
-.It Xo Ic confirm-before
-.Op Fl p Ar prompt
-.Op Fl t Ar target-client
-.Ar command
-.Xc
-.D1 (alias: Ic confirm )
-Ask for confirmation before executing
-.Ar command .
-If
-.Fl p
-is given,
-.Ar prompt
-is the prompt to display; otherwise a prompt is constructed from
-.Ar command .
-It may contain the special character sequences supported by the
-.Ic status-left
-option.
-.Pp
-This command works only from inside
-.Nm .
-.It Xo Ic display-message
-.Op Fl p
-.Op Fl c Ar target-client
-.Op Fl t Ar target-pane
-.Op Ar message
-.Xc
-.D1 (alias: Ic display )
-Display a message.
-If
-.Fl p
-is given, the output is printed to stdout, otherwise it is displayed in the
-.Ar target-client
-status line.
-The format of
-.Ar message
-is described in the
-.Sx FORMATS
-section; information is taken from
-.Ar target-pane
-if
-.Fl t
-is given, otherwise the active pane for the session attached to
-.Ar target-client .
-.El
-.Sh BUFFERS
-.Nm
-maintains a stack of
-.Em paste buffers .
-Up to the value of the
-.Ic buffer-limit
-option are kept; when a new buffer is added, the buffer at the bottom of the
-stack is removed.
-Buffers may be added using
-.Ic copy-mode
-or the
-.Ic set-buffer
-command, and pasted into a window using the
-.Ic paste-buffer
-command.
-.Pp
-A configurable history buffer is also maintained for each window.
-By default, up to 2000 lines are kept; this can be altered with the
-.Ic history-limit
-option (see the
-.Ic set-option
-command above).
-.Pp
-The buffer commands are as follows:
-.Bl -tag -width Ds
-.It Xo
-.Ic choose-buffer
-.Op Fl F Ar format
-.Op Fl t Ar target-window
-.Op Ar template
-.Xc
-Put a window into buffer choice mode, where a buffer may be chosen
-interactively from a list.
-After a buffer is selected,
-.Ql %%
-is replaced by the buffer index in
-.Ar template
-and the result executed as a command.
-If
-.Ar template
-is not given, "paste-buffer -b '%%'" is used.
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-This command works only if at least one client is attached.
-.It Ic clear-history Op Fl t Ar target-pane
-.D1 (alias: Ic clearhist )
-Remove and free the history for the specified pane.
-.It Ic delete-buffer Op Fl b Ar buffer-index
-.D1 (alias: Ic deleteb )
-Delete the buffer at
-.Ar buffer-index ,
-or the top buffer if not specified.
-.It Xo Ic list-buffers
-.Op Fl F Ar format
-.Xc
-.D1 (alias: Ic lsb )
-List the global buffers.
-For the meaning of the
-.Fl F
-flag, see the
-.Sx FORMATS
-section.
-.It Xo Ic load-buffer
-.Op Fl b Ar buffer-index
-.Ar path
-.Xc
-.D1 (alias: Ic loadb )
-Load the contents of the specified paste buffer from
-.Ar path .
-.It Xo Ic paste-buffer
-.Op Fl dpr
-.Op Fl b Ar buffer-index
-.Op Fl s Ar separator
-.Op Fl t Ar target-pane
-.Xc
-.D1 (alias: Ic pasteb )
-Insert the contents of a paste buffer into the specified pane.
-If not specified, paste into the current one.
-With
-.Fl d ,
-also delete the paste buffer from the stack.
-When output, any linefeed (LF) characters in the paste buffer are replaced with
-a separator, by default carriage return (CR).
-A custom separator may be specified using the
-.Fl s
-flag.
-The
-.Fl r
-flag means to do no replacement (equivalent to a separator of LF).
-If
-.Fl p
-is specified, paste bracket control codes are inserted around the
-buffer if the application has requested bracketed paste mode.
-.It Xo Ic save-buffer
-.Op Fl a
-.Op Fl b Ar buffer-index
-.Ar path
-.Xc
-.D1 (alias: Ic saveb )
-Save the contents of the specified paste buffer to
-.Ar path .
-The
-.Fl a
-option appends to rather than overwriting the file.
-.It Xo Ic set-buffer
-.Op Fl b Ar buffer-index
-.Ar data
-.Xc
-.D1 (alias: Ic setb )
-Set the contents of the specified buffer to
-.Ar data .
-.It Xo Ic show-buffer
-.Op Fl b Ar buffer-index
-.Xc
-.D1 (alias: Ic showb )
-Display the contents of the specified buffer.
-.El
-.Sh MISCELLANEOUS
-Miscellaneous commands are as follows:
-.Bl -tag -width Ds
-.It Ic clock-mode Op Fl t Ar target-pane
-Display a large clock.
-.It Xo Ic if-shell
-.Op Fl b
-.Op Fl t Ar target-pane
-.Ar shell-command command
-.Op Ar command
-.Xc
-.D1 (alias: Ic if )
-Execute the first
-.Ar command
-if
-.Ar shell-command
-returns success or the second
-.Ar command
-otherwise.
-Before being executed, shell-command is expanded using the rules specified in the
-.Sx FORMATS
-section, including those relevant to
-.Ar target-pane .
-With
-.Fl b ,
-.Ar shell-command
-is run in the background.
-.It Ic lock-server
-.D1 (alias: Ic lock )
-Lock each client individually by running the command specified by the
-.Ic lock-command
-option.
-.It Xo Ic run-shell
-.Fl b
-.Op Fl t Ar target-pane
-.Ar shell-command
-.Xc
-.D1 (alias: Ic run )
-Execute
-.Ar shell-command
-in the background without creating a window.
-Before being executed, shell-command is expanded using the rules specified in
-the
-.Sx FORMATS
-section.
-With
-.Fl b ,
-the command is run in the background.
-After it finishes, any output to stdout is displayed in copy mode (in the pane
-specified by
-.Fl t
-or the current pane if omitted).
-If the command doesn't return success, the exit status is also displayed.
-.It Ic server-info
-.D1 (alias: Ic info )
-Show server information and terminal details.
-.It Xo Ic wait-for
-.Fl LSU
-.Ar channel
-.Xc
-.D1 (alias: Ic wait )
-When used without options, prevents the client from exiting until woken using
-.Ic wait-for
-.Fl S
-with the same channel.
-When
-.Fl L
-is used, the channel is locked and any clients that try to lock the same
-channel are made to wait until the channel is unlocked with
-.Ic wait-for
-.Fl U .
-This command only works from outside
-.Nm .
-.El
-.Sh TERMINFO EXTENSIONS
-.Nm
-understands some extensions to
-.Xr terminfo 5 :
-.Bl -tag -width Ds
-.It Em Cc , Cr
-Set the cursor colour.
-The first takes a single string argument and is used to set the colour;
-the second takes no arguments and restores the default cursor colour.
-If set, a sequence such as this may be used
-to change the cursor colour from inside
-.Nm :
-.Bd -literal -offset indent
-$ printf '\e033]12;red\e033\e\e'
-.Ed
-.It Em Cs , Csr
-Change the cursor style.
-If set, a sequence such as this may be used
-to change the cursor to an underline:
-.Bd -literal -offset indent
-$ printf '\e033[4 q'
-.Ed
-.Pp
-If
-.Em Csr
-is set, it will be used to reset the cursor style instead
-of
-.Em Cs .
-.It Em \&Ms
-This sequence can be used by
-.Nm
-to store the current buffer in the host terminal's selection (clipboard).
-See the
-.Em set-clipboard
-option above and the
-.Xr xterm 1
-man page.
-.El
-.Sh CONTROL MODE
-.Nm
-offers a textual interface called
-.Em control mode .
-This allows applications to communicate with
-.Nm
-using a simple text-only protocol.
-.Pp
-In control mode, a client sends
-.Nm
-commands or command sequences terminated by newlines on standard input.
-Each command will produce one block of output on standard output.
-An output block consists of a
-.Em %begin
-line followed by the output (which may be empty).
-The output block ends with a
-.Em %end
-or
-.Em %error .
-.Em %begin
-and matching
-.Em %end
-or
-.Em %error
-have two arguments: an integer time (as seconds from epoch) and command number.
-For example:
-.Bd -literal -offset indent
-%begin 1363006971 2
-0: ksh* (1 panes) [80x24] [layout b25f,80x24,0,0,2] @2 (active)
-%end 1363006971 2
-.Ed
-.Pp
-In control mode,
-.Nm
-outputs notifications.
-A notification will never occur inside an output block.
-.Pp
-The following notifications are defined:
-.Bl -tag -width Ds
-.It Ic %exit Op Ar reason
-The
-.Nm
-client is exiting immediately, either because it is not attached to any session
-or an error occurred.
-If present,
-.Ar reason
-describes why the client exited.
-.It Ic %layout-change Ar window-id Ar window-layout
-The layout of a window with ID
-.Ar window-id
-changed.
-The new layout is
-.Ar window-layout .
-.It Ic %output Ar pane-id Ar value
-A window pane produced output.
-.Ar value
-escapes non-printable characters and backslash as octal \\xxx.
-.It Ic %session-changed Ar session-id Ar name
-The client is now attached to the session with ID
-.Ar session-id ,
-which is named
-.Ar name .
-.It Ic %session-renamed Ar name
-The current session was renamed to
-.Ar name .
-.It Ic %sessions-changed
-A session was created or destroyed.
-.It Ic %unlinked-window-add Ar window-id
-The window with ID
-.Ar window-id
-was created but is not linked to the current session.
-.It Ic %window-add Ar window-id
-The window with ID
-.Ar window-id
-was linked to the current session.
-.It Ic %window-close Ar window-id
-The window with ID
-.Ar window-id
-closed.
-.It Ic %window-renamed Ar window-id Ar name
-The window with ID
-.Ar window-id
-was renamed to
-.Ar name .
-.El
-.Sh FILES
-.Bl -tag -width "/etc/tmux.confXXX" -compact
-.It Pa ~/.tmux.conf
-Default
-.Nm
-configuration file.
-.It Pa /etc/tmux.conf
-System-wide configuration file.
-.El
-.Sh EXAMPLES
-To create a new
-.Nm
-session running
-.Xr vi 1 :
-.Pp
-.Dl $ tmux new-session vi
-.Pp
-Most commands have a shorter form, known as an alias.
-For new-session, this is
-.Ic new :
-.Pp
-.Dl $ tmux new vi
-.Pp
-Alternatively, the shortest unambiguous form of a command is accepted.
-If there are several options, they are listed:
-.Bd -literal -offset indent
-$ tmux n
-ambiguous command: n, could be: new-session, new-window, next-window
-.Ed
-.Pp
-Within an active session, a new window may be created by typing
-.Ql C-b c
-(Ctrl
-followed by the
-.Ql b
-key
-followed by the
-.Ql c
-key).
-.Pp
-Windows may be navigated with:
-.Ql C-b 0
-(to select window 0),
-.Ql C-b 1
-(to select window 1), and so on;
-.Ql C-b n
-to select the next window; and
-.Ql C-b p
-to select the previous window.
-.Pp
-A session may be detached using
-.Ql C-b d
-(or by an external event such as
-.Xr ssh 1
-disconnection) and reattached with:
-.Pp
-.Dl $ tmux attach-session
-.Pp
-Typing
-.Ql C-b \&?
-lists the current key bindings in the current window; up and down may be used
-to navigate the list or
-.Ql q
-to exit from it.
-.Pp
-Commands to be run when the
-.Nm
-server is started may be placed in the
-.Pa ~/.tmux.conf
-configuration file.
-Common examples include:
-.Pp
-Changing the default prefix key:
-.Bd -literal -offset indent
-set-option -g prefix C-a
-unbind-key C-b
-bind-key C-a send-prefix
-.Ed
-.Pp
-Turning the status line off, or changing its colour:
-.Bd -literal -offset indent
-set-option -g status off
-set-option -g status-bg blue
-.Ed
-.Pp
-Setting other options, such as the default command,
-or locking after 30 minutes of inactivity:
-.Bd -literal -offset indent
-set-option -g default-command "exec /bin/ksh"
-set-option -g lock-after-time 1800
-.Ed
-.Pp
-Creating new key bindings:
-.Bd -literal -offset indent
-bind-key b set-option status
-bind-key / command-prompt "split-window 'exec man %%'"
-bind-key S command-prompt "new-window -n %1 'ssh %1'"
-.Ed
-.Sh SEE ALSO
-.Xr pty 4
-.Sh AUTHORS
-.An Nicholas Marriott Aq nicm@users.sourceforge.net
diff --git a/tmux.1.in b/tmux.1.in
new file mode 100644
index 0000000..635a187
--- /dev/null
+++ b/tmux.1.in
@@ -0,0 +1,3808 @@
+.\" $Id$
+.\"
+.\" Copyright (c) 2007 Nicholas Marriott <nicm@users.sourceforge.net>
+.\"
+.\" Permission to use, copy, modify, and distribute this software for any
+.\" purpose with or without fee is hereby granted, provided that the above
+.\" copyright notice and this permission notice appear in all copies.
+.\"
+.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+.\" WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
+.\" IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+.\" OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+.\"
+.Dd $Mdocdate: March 25 2013 $
+.Dt TMUX 1
+.Os
+.Sh NAME
+.Nm tmux
+.Nd terminal multiplexer
+.Sh SYNOPSIS
+.Nm tmux
+.Bk -words
+.Op Fl 28lCquvV
+.Op Fl c Ar shell-command
+.Op Fl f Ar file
+.Op Fl L Ar socket-name
+.Op Fl S Ar socket-path
+.Op Ar command Op Ar flags
+.Ek
+.Sh DESCRIPTION
+.Nm
+is a terminal multiplexer:
+it enables a number of terminals to be created, accessed, and
+controlled from a single screen.
+.Nm
+may be detached from a screen
+and continue running in the background,
+then later reattached.
+.Pp
+When
+.Nm
+is started it creates a new
+.Em session
+with a single
+.Em window
+and displays it on screen.
+A status line at the bottom of the screen
+shows information on the current session
+and is used to enter interactive commands.
+.Pp
+A session is a single collection of
+.Em pseudo terminals
+under the management of
+.Nm .
+Each session has one or more
+windows linked to it.
+A window occupies the entire screen
+and may be split into rectangular panes,
+each of which is a separate pseudo terminal
+(the
+.Xr pty 4
+manual page documents the technical details of pseudo terminals).
+Any number of
+.Nm
+instances may connect to the same session,
+and any number of windows may be present in the same session.
+Once all sessions are killed,
+.Nm
+exits.
+.Pp
+Each session is persistent and will survive accidental disconnection
+(such as
+.Xr ssh 1
+connection timeout) or intentional detaching (with the
+.Ql C-b d
+key strokes).
+.Nm
+may be reattached using:
+.Pp
+.Dl $ tmux attach
+.Pp
+In
+.Nm ,
+a session is displayed on screen by a
+.Em client
+and all sessions are managed by a single
+.Em server .
+The server and each client are separate processes which communicate through a
+socket in
+.Pa /tmp .
+.Pp
+The options are as follows:
+.Bl -tag -width "XXXXXXXXXXXX"
+.It Fl 2
+Force
+.Nm
+to assume the terminal supports 256 colours.
+.It Fl C
+Start in control mode.
+Given twice
+.Xo ( Fl CC ) Xc
+disables echo.
+.It Fl c Ar shell-command
+Execute
+.Ar shell-command
+using the default shell.
+If necessary, the
+.Nm
+server will be started to retrieve the
+.Ic default-shell
+option.
+This option is for compatibility with
+.Xr sh 1
+when
+.Nm
+is used as a login shell.
+.It Fl f Ar file
+Specify an alternative configuration file.
+By default,
+.Nm
+loads the system configuration file from
+.Pa @sysconfdir@/tmux.conf ,
+if present, then looks for a user configuration file at
+.Pa ~/.tmux.conf .
+.Pp
+The configuration file is a set of
+.Nm
+commands which are executed in sequence when the server is first started.
+.Nm
+loads configuration files once when the server process has started.
+The
+.Ic source-file
+command may be used to load a file later.
+.Pp
+.Nm
+shows any error messages from commands in configuration files in the first
+session created, and continues to process the rest of the configuration file.
+.It Fl L Ar socket-name
+.Nm
+stores the server socket in a directory under
+.Ev TMUX_TMPDIR ,
+.Ev TMPDIR
+if it is unset, or
+.Pa /tmp
+if both are unset.
+The default socket is named
+.Em default .
+This option allows a different socket name to be specified, allowing several
+independent
+.Nm
+servers to be run.
+Unlike
+.Fl S
+a full path is not necessary: the sockets are all created in the same
+directory.
+.Pp
+If the socket is accidentally removed, the
+.Dv SIGUSR1
+signal may be sent to the
+.Nm
+server process to recreate it.
+.It Fl l
+Behave as a login shell.
+This flag currently has no effect and is for compatibility with other shells
+when using tmux as a login shell.
+.It Fl q
+Set the
+.Ic quiet
+server option to prevent the server sending various informational messages.
+.It Fl S Ar socket-path
+Specify a full alternative path to the server socket.
+If
+.Fl S
+is specified, the default socket directory is not used and any
+.Fl L
+flag is ignored.
+.It Fl u
+.Nm
+attempts to guess if the terminal is likely to support UTF-8 by checking the
+first of the
+.Ev LC_ALL ,
+.Ev LC_CTYPE
+and
+.Ev LANG
+environment variables to be set for the string "UTF-8".
+This is not always correct: the
+.Fl u
+flag explicitly informs
+.Nm
+that UTF-8 is supported.
+.Pp
+If the server is started from a client passed
+.Fl u
+or where UTF-8 is detected, the
+.Ic utf8
+and
+.Ic status-utf8
+options are enabled in the global window and session options respectively.
+.It Fl v
+Request verbose logging.
+This option may be specified multiple times for increasing verbosity.
+Log messages will be saved into
+.Pa tmux-client-PID.log
+and
+.Pa tmux-server-PID.log
+files in the current directory, where
+.Em PID
+is the PID of the server or client process.
+.It Fl V
+Report the
+.Nm
+version.
+.It Ar command Op Ar flags
+This specifies one of a set of commands used to control
+.Nm ,
+as described in the following sections.
+If no commands are specified, the
+.Ic new-session
+command is assumed.
+.El
+.Sh KEY BINDINGS
+.Nm
+may be controlled from an attached client by using a key combination of a
+prefix key,
+.Ql C-b
+(Ctrl-b) by default, followed by a command key.
+.Pp
+The default command key bindings are:
+.Pp
+.Bl -tag -width "XXXXXXXXXX" -offset indent -compact
+.It C-b
+Send the prefix key (C-b) through to the application.
+.It C-o
+Rotate the panes in the current window forwards.
+.It C-z
+Suspend the
+.Nm
+client.
+.It !
+Break the current pane out of the window.
+.It \&"
+Split the current pane into two, top and bottom.
+.It #
+List all paste buffers.
+.It $
+Rename the current session.
+.It %
+Split the current pane into two, left and right.
+.It &
+Kill the current window.
+.It '
+Prompt for a window index to select.
+.It ,
+Rename the current window.
+.It -
+Delete the most recently copied buffer of text.
+.It .
+Prompt for an index to move the current window.
+.It 0 to 9
+Select windows 0 to 9.
+.It :
+Enter the
+.Nm
+command prompt.
+.It ;
+Move to the previously active pane.
+.It =
+Choose which buffer to paste interactively from a list.
+.It \&?
+List all key bindings.
+.It D
+Choose a client to detach.
+.It \&[
+Enter copy mode to copy text or view the history.
+.It \&]
+Paste the most recently copied buffer of text.
+.It c
+Create a new window.
+.It d
+Detach the current client.
+.It f
+Prompt to search for text in open windows.
+.It i
+Display some information about the current window.
+.It l
+Move to the previously selected window.
+.It n
+Change to the next window.
+.It o
+Select the next pane in the current window.
+.It p
+Change to the previous window.
+.It q
+Briefly display pane indexes.
+.It r
+Force redraw of the attached client.
+.It s
+Select a new session for the attached client interactively.
+.It L
+Switch the attached client back to the last session.
+.It t
+Show the time.
+.It w
+Choose the current window interactively.
+.It x
+Kill the current pane.
+.It {
+Swap the current pane with the previous pane.
+.It }
+Swap the current pane with the next pane.
+.It ~
+Show previous messages from
+.Nm ,
+if any.
+.It Page Up
+Enter copy mode and scroll one page up.
+.It Up, Down
+.It Left, Right
+Change to the pane above, below, to the left, or to the right of the current
+pane.
+.It M-1 to M-5
+Arrange panes in one of the five preset layouts: even-horizontal,
+even-vertical, main-horizontal, main-vertical, or tiled.
+.It M-n
+Move to the next window with a bell or activity marker.
+.It M-o
+Rotate the panes in the current window backwards.
+.It M-p
+Move to the previous window with a bell or activity marker.
+.It C-Up, C-Down
+.It C-Left, C-Right
+Resize the current pane in steps of one cell.
+.It M-Up, M-Down
+.It M-Left, M-Right
+Resize the current pane in steps of five cells.
+.El
+.Pp
+Key bindings may be changed with the
+.Ic bind-key
+and
+.Ic unbind-key
+commands.
+.Sh COMMANDS
+This section contains a list of the commands supported by
+.Nm .
+Most commands accept the optional
+.Fl t
+argument with one of
+.Ar target-client ,
+.Ar target-session
+.Ar target-window ,
+or
+.Ar target-pane .
+These specify the client, session, window or pane which a command should affect.
+.Ar target-client
+is the name of the
+.Xr pty 4
+file to which the client is connected, for example either of
+.Pa /dev/ttyp1
+or
+.Pa ttyp1
+for the client attached to
+.Pa /dev/ttyp1 .
+If no client is specified, the current client is chosen, if possible, or an
+error is reported.
+Clients may be listed with the
+.Ic list-clients
+command.
+.Pp
+.Ar target-session
+is the session id prefixed with a $, the name of a session (as listed by the
+.Ic list-sessions
+command), or the name of a client with the same syntax as
+.Ar target-client ,
+in which case the session attached to the client is used.
+When looking for the session name,
+.Nm
+initially searches for an exact match; if none is found, the session names
+are checked for any for which
+.Ar target-session
+is a prefix or for which it matches as an
+.Xr fnmatch 3
+pattern.
+If a single match is found, it is used as the target session; multiple matches
+produce an error.
+If a session is omitted, the current session is used if available; if no
+current session is available, the most recently used is chosen.
+.Pp
+.Ar target-window
+specifies a window in the form
+.Em session Ns \&: Ns Em window .
+.Em session
+follows the same rules as for
+.Ar target-session ,
+and
+.Em window
+is looked for in order: as a window index, for example mysession:1;
+as a window ID, such as @1;
+as an exact window name, such as mysession:mywindow; then as an
+.Xr fnmatch 3
+pattern or the start of a window name, such as mysession:mywin* or
+mysession:mywin.
+An empty window name specifies the next unused index if appropriate (for
+example the
+.Ic new-window
+and
+.Ic link-window
+commands)
+otherwise the current window in
+.Em session
+is chosen.
+The special character
+.Ql \&!
+uses the last (previously current) window,
+.Ql ^
+selects the highest numbered window,
+.Ql $
+selects the lowest numbered window, and
+.Ql +
+and
+.Ql -
+select the next window or the previous window by number.
+When the argument does not contain a colon,
+.Nm
+first attempts to parse it as window; if that fails, an attempt is made to
+match a session.
+.Pp
+.Ar target-pane
+takes a similar form to
+.Ar target-window
+but with the optional addition of a period followed by a pane index, for
+example: mysession:mywindow.1.
+If the pane index is omitted, the currently active pane in the specified
+window is used.
+If neither a colon nor period appears,
+.Nm
+first attempts to use the argument as a pane index; if that fails, it is looked
+up as for
+.Ar target-window .
+A
+.Ql +
+or
+.Ql -
+indicate the next or previous pane index, respectively.
+One of the strings
+.Em top ,
+.Em bottom ,
+.Em left ,
+.Em right ,
+.Em top-left ,
+.Em top-right ,
+.Em bottom-left
+or
+.Em bottom-right
+may be used instead of a pane index.
+.Pp
+The special characters
+.Ql +
+and
+.Ql -
+may be followed by an offset, for example:
+.Bd -literal -offset indent
+select-window -t:+2
+.Ed
+.Pp
+When dealing with a session that doesn't contain sequential window indexes,
+they will be correctly skipped.
+.Pp
+.Nm
+also gives each pane created in a server an identifier consisting of a
+.Ql %
+and a number, starting from zero.
+A pane's identifier is unique for the life of the
+.Nm
+server and is passed to the child process of the pane in the
+.Ev TMUX_PANE
+environment variable.
+It may be used alone to target a pane or the window containing it.
+.Pp
+.Ar shell-command
+arguments are
+.Xr sh 1
+commands.
+These must be passed as a single item, which typically means quoting them, for
+example:
+.Bd -literal -offset indent
+new-window 'vi /etc/passwd'
+.Ed
+.Pp
+.Ar command
+.Op Ar arguments
+refers to a
+.Nm
+command, passed with the command and arguments separately, for example:
+.Bd -literal -offset indent
+bind-key F1 set-window-option force-width 81
+.Ed
+.Pp
+Or if using
+.Xr sh 1 :
+.Bd -literal -offset indent
+$ tmux bind-key F1 set-window-option force-width 81
+.Ed
+.Pp
+Multiple commands may be specified together as part of a
+.Em command sequence .
+Each command should be separated by spaces and a semicolon;
+commands are executed sequentially from left to right and
+lines ending with a backslash continue on to the next line,
+except when escaped by another backslash.
+A literal semicolon may be included by escaping it with a backslash (for
+example, when specifying a command sequence to
+.Ic bind-key ) .
+.Pp
+Example
+.Nm
+commands include:
+.Bd -literal -offset indent
+refresh-client -t/dev/ttyp2
+
+rename-session -tfirst newname
+
+set-window-option -t:0 monitor-activity on
+
+new-window ; split-window -d
+
+bind-key R source-file ~/.tmux.conf \e; \e
+	display-message "source-file done"
+.Ed
+.Pp
+Or from
+.Xr sh 1 :
+.Bd -literal -offset indent
+$ tmux kill-window -t :1
+
+$ tmux new-window \e; split-window -d
+
+$ tmux new-session -d 'vi /etc/passwd' \e; split-window -d \e; attach
+.Ed
+.Sh CLIENTS AND SESSIONS
+The
+.Nm
+server manages clients, sessions, windows and panes.
+Clients are attached to sessions to interact with them, either
+when they are created with the
+.Ic new-session
+command, or later with the
+.Ic attach-session
+command.
+Each session has one or more windows
+.Em linked
+into it.
+Windows may be linked to multiple sessions and are made up of one or
+more panes,
+each of which contains a pseudo terminal.
+Commands for creating, linking and otherwise manipulating windows
+are covered
+in the
+.Sx WINDOWS AND PANES
+section.
+.Pp
+The following commands are available to manage clients and sessions:
+.Bl -tag -width Ds
+.It Xo Ic attach-session
+.Op Fl dr
+.Op Fl t Ar target-session
+.Xc
+.D1 (alias: Ic attach )
+If run from outside
+.Nm ,
+create a new client in the current terminal and attach it to
+.Ar target-session .
+If used from inside, switch the current client.
+If
+.Fl d
+is specified, any other clients attached to the session are detached.
+.Fl r
+signifies the client is read-only (only keys bound to the
+.Ic detach-client
+or
+.Ic switch-client
+commands have any effect)
+.Pp
+If no server is started,
+.Ic attach-session
+will attempt to start it; this will fail unless sessions are created in the
+configuration file.
+.Pp
+The
+.Ar target-session
+rules for
+.Ic attach-session
+are slightly adjusted: if
+.Nm
+needs to select the most recently used session, it will prefer the most
+recently used
+.Em unattached
+session.
+.It Xo Ic detach-client
+.Op Fl P
+.Op Fl a
+.Op Fl s Ar target-session
+.Op Fl t Ar target-client
+.Xc
+.D1 (alias: Ic detach )
+Detach the current client if bound to a key, the client specified with
+.Fl t ,
+or all clients currently attached to the session specified by
+.Fl s .
+The
+.Fl a
+option kills all but the client given with
+.Fl t .
+If
+.Fl P
+is given, send SIGHUP to the parent process of the client, typically causing it
+to exit.
+.It Ic has-session Op Fl t Ar target-session
+.D1 (alias: Ic has )
+Report an error and exit with 1 if the specified session does not exist.
+If it does exist, exit with 0.
+.It Ic kill-server
+Kill the
+.Nm
+server and clients and destroy all sessions.
+.It Ic kill-session
+.Op Fl a
+.Op Fl t Ar target-session
+Destroy the given session, closing any windows linked to it and no other
+sessions, and detaching all clients attached to it.
+If
+.Fl a
+is given, all sessions but the specified one is killed.
+.It Xo Ic list-clients
+.Op Fl F Ar format
+.Op Fl t Ar target-session
+.Xc
+.D1 (alias: Ic lsc )
+List all clients attached to the server.
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+If
+.Ar target-session
+is specified, list only clients connected to that session.
+.It Ic list-commands
+.D1 (alias: Ic lscm )
+List the syntax of all commands supported by
+.Nm .
+.It Ic list-sessions Op Fl F Ar format
+.D1 (alias: Ic ls )
+List all sessions managed by the server.
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+.It Ic lock-client Op Fl t Ar target-client
+.D1 (alias: Ic lockc )
+Lock
+.Ar target-client ,
+see the
+.Ic lock-server
+command.
+.It Ic lock-session Op Fl t Ar target-session
+.D1 (alias: Ic locks )
+Lock all clients attached to
+.Ar target-session .
+.It Xo Ic new-session
+.Op Fl AdDP
+.Op Fl F Ar format
+.Op Fl n Ar window-name
+.Op Fl s Ar session-name
+.Op Fl t Ar target-session
+.Op Fl x Ar width
+.Op Fl y Ar height
+.Op Ar shell-command
+.Xc
+.D1 (alias: Ic new )
+Create a new session with name
+.Ar session-name .
+.Pp
+The new session is attached to the current terminal unless
+.Fl d
+is given.
+.Ar window-name
+and
+.Ar shell-command
+are the name of and shell command to execute in the initial window.
+If
+.Fl d
+is used,
+.Fl x
+and
+.Fl y
+specify the size of the initial window (80 by 24 if not given).
+.Pp
+If run from a terminal, any
+.Xr termios 4
+special characters are saved and used for new windows in the new session.
+.Pp
+The
+.Fl A
+flag makes
+.Ic new-session
+behave like
+.Ic attach-session
+if
+.Ar session-name
+already exists; in the case,
+.Fl D
+behaves like
+.Fl d
+to
+.Ic attach-session .
+.Pp
+If
+.Fl t
+is given, the new session is
+.Em grouped
+with
+.Ar target-session .
+This means they share the same set of windows - all windows from
+.Ar target-session
+are linked to the new session and any subsequent new windows or windows being
+closed are applied to both sessions.
+The current and previous window and any session options remain independent and
+either session may be killed without affecting the other.
+Giving
+.Fl n
+or
+.Ar shell-command
+are invalid if
+.Fl t
+is used.
+.Pp
+The
+.Fl P
+option prints information about the new session after it has been created.
+By default, it uses the format
+.Ql #{session_name}:
+but a different format may be specified with
+.Fl F .
+.It Xo Ic refresh-client
+.Op Fl S
+.Op Fl t Ar target-client
+.Xc
+.D1 (alias: Ic refresh )
+Refresh the current client if bound to a key, or a single client if one is given
+with
+.Fl t .
+If
+.Fl S
+is specified, only update the client's status bar.
+.It Xo Ic rename-session
+.Op Fl t Ar target-session
+.Ar new-name
+.Xc
+.D1 (alias: Ic rename )
+Rename the session to
+.Ar new-name .
+.It Xo Ic show-messages
+.Op Fl t Ar target-client
+.Xc
+.D1 (alias: Ic showmsgs )
+Any messages displayed on the status line are saved in a per-client message
+log, up to a maximum of the limit set by the
+.Ar message-limit
+session option for the session attached to that client.
+This command displays the log for
+.Ar target-client .
+.It Ic source-file Ar path
+.D1 (alias: Ic source )
+Execute commands from
+.Ar path .
+.It Ic start-server
+.D1 (alias: Ic start )
+Start the
+.Nm
+server, if not already running, without creating any sessions.
+.It Xo Ic suspend-client
+.Op Fl t Ar target-client
+.Xc
+.D1 (alias: Ic suspendc )
+Suspend a client by sending
+.Dv SIGTSTP
+(tty stop).
+.It Xo Ic switch-client
+.Op Fl lnpr
+.Op Fl c Ar target-client
+.Op Fl t Ar target-session
+.Xc
+.D1 (alias: Ic switchc )
+Switch the current session for client
+.Ar target-client
+to
+.Ar target-session .
+If
+.Fl l ,
+.Fl n
+or
+.Fl p
+is used, the client is moved to the last, next or previous session
+respectively.
+.Fl r
+toggles whether a client is read-only (see the
+.Ic attach-session
+command).
+.El
+.Sh WINDOWS AND PANES
+A
+.Nm
+window may be in one of several modes.
+The default permits direct access to the terminal attached to the window.
+The other is copy mode, which permits a section of a window or its
+history to be copied to a
+.Em paste buffer
+for later insertion into another window.
+This mode is entered with the
+.Ic copy-mode
+command, bound to
+.Ql \&[
+by default.
+It is also entered when a command that produces output, such as
+.Ic list-keys ,
+is executed from a key binding.
+.Pp
+The keys available depend on whether emacs or vi mode is selected
+(see the
+.Ic mode-keys
+option).
+The following keys are supported as appropriate for the mode:
+.Bl -column "FunctionXXXXXXXXXXXXXXXXX" "viXXXXXXXXXX" "emacs" -offset indent
+.It Sy "Function" Ta Sy "vi" Ta Sy "emacs"
+.It Li "Back to indentation" Ta "^" Ta "M-m"
+.It Li "Bottom of history" Ta "G" Ta "M-<"
+.It Li "Clear selection" Ta "Escape" Ta "C-g"
+.It Li "Copy selection" Ta "Enter" Ta "M-w"
+.It Li "Cursor down" Ta "j" Ta "Down"
+.It Li "Cursor left" Ta "h" Ta "Left"
+.It Li "Cursor right" Ta "l" Ta "Right"
+.It Li "Cursor to bottom line" Ta "L" Ta ""
+.It Li "Cursor to middle line" Ta "M" Ta "M-r"
+.It Li "Cursor to top line" Ta "H" Ta "M-R"
+.It Li "Cursor up" Ta "k" Ta "Up"
+.It Li "Delete entire line" Ta "d" Ta "C-u"
+.It Li "Delete/Copy to end of line" Ta "D" Ta "C-k"
+.It Li "End of line" Ta "$" Ta "C-e"
+.It Li "Go to line" Ta ":" Ta "g"
+.It Li "Half page down" Ta "C-d" Ta "M-Down"
+.It Li "Half page up" Ta "C-u" Ta "M-Up"
+.It Li "Jump forward" Ta "f" Ta "f"
+.It Li "Jump to forward" Ta "t" Ta ""
+.It Li "Jump backward" Ta "F" Ta "F"
+.It Li "Jump to backward" Ta "T" Ta ""
+.It Li "Jump again" Ta ";" Ta ";"
+.It Li "Jump again in reverse" Ta "," Ta ","
+.It Li "Next page" Ta "C-f" Ta "Page down"
+.It Li "Next space" Ta "W" Ta ""
+.It Li "Next space, end of word" Ta "E" Ta ""
+.It Li "Next word" Ta "w" Ta ""
+.It Li "Next word end" Ta "e" Ta "M-f"
+.It Li "Paste buffer" Ta "p" Ta "C-y"
+.It Li "Previous page" Ta "C-b" Ta "Page up"
+.It Li "Previous word" Ta "b" Ta "M-b"
+.It Li "Previous space" Ta "B" Ta ""
+.It Li "Quit mode" Ta "q" Ta "Escape"
+.It Li "Rectangle toggle" Ta "v" Ta "R"
+.It Li "Scroll down" Ta "C-Down or C-e" Ta "C-Down"
+.It Li "Scroll up" Ta "C-Up or C-y" Ta "C-Up"
+.It Li "Search again" Ta "n" Ta "n"
+.It Li "Search again in reverse" Ta "N" Ta "N"
+.It Li "Search backward" Ta "?" Ta "C-r"
+.It Li "Search forward" Ta "/" Ta "C-s"
+.It Li "Start of line" Ta "0" Ta "C-a"
+.It Li "Start selection" Ta "Space" Ta "C-Space"
+.It Li "Top of history" Ta "g" Ta "M->"
+.It Li "Transpose characters" Ta "" Ta "C-t"
+.El
+.Pp
+The next and previous word keys use space and the
+.Ql - ,
+.Ql _
+and
+.Ql @
+characters as word delimiters by default, but this can be adjusted by
+setting the
+.Em word-separators
+session option.
+Next word moves to the start of the next word, next word end to the end of the
+next word and previous word to the start of the previous word.
+The three next and previous space keys work similarly but use a space alone as
+the word separator.
+.Pp
+The jump commands enable quick movement within a line.
+For instance, typing
+.Ql f
+followed by
+.Ql /
+will move the cursor to the next
+.Ql /
+character on the current line.
+A
+.Ql \&;
+will then jump to the next occurrence.
+.Pp
+Commands in copy mode may be prefaced by an optional repeat count.
+With vi key bindings, a prefix is entered using the number keys; with
+emacs, the Alt (meta) key and a number begins prefix entry.
+For example, to move the cursor forward by ten words, use
+.Ql M-1 0 M-f
+in emacs mode, and
+.Ql 10w
+in vi.
+.Pp
+When copying the selection, the repeat count indicates the buffer index to
+replace, if used.
+.Pp
+Mode key bindings are defined in a set of named tables:
+.Em vi-edit
+and
+.Em emacs-edit
+for keys used when line editing at the command prompt;
+.Em vi-choice
+and
+.Em emacs-choice
+for keys used when choosing from lists (such as produced by the
+.Ic choose-window
+command); and
+.Em vi-copy
+and
+.Em emacs-copy
+used in copy mode.
+The tables may be viewed with the
+.Ic list-keys
+command and keys modified or removed with
+.Ic bind-key
+and
+.Ic unbind-key .
+One command accepts an argument,
+.Ic copy-pipe ,
+which copies the selection and pipes it to a command.
+For example the following will bind
+.Ql C-q
+to copy the selection into
+.Pa /tmp
+as well as the paste buffer:
+.Bd -literal -offset indent
+bind-key -temacs-copy C-q copy-pipe "cat >/tmp/out"
+.Ed
+.Pp
+The paste buffer key pastes the first line from the top paste buffer on the
+stack.
+.Pp
+The synopsis for the
+.Ic copy-mode
+command is:
+.Bl -tag -width Ds
+.It Xo Ic copy-mode
+.Op Fl u
+.Op Fl t Ar target-pane
+.Xc
+Enter copy mode.
+The
+.Fl u
+option scrolls one page up.
+.El
+.Pp
+Each window displayed by
+.Nm
+may be split into one or more
+.Em panes ;
+each pane takes up a certain area of the display and is a separate terminal.
+A window may be split into panes using the
+.Ic split-window
+command.
+Windows may be split horizontally (with the
+.Fl h
+flag) or vertically.
+Panes may be resized with the
+.Ic resize-pane
+command (bound to
+.Ql C-up ,
+.Ql C-down
+.Ql C-left
+and
+.Ql C-right
+by default), the current pane may be changed with the
+.Ic select-pane
+command and the
+.Ic rotate-window
+and
+.Ic swap-pane
+commands may be used to swap panes without changing their position.
+Panes are numbered beginning from zero in the order they are created.
+.Pp
+A number of preset
+.Em layouts
+are available.
+These may be selected with the
+.Ic select-layout
+command or cycled with
+.Ic next-layout
+(bound to
+.Ql Space
+by default); once a layout is chosen, panes within it may be moved and resized
+as normal.
+.Pp
+The following layouts are supported:
+.Bl -tag -width Ds
+.It Ic even-horizontal
+Panes are spread out evenly from left to right across the window.
+.It Ic even-vertical
+Panes are spread evenly from top to bottom.
+.It Ic main-horizontal
+A large (main) pane is shown at the top of the window and the remaining panes
+are spread from left to right in the leftover space at the bottom.
+Use the
+.Em main-pane-height
+window option to specify the height of the top pane.
+.It Ic main-vertical
+Similar to
+.Ic main-horizontal
+but the large pane is placed on the left and the others spread from top to
+bottom along the right.
+See the
+.Em main-pane-width
+window option.
+.It Ic tiled
+Panes are spread out as evenly as possible over the window in both rows and
+columns.
+.El
+.Pp
+In addition,
+.Ic select-layout
+may be used to apply a previously used layout - the
+.Ic list-windows
+command displays the layout of each window in a form suitable for use with
+.Ic select-layout .
+For example:
+.Bd -literal -offset indent
+$ tmux list-windows
+0: ksh [159x48]
+    layout: bb62,159x48,0,0{79x48,0,0,79x48,80,0}
+$ tmux select-layout bb62,159x48,0,0{79x48,0,0,79x48,80,0}
+.Ed
+.Pp
+.Nm
+automatically adjusts the size of the layout for the current window size.
+Note that a layout cannot be applied to a window with more panes than that
+from which the layout was originally defined.
+.Pp
+Commands related to windows and panes are as follows:
+.Bl -tag -width Ds
+.It Xo Ic break-pane
+.Op Fl dP
+.Op Fl F Ar format
+.Op Fl t Ar target-pane
+.Xc
+.D1 (alias: Ic breakp )
+Break
+.Ar target-pane
+off from its containing window to make it the only pane in a new window.
+If
+.Fl d
+is given, the new window does not become the current window.
+The
+.Fl P
+option prints information about the new window after it has been created.
+By default, it uses the format
+.Ql #{session_name}:#{window_index}
+but a different format may be specified with
+.Fl F .
+.It Xo Ic capture-pane
+.Op Fl aepPq
+.Op Fl b Ar buffer-index
+.Op Fl E Ar end-line
+.Op Fl S Ar start-line
+.Op Fl t Ar target-pane
+.Xc
+.D1 (alias: Ic capturep )
+Capture the contents of a pane.
+If
+.Fl p
+is given, the output goes to stdout, otherwise to the buffer specified with
+.Fl b
+or a new buffer if omitted.
+If
+.Fl a
+is given, the alternate screen is used, and the history is not accessible.
+If no alternate screen exists, an error will be returned unless
+.Fl q
+is given.
+If
+.Fl e
+is given, the output includes escape sequences for text and background
+attributes.
+.Fl C
+also escapes non-printable characters as octal \exxx.
+.Fl J
+joins wrapped lines and preserves trailing spaces at each line's end.
+.Fl P
+captures only any output that the pane has received that is the beginning of an
+as-yet incomplete escape sequence.
+.Pp
+.Fl S
+and
+.Fl E
+specify the starting and ending line numbers, zero is the first line of the
+visible pane and negative numbers are lines in the history.
+The default is to capture only the visible contents of the pane.
+.It Xo
+.Ic choose-client
+.Op Fl F Ar format
+.Op Fl t Ar target-window
+.Op Ar template
+.Xc
+Put a window into client choice mode, allowing a client to be selected
+interactively from a list.
+After a client is chosen,
+.Ql %%
+is replaced by the client
+.Xr pty 4
+path in
+.Ar template
+and the result executed as a command.
+If
+.Ar template
+is not given, "detach-client -t '%%'" is used.
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+This command works only if at least one client is attached.
+.It Xo
+.Ic choose-list
+.Op Fl l Ar items
+.Op Fl t Ar target-window
+.Op Ar template
+.Xc
+Put a window into list choice mode, allowing
+.Ar items
+to be selected.
+.Ar items
+can be a comma-separated list to display more than one item.
+If an item has spaces, that entry must be quoted.
+After an item is chosen,
+.Ql %%
+is replaced by the chosen item in the
+.Ar template
+and the result is executed as a command.
+If
+.Ar template
+is not given, "run-shell '%%'" is used.
+.Ar items
+also accepts format specifiers.
+For the meaning of this see the
+.Sx FORMATS
+section.
+This command works only if at least one client is attached.
+.It Xo
+.Ic choose-session
+.Op Fl F Ar format
+.Op Fl t Ar target-window
+.Op Ar template
+.Xc
+Put a window into session choice mode, where a session may be selected
+interactively from a list.
+When one is chosen,
+.Ql %%
+is replaced by the session name in
+.Ar template
+and the result executed as a command.
+If
+.Ar template
+is not given, "switch-client -t '%%'" is used.
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+This command works only if at least one client is attached.
+.It Xo
+.Ic choose-tree
+.Op Fl suw
+.Op Fl b Ar session-template
+.Op Fl c Ar window-template
+.Op Fl S Ar format
+.Op Fl W Ar format
+.Op Fl t Ar target-window
+.Xc
+Put a window into tree choice mode, where either sessions or windows may be
+selected interactively from a list.
+By default, windows belonging to a session are indented to show their
+relationship to a session.
+.Pp
+Note that the
+.Ic choose-window
+and
+.Ic choose-session
+commands are wrappers around
+.Ic choose-tree .
+.Pp
+If
+.Fl s
+is given, will show sessions.
+If
+.Fl w
+is given, will show windows.
+.Pp
+By default, the tree is collapsed and sessions must be expanded to windows
+with the right arrow key.
+The
+.Fl u
+option will start with all sessions expanded instead.
+.Pp
+If
+.Fl b
+is given, will override the default session command.
+Note that
+.Ql %%
+can be used and will be replaced with the session name.
+The default option if not specified is "switch-client -t '%%'".
+If
+.Fl c
+is given, will override the default window command.
+Like
+.Fl b ,
+.Ql %%
+can be used and will be replaced with the session name and window index.
+When a window is chosen from the list, the session command is run before the
+window command.
+.Pp
+If
+.Fl S
+is given will display the specified format instead of the default session
+format.
+If
+.Fl W
+is given will display the specified format instead of the default window
+format.
+For the meaning of the
+.Fl s
+and
+.Fl w
+options, see the
+.Sx FORMATS
+section.
+.Pp
+This command works only if at least one client is attached.
+.It Xo
+.Ic choose-window
+.Op Fl F Ar format
+.Op Fl t Ar target-window
+.Op Ar template
+.Xc
+Put a window into window choice mode, where a window may be chosen
+interactively from a list.
+After a window is selected,
+.Ql %%
+is replaced by the session name and window index in
+.Ar template
+and the result executed as a command.
+If
+.Ar template
+is not given, "select-window -t '%%'" is used.
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+This command works only if at least one client is attached.
+.It Ic display-panes Op Fl t Ar target-client
+.D1 (alias: Ic displayp)
+Display a visible indicator of each pane shown by
+.Ar target-client .
+See the
+.Ic display-panes-time ,
+.Ic display-panes-colour ,
+and
+.Ic display-panes-active-colour
+session options.
+While the indicator is on screen, a pane may be selected with the
+.Ql 0
+to
+.Ql 9
+keys.
+.It Xo Ic find-window
+.Op Fl CNT
+.Op Fl F Ar format
+.Op Fl t Ar target-window
+.Ar match-string
+.Xc
+.D1 (alias: Ic findw )
+Search for the
+.Xr fnmatch 3
+pattern
+.Ar match-string
+in window names, titles, and visible content (but not history).
+The flags control matching behavior:
+.Fl C
+matches only visible window contents,
+.Fl N
+matches only the window name and
+.Fl T
+matches only the window title.
+The default is
+.Fl CNT .
+If only one window is matched, it'll be automatically selected,
+otherwise a choice list is shown.
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+This command works only if at least one client is attached.
+.It Xo Ic join-pane
+.Op Fl bdhv
+.Oo Fl l
+.Ar size |
+.Fl p Ar percentage Oc
+.Op Fl s Ar src-pane
+.Op Fl t Ar dst-pane
+.Xc
+.D1 (alias: Ic joinp )
+Like
+.Ic split-window ,
+but instead of splitting
+.Ar dst-pane
+and creating a new pane, split it and move
+.Ar src-pane
+into the space.
+This can be used to reverse
+.Ic break-pane .
+The
+.Fl b
+option causes
+.Ar src-pane
+to be joined to left of or above
+.Ar dst-pane .
+.It Xo Ic kill-pane
+.Op Fl a
+.Op Fl t Ar target-pane
+.Xc
+.D1 (alias: Ic killp )
+Destroy the given pane.
+If no panes remain in the containing window, it is also destroyed.
+The
+.Fl a
+option kills all but the pane given with
+.Fl t .
+.It Xo Ic kill-window
+.Op Fl a
+.Op Fl t Ar target-window
+.Xc
+.D1 (alias: Ic killw )
+Kill the current window or the window at
+.Ar target-window ,
+removing it from any sessions to which it is linked.
+The
+.Fl a
+option kills all but the window given with
+.Fl t .
+.It Ic last-pane Op Fl t Ar target-window
+.D1 (alias: Ic lastp )
+Select the last (previously selected) pane.
+.It Ic last-window Op Fl t Ar target-session
+.D1 (alias: Ic last )
+Select the last (previously selected) window.
+If no
+.Ar target-session
+is specified, select the last window of the current session.
+.It Xo Ic link-window
+.Op Fl dk
+.Op Fl s Ar src-window
+.Op Fl t Ar dst-window
+.Xc
+.D1 (alias: Ic linkw )
+Link the window at
+.Ar src-window
+to the specified
+.Ar dst-window .
+If
+.Ar dst-window
+is specified and no such window exists, the
+.Ar src-window
+is linked there.
+If
+.Fl k
+is given and
+.Ar dst-window
+exists, it is killed, otherwise an error is generated.
+If
+.Fl d
+is given, the newly linked window is not selected.
+.It Xo Ic list-panes
+.Op Fl as
+.Op Fl F Ar format
+.Op Fl t Ar target
+.Xc
+.D1 (alias: Ic lsp )
+If
+.Fl a
+is given,
+.Ar target
+is ignored and all panes on the server are listed.
+If
+.Fl s
+is given,
+.Ar target
+is a session (or the current session).
+If neither is given,
+.Ar target
+is a window (or the current window).
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+.It Xo Ic list-windows
+.Op Fl a
+.Op Fl F Ar format
+.Op Fl t Ar target-session
+.Xc
+.D1 (alias: Ic lsw )
+If
+.Fl a
+is given, list all windows on the server.
+Otherwise, list windows in the current session or in
+.Ar target-session .
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+.It Xo Ic move-pane
+.Op Fl bdhv
+.Oo Fl l
+.Ar size |
+.Fl p Ar percentage Oc
+.Op Fl s Ar src-pane
+.Op Fl t Ar dst-pane
+.Xc
+.D1 (alias: Ic movep )
+Like
+.Ic join-pane ,
+but
+.Ar src-pane
+and
+.Ar dst-pane
+may belong to the same window.
+.It Xo Ic move-window
+.Op Fl rdk
+.Op Fl s Ar src-window
+.Op Fl t Ar dst-window
+.Xc
+.D1 (alias: Ic movew )
+This is similar to
+.Ic link-window ,
+except the window at
+.Ar src-window
+is moved to
+.Ar dst-window .
+With
+.Fl r ,
+all windows in the session are renumbered in sequential order, respecting
+the
+.Ic base-index
+option.
+.It Xo Ic new-window
+.Op Fl adkP
+.Op Fl c Ar start-directory
+.Op Fl F Ar format
+.Op Fl n Ar window-name
+.Op Fl t Ar target-window
+.Op Ar shell-command
+.Xc
+.D1 (alias: Ic neww )
+Create a new window.
+With
+.Fl a ,
+the new window is inserted at the next index up from the specified
+.Ar target-window ,
+moving windows up if necessary,
+otherwise
+.Ar target-window
+is the new window location.
+.Pp
+If
+.Fl d
+is given, the session does not make the new window the current window.
+.Ar target-window
+represents the window to be created; if the target already exists an error is
+shown, unless the
+.Fl k
+flag is used, in which case it is destroyed.
+.Ar shell-command
+is the command to execute.
+If
+.Ar shell-command
+is not specified, the value of the
+.Ic default-command
+option is used.
+.Fl c
+specifies the working directory in which the new window is created.
+It may have an absolute path or one of the following values (or a subdirectory):
+.Bl -column "XXXXXXXXXXXX" "XXXXXXXXXXXXXXXXXXXXXXXX" -offset indent
+.It Li "Empty string" Ta "Current pane's directory"
+.It Li "~" Ta "User's home directory"
+.It Li "-" Ta "Where session was started"
+.It Li "." Ta "Where server was started"
+.El
+.Pp
+When the shell command completes, the window closes.
+See the
+.Ic remain-on-exit
+option to change this behaviour.
+.Pp
+The
+.Ev TERM
+environment variable must be set to
+.Dq screen
+for all programs running
+.Em inside
+.Nm .
+New windows will automatically have
+.Dq TERM=screen
+added to their environment, but care must be taken not to reset this in shell
+start-up files.
+.Pp
+The
+.Fl P
+option prints information about the new window after it has been created.
+By default, it uses the format
+.Ql #{session_name}:#{window_index}
+but a different format may be specified with
+.Fl F .
+.It Ic next-layout Op Fl t Ar target-window
+.D1 (alias: Ic nextl )
+Move a window to the next layout and rearrange the panes to fit.
+.It Xo Ic next-window
+.Op Fl a
+.Op Fl t Ar target-session
+.Xc
+.D1 (alias: Ic next )
+Move to the next window in the session.
+If
+.Fl a
+is used, move to the next window with an alert.
+.It Xo Ic pipe-pane
+.Op Fl o
+.Op Fl t Ar target-pane
+.Op Ar shell-command
+.Xc
+.D1 (alias: Ic pipep )
+Pipe any output sent by the program in
+.Ar target-pane
+to a shell command.
+A pane may only be piped to one command at a time, any existing pipe is
+closed before
+.Ar shell-command
+is executed.
+The
+.Ar shell-command
+string may contain the special character sequences supported by the
+.Ic status-left
+option.
+If no
+.Ar shell-command
+is given, the current pipe (if any) is closed.
+.Pp
+The
+.Fl o
+option only opens a new pipe if no previous pipe exists, allowing a pipe to
+be toggled with a single key, for example:
+.Bd -literal -offset indent
+bind-key C-p pipe-pane -o 'cat >>~/output.#I-#P'
+.Ed
+.It Xo Ic previous-layout
+.Op Fl t Ar target-window
+.Xc
+.D1 (alias: Ic prevl )
+Move to the previous layout in the session.
+.It Xo Ic previous-window
+.Op Fl a
+.Op Fl t Ar target-session
+.Xc
+.D1 (alias: Ic prev )
+Move to the previous window in the session.
+With
+.Fl a ,
+move to the previous window with an alert.
+.It Xo Ic rename-window
+.Op Fl t Ar target-window
+.Ar new-name
+.Xc
+.D1 (alias: Ic renamew )
+Rename the current window, or the window at
+.Ar target-window
+if specified, to
+.Ar new-name .
+.It Xo Ic resize-pane
+.Op Fl DLRUZ
+.Op Fl t Ar target-pane
+.Op Fl x Ar width
+.Op Fl y Ar height
+.Op Ar adjustment
+.Xc
+.D1 (alias: Ic resizep )
+Resize a pane, up, down, left or right by
+.Ar adjustment
+with
+.Fl U ,
+.Fl D ,
+.Fl L
+or
+.Fl R ,
+or
+to an absolute size
+with
+.Fl x
+or
+.Fl y .
+The
+.Ar adjustment
+is given in lines or cells (the default is 1).
+.Pp
+With
+.Fl Z ,
+the active pane is toggled between zoomed (occupying the whole of the window)
+and unzoomed (its normal position in the layout).
+.It Xo Ic respawn-pane
+.Op Fl k
+.Op Fl t Ar target-pane
+.Op Ar shell-command
+.Xc
+.D1 (alias: Ic respawnp )
+Reactivate a pane in which the command has exited (see the
+.Ic remain-on-exit
+window option).
+If
+.Ar shell-command
+is not given, the command used when the pane was created is executed.
+The pane must be already inactive, unless
+.Fl k
+is given, in which case any existing command is killed.
+.It Xo Ic respawn-window
+.Op Fl k
+.Op Fl t Ar target-window
+.Op Ar shell-command
+.Xc
+.D1 (alias: Ic respawnw )
+Reactivate a window in which the command has exited (see the
+.Ic remain-on-exit
+window option).
+If
+.Ar shell-command
+is not given, the command used when the window was created is executed.
+The window must be already inactive, unless
+.Fl k
+is given, in which case any existing command is killed.
+.It Xo Ic rotate-window
+.Op Fl DU
+.Op Fl t Ar target-window
+.Xc
+.D1 (alias: Ic rotatew )
+Rotate the positions of the panes within a window, either upward (numerically
+lower) with
+.Fl U
+or downward (numerically higher).
+.It Xo Ic select-layout
+.Op Fl np
+.Op Fl t Ar target-window
+.Op Ar layout-name
+.Xc
+.D1 (alias: Ic selectl )
+Choose a specific layout for a window.
+If
+.Ar layout-name
+is not given, the last preset layout used (if any) is reapplied.
+.Fl n
+and
+.Fl p
+are equivalent to the
+.Ic next-layout
+and
+.Ic previous-layout
+commands.
+.It Xo Ic select-pane
+.Op Fl lDLRU
+.Op Fl t Ar target-pane
+.Xc
+.D1 (alias: Ic selectp )
+Make pane
+.Ar target-pane
+the active pane in window
+.Ar target-window .
+If one of
+.Fl D ,
+.Fl L ,
+.Fl R ,
+or
+.Fl U
+is used, respectively the pane below, to the left, to the right, or above the
+target pane is used.
+.Fl l
+is the same as using the
+.Ic last-pane
+command.
+.It Xo Ic select-window
+.Op Fl lnpT
+.Op Fl t Ar target-window
+.Xc
+.D1 (alias: Ic selectw )
+Select the window at
+.Ar target-window .
+.Fl l ,
+.Fl n
+and
+.Fl p
+are equivalent to the
+.Ic last-window ,
+.Ic next-window
+and
+.Ic previous-window
+commands.
+If
+.Fl T
+is given and the selected window is already the current window,
+the command behaves like
+.Ic last-window .
+.It Xo Ic split-window
+.Op Fl dhvP
+.Op Fl c Ar start-directory
+.Oo Fl l
+.Ar size |
+.Fl p Ar percentage Oc
+.Op Fl t Ar target-pane
+.Op Ar shell-command
+.Op Fl F Ar format
+.Xc
+.D1 (alias: Ic splitw )
+Create a new pane by splitting
+.Ar target-pane :
+.Fl h
+does a horizontal split and
+.Fl v
+a vertical split; if neither is specified,
+.Fl v
+is assumed.
+The
+.Fl l
+and
+.Fl p
+options specify the size of the new pane in lines (for vertical split) or in
+cells (for horizontal split), or as a percentage, respectively.
+All other options have the same meaning as for the
+.Ic new-window
+command.
+.It Xo Ic swap-pane
+.Op Fl dDU
+.Op Fl s Ar src-pane
+.Op Fl t Ar dst-pane
+.Xc
+.D1 (alias: Ic swapp )
+Swap two panes.
+If
+.Fl U
+is used and no source pane is specified with
+.Fl s ,
+.Ar dst-pane
+is swapped with the previous pane (before it numerically);
+.Fl D
+swaps with the next pane (after it numerically).
+.Fl d
+instructs
+.Nm
+not to change the active pane.
+.It Xo Ic swap-window
+.Op Fl d
+.Op Fl s Ar src-window
+.Op Fl t Ar dst-window
+.Xc
+.D1 (alias: Ic swapw )
+This is similar to
+.Ic link-window ,
+except the source and destination windows are swapped.
+It is an error if no window exists at
+.Ar src-window .
+.It Xo Ic unlink-window
+.Op Fl k
+.Op Fl t Ar target-window
+.Xc
+.D1 (alias: Ic unlinkw )
+Unlink
+.Ar target-window .
+Unless
+.Fl k
+is given, a window may be unlinked only if it is linked to multiple sessions -
+windows may not be linked to no sessions;
+if
+.Fl k
+is specified and the window is linked to only one session, it is unlinked and
+destroyed.
+.El
+.Sh KEY BINDINGS
+.Nm
+allows a command to be bound to most keys, with or without a prefix key.
+When specifying keys, most represent themselves (for example
+.Ql A
+to
+.Ql Z ) .
+Ctrl keys may be prefixed with
+.Ql C-
+or
+.Ql ^ ,
+and Alt (meta) with
+.Ql M- .
+In addition, the following special key names are accepted:
+.Em Up ,
+.Em Down ,
+.Em Left ,
+.Em Right ,
+.Em BSpace ,
+.Em BTab ,
+.Em DC
+(Delete),
+.Em End ,
+.Em Enter ,
+.Em Escape ,
+.Em F1
+to
+.Em F20 ,
+.Em Home ,
+.Em IC
+(Insert),
+.Em NPage/PageDown/PgDn ,
+.Em PPage/PageUp/PgUp ,
+.Em Space ,
+and
+.Em Tab .
+Note that to bind the
+.Ql \&"
+or
+.Ql '
+keys, quotation marks are necessary, for example:
+.Bd -literal -offset indent
+bind-key '"' split-window
+bind-key "'" new-window
+.Ed
+.Pp
+Commands related to key bindings are as follows:
+.Bl -tag -width Ds
+.It Xo Ic bind-key
+.Op Fl cnr
+.Op Fl t Ar key-table
+.Ar key Ar command Op Ar arguments
+.Xc
+.D1 (alias: Ic bind )
+Bind key
+.Ar key
+to
+.Ar command .
+By default (without
+.Fl t )
+the primary key bindings are modified (those normally activated with the prefix
+key); in this case, if
+.Fl n
+is specified, it is not necessary to use the prefix key,
+.Ar command
+is bound to
+.Ar key
+alone.
+The
+.Fl r
+flag indicates this key may repeat, see the
+.Ic repeat-time
+option.
+.Pp
+If
+.Fl t
+is present,
+.Ar key
+is bound in
+.Ar key-table :
+the binding for command mode with
+.Fl c
+or for normal mode without.
+To view the default bindings and possible commands, see the
+.Ic list-keys
+command.
+.It Ic list-keys Op Fl t Ar key-table
+.D1 (alias: Ic lsk )
+List all key bindings.
+Without
+.Fl t
+the primary key bindings - those executed when preceded by the prefix key -
+are printed.
+.Pp
+With
+.Fl t ,
+the key bindings in
+.Ar key-table
+are listed; this may be one of:
+.Em vi-edit ,
+.Em emacs-edit ,
+.Em vi-choice ,
+.Em emacs-choice ,
+.Em vi-copy
+or
+.Em emacs-copy .
+.It Xo Ic send-keys
+.Op Fl lR
+.Op Fl t Ar target-pane
+.Ar key Ar ...
+.Xc
+.D1 (alias: Ic send )
+Send a key or keys to a window.
+Each argument
+.Ar key
+is the name of the key (such as
+.Ql C-a
+or
+.Ql npage
+) to send; if the string is not recognised as a key, it is sent as a series of
+characters.
+The
+.Fl l
+flag disables key name lookup and sends the keys literally.
+All arguments are sent sequentially from first to last.
+The
+.Fl R
+flag causes the terminal state to be reset.
+.It Xo Ic send-prefix
+.Op Fl 2
+.Op Fl t Ar target-pane
+.Xc
+Send the prefix key, or with
+.Fl 2
+the secondary prefix key, to a window as if it was pressed.
+.It Xo Ic unbind-key
+.Op Fl acn
+.Op Fl t Ar key-table
+.Ar key
+.Xc
+.D1 (alias: Ic unbind )
+Unbind the command bound to
+.Ar key .
+Without
+.Fl t
+the primary key bindings are modified; in this case, if
+.Fl n
+is specified, the command bound to
+.Ar key
+without a prefix (if any) is removed.
+If
+.Fl a
+is present, all key bindings are removed.
+.Pp
+If
+.Fl t
+is present,
+.Ar key
+in
+.Ar key-table
+is unbound: the binding for command mode with
+.Fl c
+or for normal mode without.
+.El
+.Sh OPTIONS
+The appearance and behaviour of
+.Nm
+may be modified by changing the value of various options.
+There are three types of option:
+.Em server options ,
+.Em session options
+and
+.Em window options .
+.Pp
+The
+.Nm
+server has a set of global options which do not apply to any particular
+window or session.
+These are altered with the
+.Ic set-option
+.Fl s
+command, or displayed with the
+.Ic show-options
+.Fl s
+command.
+.Pp
+In addition, each individual session may have a set of session options, and
+there is a separate set of global session options.
+Sessions which do not have a particular option configured inherit the value
+from the global session options.
+Session options are set or unset with the
+.Ic set-option
+command and may be listed with the
+.Ic show-options
+command.
+The available server and session options are listed under the
+.Ic set-option
+command.
+.Pp
+Similarly, a set of window options is attached to each window, and there is
+a set of global window options from which any unset options are inherited.
+Window options are altered with the
+.Ic set-window-option
+command and can be listed with the
+.Ic show-window-options
+command.
+All window options are documented with the
+.Ic set-window-option
+command.
+.Pp
+.Nm
+also supports user options which are prefixed with a
+.Ql \&@ .
+User options may have any name, so long as they are prefixed with
+.Ql \&@ ,
+and be set to any string.
+For example
+.Bd -literal -offset indent
+$ tmux setw -q @foo "abc123"
+$ tmux showw -v @foo
+abc123
+.Ed
+.Pp
+Commands which set options are as follows:
+.Bl -tag -width Ds
+.It Xo Ic set-option
+.Op Fl agoqsuw
+.Op Fl t Ar target-session | Ar target-window
+.Ar option Ar value
+.Xc
+.D1 (alias: Ic set )
+Set a window option with
+.Fl w
+(equivalent to the
+.Ic set-window-option
+command),
+a server option with
+.Fl s ,
+otherwise a session option.
+.Pp
+If
+.Fl g
+is specified, the global session or window option is set.
+With
+.Fl a ,
+and if the option expects a string,
+.Ar value
+is appended to the existing setting.
+The
+.Fl u
+flag unsets an option, so a session inherits the option from the global
+options.
+It is not possible to unset a global option.
+.Pp
+The
+.Fl o
+flag prevents setting an option that is already set.
+.Pp
+The
+.Fl q
+flag suppresses the informational message (as if the
+.Ic quiet
+server option was set).
+.Pp
+Available window options are listed under
+.Ic set-window-option .
+.Pp
+.Ar value
+depends on the option and may be a number, a string, or a flag (on, off, or
+omitted to toggle).
+.Pp
+Available server options are:
+.Bl -tag -width Ds
+.It Ic buffer-limit Ar number
+Set the number of buffers; as new buffers are added to the top of the stack,
+old ones are removed from the bottom if necessary to maintain this maximum
+length.
+.It Ic escape-time Ar time
+Set the time in milliseconds for which
+.Nm
+waits after an escape is input to determine if it is part of a function or meta
+key sequences.
+The default is 500 milliseconds.
+.It Xo Ic exit-unattached
+.Op Ic on | off
+.Xc
+If enabled, the server will exit when there are no attached clients.
+.It Xo Ic quiet
+.Op Ic on | off
+.Xc
+Enable or disable the display of various informational messages (see also the
+.Fl q
+command line flag).
+.It Xo Ic set-clipboard
+.Op Ic on | off
+.Xc
+Attempt to set the terminal clipboard content using the
+\ee]52;...\e007
+.Xr xterm 1
+escape sequences.
+This option is on by default if there is an
+.Em \&Ms
+entry in the
+.Xr terminfo 5
+description for the client terminal.
+Note that this feature needs to be enabled in
+.Xr xterm 1
+by setting the resource:
+.Bd -literal -offset indent
+disallowedWindowOps: 20,21,SetXprop
+.Ed
+.Pp
+Or changing this property from the
+.Xr xterm 1
+interactive menu when required.
+.El
+.Pp
+Available session options are:
+.Bl -tag -width Ds
+.It Ic assume-paste-time Ar milliseconds
+If keys are entered faster than one in
+.Ar milliseconds ,
+they are assumed to have been pasted rather than typed and
+.Nm
+key bindings are not processed.
+The default is one millisecond and zero disables.
+.It Ic base-index Ar index
+Set the base index from which an unused index should be searched when a new
+window is created.
+The default is zero.
+.It Xo Ic bell-action
+.Op Ic any | none | current
+.Xc
+Set action on window bell.
+.Ic any
+means a bell in any window linked to a session causes a bell in the current
+window of that session,
+.Ic none
+means all bells are ignored and
+.Ic current
+means only bells in windows other than the current window are ignored.
+.It Xo Ic bell-on-alert
+.Op Ic on | off
+.Xc
+If on, ring the terminal bell when an alert
+occurs.
+.It Ic default-command Ar shell-command
+Set the command used for new windows (if not specified when the window is
+created) to
+.Ar shell-command ,
+which may be any
+.Xr sh 1
+command.
+The default is an empty string, which instructs
+.Nm
+to create a login shell using the value of the
+.Ic default-shell
+option.
+.It Ic default-path Ar path
+Set the default working directory for new panes.
+If empty (the default), the working directory is determined from the process
+running in the active pane, from the command line environment or from the
+working directory where the session was created.
+Otherwise the same options are available as for the
+.Fl c
+flag to
+.Ic new-window .
+.It Ic default-shell Ar path
+Specify the default shell.
+This is used as the login shell for new windows when the
+.Ic default-command
+option is set to empty, and must be the full path of the executable.
+When started
+.Nm
+tries to set a default value from the first suitable of the
+.Ev SHELL
+environment variable, the shell returned by
+.Xr getpwuid 3 ,
+or
+.Pa /bin/sh .
+This option should be configured when
+.Nm
+is used as a login shell.
+.It Ic default-terminal Ar terminal
+Set the default terminal for new windows created in this session - the
+default value of the
+.Ev TERM
+environment variable.
+For
+.Nm
+to work correctly, this
+.Em must
+be set to
+.Ql screen
+or a derivative of it.
+.It Xo Ic destroy-unattached
+.Op Ic on | off
+.Xc
+If enabled and the session is no longer attached to any clients, it is
+destroyed.
+.It Xo Ic detach-on-destroy
+.Op Ic on | off
+.Xc
+If on (the default), the client is detached when the session it is attached to
+is destroyed.
+If off, the client is switched to the most recently active of the remaining
+sessions.
+.It Ic display-panes-active-colour Ar colour
+Set the colour used by the
+.Ic display-panes
+command to show the indicator for the active pane.
+.It Ic display-panes-colour Ar colour
+Set the colour used by the
+.Ic display-panes
+command to show the indicators for inactive panes.
+.It Ic display-panes-time Ar time
+Set the time in milliseconds for which the indicators shown by the
+.Ic display-panes
+command appear.
+.It Ic display-time Ar time
+Set the amount of time for which status line messages and other on-screen
+indicators are displayed.
+.Ar time
+is in milliseconds.
+.It Ic history-limit Ar lines
+Set the maximum number of lines held in window history.
+This setting applies only to new windows - existing window histories are not
+resized and retain the limit at the point they were created.
+.It Ic lock-after-time Ar number
+Lock the session (like the
+.Ic lock-session
+command) after
+.Ar number
+seconds of inactivity, or the entire server (all sessions) if the
+.Ic lock-server
+option is set.
+The default is not to lock (set to 0).
+.It Ic lock-command Ar shell-command
+Command to run when locking each client.
+The default is to run
+.Xr lock 1
+with
+.Fl np .
+.It Xo Ic lock-server
+.Op Ic on | off
+.Xc
+If this option is
+.Ic on
+(the default),
+instead of each session locking individually as each has been
+idle for
+.Ic lock-after-time ,
+the entire server will lock after
+.Em all
+sessions would have locked.
+This has no effect as a session option; it must be set as a global option.
+.It Ic message-attr Ar attributes
+Set status line message attributes, where
+.Ar attributes
+is either
+.Ic none
+or a comma-delimited list of one or more of:
+.Ic bright
+(or
+.Ic bold ) ,
+.Ic dim ,
+.Ic underscore ,
+.Ic blink ,
+.Ic reverse ,
+.Ic hidden ,
+or
+.Ic italics .
+.It Ic message-bg Ar colour
+Set status line message background colour, where
+.Ar colour
+is one of:
+.Ic black ,
+.Ic red ,
+.Ic green ,
+.Ic yellow ,
+.Ic blue ,
+.Ic magenta ,
+.Ic cyan ,
+.Ic white ,
+aixterm bright variants (if supported:
+.Ic brightred ,
+.Ic brightgreen ,
+and so on),
+.Ic colour0
+to
+.Ic colour255
+from the 256-colour set,
+.Ic default ,
+or a hexadecimal RGB string such as
+.Ql #ffffff ,
+which chooses the closest match from the default 256-colour set.
+.It Ic message-command-attr Ar attributes
+Set status line message attributes when in command mode.
+.It Ic message-command-bg Ar colour
+Set status line message background colour when in command mode.
+.It Ic message-command-fg Ar colour
+Set status line message foreground colour when in command mode.
+.It Ic message-fg Ar colour
+Set status line message foreground colour.
+.It Ic message-limit Ar number
+Set the number of error or information messages to save in the message log for
+each client.
+The default is 20.
+.It Xo Ic mouse-resize-pane
+.Op Ic on | off
+.Xc
+If on,
+.Nm
+captures the mouse and allows panes to be resized by dragging on their borders.
+.It Xo Ic mouse-select-pane
+.Op Ic on | off
+.Xc
+If on,
+.Nm
+captures the mouse and when a window is split into multiple panes the mouse may
+be used to select the current pane.
+The mouse click is also passed through to the application as normal.
+.It Xo Ic mouse-select-window
+.Op Ic on | off
+.Xc
+If on, clicking the mouse on a window name in the status line will select that
+window.
+.It Xo Ic mouse-utf8
+.Op Ic on | off
+.Xc
+If enabled, request mouse input as UTF-8 on UTF-8 terminals.
+.It Ic pane-active-border-bg Ar colour
+.It Ic pane-active-border-fg Ar colour
+Set the pane border colour for the currently active pane.
+.It Ic pane-border-bg Ar colour
+.It Ic pane-border-fg Ar colour
+Set the pane border colour for panes aside from the active pane.
+.It Ic prefix Ar key
+Set the key accepted as a prefix key.
+.It Ic prefix2 Ar key
+Set a secondary key accepted as a prefix key.
+.It Xo Ic renumber-windows
+.Op Ic on | off
+.Xc
+If on, when a window is closed in a session, automatically renumber the other
+windows in numerical order.
+This respects the
+.Ic base-index
+option if it has been set.
+If off, do not renumber the windows.
+.It Ic repeat-time Ar time
+Allow multiple commands to be entered without pressing the prefix-key again
+in the specified
+.Ar time
+milliseconds (the default is 500).
+Whether a key repeats may be set when it is bound using the
+.Fl r
+flag to
+.Ic bind-key .
+Repeat is enabled for the default keys bound to the
+.Ic resize-pane
+command.
+.It Xo Ic set-remain-on-exit
+.Op Ic on | off
+.Xc
+Set the
+.Ic remain-on-exit
+window option for any windows first created in this session.
+When this option is true, windows in which the running program has
+exited do not close, instead remaining open but inactivate.
+Use the
+.Ic respawn-window
+command to reactivate such a window, or the
+.Ic kill-window
+command to destroy it.
+.It Xo Ic set-titles
+.Op Ic on | off
+.Xc
+Attempt to set the client terminal title using the
+.Em tsl
+and
+.Em fsl
+.Xr terminfo 5
+entries if they exist.
+.Nm
+automatically sets these to the \ee]2;...\e007 sequence if
+the terminal appears to be an xterm.
+This option is off by default.
+Note that elinks
+will only attempt to set the window title if the STY environment
+variable is set.
+.It Ic set-titles-string Ar string
+String used to set the window title if
+.Ic set-titles
+is on.
+Character sequences are replaced as for the
+.Ic status-left
+option.
+.It Xo Ic status
+.Op Ic on | off
+.Xc
+Show or hide the status line.
+.It Ic status-attr Ar attributes
+Set status line attributes.
+.It Ic status-bg Ar colour
+Set status line background colour.
+.It Ic status-fg Ar colour
+Set status line foreground colour.
+.It Ic status-interval Ar interval
+Update the status bar every
+.Ar interval
+seconds.
+By default, updates will occur every 15 seconds.
+A setting of zero disables redrawing at interval.
+.It Xo Ic status-justify
+.Op Ic left | centre | right
+.Xc
+Set the position of the window list component of the status line: left, centre
+or right justified.
+.It Xo Ic status-keys
+.Op Ic vi | emacs
+.Xc
+Use vi or emacs-style
+key bindings in the status line, for example at the command prompt.
+The default is emacs, unless the
+.Ev VISUAL
+or
+.Ev EDITOR
+environment variables are set and contain the string
+.Ql vi .
+.It Ic status-left Ar string
+Display
+.Ar string
+to the left of the status bar.
+.Ar string
+will be passed through
+.Xr strftime 3
+before being used.
+By default, the session name is shown.
+.Ar string
+may contain any of the following special character sequences:
+.Bl -column "Character pair" "Replaced with" -offset indent
+.It Sy "Character pair" Ta Sy "Replaced with"
+.It Li "#(shell-command)" Ta "First line of the command's output"
+.It Li "#[attributes]" Ta "Colour or attribute change"
+.It Li "#H" Ta "Hostname of local host"
+.It Li "#h" Ta "Hostname of local host without the domain name"
+.It Li "#F" Ta "Current window flag"
+.It Li "#I" Ta "Current window index"
+.It Li "#D" Ta "Current pane unique identifier"
+.It Li "#P" Ta "Current pane index"
+.It Li "#S" Ta "Session name"
+.It Li "#T" Ta "Current pane title"
+.It Li "#W" Ta "Current window name"
+.It Li "##" Ta "A literal" Ql #
+.El
+.Pp
+The #(shell-command) form executes
+.Ql shell-command
+and inserts the first line of its output.
+Note that shell commands are only executed once at the interval specified by
+the
+.Ic status-interval
+option: if the status line is redrawn in the meantime, the previous result is
+used.
+Shell commands are executed with the
+.Nm
+global environment set (see the
+.Sx ENVIRONMENT
+section).
+.Pp
+For details on how the names and titles can be set see the
+.Sx "NAMES AND TITLES"
+section.
+.Pp
+#[attributes] allows a comma-separated list of attributes to be specified,
+these may be
+.Ql fg=colour
+to set the foreground colour,
+.Ql bg=colour
+to set the background colour, the name of one of the attributes (listed under
+the
+.Ic message-attr
+option) to turn an attribute on, or an attribute prefixed with
+.Ql no
+to turn one off, for example
+.Ic nobright .
+Examples are:
+.Bd -literal -offset indent
+#(sysctl vm.loadavg)
+#[fg=yellow,bold]#(apm -l)%%#[default] [#S]
+.Ed
+.Pp
+Where appropriate, special character sequences may be prefixed with a number to
+specify the maximum length, for example
+.Ql #24T .
+.Pp
+By default, UTF-8 in
+.Ar string
+is not interpreted, to enable UTF-8, use the
+.Ic status-utf8
+option.
+.It Ic status-left-attr Ar attributes
+Set the attribute of the left part of the status line.
+.It Ic status-left-bg Ar colour
+Set the background colour of the left part of the status line.
+.It Ic status-left-fg Ar colour
+Set the foreground colour of the left part of the status line.
+.It Ic status-left-length Ar length
+Set the maximum
+.Ar length
+of the left component of the status bar.
+The default is 10.
+.It Xo Ic status-position
+.Op Ic top | bottom
+.Xc
+Set the position of the status line.
+.It Ic status-right Ar string
+Display
+.Ar string
+to the right of the status bar.
+By default, the current window title in double quotes, the date and the time
+are shown.
+As with
+.Ic status-left ,
+.Ar string
+will be passed to
+.Xr strftime 3 ,
+character pairs are replaced, and UTF-8 is dependent on the
+.Ic status-utf8
+option.
+.It Ic status-right-attr Ar attributes
+Set the attribute of the right part of the status line.
+.It Ic status-right-bg Ar colour
+Set the background colour of the right part of the status line.
+.It Ic status-right-fg Ar colour
+Set the foreground colour of the right part of the status line.
+.It Ic status-right-length Ar length
+Set the maximum
+.Ar length
+of the right component of the status bar.
+The default is 40.
+.It Xo Ic status-utf8
+.Op Ic on | off
+.Xc
+Instruct
+.Nm
+to treat top-bit-set characters in the
+.Ic status-left
+and
+.Ic status-right
+strings as UTF-8; notably, this is important for wide characters.
+This option defaults to off.
+.It Ic terminal-overrides Ar string
+Contains a list of entries which override terminal descriptions read using
+.Xr terminfo 5 .
+.Ar string
+is a comma-separated list of items each a colon-separated string made up of a
+terminal type pattern (matched using
+.Xr fnmatch 3 )
+and a set of
+.Em name=value
+entries.
+.Pp
+For example, to set the
+.Ql clear
+.Xr terminfo 5
+entry to
+.Ql \ee[H\ee[2J
+for all terminal types and the
+.Ql dch1
+entry to
+.Ql \ee[P
+for the
+.Ql rxvt
+terminal type, the option could be set to the string:
+.Bd -literal -offset indent
+"*:clear=\ee[H\ee[2J,rxvt:dch1=\ee[P"
+.Ed
+.Pp
+The terminal entry value is passed through
+.Xr strunvis 3
+before interpretation.
+The default value forcibly corrects the
+.Ql colors
+entry for terminals which support 88 or 256 colours:
+.Bd -literal -offset indent
+"*88col*:colors=88,*256col*:colors=256,xterm*:XT"
+.Ed
+.It Ic update-environment Ar variables
+Set a space-separated string containing a list of environment variables to be
+copied into the session environment when a new session is created or an
+existing session is attached.
+Any variables that do not exist in the source environment are set to be
+removed from the session environment (as if
+.Fl r
+was given to the
+.Ic set-environment
+command).
+The default is
+"DISPLAY SSH_ASKPASS SSH_AUTH_SOCK SSH_AGENT_PID SSH_CONNECTION WINDOWID
+XAUTHORITY".
+.It Xo Ic visual-activity
+.Op Ic on | off
+.Xc
+If on, display a status line message when activity occurs in a window
+for which the
+.Ic monitor-activity
+window option is enabled.
+.It Xo Ic visual-bell
+.Op Ic on | off
+.Xc
+If this option is on, a message is shown on a bell instead of it being passed
+through to the terminal (which normally makes a sound).
+Also see the
+.Ic bell-action
+option.
+.It Xo Ic visual-content
+.Op Ic on | off
+.Xc
+Like
+.Ic visual-activity ,
+display a message when content is present in a window
+for which the
+.Ic monitor-content
+window option is enabled.
+.It Xo Ic visual-silence
+.Op Ic on | off
+.Xc
+If
+.Ic monitor-silence
+is enabled, prints a message after the interval has expired on a given window.
+.It Ic word-separators Ar string
+Sets the session's conception of what characters are considered word
+separators, for the purposes of the next and previous word commands in
+copy mode.
+The default is
+.Ql \ -_@ .
+.El
+.It Xo Ic set-window-option
+.Op Fl agoqu
+.Op Fl t Ar target-window
+.Ar option Ar value
+.Xc
+.D1 (alias: Ic setw )
+Set a window option.
+The
+.Fl a ,
+.Fl g ,
+.Fl o ,
+.Fl q
+and
+.Fl u
+flags work similarly to the
+.Ic set-option
+command.
+.Pp
+Supported window options are:
+.Pp
+.Bl -tag -width Ds -compact
+.It Xo Ic aggressive-resize
+.Op Ic on | off
+.Xc
+Aggressively resize the chosen window.
+This means that
+.Nm
+will resize the window to the size of the smallest session for which it is the
+current window, rather than the smallest session to which it is attached.
+The window may resize when the current window is changed on another sessions;
+this option is good for full-screen programs which support
+.Dv SIGWINCH
+and poor for interactive programs such as shells.
+.Pp
+.It Xo Ic allow-rename
+.Op Ic on | off
+.Xc
+Allow programs to change the window name using a terminal escape
+sequence (\\033k...\\033\\\\).
+The default is on.
+.Pp
+.It Xo Ic alternate-screen
+.Op Ic on | off
+.Xc
+This option configures whether programs running inside
+.Nm
+may use the terminal alternate screen feature, which allows the
+.Em smcup
+and
+.Em rmcup
+.Xr terminfo 5
+capabilities.
+The alternate screen feature preserves the contents of the window when an
+interactive application starts and restores it on exit, so that any output
+visible before the application starts reappears unchanged after it exits.
+The default is on.
+.Pp
+.It Xo Ic automatic-rename
+.Op Ic on | off
+.Xc
+Control automatic window renaming.
+When this setting is enabled,
+.Nm
+will attempt - on supported platforms - to rename the window to reflect the
+command currently running in it.
+This flag is automatically disabled for an individual window when a name
+is specified at creation with
+.Ic new-window
+or
+.Ic new-session ,
+or later with
+.Ic rename-window ,
+or with a terminal escape sequence.
+It may be switched off globally with:
+.Bd -literal -offset indent
+set-window-option -g automatic-rename off
+.Ed
+.Pp
+.It Ic c0-change-interval Ar interval
+.It Ic c0-change-trigger Ar trigger
+These two options configure a simple form of rate limiting for a pane.
+If
+.Nm
+sees more than
+.Ar trigger
+C0 sequences that modify the screen (for example, carriage returns, linefeeds
+or backspaces) in one millisecond, it will stop updating the pane immediately and
+instead redraw it entirely every
+.Ar interval
+milliseconds.
+This helps to prevent fast output (such as
+.Xr yes 1
+overwhelming the terminal).
+The default is a trigger of 250 and an interval of 100.
+A trigger of zero disables the rate limiting.
+.Pp
+.It Ic clock-mode-colour Ar colour
+Set clock colour.
+.Pp
+.It Xo Ic clock-mode-style
+.Op Ic 12 | 24
+.Xc
+Set clock hour format.
+.Pp
+.It Ic force-height Ar height
+.It Ic force-width Ar width
+Prevent
+.Nm
+from resizing a window to greater than
+.Ar width
+or
+.Ar height .
+A value of zero restores the default unlimited setting.
+.Pp
+.It Ic main-pane-height Ar height
+.It Ic main-pane-width Ar width
+Set the width or height of the main (left or top) pane in the
+.Ic main-horizontal
+or
+.Ic main-vertical
+layouts.
+.Pp
+.It Ic mode-attr Ar attributes
+Set window modes attributes.
+.Pp
+.It Ic mode-bg Ar colour
+Set window modes background colour.
+.Pp
+.It Ic mode-fg Ar colour
+Set window modes foreground colour.
+.Pp
+.It Xo Ic mode-keys
+.Op Ic vi | emacs
+.Xc
+Use vi or emacs-style key bindings in copy and choice modes.
+As with the
+.Ic status-keys
+option, the default is emacs, unless
+.Ev VISUAL
+or
+.Ev EDITOR
+contains
+.Ql vi .
+.Pp
+.It Xo Ic mode-mouse
+.Op Ic on | off | copy-mode
+.Xc
+Mouse state in modes.
+If on, the mouse may be used to enter copy mode and copy a selection by
+dragging, to enter copy mode and scroll with the mouse wheel, or to select an
+option in choice mode.
+If set to
+.Em copy-mode ,
+the mouse behaves as set to on, but cannot be used to enter copy
+mode.
+.Pp
+.It Xo Ic monitor-activity
+.Op Ic on | off
+.Xc
+Monitor for activity in the window.
+Windows with activity are highlighted in the status line.
+.Pp
+.It Ic monitor-content Ar match-string
+Monitor content in the window.
+When
+.Xr fnmatch 3
+pattern
+.Ar match-string
+appears in the window, it is highlighted in the status line.
+.Pp
+.It Xo Ic monitor-silence
+.Op Ic interval
+.Xc
+Monitor for silence (no activity) in the window within
+.Ic interval
+seconds.
+Windows that have been silent for the interval are highlighted in the
+status line.
+An interval of zero disables the monitoring.
+.Pp
+.It Ic other-pane-height Ar height
+Set the height of the other panes (not the main pane) in the
+.Ic main-horizontal
+layout.
+If this option is set to 0 (the default), it will have no effect.
+If both the
+.Ic main-pane-height
+and
+.Ic other-pane-height
+options are set, the main pane will grow taller to make the other panes the
+specified height, but will never shrink to do so.
+.Pp
+.It Ic other-pane-width Ar width
+Like
+.Ic other-pane-height ,
+but set the width of other panes in the
+.Ic main-vertical
+layout.
+.Pp
+.It Ic pane-base-index Ar index
+Like
+.Ic base-index ,
+but set the starting index for pane numbers.
+.Pp
+.It Xo Ic remain-on-exit
+.Op Ic on | off
+.Xc
+A window with this flag set is not destroyed when the program running in it
+exits.
+The window may be reactivated with the
+.Ic respawn-window
+command.
+.Pp
+.It Xo Ic synchronize-panes
+.Op Ic on | off
+.Xc
+Duplicate input to any pane to all other panes in the same window (only
+for panes that are not in any special mode).
+.Pp
+.It Xo Ic utf8
+.Op Ic on | off
+.Xc
+Instructs
+.Nm
+to expect UTF-8 sequences to appear in this window.
+.Pp
+.It Ic window-status-bell-attr Ar attributes
+Set status line attributes for windows which have a bell alert.
+.Pp
+.It Ic window-status-bell-bg Ar colour
+Set status line background colour for windows with a bell alert.
+.Pp
+.It Ic window-status-bell-fg Ar colour
+Set status line foreground colour for windows with a bell alert.
+.Pp
+.It Ic window-status-content-attr Ar attributes
+Set status line attributes for windows which have a content alert.
+.Pp
+.It Ic window-status-content-bg Ar colour
+Set status line background colour for windows with a content alert.
+.Pp
+.It Ic window-status-content-fg Ar colour
+Set status line foreground colour for windows with a content alert.
+.Pp
+.It Ic window-status-activity-attr Ar attributes
+Set status line attributes for windows which have an activity (or silence) alert.
+.Pp
+.It Ic window-status-activity-bg Ar colour
+Set status line background colour for windows with an activity alert.
+.Pp
+.It Ic window-status-activity-fg Ar colour
+Set status line foreground colour for windows with an activity alert.
+.Pp
+.It Ic window-status-attr Ar attributes
+Set status line attributes for a single window.
+.Pp
+.It Ic window-status-bg Ar colour
+Set status line background colour for a single window.
+.Pp
+.It Ic window-status-current-attr Ar attributes
+Set status line attributes for the currently active window.
+.Pp
+.It Ic window-status-current-bg Ar colour
+Set status line background colour for the currently active window.
+.Pp
+.It Ic window-status-current-fg Ar colour
+Set status line foreground colour for the currently active window.
+.Pp
+.It Ic window-status-current-format Ar string
+Like
+.Ar window-status-format ,
+but is the format used when the window is the current window.
+.Pp
+.It Ic window-status-last-attr Ar attributes
+Set status line attributes for the last active window.
+.Pp
+.It Ic window-status-last-bg Ar colour
+Set status line background colour for the last active window.
+.Pp
+.It Ic window-status-last-fg Ar colour
+Set status line foreground colour for the last active window.
+.Pp
+.It Ic window-status-fg Ar colour
+Set status line foreground colour for a single window.
+.Pp
+.It Ic window-status-format Ar string
+Set the format in which the window is displayed in the status line window list.
+See the
+.Ar status-left
+option for details of special character sequences available.
+The default is
+.Ql #I:#W#F .
+.Pp
+.It Ic window-status-separator Ar string
+Sets the separator drawn between windows in the status line.
+The default is a single space character.
+.Pp
+.It Xo Ic xterm-keys
+.Op Ic on | off
+.Xc
+If this option is set,
+.Nm
+will generate
+.Xr xterm 1 -style
+function key sequences; these have a number included to indicate modifiers such
+as Shift, Alt or Ctrl.
+The default is off.
+.Pp
+.It Xo Ic wrap-search
+.Op Ic on | off
+.Xc
+If this option is set, searches will wrap around the end of the pane contents.
+The default is on.
+.El
+.It Xo Ic show-options
+.Op Fl gqsvw
+.Op Fl t Ar target-session | Ar target-window
+.Op Ar option
+.Xc
+.D1 (alias: Ic show )
+Show the window options (or a single window option if given) with
+.Fl w
+(equivalent to
+.Ic show-window-options ) ,
+the server options with
+.Fl s ,
+otherwise the session options for
+.Ar target session .
+Global session or window options are listed if
+.Fl g
+is used.
+.Fl v
+shows only the option value, not the name.
+If
+.Fl q
+is set, no error will be returned if
+.Ar option
+is unset.
+.It Xo Ic show-window-options
+.Op Fl gv
+.Op Fl t Ar target-window
+.Op Ar option
+.Xc
+.D1 (alias: Ic showw )
+List the window options or a single option for
+.Ar target-window ,
+or the global window options if
+.Fl g
+is used.
+.Fl v
+shows only the option value, not the name.
+.El
+.Sh FORMATS
+Certain commands accept the
+.Fl F
+flag with a
+.Ar format
+argument.
+This is a string which controls the output format of the command.
+Special character sequences are replaced as documented under the
+.Ic status-left
+option and an additional long form is accepted.
+Replacement variables are enclosed in
+.Ql #{
+and
+.Ql } ,
+for example
+.Ql #{session_name}
+is equivalent to
+.Ql #S .
+Conditionals are also accepted by prefixing with
+.Ql \&?
+and separating two alternatives with a comma;
+if the specified variable exists and is not zero, the first alternative
+is chosen, otherwise the second is used.
+For example
+.Ql #{?session_attached,attached,not attached}
+will include the string
+.Ql attached
+if the session is attached and the string
+.Ql not attached
+if it is unattached.
+.Pp
+The following variables are available, where appropriate:
+.Bl -column "session_created_string" "Replaced with" -offset indent
+.It Sy "Variable name" Ta Sy "Replaced with"
+.It Li "alternate_on" Ta "If pane is in alternate screen"
+.It Li "alternate_saved_x" Ta "Saved cursor X in alternate screen"
+.It Li "alternate_saved_y" Ta "Saved cursor Y in alternate screen"
+.It Li "buffer_sample" Ta "First 50 characters from the specified buffer"
+.It Li "buffer_size" Ta "Size of the specified buffer in bytes"
+.It Li "client_activity" Ta "Integer time client last had activity"
+.It Li "client_activity_string" Ta "String time client last had activity"
+.It Li "client_created" Ta "Integer time client created"
+.It Li "client_created_string" Ta "String time client created"
+.It Li "client_cwd" Ta "Working directory of client"
+.It Li "client_height" Ta "Height of client"
+.It Li "client_last_session" Ta "Name of the client's last session"
+.It Li "client_prefix" Ta "1 if prefix key has been pressed"
+.It Li "client_readonly" Ta "1 if client is readonly"
+.It Li "client_session" Ta "Name of the client's session"
+.It Li "client_termname" Ta "Terminal name of client"
+.It Li "client_tty" Ta "Pseudo terminal of client"
+.It Li "client_utf8" Ta "1 if client supports utf8"
+.It Li "client_width" Ta "Width of client"
+.It Li "cursor_flag" Ta "Pane cursor flag"
+.It Li "cursor_x" Ta "Cursor X position in pane"
+.It Li "cursor_y" Ta "Cursor Y position in pane"
+.It Li "history_bytes" Ta "Number of bytes in window history"
+.It Li "history_limit" Ta "Maximum window history lines"
+.It Li "history_size" Ta "Size of history in bytes"
+.It Li "host" Ta "Hostname of local host"
+.It Li "insert_flag" Ta "Pane insert flag"
+.It Li "keypad_cursor_flag" Ta "Pane keypad cursor flag"
+.It Li "keypad_flag" Ta "Pane keypad flag"
+.It Li "line" Ta "Line number in the list"
+.It Li "mouse_any_flag" Ta "Pane mouse any flag"
+.It Li "mouse_button_flag" Ta "Pane mouse button flag"
+.It Li "mouse_standard_flag" Ta "Pane mouse standard flag"
+.It Li "mouse_utf8_flag" Ta "Pane mouse UTF-8 flag"
+.It Li "pane_active" Ta "1 if active pane"
+.It Li "pane_current_command" Ta "Current command if available"
+.It Li "pane_current_path" Ta "Current path if available"
+.It Li "pane_dead" Ta "1 if pane is dead"
+.It Li "pane_height" Ta "Height of pane"
+.It Li "pane_id" Ta "Unique pane ID"
+.It Li "pane_in_mode" Ta "If pane is in a mode"
+.It Li "pane_index" Ta "Index of pane"
+.It Li "pane_pid" Ta "PID of first process in pane"
+.It Li "pane_start_command" Ta "Command pane started with"
+.It Li "pane_start_path" Ta "Path pane started with"
+.It Li "pane_tabs" Ta "Pane tab positions"
+.It Li "pane_title" Ta "Title of pane"
+.It Li "pane_tty" Ta "Pseudo terminal of pane"
+.It Li "pane_width" Ta "Width of pane"
+.It Li "saved_cursor_x" Ta "Saved cursor X in pane"
+.It Li "saved_cursor_y" Ta "Saved cursor Y in pane"
+.It Li "scroll_region_lower" Ta "Bottom of scroll region in pane"
+.It Li "scroll_region_upper" Ta "Top of scroll region in pane"
+.It Li "session_attached" Ta "1 if session attached"
+.It Li "session_created" Ta "Integer time session created"
+.It Li "session_created_string" Ta "String time session created"
+.It Li "session_group" Ta "Number of session group"
+.It Li "session_grouped" Ta "1 if session in a group"
+.It Li "session_height" Ta "Height of session"
+.It Li "session_id" Ta "Unique session ID"
+.It Li "session_name" Ta "Name of session"
+.It Li "session_width" Ta "Width of session"
+.It Li "session_windows" Ta "Number of windows in session"
+.It Li "window_active" Ta "1 if window active"
+.It Li "window_find_matches" Ta "Matched data from the find-window command if available"
+.It Li "window_flags" Ta "Window flags"
+.It Li "window_height" Ta "Height of window"
+.It Li "window_id" Ta "Unique window ID"
+.It Li "window_index" Ta "Index of window"
+.It Li "window_layout" Ta "Window layout description"
+.It Li "window_name" Ta "Name of window"
+.It Li "window_panes" Ta "Number of panes in window"
+.It Li "window_width" Ta "Width of window"
+.It Li "wrap_flag" Ta "Pane wrap flag"
+.El
+.Sh NAMES AND TITLES
+.Nm
+distinguishes between names and titles.
+Windows and sessions have names, which may be used to specify them in targets
+and are displayed in the status line and various lists: the name is the
+.Nm
+identifier for a window or session.
+Only panes have titles.
+A pane's title is typically set by the program running inside the pane and
+is not modified by
+.Nm .
+It is the same mechanism used to set for example the
+.Xr xterm 1
+window title in an
+.Xr X 7
+window manager.
+Windows themselves do not have titles - a window's title is the title of its
+active pane.
+.Nm
+itself may set the title of the terminal in which the client is running, see
+the
+.Ic set-titles
+option.
+.Pp
+A session's name is set with the
+.Ic new-session
+and
+.Ic rename-session
+commands.
+A window's name is set with one of:
+.Bl -enum -width Ds
+.It
+A command argument (such as
+.Fl n
+for
+.Ic new-window
+or
+.Ic new-session ) .
+.It
+An escape sequence:
+.Bd -literal -offset indent
+$ printf '\e033kWINDOW_NAME\e033\e\e'
+.Ed
+.It
+Automatic renaming, which sets the name to the active command in the window's
+active pane.
+See the
+.Ic automatic-rename
+option.
+.El
+.Pp
+When a pane is first created, its title is the hostname.
+A pane's title can be set via the OSC title setting sequence, for example:
+.Bd -literal -offset indent
+$ printf '\e033]2;My Title\e033\e\e'
+.Ed
+.Sh ENVIRONMENT
+When the server is started,
+.Nm
+copies the environment into the
+.Em global environment ;
+in addition, each session has a
+.Em session environment .
+When a window is created, the session and global environments are merged.
+If a variable exists in both, the value from the session environment is used.
+The result is the initial environment passed to the new process.
+.Pp
+The
+.Ic update-environment
+session option may be used to update the session environment from the client
+when a new session is created or an old reattached.
+.Nm
+also initialises the
+.Ev TMUX
+variable with some internal information to allow commands to be executed
+from inside, and the
+.Ev TERM
+variable with the correct terminal setting of
+.Ql screen .
+.Pp
+Commands to alter and view the environment are:
+.Bl -tag -width Ds
+.It Xo Ic set-environment
+.Op Fl gru
+.Op Fl t Ar target-session
+.Ar name Op Ar value
+.Xc
+.D1 (alias: Ic setenv )
+Set or unset an environment variable.
+If
+.Fl g
+is used, the change is made in the global environment; otherwise, it is applied
+to the session environment for
+.Ar target-session .
+The
+.Fl u
+flag unsets a variable.
+.Fl r
+indicates the variable is to be removed from the environment before starting a
+new process.
+.It Xo Ic show-environment
+.Op Fl g
+.Op Fl t Ar target-session
+.Op Ar variable
+.Xc
+.D1 (alias: Ic showenv )
+Display the environment for
+.Ar target-session
+or the global environment with
+.Fl g .
+If
+.Ar variable
+is omitted, all variables are shown.
+Variables removed from the environment are prefixed with
+.Ql - .
+.El
+.Sh STATUS LINE
+.Nm
+includes an optional status line which is displayed in the bottom line of each
+terminal.
+By default, the status line is enabled (it may be disabled with the
+.Ic status
+session option) and contains, from left-to-right: the name of the current
+session in square brackets; the window list; the title of the active pane
+in double quotes; and the time and date.
+.Pp
+The status line is made of three parts: configurable left and right sections
+(which may contain dynamic content such as the time or output from a shell
+command, see the
+.Ic status-left ,
+.Ic status-left-length ,
+.Ic status-right ,
+and
+.Ic status-right-length
+options below), and a central window list.
+By default, the window list shows the index, name and (if any) flag of the
+windows present in the current session in ascending numerical order.
+It may be customised with the
+.Ar window-status-format
+and
+.Ar window-status-current-format
+options.
+The flag is one of the following symbols appended to the window name:
+.Bl -column "Symbol" "Meaning" -offset indent
+.It Sy "Symbol" Ta Sy "Meaning"
+.It Li "*" Ta "Denotes the current window."
+.It Li "-" Ta "Marks the last window (previously selected)."
+.It Li "#" Ta "Window is monitored and activity has been detected."
+.It Li "!" Ta "A bell has occurred in the window."
+.It Li "+" Ta "Window is monitored for content and it has appeared."
+.It Li "~" Ta "The window has been silent for the monitor-silence interval."
+.It Li "Z" Ta "The window's active pane is zoomed."
+.El
+.Pp
+The # symbol relates to the
+.Ic monitor-activity
+and + to the
+.Ic monitor-content
+window options.
+The window name is printed in inverted colours if an alert (bell, activity or
+content) is present.
+.Pp
+The colour and attributes of the status line may be configured, the entire
+status line using the
+.Ic status-attr ,
+.Ic status-fg
+and
+.Ic status-bg
+session options and individual windows using the
+.Ic window-status-attr ,
+.Ic window-status-fg
+and
+.Ic window-status-bg
+window options.
+.Pp
+The status line is automatically refreshed at interval if it has changed, the
+interval may be controlled with the
+.Ic status-interval
+session option.
+.Pp
+Commands related to the status line are as follows:
+.Bl -tag -width Ds
+.It Xo Ic command-prompt
+.Op Fl I Ar inputs
+.Op Fl p Ar prompts
+.Op Fl t Ar target-client
+.Op Ar template
+.Xc
+Open the command prompt in a client.
+This may be used from inside
+.Nm
+to execute commands interactively.
+.Pp
+If
+.Ar template
+is specified, it is used as the command.
+If present,
+.Fl I
+is a comma-separated list of the initial text for each prompt.
+If
+.Fl p
+is given,
+.Ar prompts
+is a comma-separated list of prompts which are displayed in order; otherwise
+a single prompt is displayed, constructed from
+.Ar template
+if it is present, or
+.Ql \&:
+if not.
+.Pp
+Both
+.Ar inputs
+and
+.Ar prompts
+may contain the special character sequences supported by the
+.Ic status-left
+option.
+.Pp
+Before the command is executed, the first occurrence of the string
+.Ql %%
+and all occurrences of
+.Ql %1
+are replaced by the response to the first prompt, the second
+.Ql %%
+and all
+.Ql %2
+are replaced with the response to the second prompt, and so on for further
+prompts.
+Up to nine prompt responses may be replaced
+.Po
+.Ql %1
+to
+.Ql %9
+.Pc .
+.It Xo Ic confirm-before
+.Op Fl p Ar prompt
+.Op Fl t Ar target-client
+.Ar command
+.Xc
+.D1 (alias: Ic confirm )
+Ask for confirmation before executing
+.Ar command .
+If
+.Fl p
+is given,
+.Ar prompt
+is the prompt to display; otherwise a prompt is constructed from
+.Ar command .
+It may contain the special character sequences supported by the
+.Ic status-left
+option.
+.Pp
+This command works only from inside
+.Nm .
+.It Xo Ic display-message
+.Op Fl p
+.Op Fl c Ar target-client
+.Op Fl t Ar target-pane
+.Op Ar message
+.Xc
+.D1 (alias: Ic display )
+Display a message.
+If
+.Fl p
+is given, the output is printed to stdout, otherwise it is displayed in the
+.Ar target-client
+status line.
+The format of
+.Ar message
+is described in the
+.Sx FORMATS
+section; information is taken from
+.Ar target-pane
+if
+.Fl t
+is given, otherwise the active pane for the session attached to
+.Ar target-client .
+.El
+.Sh BUFFERS
+.Nm
+maintains a stack of
+.Em paste buffers .
+Up to the value of the
+.Ic buffer-limit
+option are kept; when a new buffer is added, the buffer at the bottom of the
+stack is removed.
+Buffers may be added using
+.Ic copy-mode
+or the
+.Ic set-buffer
+command, and pasted into a window using the
+.Ic paste-buffer
+command.
+.Pp
+A configurable history buffer is also maintained for each window.
+By default, up to 2000 lines are kept; this can be altered with the
+.Ic history-limit
+option (see the
+.Ic set-option
+command above).
+.Pp
+The buffer commands are as follows:
+.Bl -tag -width Ds
+.It Xo
+.Ic choose-buffer
+.Op Fl F Ar format
+.Op Fl t Ar target-window
+.Op Ar template
+.Xc
+Put a window into buffer choice mode, where a buffer may be chosen
+interactively from a list.
+After a buffer is selected,
+.Ql %%
+is replaced by the buffer index in
+.Ar template
+and the result executed as a command.
+If
+.Ar template
+is not given, "paste-buffer -b '%%'" is used.
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+This command works only if at least one client is attached.
+.It Ic clear-history Op Fl t Ar target-pane
+.D1 (alias: Ic clearhist )
+Remove and free the history for the specified pane.
+.It Ic delete-buffer Op Fl b Ar buffer-index
+.D1 (alias: Ic deleteb )
+Delete the buffer at
+.Ar buffer-index ,
+or the top buffer if not specified.
+.It Xo Ic list-buffers
+.Op Fl F Ar format
+.Xc
+.D1 (alias: Ic lsb )
+List the global buffers.
+For the meaning of the
+.Fl F
+flag, see the
+.Sx FORMATS
+section.
+.It Xo Ic load-buffer
+.Op Fl b Ar buffer-index
+.Ar path
+.Xc
+.D1 (alias: Ic loadb )
+Load the contents of the specified paste buffer from
+.Ar path .
+.It Xo Ic paste-buffer
+.Op Fl dpr
+.Op Fl b Ar buffer-index
+.Op Fl s Ar separator
+.Op Fl t Ar target-pane
+.Xc
+.D1 (alias: Ic pasteb )
+Insert the contents of a paste buffer into the specified pane.
+If not specified, paste into the current one.
+With
+.Fl d ,
+also delete the paste buffer from the stack.
+When output, any linefeed (LF) characters in the paste buffer are replaced with
+a separator, by default carriage return (CR).
+A custom separator may be specified using the
+.Fl s
+flag.
+The
+.Fl r
+flag means to do no replacement (equivalent to a separator of LF).
+If
+.Fl p
+is specified, paste bracket control codes are inserted around the
+buffer if the application has requested bracketed paste mode.
+.It Xo Ic save-buffer
+.Op Fl a
+.Op Fl b Ar buffer-index
+.Ar path
+.Xc
+.D1 (alias: Ic saveb )
+Save the contents of the specified paste buffer to
+.Ar path .
+The
+.Fl a
+option appends to rather than overwriting the file.
+.It Xo Ic set-buffer
+.Op Fl b Ar buffer-index
+.Ar data
+.Xc
+.D1 (alias: Ic setb )
+Set the contents of the specified buffer to
+.Ar data .
+.It Xo Ic show-buffer
+.Op Fl b Ar buffer-index
+.Xc
+.D1 (alias: Ic showb )
+Display the contents of the specified buffer.
+.El
+.Sh MISCELLANEOUS
+Miscellaneous commands are as follows:
+.Bl -tag -width Ds
+.It Ic clock-mode Op Fl t Ar target-pane
+Display a large clock.
+.It Xo Ic if-shell
+.Op Fl b
+.Op Fl t Ar target-pane
+.Ar shell-command command
+.Op Ar command
+.Xc
+.D1 (alias: Ic if )
+Execute the first
+.Ar command
+if
+.Ar shell-command
+returns success or the second
+.Ar command
+otherwise.
+Before being executed, shell-command is expanded using the rules specified in the
+.Sx FORMATS
+section, including those relevant to
+.Ar target-pane .
+With
+.Fl b ,
+.Ar shell-command
+is run in the background.
+.It Ic lock-server
+.D1 (alias: Ic lock )
+Lock each client individually by running the command specified by the
+.Ic lock-command
+option.
+.It Xo Ic run-shell
+.Fl b
+.Op Fl t Ar target-pane
+.Ar shell-command
+.Xc
+.D1 (alias: Ic run )
+Execute
+.Ar shell-command
+in the background without creating a window.
+Before being executed, shell-command is expanded using the rules specified in
+the
+.Sx FORMATS
+section.
+With
+.Fl b ,
+the command is run in the background.
+After it finishes, any output to stdout is displayed in copy mode (in the pane
+specified by
+.Fl t
+or the current pane if omitted).
+If the command doesn't return success, the exit status is also displayed.
+.It Ic server-info
+.D1 (alias: Ic info )
+Show server information and terminal details.
+.It Xo Ic wait-for
+.Fl LSU
+.Ar channel
+.Xc
+.D1 (alias: Ic wait )
+When used without options, prevents the client from exiting until woken using
+.Ic wait-for
+.Fl S
+with the same channel.
+When
+.Fl L
+is used, the channel is locked and any clients that try to lock the same
+channel are made to wait until the channel is unlocked with
+.Ic wait-for
+.Fl U .
+This command only works from outside
+.Nm .
+.El
+.Sh TERMINFO EXTENSIONS
+.Nm
+understands some extensions to
+.Xr terminfo 5 :
+.Bl -tag -width Ds
+.It Em Cc , Cr
+Set the cursor colour.
+The first takes a single string argument and is used to set the colour;
+the second takes no arguments and restores the default cursor colour.
+If set, a sequence such as this may be used
+to change the cursor colour from inside
+.Nm :
+.Bd -literal -offset indent
+$ printf '\e033]12;red\e033\e\e'
+.Ed
+.It Em Cs , Csr
+Change the cursor style.
+If set, a sequence such as this may be used
+to change the cursor to an underline:
+.Bd -literal -offset indent
+$ printf '\e033[4 q'
+.Ed
+.Pp
+If
+.Em Csr
+is set, it will be used to reset the cursor style instead
+of
+.Em Cs .
+.It Em \&Ms
+This sequence can be used by
+.Nm
+to store the current buffer in the host terminal's selection (clipboard).
+See the
+.Em set-clipboard
+option above and the
+.Xr xterm 1
+man page.
+.El
+.Sh CONTROL MODE
+.Nm
+offers a textual interface called
+.Em control mode .
+This allows applications to communicate with
+.Nm
+using a simple text-only protocol.
+.Pp
+In control mode, a client sends
+.Nm
+commands or command sequences terminated by newlines on standard input.
+Each command will produce one block of output on standard output.
+An output block consists of a
+.Em %begin
+line followed by the output (which may be empty).
+The output block ends with a
+.Em %end
+or
+.Em %error .
+.Em %begin
+and matching
+.Em %end
+or
+.Em %error
+have two arguments: an integer time (as seconds from epoch) and command number.
+For example:
+.Bd -literal -offset indent
+%begin 1363006971 2
+0: ksh* (1 panes) [80x24] [layout b25f,80x24,0,0,2] @2 (active)
+%end 1363006971 2
+.Ed
+.Pp
+In control mode,
+.Nm
+outputs notifications.
+A notification will never occur inside an output block.
+.Pp
+The following notifications are defined:
+.Bl -tag -width Ds
+.It Ic %exit Op Ar reason
+The
+.Nm
+client is exiting immediately, either because it is not attached to any session
+or an error occurred.
+If present,
+.Ar reason
+describes why the client exited.
+.It Ic %layout-change Ar window-id Ar window-layout
+The layout of a window with ID
+.Ar window-id
+changed.
+The new layout is
+.Ar window-layout .
+.It Ic %output Ar pane-id Ar value
+A window pane produced output.
+.Ar value
+escapes non-printable characters and backslash as octal \\xxx.
+.It Ic %session-changed Ar session-id Ar name
+The client is now attached to the session with ID
+.Ar session-id ,
+which is named
+.Ar name .
+.It Ic %session-renamed Ar name
+The current session was renamed to
+.Ar name .
+.It Ic %sessions-changed
+A session was created or destroyed.
+.It Ic %unlinked-window-add Ar window-id
+The window with ID
+.Ar window-id
+was created but is not linked to the current session.
+.It Ic %window-add Ar window-id
+The window with ID
+.Ar window-id
+was linked to the current session.
+.It Ic %window-close Ar window-id
+The window with ID
+.Ar window-id
+closed.
+.It Ic %window-renamed Ar window-id Ar name
+The window with ID
+.Ar window-id
+was renamed to
+.Ar name .
+.El
+.Sh FILES
+.Bl -tag -width "/etc/tmux.confXXX" -compact
+.It Pa ~/.tmux.conf
+Default
+.Nm
+configuration file.
+.It Pa /etc/tmux.conf
+System-wide configuration file.
+.El
+.Sh EXAMPLES
+To create a new
+.Nm
+session running
+.Xr vi 1 :
+.Pp
+.Dl $ tmux new-session vi
+.Pp
+Most commands have a shorter form, known as an alias.
+For new-session, this is
+.Ic new :
+.Pp
+.Dl $ tmux new vi
+.Pp
+Alternatively, the shortest unambiguous form of a command is accepted.
+If there are several options, they are listed:
+.Bd -literal -offset indent
+$ tmux n
+ambiguous command: n, could be: new-session, new-window, next-window
+.Ed
+.Pp
+Within an active session, a new window may be created by typing
+.Ql C-b c
+(Ctrl
+followed by the
+.Ql b
+key
+followed by the
+.Ql c
+key).
+.Pp
+Windows may be navigated with:
+.Ql C-b 0
+(to select window 0),
+.Ql C-b 1
+(to select window 1), and so on;
+.Ql C-b n
+to select the next window; and
+.Ql C-b p
+to select the previous window.
+.Pp
+A session may be detached using
+.Ql C-b d
+(or by an external event such as
+.Xr ssh 1
+disconnection) and reattached with:
+.Pp
+.Dl $ tmux attach-session
+.Pp
+Typing
+.Ql C-b \&?
+lists the current key bindings in the current window; up and down may be used
+to navigate the list or
+.Ql q
+to exit from it.
+.Pp
+Commands to be run when the
+.Nm
+server is started may be placed in the
+.Pa ~/.tmux.conf
+configuration file.
+Common examples include:
+.Pp
+Changing the default prefix key:
+.Bd -literal -offset indent
+set-option -g prefix C-a
+unbind-key C-b
+bind-key C-a send-prefix
+.Ed
+.Pp
+Turning the status line off, or changing its colour:
+.Bd -literal -offset indent
+set-option -g status off
+set-option -g status-bg blue
+.Ed
+.Pp
+Setting other options, such as the default command,
+or locking after 30 minutes of inactivity:
+.Bd -literal -offset indent
+set-option -g default-command "exec /bin/ksh"
+set-option -g lock-after-time 1800
+.Ed
+.Pp
+Creating new key bindings:
+.Bd -literal -offset indent
+bind-key b set-option status
+bind-key / command-prompt "split-window 'exec man %%'"
+bind-key S command-prompt "new-window -n %1 'ssh %1'"
+.Ed
+.Sh SEE ALSO
+.Xr pty 4
+.Sh AUTHORS
+.An Nicholas Marriott Aq nicm@users.sourceforge.net
diff --git a/tmux.h b/tmux.h
deleted file mode 100644
index f0b9edf..0000000
--- a/tmux.h
+++ /dev/null
@@ -1,2352 +0,0 @@
-/* $Id$ */
-
-/*
- * Copyright (c) 2007 Nicholas Marriott <nicm@users.sourceforge.net>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
- * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
- * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef TMUX_H
-#define TMUX_H
-
-#define PROTOCOL_VERSION 7
-
-#include <sys/param.h>
-#include <sys/time.h>
-#include <sys/uio.h>
-
-#include <event.h>
-#include <limits.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <termios.h>
-
-#include "array.h"
-
-#include "compat.h"
-
-extern char    *__progname;
-extern char   **environ;
-
-/* Default configuration files. */
-#define DEFAULT_CFG ".tmux.conf"
-#define SYSTEM_CFG "/etc/tmux.conf"
-
-/* Default prompt history length. */
-#define PROMPT_HISTORY 100
-
-/*
- * Minimum layout cell size, NOT including separator line. The scroll region
- * cannot be one line in height so this must be at least two.
- */
-#define PANE_MINIMUM 2
-
-/* Automatic name refresh interval, in milliseconds. */
-#define NAME_INTERVAL 500
-
-/*
- * Maximum sizes of strings in message data. Don't forget to bump
- * PROTOCOL_VERSION if any of these change!
- */
-#define COMMAND_LENGTH 2048	/* packed argv size */
-#define TERMINAL_LENGTH 128	/* length of TERM environment variable */
-#define ENVIRON_LENGTH 1024	/* environment variable length */
-
-/*
- * UTF-8 data size. This must be big enough to hold combined characters as well
- * as single.
- */
-#define UTF8_SIZE 9
-
-/* Fatal errors. */
-#define fatal(msg) log_fatal("%s: %s", __func__, msg);
-#define fatalx(msg) log_fatalx("%s: %s", __func__, msg);
-
-/* Definition to shut gcc up about unused arguments. */
-#define unused __attribute__ ((unused))
-
-/* Attribute to make gcc check printf-like arguments. */
-#define printflike1 __attribute__ ((format (printf, 1, 2)))
-#define printflike2 __attribute__ ((format (printf, 2, 3)))
-#define printflike3 __attribute__ ((format (printf, 3, 4)))
-#define printflike4 __attribute__ ((format (printf, 4, 5)))
-#define printflike5 __attribute__ ((format (printf, 5, 6)))
-
-/* Number of items in array. */
-#ifndef nitems
-#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
-#endif
-
-/* Default template for choose-buffer. */
-#define CHOOSE_BUFFER_TEMPLATE					\
-	"#{line}: #{buffer_size} bytes: \"#{buffer_sample}\""
-
-/* Default template for choose-client. */
-#define CHOOSE_CLIENT_TEMPLATE					\
-	"#{client_tty}: #{session_name} "			\
-	"[#{client_width}x#{client_height} #{client_termname}]"	\
-	"#{?client_utf8, (utf8),}#{?client_readonly, (ro),} "	\
-	"(last used #{client_activity_string})"
-
-/* Default templates for choose-tree. */
-#define CHOOSE_TREE_SESSION_TEMPLATE				\
-	"#{session_name}: #{session_windows} windows"		\
-	"#{?session_grouped, (group ,}"				\
-	"#{session_group}#{?session_grouped,),}"		\
-	"#{?session_attached, (attached),}"
-#define CHOOSE_TREE_WINDOW_TEMPLATE				\
-	"#{window_index}: #{window_name}#{window_flags} "	\
-	"\"#{pane_title}\""
-
-/* Default template for display-message. */
-#define DISPLAY_MESSAGE_TEMPLATE				\
-	"[#{session_name}] #{window_index}:"			\
-	"#{window_name}, current pane #{pane_index} "		\
-	"- (%H:%M %d-%b-%y)"
-
-/* Default template for find-window. */
-#define FIND_WINDOW_TEMPLATE					\
-	"#{window_index}: #{window_name} "			\
-	"[#{window_width}x#{window_height}] "			\
-	"(#{window_panes} panes) #{window_find_matches}"
-
-/* Default template for list-buffers. */
-#define LIST_BUFFERS_TEMPLATE					\
-	"#{line}: #{buffer_size} bytes: \"#{buffer_sample}\""
-
-/* Default template for list-clients. */
-#define LIST_CLIENTS_TEMPLATE					\
-	"#{client_tty}: #{session_name} "			\
-	"[#{client_width}x#{client_height} #{client_termname}]"	\
-	"#{?client_utf8, (utf8),} #{?client_readonly, (ro),}"
-
-/* Default template for list-sessions. */
-#define LIST_SESSIONS_TEMPLATE					\
-	"#{session_name}: #{session_windows} windows "		\
-	"(created #{session_created_string}) "			\
-	"[#{session_width}x#{session_height}]"			\
-	"#{?session_grouped, (group ,}"				\
-	"#{session_group}#{?session_grouped,),}"		\
-	"#{?session_attached, (attached),}"
-
-/* Default templates for list-windows. */
-#define LIST_WINDOWS_TEMPLATE					\
-	"#{window_index}: #{window_name}#{window_flags} "	\
-	"(#{window_panes} panes) "				\
-	"[#{window_width}x#{window_height}] "			\
-	"[layout #{window_layout}] #{window_id}"		\
-	"#{?window_active, (active),}";
-#define LIST_WINDOWS_WITH_SESSION_TEMPLATE			\
-	"#{session_name}: "					\
-	"#{window_index}: #{window_name}#{window_flags} "	\
-	"(#{window_panes} panes) "				\
-	"[#{window_width}x#{window_height}] "
-
-/* Default templates for break-pane, new-window and split-window. */
-#define BREAK_PANE_TEMPLATE "#{session_name}:#{window_index}.#{pane_index}"
-#define NEW_SESSION_TEMPLATE "#{session_name}:"
-#define NEW_WINDOW_TEMPLATE BREAK_PANE_TEMPLATE
-#define SPLIT_WINDOW_TEMPLATE BREAK_PANE_TEMPLATE
-
-/* Bell option values. */
-#define BELL_NONE 0
-#define BELL_ANY 1
-#define BELL_CURRENT 2
-
-/* Special key codes. */
-#define KEYC_NONE 0xfff
-#define KEYC_BASE 0x1000
-
-/* Key modifier bits. */
-#define KEYC_ESCAPE 0x2000
-#define KEYC_CTRL 0x4000
-#define KEYC_SHIFT 0x8000
-#define KEYC_PREFIX 0x10000
-
-/* Mask to obtain key w/o modifiers. */
-#define KEYC_MASK_MOD (KEYC_ESCAPE|KEYC_CTRL|KEYC_SHIFT|KEYC_PREFIX)
-#define KEYC_MASK_KEY (~KEYC_MASK_MOD)
-
-/* Other key codes. */
-enum key_code {
-	/* Mouse key. */
-	KEYC_MOUSE = KEYC_BASE,
-
-	/* Backspace key. */
-	KEYC_BSPACE,
-
-	/* Function keys. */
-	KEYC_F1,
-	KEYC_F2,
-	KEYC_F3,
-	KEYC_F4,
-	KEYC_F5,
-	KEYC_F6,
-	KEYC_F7,
-	KEYC_F8,
-	KEYC_F9,
-	KEYC_F10,
-	KEYC_F11,
-	KEYC_F12,
-	KEYC_F13,
-	KEYC_F14,
-	KEYC_F15,
-	KEYC_F16,
-	KEYC_F17,
-	KEYC_F18,
-	KEYC_F19,
-	KEYC_F20,
-	KEYC_IC,
-	KEYC_DC,
-	KEYC_HOME,
-	KEYC_END,
-	KEYC_NPAGE,
-	KEYC_PPAGE,
-	KEYC_BTAB,
-
-	/* Arrow keys. */
-	KEYC_UP,
-	KEYC_DOWN,
-	KEYC_LEFT,
-	KEYC_RIGHT,
-
-	/* Numeric keypad. */
-	KEYC_KP_SLASH,
-	KEYC_KP_STAR,
-	KEYC_KP_MINUS,
-	KEYC_KP_SEVEN,
-	KEYC_KP_EIGHT,
-	KEYC_KP_NINE,
-	KEYC_KP_PLUS,
-	KEYC_KP_FOUR,
-	KEYC_KP_FIVE,
-	KEYC_KP_SIX,
-	KEYC_KP_ONE,
-	KEYC_KP_TWO,
-	KEYC_KP_THREE,
-	KEYC_KP_ENTER,
-	KEYC_KP_ZERO,
-	KEYC_KP_PERIOD,
-
-	KEYC_FOCUS_IN,
-	KEYC_FOCUS_OUT,
-};
-
-/* Termcap codes. */
-enum tty_code_code {
-	TTYC_AX = 0,
-	TTYC_ACSC,	/* acs_chars, ac */
-	TTYC_BEL,	/* bell, bl */
-	TTYC_BLINK,	/* enter_blink_mode, mb */
-	TTYC_BOLD,	/* enter_bold_mode, md */
-	TTYC_CC,	/* set colour cursor, Cc */
-	TTYC_CIVIS,	/* cursor_invisible, vi */
-	TTYC_CLEAR,	/* clear_screen, cl */
-	TTYC_CNORM,	/* cursor_normal, ve */
-	TTYC_COLORS,	/* max_colors, Co */
-	TTYC_CR,	/* restore cursor colour, Cr */
-	TTYC_CS1,	/* set cursor style, Cs */
-	TTYC_CSR,	/* change_scroll_region, cs */
-	TTYC_CSR1,	/* reset cursor style, Csr */
-	TTYC_CUB,	/* parm_left_cursor, LE */
-	TTYC_CUB1,	/* cursor_left, le */
-	TTYC_CUD,	/* parm_down_cursor, DO */
-	TTYC_CUD1,	/* cursor_down, do */
-	TTYC_CUF,	/* parm_right_cursor, RI */
-	TTYC_CUF1,	/* cursor_right, nd */
-	TTYC_CUP,	/* cursor_address, cm */
-	TTYC_CUU,	/* parm_up_cursor, UP */
-	TTYC_CUU1,	/* cursor_up, up */
-	TTYC_DCH,	/* parm_dch, DC */
-	TTYC_DCH1,	/* delete_character, dc */
-	TTYC_DIM,	/* enter_dim_mode, mh */
-	TTYC_DL,	/* parm_delete_line, DL */
-	TTYC_DL1,	/* delete_line, dl */
-	TTYC_E3,
-	TTYC_ECH,	/* erase_chars, ec */
-	TTYC_EL,	/* clr_eol, ce */
-	TTYC_EL1,	/* clr_bol, cb */
-	TTYC_ENACS,	/* ena_acs, eA */
-	TTYC_FSL,	/* from_status_line, fsl */
-	TTYC_HOME,	/* cursor_home, ho */
-	TTYC_HPA,	/* column_address, ch */
-	TTYC_ICH,	/* parm_ich, IC */
-	TTYC_ICH1,	/* insert_character, ic */
-	TTYC_IL,	/* parm_insert_line, IL */
-	TTYC_IL1,	/* insert_line, il */
-	TTYC_INVIS,	/* enter_secure_mode, mk */
-	TTYC_IS1,	/* init_1string, i1 */
-	TTYC_IS2,	/* init_2string, i2 */
-	TTYC_IS3,	/* init_3string, i3 */
-	TTYC_KCBT,	/* key_btab, kB */
-	TTYC_KCUB1,	/* key_left, kl */
-	TTYC_KCUD1,	/* key_down, kd */
-	TTYC_KCUF1,	/* key_right, kr */
-	TTYC_KCUU1,	/* key_up, ku */
-	TTYC_KDC2,
-	TTYC_KDC3,
-	TTYC_KDC4,
-	TTYC_KDC5,
-	TTYC_KDC6,
-	TTYC_KDC7,
-	TTYC_KDCH1,	/* key_dc, kD */
-	TTYC_KDN2,
-	TTYC_KDN3,
-	TTYC_KDN4,
-	TTYC_KDN5,
-	TTYC_KDN6,
-	TTYC_KDN7,
-	TTYC_KEND,	/* key_end, ke */
-	TTYC_KEND2,
-	TTYC_KEND3,
-	TTYC_KEND4,
-	TTYC_KEND5,
-	TTYC_KEND6,
-	TTYC_KEND7,
-	TTYC_KF1,	/* key_f1, k1 */
-	TTYC_KF10,	/* key_f10, k; */
-	TTYC_KF11,	/* key_f11, F1 */
-	TTYC_KF12,	/* key_f12, F2 */
-	TTYC_KF13,	/* key_f13, F3 */
-	TTYC_KF14,	/* key_f14, F4 */
-	TTYC_KF15,	/* key_f15, F5 */
-	TTYC_KF16,	/* key_f16, F6 */
-	TTYC_KF17,	/* key_f17, F7 */
-	TTYC_KF18,	/* key_f18, F8 */
-	TTYC_KF19,	/* key_f19, F9 */
-	TTYC_KF2,	/* key_f2, k2 */
-	TTYC_KF20,	/* key_f20, F10 */
-	TTYC_KF3,	/* key_f3, k3 */
-	TTYC_KF4,	/* key_f4, k4 */
-	TTYC_KF5,	/* key_f5, k5 */
-	TTYC_KF6,	/* key_f6, k6 */
-	TTYC_KF7,	/* key_f7, k7 */
-	TTYC_KF8,	/* key_f8, k8 */
-	TTYC_KF9,	/* key_f9, k9 */
-	TTYC_KHOM2,
-	TTYC_KHOM3,
-	TTYC_KHOM4,
-	TTYC_KHOM5,
-	TTYC_KHOM6,
-	TTYC_KHOM7,
-	TTYC_KHOME,	/* key_home, kh */
-	TTYC_KIC2,
-	TTYC_KIC3,
-	TTYC_KIC4,
-	TTYC_KIC5,
-	TTYC_KIC6,
-	TTYC_KIC7,
-	TTYC_KICH1,	/* key_ic, kI */
-	TTYC_KLFT2,
-	TTYC_KLFT3,
-	TTYC_KLFT4,
-	TTYC_KLFT5,
-	TTYC_KLFT6,
-	TTYC_KLFT7,
-	TTYC_KMOUS,	/* key_mouse, Km */
-	TTYC_KNP,	/* key_npage, kN */
-	TTYC_KNXT2,
-	TTYC_KNXT3,
-	TTYC_KNXT4,
-	TTYC_KNXT5,
-	TTYC_KNXT6,
-	TTYC_KNXT7,
-	TTYC_KPP,	/* key_ppage, kP */
-	TTYC_KPRV2,
-	TTYC_KPRV3,
-	TTYC_KPRV4,
-	TTYC_KPRV5,
-	TTYC_KPRV6,
-	TTYC_KPRV7,
-	TTYC_KRIT2,
-	TTYC_KRIT3,
-	TTYC_KRIT4,
-	TTYC_KRIT5,
-	TTYC_KRIT6,
-	TTYC_KRIT7,
-	TTYC_KUP2,
-	TTYC_KUP3,
-	TTYC_KUP4,
-	TTYC_KUP5,
-	TTYC_KUP6,
-	TTYC_KUP7,
-	TTYC_MS,	/* modify xterm(1) selection */
-	TTYC_OP,	/* orig_pair, op */
-	TTYC_REV,	/* enter_reverse_mode, mr */
-	TTYC_RI,	/* scroll_reverse, sr */
-	TTYC_RMACS,	/* exit_alt_charset_mode */
-	TTYC_RMCUP,	/* exit_ca_mode, te */
-	TTYC_RMKX,	/* keypad_local, ke */
-	TTYC_SETAB,	/* set_a_background, AB */
-	TTYC_SETAF,	/* set_a_foreground, AF */
-	TTYC_SGR0,	/* exit_attribute_mode, me */
-	TTYC_SITM,	/* enter_italics_mode, it */
-	TTYC_SMACS,	/* enter_alt_charset_mode, as */
-	TTYC_SMCUP,	/* enter_ca_mode, ti */
-	TTYC_SMKX,	/* keypad_xmit, ks */
-	TTYC_SMSO,	/* enter_standout_mode, so */
-	TTYC_SMUL,	/* enter_underline_mode, us */
-	TTYC_TSL,	/* to_status_line, tsl */
-	TTYC_VPA,	/* row_address, cv */
-	TTYC_XENL,	/* eat_newline_glitch, xn */
-	TTYC_XT,	/* xterm(1)-compatible title, XT */
-};
-#define NTTYCODE (TTYC_XT + 1)
-
-/* Termcap types. */
-enum tty_code_type {
-	TTYCODE_NONE = 0,
-	TTYCODE_STRING,
-	TTYCODE_NUMBER,
-	TTYCODE_FLAG,
-};
-
-/* Termcap code. */
-struct tty_code {
-	enum tty_code_type	type;
-	union {
-		char	       *string;
-		int		number;
-		int		flag;
-	} value;
-};
-
-/* Entry in terminal code table. */
-struct tty_term_code_entry {
-	enum tty_code_code	code;
-	enum tty_code_type	type;
-	const char	       *name;
-};
-
-/* List of error causes. */
-ARRAY_DECL(causelist, char *);
-
-/* Message codes. */
-enum msgtype {
-	MSG_COMMAND,
-	MSG_DETACH,
-	MSG_ERROR,
-	MSG_EXIT,
-	MSG_EXITED,
-	MSG_EXITING,
-	MSG_IDENTIFY,
-	MSG_STDIN,
-	MSG_READY,
-	MSG_RESIZE,
-	MSG_SHUTDOWN,
-	MSG_SUSPEND,
-	MSG_VERSION,
-	MSG_WAKEUP,
-	MSG_ENVIRON,
-	MSG_UNLOCK,
-	MSG_LOCK,
-	MSG_SHELL,
-	MSG_STDERR,
-	MSG_STDOUT,
-	MSG_DETACHKILL
-};
-
-/*
- * Message data.
- *
- * Don't forget to bump PROTOCOL_VERSION if any of these change!
- */
-struct msg_command_data {
-	pid_t		pid;		/* from $TMUX or -1 */
-	int		session_id;	/* from $TMUX or -1 */
-
-	int		argc;
-	char		argv[COMMAND_LENGTH];
-};
-
-struct msg_identify_data {
-	char		cwd[MAXPATHLEN];
-
-	char		term[TERMINAL_LENGTH];
-
-#define IDENTIFY_UTF8 0x1
-#define IDENTIFY_256COLOURS 0x2
-/* 0x4 unused */
-#define IDENTIFY_CONTROL 0x8
-#define IDENTIFY_TERMIOS 0x10
-	int		flags;
-};
-
-struct msg_lock_data {
-	char		cmd[COMMAND_LENGTH];
-};
-
-struct msg_environ_data {
-	char		var[ENVIRON_LENGTH];
-};
-
-struct msg_shell_data {
-	char		shell[MAXPATHLEN];
-};
-
-struct msg_exit_data {
-	int		retcode;
-};
-
-struct msg_stdin_data {
-	ssize_t	size;
-	char	data[BUFSIZ];
-};
-
-struct msg_stdout_data {
-	ssize_t	size;
-	char	data[BUFSIZ];
-};
-
-struct msg_stderr_data {
-	ssize_t	size;
-	char	data[BUFSIZ];
-};
-
-/* Mode key commands. */
-enum mode_key_cmd {
-	MODEKEY_NONE,
-	MODEKEY_OTHER,
-
-	/* Editing keys. */
-	MODEKEYEDIT_BACKSPACE,
-	MODEKEYEDIT_CANCEL,
-	MODEKEYEDIT_COMPLETE,
-	MODEKEYEDIT_CURSORLEFT,
-	MODEKEYEDIT_CURSORRIGHT,
-	MODEKEYEDIT_DELETE,
-	MODEKEYEDIT_DELETELINE,
-	MODEKEYEDIT_DELETETOENDOFLINE,
-	MODEKEYEDIT_DELETEWORD,
-	MODEKEYEDIT_ENDOFLINE,
-	MODEKEYEDIT_ENTER,
-	MODEKEYEDIT_HISTORYDOWN,
-	MODEKEYEDIT_HISTORYUP,
-	MODEKEYEDIT_NEXTSPACE,
-	MODEKEYEDIT_NEXTSPACEEND,
-	MODEKEYEDIT_NEXTWORD,
-	MODEKEYEDIT_NEXTWORDEND,
-	MODEKEYEDIT_PASTE,
-	MODEKEYEDIT_PREVIOUSSPACE,
-	MODEKEYEDIT_PREVIOUSWORD,
-	MODEKEYEDIT_STARTOFLINE,
-	MODEKEYEDIT_SWITCHMODE,
-	MODEKEYEDIT_SWITCHMODEAPPEND,
-	MODEKEYEDIT_SWITCHMODEAPPENDLINE,
-	MODEKEYEDIT_SWITCHMODEBEGINLINE,
-	MODEKEYEDIT_TRANSPOSECHARS,
-
-	/* Menu (choice) keys. */
-	MODEKEYCHOICE_BACKSPACE,
-	MODEKEYCHOICE_CANCEL,
-	MODEKEYCHOICE_CHOOSE,
-	MODEKEYCHOICE_DOWN,
-	MODEKEYCHOICE_PAGEDOWN,
-	MODEKEYCHOICE_PAGEUP,
-	MODEKEYCHOICE_SCROLLDOWN,
-	MODEKEYCHOICE_SCROLLUP,
-	MODEKEYCHOICE_STARTNUMBERPREFIX,
-	MODEKEYCHOICE_TREE_COLLAPSE,
-	MODEKEYCHOICE_TREE_COLLAPSE_ALL,
-	MODEKEYCHOICE_TREE_EXPAND,
-	MODEKEYCHOICE_TREE_EXPAND_ALL,
-	MODEKEYCHOICE_TREE_TOGGLE,
-	MODEKEYCHOICE_UP,
-
-	/* Copy keys. */
-	MODEKEYCOPY_BACKTOINDENTATION,
-	MODEKEYCOPY_BOTTOMLINE,
-	MODEKEYCOPY_CANCEL,
-	MODEKEYCOPY_CLEARSELECTION,
-	MODEKEYCOPY_COPYPIPE,
-	MODEKEYCOPY_COPYLINE,
-	MODEKEYCOPY_COPYENDOFLINE,
-	MODEKEYCOPY_COPYSELECTION,
-	MODEKEYCOPY_DOWN,
-	MODEKEYCOPY_ENDOFLINE,
-	MODEKEYCOPY_GOTOLINE,
-	MODEKEYCOPY_HALFPAGEDOWN,
-	MODEKEYCOPY_HALFPAGEUP,
-	MODEKEYCOPY_HISTORYBOTTOM,
-	MODEKEYCOPY_HISTORYTOP,
-	MODEKEYCOPY_JUMP,
-	MODEKEYCOPY_JUMPAGAIN,
-	MODEKEYCOPY_JUMPREVERSE,
-	MODEKEYCOPY_JUMPBACK,
-	MODEKEYCOPY_JUMPTO,
-	MODEKEYCOPY_JUMPTOBACK,
-	MODEKEYCOPY_LEFT,
-	MODEKEYCOPY_MIDDLELINE,
-	MODEKEYCOPY_NEXTPAGE,
-	MODEKEYCOPY_NEXTSPACE,
-	MODEKEYCOPY_NEXTSPACEEND,
-	MODEKEYCOPY_NEXTWORD,
-	MODEKEYCOPY_NEXTWORDEND,
-	MODEKEYCOPY_PREVIOUSPAGE,
-	MODEKEYCOPY_PREVIOUSSPACE,
-	MODEKEYCOPY_PREVIOUSWORD,
-	MODEKEYCOPY_RECTANGLETOGGLE,
-	MODEKEYCOPY_RIGHT,
-	MODEKEYCOPY_SCROLLDOWN,
-	MODEKEYCOPY_SCROLLUP,
-	MODEKEYCOPY_SEARCHAGAIN,
-	MODEKEYCOPY_SEARCHDOWN,
-	MODEKEYCOPY_SEARCHREVERSE,
-	MODEKEYCOPY_SEARCHUP,
-	MODEKEYCOPY_SELECTLINE,
-	MODEKEYCOPY_STARTNUMBERPREFIX,
-	MODEKEYCOPY_STARTOFLINE,
-	MODEKEYCOPY_STARTSELECTION,
-	MODEKEYCOPY_TOPLINE,
-	MODEKEYCOPY_UP,
-};
-
-/* Entry in the default mode key tables. */
-struct mode_key_entry {
-	int			key;
-
-	/*
-	 * Editing mode for vi: 0 is edit mode, keys not in the table are
-	 * returned as MODEKEY_OTHER; 1 is command mode, keys not in the table
-	 * are returned as MODEKEY_NONE. This is also matched on, allowing some
-	 * keys to be bound in edit mode.
-	 */
-	int			mode;
-	enum mode_key_cmd	cmd;
-};
-
-/* Data required while mode keys are in use. */
-struct mode_key_data {
-	struct mode_key_tree   *tree;
-	int			mode;
-};
-#define MODEKEY_EMACS 0
-#define MODEKEY_VI 1
-
-/* Binding between a key and a command. */
-struct mode_key_binding {
-	int				 key;
-
-	int				 mode;
-	enum mode_key_cmd		 cmd;
-	const char			*arg;
-
-	RB_ENTRY(mode_key_binding)	 entry;
-};
-RB_HEAD(mode_key_tree, mode_key_binding);
-
-/* Command to string mapping. */
-struct mode_key_cmdstr {
-	enum mode_key_cmd	 cmd;
-	const char		*name;
-};
-
-/* Named mode key table description. */
-struct mode_key_table {
-	const char			*name;
-	const struct mode_key_cmdstr	*cmdstr;
-	struct mode_key_tree		*tree;
-	const struct mode_key_entry	*table;	/* default entries */
-};
-
-/* Modes. */
-#define MODE_CURSOR 0x1
-#define MODE_INSERT 0x2
-#define MODE_KCURSOR 0x4
-#define MODE_KKEYPAD 0x8	/* set = application, clear = number */
-#define MODE_WRAP 0x10		/* whether lines wrap */
-#define MODE_MOUSE_STANDARD 0x20
-#define MODE_MOUSE_BUTTON 0x40
-#define MODE_MOUSE_ANY 0x80
-#define MODE_MOUSE_UTF8 0x100
-#define MODE_MOUSE_SGR 0x200
-#define MODE_BRACKETPASTE 0x400
-#define MODE_FOCUSON 0x800
-
-#define ALL_MOUSE_MODES (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON|MODE_MOUSE_ANY)
-
-/* A single UTF-8 character. */
-struct utf8_data {
-	u_char	data[UTF8_SIZE];
-
-	size_t	have;
-	size_t	size;
-
-	u_int	width;
-};
-
-/* Grid output. */
-#if defined(DEBUG) && \
-    ((defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || \
-     (defined(__GNUC__) && __GNUC__ >= 3))
-#define GRID_DEBUG(gd, fmt, ...) log_debug2("%s: (sx=%u, sy=%u, hsize=%u) " \
-    fmt, __func__, (gd)->sx, (gd)->sy, (gd)->hsize, ## __VA_ARGS__)
-#else
-#define GRID_DEBUG(...)
-#endif
-
-/* Grid attributes. */
-#define GRID_ATTR_BRIGHT 0x1
-#define GRID_ATTR_DIM 0x2
-#define GRID_ATTR_UNDERSCORE 0x4
-#define GRID_ATTR_BLINK 0x8
-#define GRID_ATTR_REVERSE 0x10
-#define GRID_ATTR_HIDDEN 0x20
-#define GRID_ATTR_ITALICS 0x40
-#define GRID_ATTR_CHARSET 0x80	/* alternative character set */
-
-/* Grid flags. */
-#define GRID_FLAG_FG256 0x1
-#define GRID_FLAG_BG256 0x2
-#define GRID_FLAG_PADDING 0x4
-
-/* Grid line flags. */
-#define GRID_LINE_WRAPPED 0x1
-
-/* Grid cell data. */
-struct grid_cell {
-	u_char	attr;
-	u_char	flags;
-	u_char	fg;
-	u_char	bg;
-
-	u_char	xstate; /* top 4 bits width, bottom 4 bits size */
-	u_char	xdata[UTF8_SIZE];
-} __packed;
-
-/* Grid line. */
-struct grid_line {
-	u_int	cellsize;
-	struct grid_cell *celldata;
-
-	int	flags;
-} __packed;
-
-/* Entire grid of cells. */
-struct grid {
-	int	flags;
-#define GRID_HISTORY 0x1	/* scroll lines into history */
-
-	u_int	sx;
-	u_int	sy;
-
-	u_int	hsize;
-	u_int	hlimit;
-
-	struct grid_line *linedata;
-};
-
-/* Option data structures. */
-struct options_entry {
-	char		*name;
-
-	enum {
-		OPTIONS_STRING,
-		OPTIONS_NUMBER,
-		OPTIONS_DATA,
-	} type;
-
-	char		*str;
-	long long	 num;
-
-	RB_ENTRY(options_entry) entry;
-};
-
-struct options {
-	RB_HEAD(options_tree, options_entry) tree;
-	struct options	*parent;
-};
-
-/* Scheduled job. */
-struct job {
-	char		*cmd;
-	pid_t		 pid;
-	int		 status;
-
-	int		 fd;
-	struct bufferevent *event;
-
-	void		(*callbackfn)(struct job *);
-	void		(*freefn)(void *);
-	void		*data;
-
-	LIST_ENTRY(job)	 lentry;
-};
-LIST_HEAD(joblist, job);
-
-/* Screen selection. */
-struct screen_sel {
-	int		 flag;
-	int		 rectflag;
-
-	u_int		 sx;
-	u_int		 sy;
-
-	u_int		 ex;
-	u_int		 ey;
-
-	struct grid_cell cell;
-};
-
-/* Virtual screen. */
-struct screen {
-	char		*title;
-
-	struct grid	*grid;		/* grid data */
-
-	u_int		 cx;		/* cursor x */
-	u_int		 cy;		/* cursor y */
-
-	u_int		 cstyle;	/* cursor style */
-	char		*ccolour;	/* cursor colour string */
-
-	u_int		 rupper;	/* scroll region top */
-	u_int		 rlower;	/* scroll region bottom */
-
-	int		 mode;
-
-	bitstr_t	*tabs;
-
-	struct screen_sel sel;
-};
-
-/* Screen write context. */
-struct screen_write_ctx {
-	struct window_pane *wp;
-	struct screen	*s;
-};
-
-/* Screen size. */
-#define screen_size_x(s) ((s)->grid->sx)
-#define screen_size_y(s) ((s)->grid->sy)
-#define screen_hsize(s) ((s)->grid->hsize)
-#define screen_hlimit(s) ((s)->grid->hlimit)
-
-/* Input parser context. */
-struct input_ctx {
-	struct window_pane     *wp;
-	struct screen_write_ctx ctx;
-
-	struct grid_cell	cell;
-
-	struct grid_cell	old_cell;
-	u_int 			old_cx;
-	u_int			old_cy;
-
-	u_char			interm_buf[4];
-	size_t			interm_len;
-
-	u_char			param_buf[64];
-	size_t			param_len;
-
-	u_char			input_buf[256];
-	size_t			input_len;
-
-	int			param_list[24];	/* -1 not present */
-	u_int			param_list_len;
-
-	struct utf8_data	utf8data;
-
-	int			ch;
-	int			flags;
-#define INPUT_DISCARD 0x1
-
-	const struct input_state *state;
-
-	/*
-	 * All input received since we were last in the ground state. Sent to
-	 * control clients on connection.
-	 */
-	struct evbuffer	 	*since_ground;
-};
-
-/*
- * Window mode. Windows can be in several modes and this is used to call the
- * right function to handle input and output.
- */
-struct session;
-struct window;
-struct mouse_event;
-struct window_mode {
-	struct screen *(*init)(struct window_pane *);
-	void	(*free)(struct window_pane *);
-	void	(*resize)(struct window_pane *, u_int, u_int);
-	void	(*key)(struct window_pane *, struct session *, int);
-	void	(*mouse)(struct window_pane *,
-		    struct session *, struct mouse_event *);
-	void	(*timer)(struct window_pane *);
-};
-
-/* Structures for choose mode. */
-struct window_choose_data {
-	struct client		*start_client;
-	struct session		*start_session;
-
-	u_int			 idx;
-	int			 type;
-#define TREE_OTHER 0x0
-#define TREE_WINDOW 0x1
-#define TREE_SESSION 0x2
-
-	struct session		*tree_session; /* session of items in tree */
-
-	struct winlink		*wl;
-	int			 pane_id;
-
-	char		        *ft_template;
-	struct format_tree	*ft;
-
-	char			*command;
-};
-
-struct window_choose_mode_item {
-	struct window_choose_data	*wcd;
-	char				*name;
-	int				 pos;
-	int				 state;
-#define TREE_EXPANDED 0x1
-};
-
-/* Child window structure. */
-struct window_pane {
-	u_int		 id;
-
-	struct window	*window;
-
-	struct layout_cell *layout_cell;
-	struct layout_cell *saved_layout_cell;
-
-	u_int		 sx;
-	u_int		 sy;
-
-	u_int		 xoff;
-	u_int		 yoff;
-
-	int		 flags;
-#define PANE_REDRAW 0x1
-#define PANE_DROP 0x2
-#define PANE_FOCUSED 0x4
-#define PANE_RESIZE 0x8
-
-	char		*cmd;
-	char		*shell;
-	char		*cwd;
-
-	pid_t		 pid;
-	char		 tty[TTY_NAME_MAX];
-
-	u_int		 changes;
-	struct event	 changes_timer;
-	u_int		 changes_redraw;
-
-	int		 fd;
-	struct bufferevent *event;
-
-	struct input_ctx ictx;
-
-	int		 pipe_fd;
-	struct bufferevent *pipe_event;
-	size_t		 pipe_off;
-
-	struct screen	*screen;
-	struct screen	 base;
-
-	/* Saved in alternative screen mode. */
-	u_int		 saved_cx;
-	u_int		 saved_cy;
-	struct grid	*saved_grid;
-	struct grid_cell saved_cell;
-
-	const struct window_mode *mode;
-	void		*modedata;
-
-	TAILQ_ENTRY(window_pane) entry;
-	RB_ENTRY(window_pane) tree_entry;
-};
-TAILQ_HEAD(window_panes, window_pane);
-RB_HEAD(window_pane_tree, window_pane);
-
-/* Window structure. */
-struct window {
-	u_int		 id;
-	char		*name;
-	struct event	 name_timer;
-	struct timeval   silence_timer;
-
-	struct window_pane *active;
-	struct window_pane *last;
-	struct window_panes panes;
-
-	int		 lastlayout;
-	struct layout_cell *layout_root;
-	struct layout_cell *saved_layout_root;
-
-	u_int		 sx;
-	u_int		 sy;
-
-	int		 flags;
-#define WINDOW_BELL 0x1
-#define WINDOW_ACTIVITY 0x2
-#define WINDOW_REDRAW 0x4
-#define WINDOW_SILENCE 0x8
-#define WINDOW_ZOOMED 0x10
-
-	struct options	 options;
-
-	u_int		 references;
-};
-ARRAY_DECL(windows, struct window *);
-
-/* Entry on local window list. */
-struct winlink {
-	int		 idx;
-	struct window	*window;
-
-	size_t		 status_width;
-	struct grid_cell status_cell;
-	char		*status_text;
-
-	int              flags;
-#define WINLINK_BELL 0x1
-#define WINLINK_ACTIVITY 0x2
-#define WINLINK_CONTENT 0x4
-#define WINLINK_SILENCE 0x8
-#define WINLINK_ALERTFLAGS \
-    (WINLINK_BELL|WINLINK_ACTIVITY|WINLINK_CONTENT|WINLINK_SILENCE)
-
-	RB_ENTRY(winlink) entry;
-	TAILQ_ENTRY(winlink) sentry;
-};
-RB_HEAD(winlinks, winlink);
-TAILQ_HEAD(winlink_stack, winlink);
-
-/* Layout direction. */
-enum layout_type {
-	LAYOUT_LEFTRIGHT,
-	LAYOUT_TOPBOTTOM,
-	LAYOUT_WINDOWPANE
-};
-
-/* Layout cells queue. */
-TAILQ_HEAD(layout_cells, layout_cell);
-
-/* Layout cell. */
-struct layout_cell {
-	enum layout_type type;
-
-	struct layout_cell *parent;
-
-	u_int		 sx;
-	u_int		 sy;
-
-	u_int		 xoff;
-	u_int		 yoff;
-
-	struct window_pane *wp;
-	struct layout_cells cells;
-
-	TAILQ_ENTRY(layout_cell) entry;
-};
-
-/* Paste buffer. */
-struct paste_buffer {
-	char		*data;
-	size_t		 size;
-};
-ARRAY_DECL(paste_stack, struct paste_buffer *);
-
-/* Environment variable. */
-struct environ_entry {
-	char		*name;
-	char		*value;
-
-	RB_ENTRY(environ_entry) entry;
-};
-RB_HEAD(environ, environ_entry);
-
-/* Client session. */
-struct session_group {
-	TAILQ_HEAD(, session) sessions;
-
-	TAILQ_ENTRY(session_group) entry;
-};
-TAILQ_HEAD(session_groups, session_group);
-
-struct session {
-	u_int		 id;
-
-	char		*name;
-	char		*cwd;
-
-	struct timeval	 creation_time;
-	struct timeval	 activity_time;
-	struct timeval	 last_activity_time;
-
-	u_int		 sx;
-	u_int		 sy;
-
-	struct winlink	*curw;
-	struct winlink_stack lastw;
-	struct winlinks	 windows;
-
-	struct options	 options;
-
-#define SESSION_UNATTACHED 0x1	/* not attached to any clients */
-	int		 flags;
-
-	struct termios	*tio;
-
-	struct environ	 environ;
-
-	int		 references;
-
-	TAILQ_ENTRY(session) gentry;
-	RB_ENTRY(session)    entry;
-};
-RB_HEAD(sessions, session);
-ARRAY_DECL(sessionslist, struct session *);
-
-/* TTY information. */
-struct tty_key {
-	char		 ch;
-	int		 key;
-
-	struct tty_key	*left;
-	struct tty_key	*right;
-
-	struct tty_key	*next;
-};
-
-struct tty_term {
-	char		*name;
-	u_int		 references;
-
-	char		 acs[UCHAR_MAX + 1][2];
-
-	struct tty_code	 codes[NTTYCODE];
-
-#define TERM_256COLOURS 0x1
-#define TERM_EARLYWRAP 0x2
-	int		 flags;
-
-	LIST_ENTRY(tty_term) entry;
-};
-LIST_HEAD(tty_terms, tty_term);
-
-/* Mouse wheel states. */
-#define MOUSE_WHEEL_UP 0
-#define MOUSE_WHEEL_DOWN 1
-
-/* Mouse events. */
-#define MOUSE_EVENT_DOWN (1 << 0)
-#define MOUSE_EVENT_DRAG (1 << 1)
-#define MOUSE_EVENT_UP (1 << 2)
-#define MOUSE_EVENT_CLICK (1 << 3)
-#define MOUSE_EVENT_WHEEL (1 << 4)
-
-/* Mouse flags. */
-#define MOUSE_RESIZE_PANE (1 << 0)
-
-/*
- * Mouse input. When sent by xterm:
- *
- * - buttons are in the bottom two bits: 0 = b1; 1 = b2; 2 = b3; 3 = released
- * - bits 3, 4 and 5 are for keys
- * - bit 6 is set for dragging
- * - bit 7 for buttons 4 and 5
- *
- * With the SGR 1006 extension the released button becomes known. Store these
- * in separate fields and store the value converted to the old format in xb.
- */
-struct mouse_event {
-	u_int	xb;
-
-	u_int	x;
-	u_int	lx;
-	u_int	sx;
-
-	u_int	y;
-	u_int	ly;
-	u_int	sy;
-
-	u_int   sgr;		/* whether the input arrived in SGR format */
-	u_int   sgr_xb;		/* only for SGR: the unmangled button */
-	u_int   sgr_rel;	/* only for SGR: if it is a release event */
-
-	u_int	button;
-	u_int	clicks;
-
-	int	wheel;
-	int     event;
-	int     flags;
-};
-
-struct tty {
-	struct client	*client;
-
-	char		*path;
-	u_int		 class;
-
-	u_int		 sx;
-	u_int		 sy;
-
-	u_int		 cx;
-	u_int		 cy;
-	u_int		 cstyle;
-	char		*ccolour;
-
-	int		 mode;
-
-	u_int		 rlower;
-	u_int		 rupper;
-
-	char		*termname;
-	struct tty_term	*term;
-
-	int		 fd;
-	struct bufferevent *event;
-
-	int		 log_fd;
-
-	struct termios	 tio;
-
-	struct grid_cell cell;
-
-#define TTY_NOCURSOR 0x1
-#define TTY_FREEZE 0x2
-#define TTY_TIMER 0x4
-#define TTY_UTF8 0x8
-#define TTY_STARTED 0x10
-#define TTY_OPENED 0x20
-	int		 flags;
-
-	int		 term_flags;
-
-	struct mouse_event mouse;
-
-	struct event	 key_timer;
-	struct tty_key	*key_tree;
-};
-
-/* TTY command context and function pointer. */
-struct tty_ctx {
-	struct window_pane *wp;
-
-	const struct grid_cell *cell;
-
-	u_int		 num;
-	void		*ptr;
-
-	/*
-	 * Cursor and region position before the screen was updated - this is
-	 * where the command should be applied; the values in the screen have
-	 * already been updated.
-	 */
-	u_int		 ocx;
-	u_int		 ocy;
-
-	u_int		 orupper;
-	u_int		 orlower;
-
-	u_int		 xoff;
-	u_int		 yoff;
-
-	/* Saved last cell on line. */
-	struct grid_cell last_cell;
-	u_int		 last_width;
-};
-
-/* Saved message entry. */
-struct message_entry {
-	char   *msg;
-	time_t	msg_time;
-};
-
-/* Status output data from a job. */
-struct status_out {
-	char   *cmd;
-	char   *out;
-
-	RB_ENTRY(status_out) entry;
-};
-RB_HEAD(status_out_tree, status_out);
-
-/* Client connection. */
-struct client {
-	struct imsgbuf	 ibuf;
-	struct event	 event;
-	int		 retcode;
-
-	struct timeval	 creation_time;
-	struct timeval	 activity_time;
-
-	struct environ	 environ;
-
-	char		*title;
-	char		*cwd;
-
-	struct tty	 tty;
-
-	void		(*stdin_callback)(struct client *, int, void *);
-	void		*stdin_callback_data;
-	struct evbuffer	*stdin_data;
-	int              stdin_closed;
-	struct evbuffer	*stdout_data;
-	struct evbuffer	*stderr_data;
-
-	struct event	 repeat_timer;
-
-	struct status_out_tree status_old;
-	struct status_out_tree status_new;
-	struct timeval	 status_timer;
-	struct screen	 status;
-
-#define CLIENT_TERMINAL 0x1
-#define CLIENT_PREFIX 0x2
-#define CLIENT_EXIT 0x4
-#define CLIENT_REDRAW 0x8
-#define CLIENT_STATUS 0x10
-#define CLIENT_REPEAT 0x20 /* allow command to repeat within repeat time */
-#define CLIENT_SUSPENDED 0x40
-#define CLIENT_BAD 0x80
-#define CLIENT_IDENTIFY 0x100
-#define CLIENT_DEAD 0x200
-#define CLIENT_BORDERS 0x400
-#define CLIENT_READONLY 0x800
-#define CLIENT_REDRAWWINDOW 0x1000
-#define CLIENT_CONTROL 0x2000
-#define CLIENT_FOCUSED 0x4000
-	int		 flags;
-
-	struct event	 identify_timer;
-
-	char		*message_string;
-	struct event	 message_timer;
-	ARRAY_DECL(, struct message_entry) message_log;
-
-	char		*prompt_string;
-	char		*prompt_buffer;
-	size_t		 prompt_index;
-	int		 (*prompt_callbackfn)(void *, const char *);
-	void		 (*prompt_freefn)(void *);
-	void		*prompt_data;
-	u_int            prompt_hindex;
-
-#define PROMPT_SINGLE 0x1
-	int		 prompt_flags;
-
-	struct mode_key_data prompt_mdata;
-
-	struct session	*session;
-	struct session	*last_session;
-
-	int		 wlmouse;
-
-	struct cmd_q	*cmdq;
-	int		 references;
-};
-ARRAY_DECL(clients, struct client *);
-
-/* Parsed arguments. */
-struct args {
-	bitstr_t	*flags;
-	char		*values[SCHAR_MAX]; /* XXX This is awfully big. */
-
-	int		 argc;
-	char	       **argv;
-};
-
-/* Command and list of commands. */
-struct cmd {
-	const struct cmd_entry	*entry;
-	struct args		*args;
-
-	char			*file;
-	u_int			 line;
-
-	TAILQ_ENTRY(cmd)	 qentry;
-};
-struct cmd_list {
-	int		 	 references;
-	TAILQ_HEAD(, cmd) 	 list;
-};
-
-/* Command return values. */
-enum cmd_retval {
-	CMD_RETURN_ERROR = -1,
-	CMD_RETURN_NORMAL = 0,
-	CMD_RETURN_WAIT,
-	CMD_RETURN_STOP
-};
-
-/* Command queue entry. */
-struct cmd_q_item {
-	struct cmd_list		*cmdlist;
-	TAILQ_ENTRY(cmd_q_item)	 qentry;
-};
-TAILQ_HEAD(cmd_q_items, cmd_q_item);
-
-/* Command queue. */
-struct cmd_q {
-	int			 references;
-	int			 dead;
-
-	struct client		*client;
-	int			 client_exit;
-
-	struct cmd_q_items	 queue;
-	struct cmd_q_item	*item;
-	struct cmd		*cmd;
-
-	time_t			 time;
-	u_int			 number;
-
-	void			 (*emptyfn)(struct cmd_q *);
-	void			*data;
-
-	struct msg_command_data	*msgdata;
-
-	TAILQ_ENTRY(cmd_q)       waitentry;
-};
-
-/* Command definition. */
-struct cmd_entry {
-	const char	*name;
-	const char	*alias;
-
-	const char	*args_template;
-	int		 args_lower;
-	int		 args_upper;
-
-	const char	*usage;
-
-#define CMD_STARTSERVER 0x1
-#define CMD_CANTNEST 0x2
-#define CMD_SENDENVIRON 0x4
-#define CMD_READONLY 0x8
-	int		 flags;
-
-	void		 (*key_binding)(struct cmd *, int);
-	int		 (*check)(struct args *);
-	enum cmd_retval	 (*exec)(struct cmd *, struct cmd_q *);
-};
-
-/* Key binding. */
-struct key_binding {
-	int		 key;
-	struct cmd_list	*cmdlist;
-	int		 can_repeat;
-
-	RB_ENTRY(key_binding) entry;
-};
-RB_HEAD(key_bindings, key_binding);
-
-/*
- * Option table entries. The option table is the user-visible part of the
- * option, as opposed to the internal options (struct option) which are just
- * number or string.
- */
-enum options_table_type {
-	OPTIONS_TABLE_STRING,
-	OPTIONS_TABLE_NUMBER,
-	OPTIONS_TABLE_KEY,
-	OPTIONS_TABLE_COLOUR,
-	OPTIONS_TABLE_ATTRIBUTES,
-	OPTIONS_TABLE_FLAG,
-	OPTIONS_TABLE_CHOICE
-};
-
-struct options_table_entry {
-	const char	       *name;
-	enum options_table_type	type;
-
-	u_int		 	minimum;
-	u_int		 	maximum;
-	const char	      **choices;
-
-	const char	       *default_str;
-	long long		default_num;
-};
-
-/* Tree of format entries. */
-struct format_entry {
-	char		       *key;
-	char		       *value;
-
-	RB_ENTRY(format_entry)	entry;
-};
-RB_HEAD(format_tree, format_entry);
-
-/* Common command usages. */
-#define CMD_TARGET_PANE_USAGE "[-t target-pane]"
-#define CMD_TARGET_WINDOW_USAGE "[-t target-window]"
-#define CMD_TARGET_SESSION_USAGE "[-t target-session]"
-#define CMD_TARGET_CLIENT_USAGE "[-t target-client]"
-#define CMD_SRCDST_PANE_USAGE "[-s src-pane] [-t dst-pane]"
-#define CMD_SRCDST_WINDOW_USAGE "[-s src-window] [-t dst-window]"
-#define CMD_SRCDST_SESSION_USAGE "[-s src-session] [-t dst-session]"
-#define CMD_SRCDST_CLIENT_USAGE "[-s src-client] [-t dst-client]"
-#define CMD_BUFFER_USAGE "[-b buffer-index]"
-
-/* tmux.c */
-extern struct options global_options;
-extern struct options global_s_options;
-extern struct options global_w_options;
-extern struct environ global_environ;
-extern struct event_base *ev_base;
-extern char	*cfg_file;
-extern char	*shell_cmd;
-extern int	 debug_level;
-extern time_t	 start_time;
-extern char	 socket_path[MAXPATHLEN];
-extern int	 login_shell;
-extern char	*environ_path;
-extern pid_t	 environ_pid;
-extern int	 environ_session_id;
-void		 logfile(const char *);
-const char	*getshell(void);
-int		 checkshell(const char *);
-int		 areshell(const char *);
-const char*	 get_full_path(const char *, const char *);
-void		 setblocking(int, int);
-__dead void	 shell_exec(const char *, const char *);
-
-/* cfg.c */
-extern struct cmd_q *cfg_cmd_q;
-extern int cfg_finished;
-extern int cfg_references;
-extern struct causelist cfg_causes;
-int		 load_cfg(const char *, struct cmd_q *, char **);
-void		 cfg_default_done(struct cmd_q *);
-void		 cfg_show_causes(struct session *);
-
-/* format.c */
-int		 format_cmp(struct format_entry *, struct format_entry *);
-RB_PROTOTYPE(format_tree, format_entry, entry, format_cmp);
-struct format_tree *format_create(void);
-void		 format_free(struct format_tree *);
-void printflike3 format_add(
-		     struct format_tree *, const char *, const char *, ...);
-const char	*format_find(struct format_tree *, const char *);
-char		*format_expand(struct format_tree *, const char *);
-void		 format_session(struct format_tree *, struct session *);
-void		 format_client(struct format_tree *, struct client *);
-void		 format_winlink(
-		     struct format_tree *, struct session *, struct winlink *);
-void		 format_window_pane(struct format_tree *, struct window_pane *);
-void		 format_paste_buffer(struct format_tree *, struct paste_buffer *);
-
-/* mode-key.c */
-extern const struct mode_key_table mode_key_tables[];
-extern struct mode_key_tree mode_key_tree_vi_edit;
-extern struct mode_key_tree mode_key_tree_vi_choice;
-extern struct mode_key_tree mode_key_tree_vi_copy;
-extern struct mode_key_tree mode_key_tree_emacs_edit;
-extern struct mode_key_tree mode_key_tree_emacs_choice;
-extern struct mode_key_tree mode_key_tree_emacs_copy;
-int	mode_key_cmp(struct mode_key_binding *, struct mode_key_binding *);
-RB_PROTOTYPE(mode_key_tree, mode_key_binding, entry, mode_key_cmp);
-const char *mode_key_tostring(const struct mode_key_cmdstr *,
-	    enum mode_key_cmd);
-enum mode_key_cmd mode_key_fromstring(const struct mode_key_cmdstr *,
-	    const char *);
-const struct mode_key_table *mode_key_findtable(const char *);
-void	mode_key_init_trees(void);
-void	mode_key_init(struct mode_key_data *, struct mode_key_tree *);
-enum mode_key_cmd mode_key_lookup(struct mode_key_data *, int, const char **);
-
-/* notify.c */
-void	notify_enable(void);
-void	notify_disable(void);
-void	notify_input(struct window_pane *, struct evbuffer *);
-void	notify_window_layout_changed(struct window *);
-void	notify_window_unlinked(struct session *, struct window *);
-void	notify_window_linked(struct session *, struct window *);
-void	notify_window_renamed(struct window *);
-void	notify_attached_session_changed(struct client *);
-void	notify_session_renamed(struct session *);
-void	notify_session_created(struct session *);
-void	notify_session_closed(struct session *);
-
-/* options.c */
-int	options_cmp(struct options_entry *, struct options_entry *);
-RB_PROTOTYPE(options_tree, options_entry, entry, options_cmp);
-void	options_init(struct options *, struct options *);
-void	options_free(struct options *);
-struct options_entry *options_find1(struct options *, const char *);
-struct options_entry *options_find(struct options *, const char *);
-void	options_remove(struct options *, const char *);
-struct options_entry *printflike3 options_set_string(
-	    struct options *, const char *, const char *, ...);
-char   *options_get_string(struct options *, const char *);
-struct options_entry *options_set_number(
-	    struct options *, const char *, long long);
-long long options_get_number(struct options *, const char *);
-
-/* options-table.c */
-extern const struct options_table_entry server_options_table[];
-extern const struct options_table_entry session_options_table[];
-extern const struct options_table_entry window_options_table[];
-void	options_table_populate_tree(const struct options_table_entry *,
-	    struct options *);
-const char *options_table_print_entry(const struct options_table_entry *,
-	    struct options_entry *, int);
-int	options_table_find(const char *, const struct options_table_entry **,
-	    const struct options_table_entry **);
-
-/* job.c */
-extern struct joblist all_jobs;
-struct job *job_run(const char *, struct session *,
-	    void (*)(struct job *), void (*)(void *), void *);
-void	job_free(struct job *);
-void	job_died(struct job *, int);
-
-/* environ.c */
-int	environ_cmp(struct environ_entry *, struct environ_entry *);
-RB_PROTOTYPE(environ, environ_entry, entry, environ_cmp);
-void	environ_init(struct environ *);
-void	environ_free(struct environ *);
-void	environ_copy(struct environ *, struct environ *);
-struct environ_entry *environ_find(struct environ *, const char *);
-void	environ_set(struct environ *, const char *, const char *);
-void	environ_put(struct environ *, const char *);
-void	environ_unset(struct environ *, const char *);
-void	environ_update(const char *, struct environ *, struct environ *);
-void	environ_push(struct environ *);
-
-/* tty.c */
-void	tty_init_termios(int, struct termios *, struct bufferevent *);
-void	tty_raw(struct tty *, const char *);
-void	tty_attributes(struct tty *, const struct grid_cell *);
-void	tty_reset(struct tty *);
-void	tty_region_pane(struct tty *, const struct tty_ctx *, u_int, u_int);
-void	tty_region(struct tty *, u_int, u_int);
-void	tty_cursor_pane(struct tty *, const struct tty_ctx *, u_int, u_int);
-void	tty_cursor(struct tty *, u_int, u_int);
-void	tty_putcode(struct tty *, enum tty_code_code);
-void	tty_putcode1(struct tty *, enum tty_code_code, int);
-void	tty_putcode2(struct tty *, enum tty_code_code, int, int);
-void	tty_putcode_ptr1(struct tty *, enum tty_code_code, const void *);
-void	tty_putcode_ptr2(struct tty *, enum tty_code_code, const void *,
-	    const void *);
-void	tty_puts(struct tty *, const char *);
-void	tty_putc(struct tty *, u_char);
-void	tty_putn(struct tty *, const void *, size_t, u_int);
-void	tty_init(struct tty *, struct client *, int, char *);
-int	tty_resize(struct tty *);
-int	tty_set_size(struct tty *, u_int, u_int);
-void	tty_set_class(struct tty *, u_int);
-void	tty_start_tty(struct tty *);
-void	tty_stop_tty(struct tty *);
-void	tty_set_title(struct tty *, const char *);
-void	tty_update_mode(struct tty *, int, struct screen *);
-void	tty_force_cursor_colour(struct tty *, const char *);
-void	tty_draw_line(struct tty *, struct screen *, u_int, u_int, u_int);
-int	tty_open(struct tty *, const char *, char **);
-void	tty_close(struct tty *);
-void	tty_free(struct tty *);
-void	tty_write(
-	    void (*)(struct tty *, const struct tty_ctx *), struct tty_ctx *);
-void	tty_cmd_alignmenttest(struct tty *, const struct tty_ctx *);
-void	tty_cmd_cell(struct tty *, const struct tty_ctx *);
-void	tty_cmd_clearendofline(struct tty *, const struct tty_ctx *);
-void	tty_cmd_clearendofscreen(struct tty *, const struct tty_ctx *);
-void	tty_cmd_clearline(struct tty *, const struct tty_ctx *);
-void	tty_cmd_clearscreen(struct tty *, const struct tty_ctx *);
-void	tty_cmd_clearstartofline(struct tty *, const struct tty_ctx *);
-void	tty_cmd_clearstartofscreen(struct tty *, const struct tty_ctx *);
-void	tty_cmd_deletecharacter(struct tty *, const struct tty_ctx *);
-void	tty_cmd_clearcharacter(struct tty *, const struct tty_ctx *);
-void	tty_cmd_deleteline(struct tty *, const struct tty_ctx *);
-void	tty_cmd_erasecharacter(struct tty *, const struct tty_ctx *);
-void	tty_cmd_insertcharacter(struct tty *, const struct tty_ctx *);
-void	tty_cmd_insertline(struct tty *, const struct tty_ctx *);
-void	tty_cmd_linefeed(struct tty *, const struct tty_ctx *);
-void	tty_cmd_utf8character(struct tty *, const struct tty_ctx *);
-void	tty_cmd_reverseindex(struct tty *, const struct tty_ctx *);
-void	tty_cmd_setselection(struct tty *, const struct tty_ctx *);
-void	tty_cmd_rawstring(struct tty *, const struct tty_ctx *);
-void	tty_bell(struct tty *);
-
-/* tty-term.c */
-extern struct tty_terms tty_terms;
-extern const struct tty_term_code_entry tty_term_codes[NTTYCODE];
-struct tty_term *tty_term_find(char *, int, const char *, char **);
-void		 tty_term_free(struct tty_term *);
-int		 tty_term_has(struct tty_term *, enum tty_code_code);
-const char	*tty_term_string(struct tty_term *, enum tty_code_code);
-const char	*tty_term_string1(struct tty_term *, enum tty_code_code, int);
-const char	*tty_term_string2(
-		     struct tty_term *, enum tty_code_code, int, int);
-const char	*tty_term_ptr1(
-		     struct tty_term *, enum tty_code_code, const void *);
-const char	*tty_term_ptr2(struct tty_term *, enum tty_code_code,
-		     const void *, const void *);
-int		 tty_term_number(struct tty_term *, enum tty_code_code);
-int		 tty_term_flag(struct tty_term *, enum tty_code_code);
-
-/* tty-acs.c */
-const char	*tty_acs_get(struct tty *, u_char);
-
-/* tty-keys.c */
-void	tty_keys_build(struct tty *);
-void	tty_keys_free(struct tty *);
-int	tty_keys_next(struct tty *);
-
-/* paste.c */
-struct paste_buffer *paste_walk_stack(struct paste_stack *, u_int *);
-struct paste_buffer *paste_get_top(struct paste_stack *);
-struct paste_buffer *paste_get_index(struct paste_stack *, u_int);
-int		 paste_free_top(struct paste_stack *);
-int		 paste_free_index(struct paste_stack *, u_int);
-void		 paste_add(struct paste_stack *, char *, size_t, u_int);
-int		 paste_replace(struct paste_stack *, u_int, char *, size_t);
-char		*paste_print(struct paste_buffer *, size_t);
-void		 paste_send_pane(struct paste_buffer *, struct window_pane *,
-		     const char *, int);
-
-/* clock.c */
-extern const char clock_table[14][5][5];
-void		 clock_draw(struct screen_write_ctx *, int, int);
-
-/* arguments.c */
-struct args	*args_create(int, ...);
-struct args	*args_parse(const char *, int, char **);
-void		 args_free(struct args *);
-size_t		 args_print(struct args *, char *, size_t);
-int		 args_has(struct args *, u_char);
-void		 args_set(struct args *, u_char, const char *);
-const char	*args_get(struct args *, u_char);
-long long	 args_strtonum(
-		    struct args *, u_char, long long, long long, char **);
-
-/* cmd.c */
-int		 cmd_pack_argv(int, char **, char *, size_t);
-int		 cmd_unpack_argv(char *, size_t, int, char ***);
-char	       **cmd_copy_argv(int, char *const *);
-void		 cmd_free_argv(int, char **);
-struct cmd	*cmd_parse(int, char **, const char *, u_int, char **);
-size_t		 cmd_print(struct cmd *, char *, size_t);
-struct session	*cmd_current_session(struct cmd_q *, int);
-struct client	*cmd_current_client(struct cmd_q *);
-struct client	*cmd_find_client(struct cmd_q *, const char *, int);
-struct session	*cmd_find_session(struct cmd_q *, const char *, int);
-struct winlink	*cmd_find_window(struct cmd_q *, const char *,
-		     struct session **);
-int		 cmd_find_index(struct cmd_q *, const char *,
-		     struct session **);
-struct winlink	*cmd_find_pane(struct cmd_q *, const char *, struct session **,
-		     struct window_pane **);
-char		*cmd_template_replace(const char *, const char *, int);
-const char     	*cmd_get_default_path(struct cmd_q *, const char *);
-extern const struct cmd_entry *cmd_table[];
-extern const struct cmd_entry cmd_attach_session_entry;
-extern const struct cmd_entry cmd_bind_key_entry;
-extern const struct cmd_entry cmd_break_pane_entry;
-extern const struct cmd_entry cmd_capture_pane_entry;
-extern const struct cmd_entry cmd_choose_buffer_entry;
-extern const struct cmd_entry cmd_choose_client_entry;
-extern const struct cmd_entry cmd_choose_list_entry;
-extern const struct cmd_entry cmd_choose_session_entry;
-extern const struct cmd_entry cmd_choose_tree_entry;
-extern const struct cmd_entry cmd_choose_window_entry;
-extern const struct cmd_entry cmd_clear_history_entry;
-extern const struct cmd_entry cmd_clock_mode_entry;
-extern const struct cmd_entry cmd_command_prompt_entry;
-extern const struct cmd_entry cmd_confirm_before_entry;
-extern const struct cmd_entry cmd_copy_mode_entry;
-extern const struct cmd_entry cmd_delete_buffer_entry;
-extern const struct cmd_entry cmd_detach_client_entry;
-extern const struct cmd_entry cmd_display_message_entry;
-extern const struct cmd_entry cmd_display_panes_entry;
-extern const struct cmd_entry cmd_down_pane_entry;
-extern const struct cmd_entry cmd_find_window_entry;
-extern const struct cmd_entry cmd_has_session_entry;
-extern const struct cmd_entry cmd_if_shell_entry;
-extern const struct cmd_entry cmd_join_pane_entry;
-extern const struct cmd_entry cmd_kill_pane_entry;
-extern const struct cmd_entry cmd_kill_server_entry;
-extern const struct cmd_entry cmd_kill_session_entry;
-extern const struct cmd_entry cmd_kill_window_entry;
-extern const struct cmd_entry cmd_last_pane_entry;
-extern const struct cmd_entry cmd_last_window_entry;
-extern const struct cmd_entry cmd_link_window_entry;
-extern const struct cmd_entry cmd_list_buffers_entry;
-extern const struct cmd_entry cmd_list_clients_entry;
-extern const struct cmd_entry cmd_list_commands_entry;
-extern const struct cmd_entry cmd_list_keys_entry;
-extern const struct cmd_entry cmd_list_panes_entry;
-extern const struct cmd_entry cmd_list_sessions_entry;
-extern const struct cmd_entry cmd_list_windows_entry;
-extern const struct cmd_entry cmd_load_buffer_entry;
-extern const struct cmd_entry cmd_lock_client_entry;
-extern const struct cmd_entry cmd_lock_server_entry;
-extern const struct cmd_entry cmd_lock_session_entry;
-extern const struct cmd_entry cmd_move_pane_entry;
-extern const struct cmd_entry cmd_move_window_entry;
-extern const struct cmd_entry cmd_new_session_entry;
-extern const struct cmd_entry cmd_new_window_entry;
-extern const struct cmd_entry cmd_next_layout_entry;
-extern const struct cmd_entry cmd_next_window_entry;
-extern const struct cmd_entry cmd_paste_buffer_entry;
-extern const struct cmd_entry cmd_pipe_pane_entry;
-extern const struct cmd_entry cmd_previous_layout_entry;
-extern const struct cmd_entry cmd_previous_window_entry;
-extern const struct cmd_entry cmd_refresh_client_entry;
-extern const struct cmd_entry cmd_rename_session_entry;
-extern const struct cmd_entry cmd_rename_window_entry;
-extern const struct cmd_entry cmd_resize_pane_entry;
-extern const struct cmd_entry cmd_respawn_pane_entry;
-extern const struct cmd_entry cmd_respawn_window_entry;
-extern const struct cmd_entry cmd_rotate_window_entry;
-extern const struct cmd_entry cmd_run_shell_entry;
-extern const struct cmd_entry cmd_save_buffer_entry;
-extern const struct cmd_entry cmd_select_layout_entry;
-extern const struct cmd_entry cmd_select_pane_entry;
-extern const struct cmd_entry cmd_select_window_entry;
-extern const struct cmd_entry cmd_send_keys_entry;
-extern const struct cmd_entry cmd_send_prefix_entry;
-extern const struct cmd_entry cmd_server_info_entry;
-extern const struct cmd_entry cmd_set_buffer_entry;
-extern const struct cmd_entry cmd_set_environment_entry;
-extern const struct cmd_entry cmd_set_option_entry;
-extern const struct cmd_entry cmd_set_window_option_entry;
-extern const struct cmd_entry cmd_show_buffer_entry;
-extern const struct cmd_entry cmd_show_environment_entry;
-extern const struct cmd_entry cmd_show_messages_entry;
-extern const struct cmd_entry cmd_show_options_entry;
-extern const struct cmd_entry cmd_show_window_options_entry;
-extern const struct cmd_entry cmd_source_file_entry;
-extern const struct cmd_entry cmd_split_window_entry;
-extern const struct cmd_entry cmd_start_server_entry;
-extern const struct cmd_entry cmd_suspend_client_entry;
-extern const struct cmd_entry cmd_swap_pane_entry;
-extern const struct cmd_entry cmd_swap_window_entry;
-extern const struct cmd_entry cmd_switch_client_entry;
-extern const struct cmd_entry cmd_unbind_key_entry;
-extern const struct cmd_entry cmd_unlink_window_entry;
-extern const struct cmd_entry cmd_up_pane_entry;
-extern const struct cmd_entry cmd_wait_for_entry;
-
-/* cmd-attach-session.c */
-enum cmd_retval	 cmd_attach_session(struct cmd_q *, const char*, int, int);
-
-/* cmd-list.c */
-struct cmd_list	*cmd_list_parse(int, char **, const char *, u_int, char **);
-void		 cmd_list_free(struct cmd_list *);
-size_t		 cmd_list_print(struct cmd_list *, char *, size_t);
-
-/* cmd-queue.c */
-struct cmd_q	*cmdq_new(struct client *);
-int		 cmdq_free(struct cmd_q *);
-void printflike2 cmdq_print(struct cmd_q *, const char *, ...);
-void printflike2 cmdq_info(struct cmd_q *, const char *, ...);
-void printflike2 cmdq_error(struct cmd_q *, const char *, ...);
-int		 cmdq_guard(struct cmd_q *, const char *);
-void		 cmdq_run(struct cmd_q *, struct cmd_list *);
-void		 cmdq_append(struct cmd_q *, struct cmd_list *);
-int		 cmdq_continue(struct cmd_q *);
-void		 cmdq_flush(struct cmd_q *);
-
-/* cmd-string.c */
-int	cmd_string_parse(const char *, struct cmd_list **, const char *,
-	    u_int, char **);
-
-/* client.c */
-int	client_main(int, char **, int);
-
-/* key-bindings.c */
-extern struct key_bindings key_bindings;
-int	 key_bindings_cmp(struct key_binding *, struct key_binding *);
-RB_PROTOTYPE(key_bindings, key_binding, entry, key_bindings_cmp);
-struct key_binding *key_bindings_lookup(int);
-void	 key_bindings_add(int, int, struct cmd_list *);
-void	 key_bindings_remove(int);
-void	 key_bindings_clean(void);
-void	 key_bindings_init(void);
-void	 key_bindings_dispatch(struct key_binding *, struct client *);
-
-/* key-string.c */
-int	 key_string_lookup_string(const char *);
-const char *key_string_lookup_key(int);
-
-/* server.c */
-extern struct clients clients;
-extern struct clients dead_clients;
-extern struct paste_stack global_buffers;
-int	 server_start(int, char *);
-void	 server_update_socket(void);
-void	 server_add_accept(int);
-
-/* server-client.c */
-void	 server_client_handle_key(struct client *, int);
-void	 server_client_create(int);
-int      server_client_open(struct client *, struct session *, char **);
-void	 server_client_lost(struct client *);
-void	 server_client_callback(int, short, void *);
-void	 server_client_status_timer(void);
-void	 server_client_loop(void);
-
-/* server-window.c */
-void	 server_window_loop(void);
-
-/* server-fn.c */
-void	 server_fill_environ(struct session *, struct environ *);
-void	 server_write_ready(struct client *);
-int	 server_write_client(
-	     struct client *, enum msgtype, const void *, size_t);
-void	 server_write_session(
-	     struct session *, enum msgtype, const void *, size_t);
-void	 server_redraw_client(struct client *);
-void	 server_status_client(struct client *);
-void	 server_redraw_session(struct session *);
-void	 server_redraw_session_group(struct session *);
-void	 server_status_session(struct session *);
-void	 server_status_session_group(struct session *);
-void	 server_redraw_window(struct window *);
-void	 server_redraw_window_borders(struct window *);
-void	 server_status_window(struct window *);
-void	 server_lock(void);
-void	 server_lock_session(struct session *);
-void	 server_lock_client(struct client *);
-int	 server_unlock(const char *);
-void	 server_kill_window(struct window *);
-int	 server_link_window(struct session *,
-	     struct winlink *, struct session *, int, int, int, char **);
-void	 server_unlink_window(struct session *, struct winlink *);
-void	 server_destroy_pane(struct window_pane *);
-void	 server_destroy_session_group(struct session *);
-void	 server_destroy_session(struct session *);
-void	 server_check_unattached(void);
-void	 server_set_identify(struct client *);
-void	 server_clear_identify(struct client *);
-void	 server_update_event(struct client *);
-void	 server_push_stdout(struct client *);
-void	 server_push_stderr(struct client *);
-int	 server_set_stdin_callback(struct client *, void (*)(struct client *,
-	     int, void *), void *, char **);
-void	 server_unzoom_window(struct window *);
-
-/* status.c */
-int	 status_out_cmp(struct status_out *, struct status_out *);
-RB_PROTOTYPE(status_out_tree, status_out, entry, status_out_cmp);
-int	 status_at_line(struct client *);
-void	 status_free_jobs(struct status_out_tree *);
-void	 status_update_jobs(struct client *);
-void	 status_set_window_at(struct client *, u_int);
-int	 status_redraw(struct client *);
-char	*status_replace(struct client *, struct session *,
-	     struct winlink *, struct window_pane *, const char *, time_t, int);
-void printflike2 status_message_set(struct client *, const char *, ...);
-void	 status_message_clear(struct client *);
-int	 status_message_redraw(struct client *);
-void	 status_prompt_set(struct client *, const char *, const char *,
-	     int (*)(void *, const char *), void (*)(void *), void *, int);
-void	 status_prompt_clear(struct client *);
-int	 status_prompt_redraw(struct client *);
-void	 status_prompt_key(struct client *, int);
-void	 status_prompt_update(struct client *, const char *, const char *);
-
-/* resize.c */
-void	 recalculate_sizes(void);
-
-/* input.c */
-void	 input_init(struct window_pane *);
-void	 input_free(struct window_pane *);
-void	 input_parse(struct window_pane *);
-
-/* input-key.c */
-void	 input_key(struct window_pane *, int);
-void	 input_mouse(struct window_pane *, struct session *,
-	     struct mouse_event *);
-
-/* xterm-keys.c */
-char	*xterm_keys_lookup(int);
-int	 xterm_keys_find(const char *, size_t, size_t *, int *);
-
-/* colour.c */
-void	 colour_set_fg(struct grid_cell *, int);
-void	 colour_set_bg(struct grid_cell *, int);
-const char *colour_tostring(int);
-int	 colour_fromstring(const char *);
-u_char	 colour_256to16(u_char);
-
-/* attributes.c */
-const char *attributes_tostring(u_char);
-int	 attributes_fromstring(const char *);
-
-/* grid.c */
-extern const struct grid_cell grid_default_cell;
-extern const struct grid_cell grid_marker_cell;
-struct grid *grid_create(u_int, u_int, u_int);
-void	 grid_destroy(struct grid *);
-int	 grid_compare(struct grid *, struct grid *);
-void	 grid_collect_history(struct grid *);
-void	 grid_scroll_history(struct grid *);
-void	 grid_scroll_history_region(struct grid *, u_int, u_int);
-void	 grid_expand_line(struct grid *, u_int, u_int);
-const struct grid_cell *grid_peek_cell(struct grid *, u_int, u_int);
-const struct grid_line *grid_peek_line(struct grid *, u_int);
-struct grid_cell *grid_get_cell(struct grid *, u_int, u_int);
-void	 grid_set_cell(struct grid *, u_int, u_int, const struct grid_cell *);
-void	 grid_clear(struct grid *, u_int, u_int, u_int, u_int);
-void	 grid_clear_lines(struct grid *, u_int, u_int);
-void	 grid_move_lines(struct grid *, u_int, u_int, u_int);
-void	 grid_move_cells(struct grid *, u_int, u_int, u_int, u_int);
-char	*grid_string_cells(struct grid *, u_int, u_int, u_int,
-	     struct grid_cell **, int, int, int);
-void	 grid_duplicate_lines(
-	     struct grid *, u_int, struct grid *, u_int, u_int);
-u_int	 grid_reflow(struct grid *, struct grid *, u_int);
-
-/* grid-cell.c */
-u_int	 grid_cell_width(const struct grid_cell *);
-void	 grid_cell_get(const struct grid_cell *, struct utf8_data *);
-void	 grid_cell_set(struct grid_cell *, const struct utf8_data *);
-void	 grid_cell_one(struct grid_cell *, u_char);
-
-/* grid-view.c */
-const struct grid_cell *grid_view_peek_cell(struct grid *, u_int, u_int);
-struct grid_cell *grid_view_get_cell(struct grid *, u_int, u_int);
-void	 grid_view_set_cell(
-	     struct grid *, u_int, u_int, const struct grid_cell *);
-void	 grid_view_clear_history(struct grid *);
-void	 grid_view_clear(struct grid *, u_int, u_int, u_int, u_int);
-void	 grid_view_scroll_region_up(struct grid *, u_int, u_int);
-void	 grid_view_scroll_region_down(struct grid *, u_int, u_int);
-void	 grid_view_insert_lines(struct grid *, u_int, u_int);
-void	 grid_view_insert_lines_region(struct grid *, u_int, u_int, u_int);
-void	 grid_view_delete_lines(struct grid *, u_int, u_int);
-void	 grid_view_delete_lines_region(struct grid *, u_int, u_int, u_int);
-void	 grid_view_insert_cells(struct grid *, u_int, u_int, u_int);
-void	 grid_view_delete_cells(struct grid *, u_int, u_int, u_int);
-char	*grid_view_string_cells(struct grid *, u_int, u_int, u_int);
-
-/* screen-write.c */
-void	 screen_write_start(
-	     struct screen_write_ctx *, struct window_pane *, struct screen *);
-void	 screen_write_stop(struct screen_write_ctx *);
-void	 screen_write_reset(struct screen_write_ctx *);
-size_t printflike2 screen_write_cstrlen(int, const char *, ...);
-void printflike5 screen_write_cnputs(struct screen_write_ctx *,
-	     ssize_t, struct grid_cell *, int, const char *, ...);
-size_t printflike2 screen_write_strlen(int, const char *, ...);
-void printflike3 screen_write_puts(struct screen_write_ctx *,
-	     struct grid_cell *, const char *, ...);
-void printflike5 screen_write_nputs(struct screen_write_ctx *,
-	     ssize_t, struct grid_cell *, int, const char *, ...);
-void	 screen_write_vnputs(struct screen_write_ctx *,
-	     ssize_t, struct grid_cell *, int, const char *, va_list);
-void	 screen_write_parsestyle(
-	     struct grid_cell *, struct grid_cell *, const char *);
-void	 screen_write_putc(
-	     struct screen_write_ctx *, struct grid_cell *, u_char);
-void	 screen_write_copy(struct screen_write_ctx *,
-	     struct screen *, u_int, u_int, u_int, u_int);
-void	 screen_write_backspace(struct screen_write_ctx *);
-void	 screen_write_mode_set(struct screen_write_ctx *, int);
-void	 screen_write_mode_clear(struct screen_write_ctx *, int);
-void	 screen_write_cursorup(struct screen_write_ctx *, u_int);
-void	 screen_write_cursordown(struct screen_write_ctx *, u_int);
-void	 screen_write_cursorright(struct screen_write_ctx *, u_int);
-void	 screen_write_cursorleft(struct screen_write_ctx *, u_int);
-void	 screen_write_alignmenttest(struct screen_write_ctx *);
-void	 screen_write_insertcharacter(struct screen_write_ctx *, u_int);
-void	 screen_write_deletecharacter(struct screen_write_ctx *, u_int);
-void	 screen_write_clearcharacter(struct screen_write_ctx *, u_int);
-void	 screen_write_insertline(struct screen_write_ctx *, u_int);
-void	 screen_write_deleteline(struct screen_write_ctx *, u_int);
-void	 screen_write_clearline(struct screen_write_ctx *);
-void	 screen_write_clearendofline(struct screen_write_ctx *);
-void	 screen_write_clearstartofline(struct screen_write_ctx *);
-void	 screen_write_cursormove(struct screen_write_ctx *, u_int, u_int);
-void	 screen_write_reverseindex(struct screen_write_ctx *);
-void	 screen_write_scrollregion(struct screen_write_ctx *, u_int, u_int);
-void	 screen_write_linefeed(struct screen_write_ctx *, int);
-void	 screen_write_linefeedscreen(struct screen_write_ctx *, int);
-void	 screen_write_carriagereturn(struct screen_write_ctx *);
-void	 screen_write_clearendofscreen(struct screen_write_ctx *);
-void	 screen_write_clearstartofscreen(struct screen_write_ctx *);
-void	 screen_write_clearscreen(struct screen_write_ctx *);
-void	 screen_write_clearhistory(struct screen_write_ctx *);
-void	 screen_write_cell(struct screen_write_ctx *, const struct grid_cell *);
-void	 screen_write_setselection(struct screen_write_ctx *, u_char *, u_int);
-void	 screen_write_rawstring(struct screen_write_ctx *, u_char *, u_int);
-
-/* screen-redraw.c */
-void	 screen_redraw_screen(struct client *, int, int);
-void	 screen_redraw_pane(struct client *, struct window_pane *);
-
-/* screen.c */
-void	 screen_init(struct screen *, u_int, u_int, u_int);
-void	 screen_reinit(struct screen *);
-void	 screen_free(struct screen *);
-void	 screen_reset_tabs(struct screen *);
-void	 screen_set_cursor_style(struct screen *, u_int);
-void	 screen_set_cursor_colour(struct screen *, const char *);
-void	 screen_set_title(struct screen *, const char *);
-void	 screen_resize(struct screen *, u_int, u_int, int);
-void	 screen_set_selection(struct screen *,
-	     u_int, u_int, u_int, u_int, u_int, struct grid_cell *);
-void	 screen_clear_selection(struct screen *);
-int	 screen_check_selection(struct screen *, u_int, u_int);
-void	 screen_reflow(struct screen *, u_int);
-
-/* window.c */
-extern struct windows windows;
-extern struct window_pane_tree all_window_panes;
-int		 winlink_cmp(struct winlink *, struct winlink *);
-RB_PROTOTYPE(winlinks, winlink, entry, winlink_cmp);
-int		 window_pane_cmp(struct window_pane *, struct window_pane *);
-RB_PROTOTYPE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);
-struct winlink	*winlink_find_by_index(struct winlinks *, int);
-struct winlink	*winlink_find_by_window(struct winlinks *, struct window *);
-struct winlink	*winlink_find_by_window_id(struct winlinks *, u_int);
-int		 winlink_next_index(struct winlinks *, int);
-u_int		 winlink_count(struct winlinks *);
-struct winlink	*winlink_add(struct winlinks *, int);
-void		 winlink_set_window(struct winlink *, struct window *);
-void		 winlink_remove(struct winlinks *, struct winlink *);
-struct winlink	*winlink_next(struct winlink *);
-struct winlink	*winlink_previous(struct winlink *);
-struct winlink	*winlink_next_by_number(struct winlink *, struct session *,
-		     int);
-struct winlink	*winlink_previous_by_number(struct winlink *, struct session *,
-		     int);
-void		 winlink_stack_push(struct winlink_stack *, struct winlink *);
-void		 winlink_stack_remove(struct winlink_stack *, struct winlink *);
-int		 window_index(struct window *, u_int *);
-struct window	*window_find_by_id(u_int);
-struct window	*window_create1(u_int, u_int);
-struct window	*window_create(const char *, const char *, const char *,
-		     const char *, struct environ *, struct termios *,
-		     u_int, u_int, u_int, char **);
-void		 window_destroy(struct window *);
-struct window_pane *window_get_active_at(struct window *, u_int, u_int);
-void		 window_set_active_at(struct window *, u_int, u_int);
-struct window_pane *window_find_string(struct window *, const char *);
-void		 window_set_active_pane(struct window *, struct window_pane *);
-struct window_pane *window_add_pane(struct window *, u_int);
-void		 window_resize(struct window *, u_int, u_int);
-int		 window_zoom(struct window_pane *);
-int		 window_unzoom(struct window *);
-void		 window_remove_pane(struct window *, struct window_pane *);
-struct window_pane *window_pane_at_index(struct window *, u_int);
-struct window_pane *window_pane_next_by_number(struct window *,
-		        struct window_pane *, u_int);
-struct window_pane *window_pane_previous_by_number(struct window *,
-		        struct window_pane *, u_int);
-int		 window_pane_index(struct window_pane *, u_int *);
-u_int		 window_count_panes(struct window *);
-void		 window_destroy_panes(struct window *);
-struct window_pane *window_pane_find_by_id(u_int);
-struct window_pane *window_pane_create(struct window *, u_int, u_int, u_int);
-void		 window_pane_destroy(struct window_pane *);
-void		 window_pane_timer_start(struct window_pane *);
-int		 window_pane_spawn(struct window_pane *, const char *,
-		     const char *, const char *, struct environ *,
-		     struct termios *, char **);
-void		 window_pane_resize(struct window_pane *, u_int, u_int);
-void		 window_pane_alternate_on(struct window_pane *,
-		     struct grid_cell *, int);
-void		 window_pane_alternate_off(struct window_pane *,
-		     struct grid_cell *, int);
-int		 window_pane_set_mode(
-		     struct window_pane *, const struct window_mode *);
-void		 window_pane_reset_mode(struct window_pane *);
-void		 window_pane_key(struct window_pane *, struct session *, int);
-void		 window_pane_mouse(struct window_pane *,
-		     struct session *, struct mouse_event *);
-int		 window_pane_visible(struct window_pane *);
-char		*window_pane_search(
-		     struct window_pane *, const char *, u_int *);
-char		*window_printable_flags(struct session *, struct winlink *);
-struct window_pane *window_pane_find_up(struct window_pane *);
-struct window_pane *window_pane_find_down(struct window_pane *);
-struct window_pane *window_pane_find_left(struct window_pane *);
-struct window_pane *window_pane_find_right(struct window_pane *);
-void		 window_set_name(struct window *, const char *);
-void		 window_remove_ref(struct window *);
-void		 winlink_clear_flags(struct winlink *);
-void		 window_mode_attrs(struct grid_cell *, struct options *);
-
-/* layout.c */
-u_int		 layout_count_cells(struct layout_cell *);
-struct layout_cell *layout_create_cell(struct layout_cell *);
-void		 layout_free_cell(struct layout_cell *);
-void		 layout_print_cell(struct layout_cell *, const char *, u_int);
-void		 layout_destroy_cell(struct layout_cell *, struct layout_cell **);
-void		 layout_set_size(
-		     struct layout_cell *, u_int, u_int, u_int, u_int);
-void		 layout_make_leaf(
-		     struct layout_cell *, struct window_pane *);
-void		 layout_make_node(struct layout_cell *, enum layout_type);
-void		 layout_fix_offsets(struct layout_cell *);
-void		 layout_fix_panes(struct window *, u_int, u_int);
-u_int		 layout_resize_check(struct layout_cell *, enum layout_type);
-void		 layout_resize_adjust(
-		     struct layout_cell *, enum layout_type, int);
-void		 layout_init(struct window *, struct window_pane *);
-void		 layout_free(struct window *);
-void		 layout_resize(struct window *, u_int, u_int);
-void		 layout_resize_pane(struct window_pane *, enum layout_type,
-		     int);
-void		 layout_resize_pane_to(struct window_pane *, enum layout_type,
-		     u_int);
-void		 layout_resize_pane_mouse(struct client *);
-void		 layout_assign_pane(struct layout_cell *, struct window_pane *);
-struct layout_cell *layout_split_pane(
-		     struct window_pane *, enum layout_type, int, int);
-void		 layout_close_pane(struct window_pane *);
-
-/* layout-custom.c */
-char		*layout_dump(struct window *);
-int		 layout_parse(struct window *, const char *);
-
-/* layout-set.c */
-const char	*layout_set_name(u_int);
-int		 layout_set_lookup(const char *);
-u_int		 layout_set_select(struct window *, u_int);
-u_int		 layout_set_next(struct window *);
-u_int		 layout_set_previous(struct window *);
-void		 layout_set_active_changed(struct window *);
-
-/* window-clock.c */
-extern const struct window_mode window_clock_mode;
-
-/* window-copy.c */
-extern const struct window_mode window_copy_mode;
-void		 window_copy_init_from_pane(struct window_pane *);
-void		 window_copy_init_for_output(struct window_pane *);
-void printflike2 window_copy_add(struct window_pane *, const char *, ...);
-void		 window_copy_vadd(struct window_pane *, const char *, va_list);
-void		 window_copy_pageup(struct window_pane *);
-
-/* window-choose.c */
-extern const struct window_mode window_choose_mode;
-void		 window_choose_add(struct window_pane *,
-			 struct window_choose_data *);
-void		 window_choose_ready(struct window_pane *,
-		     u_int, void (*)(struct window_choose_data *));
-struct window_choose_data	*window_choose_data_create (int,
-		     struct client *, struct session *);
-void	window_choose_data_free(struct window_choose_data *);
-void	window_choose_data_run(struct window_choose_data *);
-struct window_choose_data	*window_choose_add_window(struct window_pane *,
-			struct client *, struct session *, struct winlink *,
-			const char *, const char *, u_int);
-struct window_choose_data	*window_choose_add_session(struct window_pane *,
-			struct client *, struct session *, const char *,
-			const char *, u_int);
-struct window_choose_data	*window_choose_add_item(struct window_pane *,
-			struct client *, struct winlink *, const char *,
-			const char *, u_int);
-void	window_choose_expand_all(struct window_pane *);
-
-/* names.c */
-void		 queue_window_name(struct window *);
-char		*default_window_name(struct window *);
-
-/* signal.c */
-void	set_signals(void(*)(int, short, void *));
-void	clear_signals(int);
-
-/* control.c */
-void	control_callback(struct client *, int, void*);
-void printflike2 control_write(struct client *, const char *, ...);
-void	control_write_buffer(struct client *, struct evbuffer *);
-
-/* control-notify.c */
-void	control_notify_input(struct client *, struct window_pane *,
-	    struct evbuffer *);
-void	control_notify_window_layout_changed(struct window *);
-void	control_notify_window_unlinked(struct session *, struct window *);
-void	control_notify_window_linked(struct session *, struct window *);
-void	control_notify_window_renamed(struct window *);
-void	control_notify_attached_session_changed(struct client *);
-void	control_notify_session_renamed(struct session *);
-void	control_notify_session_created(struct session *);
-void	control_notify_session_close(struct session *);
-
-/* session.c */
-extern struct sessions sessions;
-extern struct sessions dead_sessions;
-extern struct session_groups session_groups;
-int	session_cmp(struct session *, struct session *);
-RB_PROTOTYPE(sessions, session, entry, session_cmp);
-int		 session_alive(struct session *);
-struct session	*session_find(const char *);
-struct session	*session_find_by_id(u_int);
-struct session	*session_create(const char *, const char *, const char *,
-		     struct environ *, struct termios *, int, u_int, u_int,
-		     char **);
-void		 session_destroy(struct session *);
-int		 session_check_name(const char *);
-void		 session_update_activity(struct session *);
-struct session	*session_next_session(struct session *);
-struct session	*session_previous_session(struct session *);
-struct winlink	*session_new(struct session *,
-		     const char *, const char *, const char *, int, char **);
-struct winlink	*session_attach(
-		     struct session *, struct window *, int, char **);
-int		 session_detach(struct session *, struct winlink *);
-struct winlink*	 session_has(struct session *, struct window *);
-int		 session_next(struct session *, int);
-int		 session_previous(struct session *, int);
-int		 session_select(struct session *, int);
-int		 session_last(struct session *);
-int		 session_set_current(struct session *, struct winlink *);
-struct session_group *session_group_find(struct session *);
-u_int		 session_group_index(struct session_group *);
-void		 session_group_add(struct session *, struct session *);
-void		 session_group_remove(struct session *);
-void		 session_group_synchronize_to(struct session *);
-void		 session_group_synchronize_from(struct session *);
-void		 session_group_synchronize1(struct session *, struct session *);
-void		 session_renumber_windows(struct session *);
-
-/* utf8.c */
-void	utf8_build(void);
-int	utf8_open(struct utf8_data *, u_char);
-int	utf8_append(struct utf8_data *, u_char);
-u_int	utf8_combine(const struct utf8_data *);
-u_int	utf8_split2(u_int, u_char *);
-
-/* osdep-*.c */
-char		*osdep_get_name(int, char *);
-char		*osdep_get_cwd(int);
-struct event_base *osdep_event_init(void);
-
-/* log.c */
-void		 log_open(int, const char *);
-void		 log_close(void);
-void printflike1 log_warn(const char *, ...);
-void printflike1 log_warnx(const char *, ...);
-void printflike1 log_info(const char *, ...);
-void printflike1 log_debug(const char *, ...);
-void printflike1 log_debug2(const char *, ...);
-__dead void printflike1 log_fatal(const char *, ...);
-__dead void printflike1 log_fatalx(const char *, ...);
-
-/* xmalloc.c */
-char		*xstrdup(const char *);
-void		*xcalloc(size_t, size_t);
-void		*xmalloc(size_t);
-void		*xrealloc(void *, size_t, size_t);
-int printflike2	 xasprintf(char **, const char *, ...);
-int		 xvasprintf(char **, const char *, va_list);
-int printflike3	 xsnprintf(char *, size_t, const char *, ...);
-int		 xvsnprintf(char *, size_t, const char *, va_list);
-
-#endif /* TMUX_H */
diff --git a/tmux.h.in b/tmux.h.in
new file mode 100644
index 0000000..22db03b
--- /dev/null
+++ b/tmux.h.in
@@ -0,0 +1,2352 @@
+/* $Id$ */
+
+/*
+ * Copyright (c) 2007 Nicholas Marriott <nicm@users.sourceforge.net>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef TMUX_H
+#define TMUX_H
+
+#define PROTOCOL_VERSION 7
+
+#include <sys/param.h>
+#include <sys/time.h>
+#include <sys/uio.h>
+
+#include <event.h>
+#include <limits.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <termios.h>
+
+#include "array.h"
+
+#include "compat.h"
+
+extern char    *__progname;
+extern char   **environ;
+
+/* Default configuration files. */
+#define DEFAULT_CFG ".tmux.conf"
+#define SYSTEM_CFG "@sysconfdir@/tmux.conf"
+
+/* Default prompt history length. */
+#define PROMPT_HISTORY 100
+
+/*
+ * Minimum layout cell size, NOT including separator line. The scroll region
+ * cannot be one line in height so this must be at least two.
+ */
+#define PANE_MINIMUM 2
+
+/* Automatic name refresh interval, in milliseconds. */
+#define NAME_INTERVAL 500
+
+/*
+ * Maximum sizes of strings in message data. Don't forget to bump
+ * PROTOCOL_VERSION if any of these change!
+ */
+#define COMMAND_LENGTH 2048	/* packed argv size */
+#define TERMINAL_LENGTH 128	/* length of TERM environment variable */
+#define ENVIRON_LENGTH 1024	/* environment variable length */
+
+/*
+ * UTF-8 data size. This must be big enough to hold combined characters as well
+ * as single.
+ */
+#define UTF8_SIZE 9
+
+/* Fatal errors. */
+#define fatal(msg) log_fatal("%s: %s", __func__, msg);
+#define fatalx(msg) log_fatalx("%s: %s", __func__, msg);
+
+/* Definition to shut gcc up about unused arguments. */
+#define unused __attribute__ ((unused))
+
+/* Attribute to make gcc check printf-like arguments. */
+#define printflike1 __attribute__ ((format (printf, 1, 2)))
+#define printflike2 __attribute__ ((format (printf, 2, 3)))
+#define printflike3 __attribute__ ((format (printf, 3, 4)))
+#define printflike4 __attribute__ ((format (printf, 4, 5)))
+#define printflike5 __attribute__ ((format (printf, 5, 6)))
+
+/* Number of items in array. */
+#ifndef nitems
+#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
+#endif
+
+/* Default template for choose-buffer. */
+#define CHOOSE_BUFFER_TEMPLATE					\
+	"#{line}: #{buffer_size} bytes: \"#{buffer_sample}\""
+
+/* Default template for choose-client. */
+#define CHOOSE_CLIENT_TEMPLATE					\
+	"#{client_tty}: #{session_name} "			\
+	"[#{client_width}x#{client_height} #{client_termname}]"	\
+	"#{?client_utf8, (utf8),}#{?client_readonly, (ro),} "	\
+	"(last used #{client_activity_string})"
+
+/* Default templates for choose-tree. */
+#define CHOOSE_TREE_SESSION_TEMPLATE				\
+	"#{session_name}: #{session_windows} windows"		\
+	"#{?session_grouped, (group ,}"				\
+	"#{session_group}#{?session_grouped,),}"		\
+	"#{?session_attached, (attached),}"
+#define CHOOSE_TREE_WINDOW_TEMPLATE				\
+	"#{window_index}: #{window_name}#{window_flags} "	\
+	"\"#{pane_title}\""
+
+/* Default template for display-message. */
+#define DISPLAY_MESSAGE_TEMPLATE				\
+	"[#{session_name}] #{window_index}:"			\
+	"#{window_name}, current pane #{pane_index} "		\
+	"- (%H:%M %d-%b-%y)"
+
+/* Default template for find-window. */
+#define FIND_WINDOW_TEMPLATE					\
+	"#{window_index}: #{window_name} "			\
+	"[#{window_width}x#{window_height}] "			\
+	"(#{window_panes} panes) #{window_find_matches}"
+
+/* Default template for list-buffers. */
+#define LIST_BUFFERS_TEMPLATE					\
+	"#{line}: #{buffer_size} bytes: \"#{buffer_sample}\""
+
+/* Default template for list-clients. */
+#define LIST_CLIENTS_TEMPLATE					\
+	"#{client_tty}: #{session_name} "			\
+	"[#{client_width}x#{client_height} #{client_termname}]"	\
+	"#{?client_utf8, (utf8),} #{?client_readonly, (ro),}"
+
+/* Default template for list-sessions. */
+#define LIST_SESSIONS_TEMPLATE					\
+	"#{session_name}: #{session_windows} windows "		\
+	"(created #{session_created_string}) "			\
+	"[#{session_width}x#{session_height}]"			\
+	"#{?session_grouped, (group ,}"				\
+	"#{session_group}#{?session_grouped,),}"		\
+	"#{?session_attached, (attached),}"
+
+/* Default templates for list-windows. */
+#define LIST_WINDOWS_TEMPLATE					\
+	"#{window_index}: #{window_name}#{window_flags} "	\
+	"(#{window_panes} panes) "				\
+	"[#{window_width}x#{window_height}] "			\
+	"[layout #{window_layout}] #{window_id}"		\
+	"#{?window_active, (active),}";
+#define LIST_WINDOWS_WITH_SESSION_TEMPLATE			\
+	"#{session_name}: "					\
+	"#{window_index}: #{window_name}#{window_flags} "	\
+	"(#{window_panes} panes) "				\
+	"[#{window_width}x#{window_height}] "
+
+/* Default templates for break-pane, new-window and split-window. */
+#define BREAK_PANE_TEMPLATE "#{session_name}:#{window_index}.#{pane_index}"
+#define NEW_SESSION_TEMPLATE "#{session_name}:"
+#define NEW_WINDOW_TEMPLATE BREAK_PANE_TEMPLATE
+#define SPLIT_WINDOW_TEMPLATE BREAK_PANE_TEMPLATE
+
+/* Bell option values. */
+#define BELL_NONE 0
+#define BELL_ANY 1
+#define BELL_CURRENT 2
+
+/* Special key codes. */
+#define KEYC_NONE 0xfff
+#define KEYC_BASE 0x1000
+
+/* Key modifier bits. */
+#define KEYC_ESCAPE 0x2000
+#define KEYC_CTRL 0x4000
+#define KEYC_SHIFT 0x8000
+#define KEYC_PREFIX 0x10000
+
+/* Mask to obtain key w/o modifiers. */
+#define KEYC_MASK_MOD (KEYC_ESCAPE|KEYC_CTRL|KEYC_SHIFT|KEYC_PREFIX)
+#define KEYC_MASK_KEY (~KEYC_MASK_MOD)
+
+/* Other key codes. */
+enum key_code {
+	/* Mouse key. */
+	KEYC_MOUSE = KEYC_BASE,
+
+	/* Backspace key. */
+	KEYC_BSPACE,
+
+	/* Function keys. */
+	KEYC_F1,
+	KEYC_F2,
+	KEYC_F3,
+	KEYC_F4,
+	KEYC_F5,
+	KEYC_F6,
+	KEYC_F7,
+	KEYC_F8,
+	KEYC_F9,
+	KEYC_F10,
+	KEYC_F11,
+	KEYC_F12,
+	KEYC_F13,
+	KEYC_F14,
+	KEYC_F15,
+	KEYC_F16,
+	KEYC_F17,
+	KEYC_F18,
+	KEYC_F19,
+	KEYC_F20,
+	KEYC_IC,
+	KEYC_DC,
+	KEYC_HOME,
+	KEYC_END,
+	KEYC_NPAGE,
+	KEYC_PPAGE,
+	KEYC_BTAB,
+
+	/* Arrow keys. */
+	KEYC_UP,
+	KEYC_DOWN,
+	KEYC_LEFT,
+	KEYC_RIGHT,
+
+	/* Numeric keypad. */
+	KEYC_KP_SLASH,
+	KEYC_KP_STAR,
+	KEYC_KP_MINUS,
+	KEYC_KP_SEVEN,
+	KEYC_KP_EIGHT,
+	KEYC_KP_NINE,
+	KEYC_KP_PLUS,
+	KEYC_KP_FOUR,
+	KEYC_KP_FIVE,
+	KEYC_KP_SIX,
+	KEYC_KP_ONE,
+	KEYC_KP_TWO,
+	KEYC_KP_THREE,
+	KEYC_KP_ENTER,
+	KEYC_KP_ZERO,
+	KEYC_KP_PERIOD,
+
+	KEYC_FOCUS_IN,
+	KEYC_FOCUS_OUT,
+};
+
+/* Termcap codes. */
+enum tty_code_code {
+	TTYC_AX = 0,
+	TTYC_ACSC,	/* acs_chars, ac */
+	TTYC_BEL,	/* bell, bl */
+	TTYC_BLINK,	/* enter_blink_mode, mb */
+	TTYC_BOLD,	/* enter_bold_mode, md */
+	TTYC_CC,	/* set colour cursor, Cc */
+	TTYC_CIVIS,	/* cursor_invisible, vi */
+	TTYC_CLEAR,	/* clear_screen, cl */
+	TTYC_CNORM,	/* cursor_normal, ve */
+	TTYC_COLORS,	/* max_colors, Co */
+	TTYC_CR,	/* restore cursor colour, Cr */
+	TTYC_CS1,	/* set cursor style, Cs */
+	TTYC_CSR,	/* change_scroll_region, cs */
+	TTYC_CSR1,	/* reset cursor style, Csr */
+	TTYC_CUB,	/* parm_left_cursor, LE */
+	TTYC_CUB1,	/* cursor_left, le */
+	TTYC_CUD,	/* parm_down_cursor, DO */
+	TTYC_CUD1,	/* cursor_down, do */
+	TTYC_CUF,	/* parm_right_cursor, RI */
+	TTYC_CUF1,	/* cursor_right, nd */
+	TTYC_CUP,	/* cursor_address, cm */
+	TTYC_CUU,	/* parm_up_cursor, UP */
+	TTYC_CUU1,	/* cursor_up, up */
+	TTYC_DCH,	/* parm_dch, DC */
+	TTYC_DCH1,	/* delete_character, dc */
+	TTYC_DIM,	/* enter_dim_mode, mh */
+	TTYC_DL,	/* parm_delete_line, DL */
+	TTYC_DL1,	/* delete_line, dl */
+	TTYC_E3,
+	TTYC_ECH,	/* erase_chars, ec */
+	TTYC_EL,	/* clr_eol, ce */
+	TTYC_EL1,	/* clr_bol, cb */
+	TTYC_ENACS,	/* ena_acs, eA */
+	TTYC_FSL,	/* from_status_line, fsl */
+	TTYC_HOME,	/* cursor_home, ho */
+	TTYC_HPA,	/* column_address, ch */
+	TTYC_ICH,	/* parm_ich, IC */
+	TTYC_ICH1,	/* insert_character, ic */
+	TTYC_IL,	/* parm_insert_line, IL */
+	TTYC_IL1,	/* insert_line, il */
+	TTYC_INVIS,	/* enter_secure_mode, mk */
+	TTYC_IS1,	/* init_1string, i1 */
+	TTYC_IS2,	/* init_2string, i2 */
+	TTYC_IS3,	/* init_3string, i3 */
+	TTYC_KCBT,	/* key_btab, kB */
+	TTYC_KCUB1,	/* key_left, kl */
+	TTYC_KCUD1,	/* key_down, kd */
+	TTYC_KCUF1,	/* key_right, kr */
+	TTYC_KCUU1,	/* key_up, ku */
+	TTYC_KDC2,
+	TTYC_KDC3,
+	TTYC_KDC4,
+	TTYC_KDC5,
+	TTYC_KDC6,
+	TTYC_KDC7,
+	TTYC_KDCH1,	/* key_dc, kD */
+	TTYC_KDN2,
+	TTYC_KDN3,
+	TTYC_KDN4,
+	TTYC_KDN5,
+	TTYC_KDN6,
+	TTYC_KDN7,
+	TTYC_KEND,	/* key_end, ke */
+	TTYC_KEND2,
+	TTYC_KEND3,
+	TTYC_KEND4,
+	TTYC_KEND5,
+	TTYC_KEND6,
+	TTYC_KEND7,
+	TTYC_KF1,	/* key_f1, k1 */
+	TTYC_KF10,	/* key_f10, k; */
+	TTYC_KF11,	/* key_f11, F1 */
+	TTYC_KF12,	/* key_f12, F2 */
+	TTYC_KF13,	/* key_f13, F3 */
+	TTYC_KF14,	/* key_f14, F4 */
+	TTYC_KF15,	/* key_f15, F5 */
+	TTYC_KF16,	/* key_f16, F6 */
+	TTYC_KF17,	/* key_f17, F7 */
+	TTYC_KF18,	/* key_f18, F8 */
+	TTYC_KF19,	/* key_f19, F9 */
+	TTYC_KF2,	/* key_f2, k2 */
+	TTYC_KF20,	/* key_f20, F10 */
+	TTYC_KF3,	/* key_f3, k3 */
+	TTYC_KF4,	/* key_f4, k4 */
+	TTYC_KF5,	/* key_f5, k5 */
+	TTYC_KF6,	/* key_f6, k6 */
+	TTYC_KF7,	/* key_f7, k7 */
+	TTYC_KF8,	/* key_f8, k8 */
+	TTYC_KF9,	/* key_f9, k9 */
+	TTYC_KHOM2,
+	TTYC_KHOM3,
+	TTYC_KHOM4,
+	TTYC_KHOM5,
+	TTYC_KHOM6,
+	TTYC_KHOM7,
+	TTYC_KHOME,	/* key_home, kh */
+	TTYC_KIC2,
+	TTYC_KIC3,
+	TTYC_KIC4,
+	TTYC_KIC5,
+	TTYC_KIC6,
+	TTYC_KIC7,
+	TTYC_KICH1,	/* key_ic, kI */
+	TTYC_KLFT2,
+	TTYC_KLFT3,
+	TTYC_KLFT4,
+	TTYC_KLFT5,
+	TTYC_KLFT6,
+	TTYC_KLFT7,
+	TTYC_KMOUS,	/* key_mouse, Km */
+	TTYC_KNP,	/* key_npage, kN */
+	TTYC_KNXT2,
+	TTYC_KNXT3,
+	TTYC_KNXT4,
+	TTYC_KNXT5,
+	TTYC_KNXT6,
+	TTYC_KNXT7,
+	TTYC_KPP,	/* key_ppage, kP */
+	TTYC_KPRV2,
+	TTYC_KPRV3,
+	TTYC_KPRV4,
+	TTYC_KPRV5,
+	TTYC_KPRV6,
+	TTYC_KPRV7,
+	TTYC_KRIT2,
+	TTYC_KRIT3,
+	TTYC_KRIT4,
+	TTYC_KRIT5,
+	TTYC_KRIT6,
+	TTYC_KRIT7,
+	TTYC_KUP2,
+	TTYC_KUP3,
+	TTYC_KUP4,
+	TTYC_KUP5,
+	TTYC_KUP6,
+	TTYC_KUP7,
+	TTYC_MS,	/* modify xterm(1) selection */
+	TTYC_OP,	/* orig_pair, op */
+	TTYC_REV,	/* enter_reverse_mode, mr */
+	TTYC_RI,	/* scroll_reverse, sr */
+	TTYC_RMACS,	/* exit_alt_charset_mode */
+	TTYC_RMCUP,	/* exit_ca_mode, te */
+	TTYC_RMKX,	/* keypad_local, ke */
+	TTYC_SETAB,	/* set_a_background, AB */
+	TTYC_SETAF,	/* set_a_foreground, AF */
+	TTYC_SGR0,	/* exit_attribute_mode, me */
+	TTYC_SITM,	/* enter_italics_mode, it */
+	TTYC_SMACS,	/* enter_alt_charset_mode, as */
+	TTYC_SMCUP,	/* enter_ca_mode, ti */
+	TTYC_SMKX,	/* keypad_xmit, ks */
+	TTYC_SMSO,	/* enter_standout_mode, so */
+	TTYC_SMUL,	/* enter_underline_mode, us */
+	TTYC_TSL,	/* to_status_line, tsl */
+	TTYC_VPA,	/* row_address, cv */
+	TTYC_XENL,	/* eat_newline_glitch, xn */
+	TTYC_XT,	/* xterm(1)-compatible title, XT */
+};
+#define NTTYCODE (TTYC_XT + 1)
+
+/* Termcap types. */
+enum tty_code_type {
+	TTYCODE_NONE = 0,
+	TTYCODE_STRING,
+	TTYCODE_NUMBER,
+	TTYCODE_FLAG,
+};
+
+/* Termcap code. */
+struct tty_code {
+	enum tty_code_type	type;
+	union {
+		char	       *string;
+		int		number;
+		int		flag;
+	} value;
+};
+
+/* Entry in terminal code table. */
+struct tty_term_code_entry {
+	enum tty_code_code	code;
+	enum tty_code_type	type;
+	const char	       *name;
+};
+
+/* List of error causes. */
+ARRAY_DECL(causelist, char *);
+
+/* Message codes. */
+enum msgtype {
+	MSG_COMMAND,
+	MSG_DETACH,
+	MSG_ERROR,
+	MSG_EXIT,
+	MSG_EXITED,
+	MSG_EXITING,
+	MSG_IDENTIFY,
+	MSG_STDIN,
+	MSG_READY,
+	MSG_RESIZE,
+	MSG_SHUTDOWN,
+	MSG_SUSPEND,
+	MSG_VERSION,
+	MSG_WAKEUP,
+	MSG_ENVIRON,
+	MSG_UNLOCK,
+	MSG_LOCK,
+	MSG_SHELL,
+	MSG_STDERR,
+	MSG_STDOUT,
+	MSG_DETACHKILL
+};
+
+/*
+ * Message data.
+ *
+ * Don't forget to bump PROTOCOL_VERSION if any of these change!
+ */
+struct msg_command_data {
+	pid_t		pid;		/* from $TMUX or -1 */
+	int		session_id;	/* from $TMUX or -1 */
+
+	int		argc;
+	char		argv[COMMAND_LENGTH];
+};
+
+struct msg_identify_data {
+	char		cwd[MAXPATHLEN];
+
+	char		term[TERMINAL_LENGTH];
+
+#define IDENTIFY_UTF8 0x1
+#define IDENTIFY_256COLOURS 0x2
+/* 0x4 unused */
+#define IDENTIFY_CONTROL 0x8
+#define IDENTIFY_TERMIOS 0x10
+	int		flags;
+};
+
+struct msg_lock_data {
+	char		cmd[COMMAND_LENGTH];
+};
+
+struct msg_environ_data {
+	char		var[ENVIRON_LENGTH];
+};
+
+struct msg_shell_data {
+	char		shell[MAXPATHLEN];
+};
+
+struct msg_exit_data {
+	int		retcode;
+};
+
+struct msg_stdin_data {
+	ssize_t	size;
+	char	data[BUFSIZ];
+};
+
+struct msg_stdout_data {
+	ssize_t	size;
+	char	data[BUFSIZ];
+};
+
+struct msg_stderr_data {
+	ssize_t	size;
+	char	data[BUFSIZ];
+};
+
+/* Mode key commands. */
+enum mode_key_cmd {
+	MODEKEY_NONE,
+	MODEKEY_OTHER,
+
+	/* Editing keys. */
+	MODEKEYEDIT_BACKSPACE,
+	MODEKEYEDIT_CANCEL,
+	MODEKEYEDIT_COMPLETE,
+	MODEKEYEDIT_CURSORLEFT,
+	MODEKEYEDIT_CURSORRIGHT,
+	MODEKEYEDIT_DELETE,
+	MODEKEYEDIT_DELETELINE,
+	MODEKEYEDIT_DELETETOENDOFLINE,
+	MODEKEYEDIT_DELETEWORD,
+	MODEKEYEDIT_ENDOFLINE,
+	MODEKEYEDIT_ENTER,
+	MODEKEYEDIT_HISTORYDOWN,
+	MODEKEYEDIT_HISTORYUP,
+	MODEKEYEDIT_NEXTSPACE,
+	MODEKEYEDIT_NEXTSPACEEND,
+	MODEKEYEDIT_NEXTWORD,
+	MODEKEYEDIT_NEXTWORDEND,
+	MODEKEYEDIT_PASTE,
+	MODEKEYEDIT_PREVIOUSSPACE,
+	MODEKEYEDIT_PREVIOUSWORD,
+	MODEKEYEDIT_STARTOFLINE,
+	MODEKEYEDIT_SWITCHMODE,
+	MODEKEYEDIT_SWITCHMODEAPPEND,
+	MODEKEYEDIT_SWITCHMODEAPPENDLINE,
+	MODEKEYEDIT_SWITCHMODEBEGINLINE,
+	MODEKEYEDIT_TRANSPOSECHARS,
+
+	/* Menu (choice) keys. */
+	MODEKEYCHOICE_BACKSPACE,
+	MODEKEYCHOICE_CANCEL,
+	MODEKEYCHOICE_CHOOSE,
+	MODEKEYCHOICE_DOWN,
+	MODEKEYCHOICE_PAGEDOWN,
+	MODEKEYCHOICE_PAGEUP,
+	MODEKEYCHOICE_SCROLLDOWN,
+	MODEKEYCHOICE_SCROLLUP,
+	MODEKEYCHOICE_STARTNUMBERPREFIX,
+	MODEKEYCHOICE_TREE_COLLAPSE,
+	MODEKEYCHOICE_TREE_COLLAPSE_ALL,
+	MODEKEYCHOICE_TREE_EXPAND,
+	MODEKEYCHOICE_TREE_EXPAND_ALL,
+	MODEKEYCHOICE_TREE_TOGGLE,
+	MODEKEYCHOICE_UP,
+
+	/* Copy keys. */
+	MODEKEYCOPY_BACKTOINDENTATION,
+	MODEKEYCOPY_BOTTOMLINE,
+	MODEKEYCOPY_CANCEL,
+	MODEKEYCOPY_CLEARSELECTION,
+	MODEKEYCOPY_COPYPIPE,
+	MODEKEYCOPY_COPYLINE,
+	MODEKEYCOPY_COPYENDOFLINE,
+	MODEKEYCOPY_COPYSELECTION,
+	MODEKEYCOPY_DOWN,
+	MODEKEYCOPY_ENDOFLINE,
+	MODEKEYCOPY_GOTOLINE,
+	MODEKEYCOPY_HALFPAGEDOWN,
+	MODEKEYCOPY_HALFPAGEUP,
+	MODEKEYCOPY_HISTORYBOTTOM,
+	MODEKEYCOPY_HISTORYTOP,
+	MODEKEYCOPY_JUMP,
+	MODEKEYCOPY_JUMPAGAIN,
+	MODEKEYCOPY_JUMPREVERSE,
+	MODEKEYCOPY_JUMPBACK,
+	MODEKEYCOPY_JUMPTO,
+	MODEKEYCOPY_JUMPTOBACK,
+	MODEKEYCOPY_LEFT,
+	MODEKEYCOPY_MIDDLELINE,
+	MODEKEYCOPY_NEXTPAGE,
+	MODEKEYCOPY_NEXTSPACE,
+	MODEKEYCOPY_NEXTSPACEEND,
+	MODEKEYCOPY_NEXTWORD,
+	MODEKEYCOPY_NEXTWORDEND,
+	MODEKEYCOPY_PREVIOUSPAGE,
+	MODEKEYCOPY_PREVIOUSSPACE,
+	MODEKEYCOPY_PREVIOUSWORD,
+	MODEKEYCOPY_RECTANGLETOGGLE,
+	MODEKEYCOPY_RIGHT,
+	MODEKEYCOPY_SCROLLDOWN,
+	MODEKEYCOPY_SCROLLUP,
+	MODEKEYCOPY_SEARCHAGAIN,
+	MODEKEYCOPY_SEARCHDOWN,
+	MODEKEYCOPY_SEARCHREVERSE,
+	MODEKEYCOPY_SEARCHUP,
+	MODEKEYCOPY_SELECTLINE,
+	MODEKEYCOPY_STARTNUMBERPREFIX,
+	MODEKEYCOPY_STARTOFLINE,
+	MODEKEYCOPY_STARTSELECTION,
+	MODEKEYCOPY_TOPLINE,
+	MODEKEYCOPY_UP,
+};
+
+/* Entry in the default mode key tables. */
+struct mode_key_entry {
+	int			key;
+
+	/*
+	 * Editing mode for vi: 0 is edit mode, keys not in the table are
+	 * returned as MODEKEY_OTHER; 1 is command mode, keys not in the table
+	 * are returned as MODEKEY_NONE. This is also matched on, allowing some
+	 * keys to be bound in edit mode.
+	 */
+	int			mode;
+	enum mode_key_cmd	cmd;
+};
+
+/* Data required while mode keys are in use. */
+struct mode_key_data {
+	struct mode_key_tree   *tree;
+	int			mode;
+};
+#define MODEKEY_EMACS 0
+#define MODEKEY_VI 1
+
+/* Binding between a key and a command. */
+struct mode_key_binding {
+	int				 key;
+
+	int				 mode;
+	enum mode_key_cmd		 cmd;
+	const char			*arg;
+
+	RB_ENTRY(mode_key_binding)	 entry;
+};
+RB_HEAD(mode_key_tree, mode_key_binding);
+
+/* Command to string mapping. */
+struct mode_key_cmdstr {
+	enum mode_key_cmd	 cmd;
+	const char		*name;
+};
+
+/* Named mode key table description. */
+struct mode_key_table {
+	const char			*name;
+	const struct mode_key_cmdstr	*cmdstr;
+	struct mode_key_tree		*tree;
+	const struct mode_key_entry	*table;	/* default entries */
+};
+
+/* Modes. */
+#define MODE_CURSOR 0x1
+#define MODE_INSERT 0x2
+#define MODE_KCURSOR 0x4
+#define MODE_KKEYPAD 0x8	/* set = application, clear = number */
+#define MODE_WRAP 0x10		/* whether lines wrap */
+#define MODE_MOUSE_STANDARD 0x20
+#define MODE_MOUSE_BUTTON 0x40
+#define MODE_MOUSE_ANY 0x80
+#define MODE_MOUSE_UTF8 0x100
+#define MODE_MOUSE_SGR 0x200
+#define MODE_BRACKETPASTE 0x400
+#define MODE_FOCUSON 0x800
+
+#define ALL_MOUSE_MODES (MODE_MOUSE_STANDARD|MODE_MOUSE_BUTTON|MODE_MOUSE_ANY)
+
+/* A single UTF-8 character. */
+struct utf8_data {
+	u_char	data[UTF8_SIZE];
+
+	size_t	have;
+	size_t	size;
+
+	u_int	width;
+};
+
+/* Grid output. */
+#if defined(DEBUG) && \
+    ((defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || \
+     (defined(__GNUC__) && __GNUC__ >= 3))
+#define GRID_DEBUG(gd, fmt, ...) log_debug2("%s: (sx=%u, sy=%u, hsize=%u) " \
+    fmt, __func__, (gd)->sx, (gd)->sy, (gd)->hsize, ## __VA_ARGS__)
+#else
+#define GRID_DEBUG(...)
+#endif
+
+/* Grid attributes. */
+#define GRID_ATTR_BRIGHT 0x1
+#define GRID_ATTR_DIM 0x2
+#define GRID_ATTR_UNDERSCORE 0x4
+#define GRID_ATTR_BLINK 0x8
+#define GRID_ATTR_REVERSE 0x10
+#define GRID_ATTR_HIDDEN 0x20
+#define GRID_ATTR_ITALICS 0x40
+#define GRID_ATTR_CHARSET 0x80	/* alternative character set */
+
+/* Grid flags. */
+#define GRID_FLAG_FG256 0x1
+#define GRID_FLAG_BG256 0x2
+#define GRID_FLAG_PADDING 0x4
+
+/* Grid line flags. */
+#define GRID_LINE_WRAPPED 0x1
+
+/* Grid cell data. */
+struct grid_cell {
+	u_char	attr;
+	u_char	flags;
+	u_char	fg;
+	u_char	bg;
+
+	u_char	xstate; /* top 4 bits width, bottom 4 bits size */
+	u_char	xdata[UTF8_SIZE];
+} __packed;
+
+/* Grid line. */
+struct grid_line {
+	u_int	cellsize;
+	struct grid_cell *celldata;
+
+	int	flags;
+} __packed;
+
+/* Entire grid of cells. */
+struct grid {
+	int	flags;
+#define GRID_HISTORY 0x1	/* scroll lines into history */
+
+	u_int	sx;
+	u_int	sy;
+
+	u_int	hsize;
+	u_int	hlimit;
+
+	struct grid_line *linedata;
+};
+
+/* Option data structures. */
+struct options_entry {
+	char		*name;
+
+	enum {
+		OPTIONS_STRING,
+		OPTIONS_NUMBER,
+		OPTIONS_DATA,
+	} type;
+
+	char		*str;
+	long long	 num;
+
+	RB_ENTRY(options_entry) entry;
+};
+
+struct options {
+	RB_HEAD(options_tree, options_entry) tree;
+	struct options	*parent;
+};
+
+/* Scheduled job. */
+struct job {
+	char		*cmd;
+	pid_t		 pid;
+	int		 status;
+
+	int		 fd;
+	struct bufferevent *event;
+
+	void		(*callbackfn)(struct job *);
+	void		(*freefn)(void *);
+	void		*data;
+
+	LIST_ENTRY(job)	 lentry;
+};
+LIST_HEAD(joblist, job);
+
+/* Screen selection. */
+struct screen_sel {
+	int		 flag;
+	int		 rectflag;
+
+	u_int		 sx;
+	u_int		 sy;
+
+	u_int		 ex;
+	u_int		 ey;
+
+	struct grid_cell cell;
+};
+
+/* Virtual screen. */
+struct screen {
+	char		*title;
+
+	struct grid	*grid;		/* grid data */
+
+	u_int		 cx;		/* cursor x */
+	u_int		 cy;		/* cursor y */
+
+	u_int		 cstyle;	/* cursor style */
+	char		*ccolour;	/* cursor colour string */
+
+	u_int		 rupper;	/* scroll region top */
+	u_int		 rlower;	/* scroll region bottom */
+
+	int		 mode;
+
+	bitstr_t	*tabs;
+
+	struct screen_sel sel;
+};
+
+/* Screen write context. */
+struct screen_write_ctx {
+	struct window_pane *wp;
+	struct screen	*s;
+};
+
+/* Screen size. */
+#define screen_size_x(s) ((s)->grid->sx)
+#define screen_size_y(s) ((s)->grid->sy)
+#define screen_hsize(s) ((s)->grid->hsize)
+#define screen_hlimit(s) ((s)->grid->hlimit)
+
+/* Input parser context. */
+struct input_ctx {
+	struct window_pane     *wp;
+	struct screen_write_ctx ctx;
+
+	struct grid_cell	cell;
+
+	struct grid_cell	old_cell;
+	u_int 			old_cx;
+	u_int			old_cy;
+
+	u_char			interm_buf[4];
+	size_t			interm_len;
+
+	u_char			param_buf[64];
+	size_t			param_len;
+
+	u_char			input_buf[256];
+	size_t			input_len;
+
+	int			param_list[24];	/* -1 not present */
+	u_int			param_list_len;
+
+	struct utf8_data	utf8data;
+
+	int			ch;
+	int			flags;
+#define INPUT_DISCARD 0x1
+
+	const struct input_state *state;
+
+	/*
+	 * All input received since we were last in the ground state. Sent to
+	 * control clients on connection.
+	 */
+	struct evbuffer	 	*since_ground;
+};
+
+/*
+ * Window mode. Windows can be in several modes and this is used to call the
+ * right function to handle input and output.
+ */
+struct session;
+struct window;
+struct mouse_event;
+struct window_mode {
+	struct screen *(*init)(struct window_pane *);
+	void	(*free)(struct window_pane *);
+	void	(*resize)(struct window_pane *, u_int, u_int);
+	void	(*key)(struct window_pane *, struct session *, int);
+	void	(*mouse)(struct window_pane *,
+		    struct session *, struct mouse_event *);
+	void	(*timer)(struct window_pane *);
+};
+
+/* Structures for choose mode. */
+struct window_choose_data {
+	struct client		*start_client;
+	struct session		*start_session;
+
+	u_int			 idx;
+	int			 type;
+#define TREE_OTHER 0x0
+#define TREE_WINDOW 0x1
+#define TREE_SESSION 0x2
+
+	struct session		*tree_session; /* session of items in tree */
+
+	struct winlink		*wl;
+	int			 pane_id;
+
+	char		        *ft_template;
+	struct format_tree	*ft;
+
+	char			*command;
+};
+
+struct window_choose_mode_item {
+	struct window_choose_data	*wcd;
+	char				*name;
+	int				 pos;
+	int				 state;
+#define TREE_EXPANDED 0x1
+};
+
+/* Child window structure. */
+struct window_pane {
+	u_int		 id;
+
+	struct window	*window;
+
+	struct layout_cell *layout_cell;
+	struct layout_cell *saved_layout_cell;
+
+	u_int		 sx;
+	u_int		 sy;
+
+	u_int		 xoff;
+	u_int		 yoff;
+
+	int		 flags;
+#define PANE_REDRAW 0x1
+#define PANE_DROP 0x2
+#define PANE_FOCUSED 0x4
+#define PANE_RESIZE 0x8
+
+	char		*cmd;
+	char		*shell;
+	char		*cwd;
+
+	pid_t		 pid;
+	char		 tty[TTY_NAME_MAX];
+
+	u_int		 changes;
+	struct event	 changes_timer;
+	u_int		 changes_redraw;
+
+	int		 fd;
+	struct bufferevent *event;
+
+	struct input_ctx ictx;
+
+	int		 pipe_fd;
+	struct bufferevent *pipe_event;
+	size_t		 pipe_off;
+
+	struct screen	*screen;
+	struct screen	 base;
+
+	/* Saved in alternative screen mode. */
+	u_int		 saved_cx;
+	u_int		 saved_cy;
+	struct grid	*saved_grid;
+	struct grid_cell saved_cell;
+
+	const struct window_mode *mode;
+	void		*modedata;
+
+	TAILQ_ENTRY(window_pane) entry;
+	RB_ENTRY(window_pane) tree_entry;
+};
+TAILQ_HEAD(window_panes, window_pane);
+RB_HEAD(window_pane_tree, window_pane);
+
+/* Window structure. */
+struct window {
+	u_int		 id;
+	char		*name;
+	struct event	 name_timer;
+	struct timeval   silence_timer;
+
+	struct window_pane *active;
+	struct window_pane *last;
+	struct window_panes panes;
+
+	int		 lastlayout;
+	struct layout_cell *layout_root;
+	struct layout_cell *saved_layout_root;
+
+	u_int		 sx;
+	u_int		 sy;
+
+	int		 flags;
+#define WINDOW_BELL 0x1
+#define WINDOW_ACTIVITY 0x2
+#define WINDOW_REDRAW 0x4
+#define WINDOW_SILENCE 0x8
+#define WINDOW_ZOOMED 0x10
+
+	struct options	 options;
+
+	u_int		 references;
+};
+ARRAY_DECL(windows, struct window *);
+
+/* Entry on local window list. */
+struct winlink {
+	int		 idx;
+	struct window	*window;
+
+	size_t		 status_width;
+	struct grid_cell status_cell;
+	char		*status_text;
+
+	int              flags;
+#define WINLINK_BELL 0x1
+#define WINLINK_ACTIVITY 0x2
+#define WINLINK_CONTENT 0x4
+#define WINLINK_SILENCE 0x8
+#define WINLINK_ALERTFLAGS \
+    (WINLINK_BELL|WINLINK_ACTIVITY|WINLINK_CONTENT|WINLINK_SILENCE)
+
+	RB_ENTRY(winlink) entry;
+	TAILQ_ENTRY(winlink) sentry;
+};
+RB_HEAD(winlinks, winlink);
+TAILQ_HEAD(winlink_stack, winlink);
+
+/* Layout direction. */
+enum layout_type {
+	LAYOUT_LEFTRIGHT,
+	LAYOUT_TOPBOTTOM,
+	LAYOUT_WINDOWPANE
+};
+
+/* Layout cells queue. */
+TAILQ_HEAD(layout_cells, layout_cell);
+
+/* Layout cell. */
+struct layout_cell {
+	enum layout_type type;
+
+	struct layout_cell *parent;
+
+	u_int		 sx;
+	u_int		 sy;
+
+	u_int		 xoff;
+	u_int		 yoff;
+
+	struct window_pane *wp;
+	struct layout_cells cells;
+
+	TAILQ_ENTRY(layout_cell) entry;
+};
+
+/* Paste buffer. */
+struct paste_buffer {
+	char		*data;
+	size_t		 size;
+};
+ARRAY_DECL(paste_stack, struct paste_buffer *);
+
+/* Environment variable. */
+struct environ_entry {
+	char		*name;
+	char		*value;
+
+	RB_ENTRY(environ_entry) entry;
+};
+RB_HEAD(environ, environ_entry);
+
+/* Client session. */
+struct session_group {
+	TAILQ_HEAD(, session) sessions;
+
+	TAILQ_ENTRY(session_group) entry;
+};
+TAILQ_HEAD(session_groups, session_group);
+
+struct session {
+	u_int		 id;
+
+	char		*name;
+	char		*cwd;
+
+	struct timeval	 creation_time;
+	struct timeval	 activity_time;
+	struct timeval	 last_activity_time;
+
+	u_int		 sx;
+	u_int		 sy;
+
+	struct winlink	*curw;
+	struct winlink_stack lastw;
+	struct winlinks	 windows;
+
+	struct options	 options;
+
+#define SESSION_UNATTACHED 0x1	/* not attached to any clients */
+	int		 flags;
+
+	struct termios	*tio;
+
+	struct environ	 environ;
+
+	int		 references;
+
+	TAILQ_ENTRY(session) gentry;
+	RB_ENTRY(session)    entry;
+};
+RB_HEAD(sessions, session);
+ARRAY_DECL(sessionslist, struct session *);
+
+/* TTY information. */
+struct tty_key {
+	char		 ch;
+	int		 key;
+
+	struct tty_key	*left;
+	struct tty_key	*right;
+
+	struct tty_key	*next;
+};
+
+struct tty_term {
+	char		*name;
+	u_int		 references;
+
+	char		 acs[UCHAR_MAX + 1][2];
+
+	struct tty_code	 codes[NTTYCODE];
+
+#define TERM_256COLOURS 0x1
+#define TERM_EARLYWRAP 0x2
+	int		 flags;
+
+	LIST_ENTRY(tty_term) entry;
+};
+LIST_HEAD(tty_terms, tty_term);
+
+/* Mouse wheel states. */
+#define MOUSE_WHEEL_UP 0
+#define MOUSE_WHEEL_DOWN 1
+
+/* Mouse events. */
+#define MOUSE_EVENT_DOWN (1 << 0)
+#define MOUSE_EVENT_DRAG (1 << 1)
+#define MOUSE_EVENT_UP (1 << 2)
+#define MOUSE_EVENT_CLICK (1 << 3)
+#define MOUSE_EVENT_WHEEL (1 << 4)
+
+/* Mouse flags. */
+#define MOUSE_RESIZE_PANE (1 << 0)
+
+/*
+ * Mouse input. When sent by xterm:
+ *
+ * - buttons are in the bottom two bits: 0 = b1; 1 = b2; 2 = b3; 3 = released
+ * - bits 3, 4 and 5 are for keys
+ * - bit 6 is set for dragging
+ * - bit 7 for buttons 4 and 5
+ *
+ * With the SGR 1006 extension the released button becomes known. Store these
+ * in separate fields and store the value converted to the old format in xb.
+ */
+struct mouse_event {
+	u_int	xb;
+
+	u_int	x;
+	u_int	lx;
+	u_int	sx;
+
+	u_int	y;
+	u_int	ly;
+	u_int	sy;
+
+	u_int   sgr;		/* whether the input arrived in SGR format */
+	u_int   sgr_xb;		/* only for SGR: the unmangled button */
+	u_int   sgr_rel;	/* only for SGR: if it is a release event */
+
+	u_int	button;
+	u_int	clicks;
+
+	int	wheel;
+	int     event;
+	int     flags;
+};
+
+struct tty {
+	struct client	*client;
+
+	char		*path;
+	u_int		 class;
+
+	u_int		 sx;
+	u_int		 sy;
+
+	u_int		 cx;
+	u_int		 cy;
+	u_int		 cstyle;
+	char		*ccolour;
+
+	int		 mode;
+
+	u_int		 rlower;
+	u_int		 rupper;
+
+	char		*termname;
+	struct tty_term	*term;
+
+	int		 fd;
+	struct bufferevent *event;
+
+	int		 log_fd;
+
+	struct termios	 tio;
+
+	struct grid_cell cell;
+
+#define TTY_NOCURSOR 0x1
+#define TTY_FREEZE 0x2
+#define TTY_TIMER 0x4
+#define TTY_UTF8 0x8
+#define TTY_STARTED 0x10
+#define TTY_OPENED 0x20
+	int		 flags;
+
+	int		 term_flags;
+
+	struct mouse_event mouse;
+
+	struct event	 key_timer;
+	struct tty_key	*key_tree;
+};
+
+/* TTY command context and function pointer. */
+struct tty_ctx {
+	struct window_pane *wp;
+
+	const struct grid_cell *cell;
+
+	u_int		 num;
+	void		*ptr;
+
+	/*
+	 * Cursor and region position before the screen was updated - this is
+	 * where the command should be applied; the values in the screen have
+	 * already been updated.
+	 */
+	u_int		 ocx;
+	u_int		 ocy;
+
+	u_int		 orupper;
+	u_int		 orlower;
+
+	u_int		 xoff;
+	u_int		 yoff;
+
+	/* Saved last cell on line. */
+	struct grid_cell last_cell;
+	u_int		 last_width;
+};
+
+/* Saved message entry. */
+struct message_entry {
+	char   *msg;
+	time_t	msg_time;
+};
+
+/* Status output data from a job. */
+struct status_out {
+	char   *cmd;
+	char   *out;
+
+	RB_ENTRY(status_out) entry;
+};
+RB_HEAD(status_out_tree, status_out);
+
+/* Client connection. */
+struct client {
+	struct imsgbuf	 ibuf;
+	struct event	 event;
+	int		 retcode;
+
+	struct timeval	 creation_time;
+	struct timeval	 activity_time;
+
+	struct environ	 environ;
+
+	char		*title;
+	char		*cwd;
+
+	struct tty	 tty;
+
+	void		(*stdin_callback)(struct client *, int, void *);
+	void		*stdin_callback_data;
+	struct evbuffer	*stdin_data;
+	int              stdin_closed;
+	struct evbuffer	*stdout_data;
+	struct evbuffer	*stderr_data;
+
+	struct event	 repeat_timer;
+
+	struct status_out_tree status_old;
+	struct status_out_tree status_new;
+	struct timeval	 status_timer;
+	struct screen	 status;
+
+#define CLIENT_TERMINAL 0x1
+#define CLIENT_PREFIX 0x2
+#define CLIENT_EXIT 0x4
+#define CLIENT_REDRAW 0x8
+#define CLIENT_STATUS 0x10
+#define CLIENT_REPEAT 0x20 /* allow command to repeat within repeat time */
+#define CLIENT_SUSPENDED 0x40
+#define CLIENT_BAD 0x80
+#define CLIENT_IDENTIFY 0x100
+#define CLIENT_DEAD 0x200
+#define CLIENT_BORDERS 0x400
+#define CLIENT_READONLY 0x800
+#define CLIENT_REDRAWWINDOW 0x1000
+#define CLIENT_CONTROL 0x2000
+#define CLIENT_FOCUSED 0x4000
+	int		 flags;
+
+	struct event	 identify_timer;
+
+	char		*message_string;
+	struct event	 message_timer;
+	ARRAY_DECL(, struct message_entry) message_log;
+
+	char		*prompt_string;
+	char		*prompt_buffer;
+	size_t		 prompt_index;
+	int		 (*prompt_callbackfn)(void *, const char *);
+	void		 (*prompt_freefn)(void *);
+	void		*prompt_data;
+	u_int            prompt_hindex;
+
+#define PROMPT_SINGLE 0x1
+	int		 prompt_flags;
+
+	struct mode_key_data prompt_mdata;
+
+	struct session	*session;
+	struct session	*last_session;
+
+	int		 wlmouse;
+
+	struct cmd_q	*cmdq;
+	int		 references;
+};
+ARRAY_DECL(clients, struct client *);
+
+/* Parsed arguments. */
+struct args {
+	bitstr_t	*flags;
+	char		*values[SCHAR_MAX]; /* XXX This is awfully big. */
+
+	int		 argc;
+	char	       **argv;
+};
+
+/* Command and list of commands. */
+struct cmd {
+	const struct cmd_entry	*entry;
+	struct args		*args;
+
+	char			*file;
+	u_int			 line;
+
+	TAILQ_ENTRY(cmd)	 qentry;
+};
+struct cmd_list {
+	int		 	 references;
+	TAILQ_HEAD(, cmd) 	 list;
+};
+
+/* Command return values. */
+enum cmd_retval {
+	CMD_RETURN_ERROR = -1,
+	CMD_RETURN_NORMAL = 0,
+	CMD_RETURN_WAIT,
+	CMD_RETURN_STOP
+};
+
+/* Command queue entry. */
+struct cmd_q_item {
+	struct cmd_list		*cmdlist;
+	TAILQ_ENTRY(cmd_q_item)	 qentry;
+};
+TAILQ_HEAD(cmd_q_items, cmd_q_item);
+
+/* Command queue. */
+struct cmd_q {
+	int			 references;
+	int			 dead;
+
+	struct client		*client;
+	int			 client_exit;
+
+	struct cmd_q_items	 queue;
+	struct cmd_q_item	*item;
+	struct cmd		*cmd;
+
+	time_t			 time;
+	u_int			 number;
+
+	void			 (*emptyfn)(struct cmd_q *);
+	void			*data;
+
+	struct msg_command_data	*msgdata;
+
+	TAILQ_ENTRY(cmd_q)       waitentry;
+};
+
+/* Command definition. */
+struct cmd_entry {
+	const char	*name;
+	const char	*alias;
+
+	const char	*args_template;
+	int		 args_lower;
+	int		 args_upper;
+
+	const char	*usage;
+
+#define CMD_STARTSERVER 0x1
+#define CMD_CANTNEST 0x2
+#define CMD_SENDENVIRON 0x4
+#define CMD_READONLY 0x8
+	int		 flags;
+
+	void		 (*key_binding)(struct cmd *, int);
+	int		 (*check)(struct args *);
+	enum cmd_retval	 (*exec)(struct cmd *, struct cmd_q *);
+};
+
+/* Key binding. */
+struct key_binding {
+	int		 key;
+	struct cmd_list	*cmdlist;
+	int		 can_repeat;
+
+	RB_ENTRY(key_binding) entry;
+};
+RB_HEAD(key_bindings, key_binding);
+
+/*
+ * Option table entries. The option table is the user-visible part of the
+ * option, as opposed to the internal options (struct option) which are just
+ * number or string.
+ */
+enum options_table_type {
+	OPTIONS_TABLE_STRING,
+	OPTIONS_TABLE_NUMBER,
+	OPTIONS_TABLE_KEY,
+	OPTIONS_TABLE_COLOUR,
+	OPTIONS_TABLE_ATTRIBUTES,
+	OPTIONS_TABLE_FLAG,
+	OPTIONS_TABLE_CHOICE
+};
+
+struct options_table_entry {
+	const char	       *name;
+	enum options_table_type	type;
+
+	u_int		 	minimum;
+	u_int		 	maximum;
+	const char	      **choices;
+
+	const char	       *default_str;
+	long long		default_num;
+};
+
+/* Tree of format entries. */
+struct format_entry {
+	char		       *key;
+	char		       *value;
+
+	RB_ENTRY(format_entry)	entry;
+};
+RB_HEAD(format_tree, format_entry);
+
+/* Common command usages. */
+#define CMD_TARGET_PANE_USAGE "[-t target-pane]"
+#define CMD_TARGET_WINDOW_USAGE "[-t target-window]"
+#define CMD_TARGET_SESSION_USAGE "[-t target-session]"
+#define CMD_TARGET_CLIENT_USAGE "[-t target-client]"
+#define CMD_SRCDST_PANE_USAGE "[-s src-pane] [-t dst-pane]"
+#define CMD_SRCDST_WINDOW_USAGE "[-s src-window] [-t dst-window]"
+#define CMD_SRCDST_SESSION_USAGE "[-s src-session] [-t dst-session]"
+#define CMD_SRCDST_CLIENT_USAGE "[-s src-client] [-t dst-client]"
+#define CMD_BUFFER_USAGE "[-b buffer-index]"
+
+/* tmux.c */
+extern struct options global_options;
+extern struct options global_s_options;
+extern struct options global_w_options;
+extern struct environ global_environ;
+extern struct event_base *ev_base;
+extern char	*cfg_file;
+extern char	*shell_cmd;
+extern int	 debug_level;
+extern time_t	 start_time;
+extern char	 socket_path[MAXPATHLEN];
+extern int	 login_shell;
+extern char	*environ_path;
+extern pid_t	 environ_pid;
+extern int	 environ_session_id;
+void		 logfile(const char *);
+const char	*getshell(void);
+int		 checkshell(const char *);
+int		 areshell(const char *);
+const char*	 get_full_path(const char *, const char *);
+void		 setblocking(int, int);
+__dead void	 shell_exec(const char *, const char *);
+
+/* cfg.c */
+extern struct cmd_q *cfg_cmd_q;
+extern int cfg_finished;
+extern int cfg_references;
+extern struct causelist cfg_causes;
+int		 load_cfg(const char *, struct cmd_q *, char **);
+void		 cfg_default_done(struct cmd_q *);
+void		 cfg_show_causes(struct session *);
+
+/* format.c */
+int		 format_cmp(struct format_entry *, struct format_entry *);
+RB_PROTOTYPE(format_tree, format_entry, entry, format_cmp);
+struct format_tree *format_create(void);
+void		 format_free(struct format_tree *);
+void printflike3 format_add(
+		     struct format_tree *, const char *, const char *, ...);
+const char	*format_find(struct format_tree *, const char *);
+char		*format_expand(struct format_tree *, const char *);
+void		 format_session(struct format_tree *, struct session *);
+void		 format_client(struct format_tree *, struct client *);
+void		 format_winlink(
+		     struct format_tree *, struct session *, struct winlink *);
+void		 format_window_pane(struct format_tree *, struct window_pane *);
+void		 format_paste_buffer(struct format_tree *, struct paste_buffer *);
+
+/* mode-key.c */
+extern const struct mode_key_table mode_key_tables[];
+extern struct mode_key_tree mode_key_tree_vi_edit;
+extern struct mode_key_tree mode_key_tree_vi_choice;
+extern struct mode_key_tree mode_key_tree_vi_copy;
+extern struct mode_key_tree mode_key_tree_emacs_edit;
+extern struct mode_key_tree mode_key_tree_emacs_choice;
+extern struct mode_key_tree mode_key_tree_emacs_copy;
+int	mode_key_cmp(struct mode_key_binding *, struct mode_key_binding *);
+RB_PROTOTYPE(mode_key_tree, mode_key_binding, entry, mode_key_cmp);
+const char *mode_key_tostring(const struct mode_key_cmdstr *,
+	    enum mode_key_cmd);
+enum mode_key_cmd mode_key_fromstring(const struct mode_key_cmdstr *,
+	    const char *);
+const struct mode_key_table *mode_key_findtable(const char *);
+void	mode_key_init_trees(void);
+void	mode_key_init(struct mode_key_data *, struct mode_key_tree *);
+enum mode_key_cmd mode_key_lookup(struct mode_key_data *, int, const char **);
+
+/* notify.c */
+void	notify_enable(void);
+void	notify_disable(void);
+void	notify_input(struct window_pane *, struct evbuffer *);
+void	notify_window_layout_changed(struct window *);
+void	notify_window_unlinked(struct session *, struct window *);
+void	notify_window_linked(struct session *, struct window *);
+void	notify_window_renamed(struct window *);
+void	notify_attached_session_changed(struct client *);
+void	notify_session_renamed(struct session *);
+void	notify_session_created(struct session *);
+void	notify_session_closed(struct session *);
+
+/* options.c */
+int	options_cmp(struct options_entry *, struct options_entry *);
+RB_PROTOTYPE(options_tree, options_entry, entry, options_cmp);
+void	options_init(struct options *, struct options *);
+void	options_free(struct options *);
+struct options_entry *options_find1(struct options *, const char *);
+struct options_entry *options_find(struct options *, const char *);
+void	options_remove(struct options *, const char *);
+struct options_entry *printflike3 options_set_string(
+	    struct options *, const char *, const char *, ...);
+char   *options_get_string(struct options *, const char *);
+struct options_entry *options_set_number(
+	    struct options *, const char *, long long);
+long long options_get_number(struct options *, const char *);
+
+/* options-table.c */
+extern const struct options_table_entry server_options_table[];
+extern const struct options_table_entry session_options_table[];
+extern const struct options_table_entry window_options_table[];
+void	options_table_populate_tree(const struct options_table_entry *,
+	    struct options *);
+const char *options_table_print_entry(const struct options_table_entry *,
+	    struct options_entry *, int);
+int	options_table_find(const char *, const struct options_table_entry **,
+	    const struct options_table_entry **);
+
+/* job.c */
+extern struct joblist all_jobs;
+struct job *job_run(const char *, struct session *,
+	    void (*)(struct job *), void (*)(void *), void *);
+void	job_free(struct job *);
+void	job_died(struct job *, int);
+
+/* environ.c */
+int	environ_cmp(struct environ_entry *, struct environ_entry *);
+RB_PROTOTYPE(environ, environ_entry, entry, environ_cmp);
+void	environ_init(struct environ *);
+void	environ_free(struct environ *);
+void	environ_copy(struct environ *, struct environ *);
+struct environ_entry *environ_find(struct environ *, const char *);
+void	environ_set(struct environ *, const char *, const char *);
+void	environ_put(struct environ *, const char *);
+void	environ_unset(struct environ *, const char *);
+void	environ_update(const char *, struct environ *, struct environ *);
+void	environ_push(struct environ *);
+
+/* tty.c */
+void	tty_init_termios(int, struct termios *, struct bufferevent *);
+void	tty_raw(struct tty *, const char *);
+void	tty_attributes(struct tty *, const struct grid_cell *);
+void	tty_reset(struct tty *);
+void	tty_region_pane(struct tty *, const struct tty_ctx *, u_int, u_int);
+void	tty_region(struct tty *, u_int, u_int);
+void	tty_cursor_pane(struct tty *, const struct tty_ctx *, u_int, u_int);
+void	tty_cursor(struct tty *, u_int, u_int);
+void	tty_putcode(struct tty *, enum tty_code_code);
+void	tty_putcode1(struct tty *, enum tty_code_code, int);
+void	tty_putcode2(struct tty *, enum tty_code_code, int, int);
+void	tty_putcode_ptr1(struct tty *, enum tty_code_code, const void *);
+void	tty_putcode_ptr2(struct tty *, enum tty_code_code, const void *,
+	    const void *);
+void	tty_puts(struct tty *, const char *);
+void	tty_putc(struct tty *, u_char);
+void	tty_putn(struct tty *, const void *, size_t, u_int);
+void	tty_init(struct tty *, struct client *, int, char *);
+int	tty_resize(struct tty *);
+int	tty_set_size(struct tty *, u_int, u_int);
+void	tty_set_class(struct tty *, u_int);
+void	tty_start_tty(struct tty *);
+void	tty_stop_tty(struct tty *);
+void	tty_set_title(struct tty *, const char *);
+void	tty_update_mode(struct tty *, int, struct screen *);
+void	tty_force_cursor_colour(struct tty *, const char *);
+void	tty_draw_line(struct tty *, struct screen *, u_int, u_int, u_int);
+int	tty_open(struct tty *, const char *, char **);
+void	tty_close(struct tty *);
+void	tty_free(struct tty *);
+void	tty_write(
+	    void (*)(struct tty *, const struct tty_ctx *), struct tty_ctx *);
+void	tty_cmd_alignmenttest(struct tty *, const struct tty_ctx *);
+void	tty_cmd_cell(struct tty *, const struct tty_ctx *);
+void	tty_cmd_clearendofline(struct tty *, const struct tty_ctx *);
+void	tty_cmd_clearendofscreen(struct tty *, const struct tty_ctx *);
+void	tty_cmd_clearline(struct tty *, const struct tty_ctx *);
+void	tty_cmd_clearscreen(struct tty *, const struct tty_ctx *);
+void	tty_cmd_clearstartofline(struct tty *, const struct tty_ctx *);
+void	tty_cmd_clearstartofscreen(struct tty *, const struct tty_ctx *);
+void	tty_cmd_deletecharacter(struct tty *, const struct tty_ctx *);
+void	tty_cmd_clearcharacter(struct tty *, const struct tty_ctx *);
+void	tty_cmd_deleteline(struct tty *, const struct tty_ctx *);
+void	tty_cmd_erasecharacter(struct tty *, const struct tty_ctx *);
+void	tty_cmd_insertcharacter(struct tty *, const struct tty_ctx *);
+void	tty_cmd_insertline(struct tty *, const struct tty_ctx *);
+void	tty_cmd_linefeed(struct tty *, const struct tty_ctx *);
+void	tty_cmd_utf8character(struct tty *, const struct tty_ctx *);
+void	tty_cmd_reverseindex(struct tty *, const struct tty_ctx *);
+void	tty_cmd_setselection(struct tty *, const struct tty_ctx *);
+void	tty_cmd_rawstring(struct tty *, const struct tty_ctx *);
+void	tty_bell(struct tty *);
+
+/* tty-term.c */
+extern struct tty_terms tty_terms;
+extern const struct tty_term_code_entry tty_term_codes[NTTYCODE];
+struct tty_term *tty_term_find(char *, int, const char *, char **);
+void		 tty_term_free(struct tty_term *);
+int		 tty_term_has(struct tty_term *, enum tty_code_code);
+const char	*tty_term_string(struct tty_term *, enum tty_code_code);
+const char	*tty_term_string1(struct tty_term *, enum tty_code_code, int);
+const char	*tty_term_string2(
+		     struct tty_term *, enum tty_code_code, int, int);
+const char	*tty_term_ptr1(
+		     struct tty_term *, enum tty_code_code, const void *);
+const char	*tty_term_ptr2(struct tty_term *, enum tty_code_code,
+		     const void *, const void *);
+int		 tty_term_number(struct tty_term *, enum tty_code_code);
+int		 tty_term_flag(struct tty_term *, enum tty_code_code);
+
+/* tty-acs.c */
+const char	*tty_acs_get(struct tty *, u_char);
+
+/* tty-keys.c */
+void	tty_keys_build(struct tty *);
+void	tty_keys_free(struct tty *);
+int	tty_keys_next(struct tty *);
+
+/* paste.c */
+struct paste_buffer *paste_walk_stack(struct paste_stack *, u_int *);
+struct paste_buffer *paste_get_top(struct paste_stack *);
+struct paste_buffer *paste_get_index(struct paste_stack *, u_int);
+int		 paste_free_top(struct paste_stack *);
+int		 paste_free_index(struct paste_stack *, u_int);
+void		 paste_add(struct paste_stack *, char *, size_t, u_int);
+int		 paste_replace(struct paste_stack *, u_int, char *, size_t);
+char		*paste_print(struct paste_buffer *, size_t);
+void		 paste_send_pane(struct paste_buffer *, struct window_pane *,
+		     const char *, int);
+
+/* clock.c */
+extern const char clock_table[14][5][5];
+void		 clock_draw(struct screen_write_ctx *, int, int);
+
+/* arguments.c */
+struct args	*args_create(int, ...);
+struct args	*args_parse(const char *, int, char **);
+void		 args_free(struct args *);
+size_t		 args_print(struct args *, char *, size_t);
+int		 args_has(struct args *, u_char);
+void		 args_set(struct args *, u_char, const char *);
+const char	*args_get(struct args *, u_char);
+long long	 args_strtonum(
+		    struct args *, u_char, long long, long long, char **);
+
+/* cmd.c */
+int		 cmd_pack_argv(int, char **, char *, size_t);
+int		 cmd_unpack_argv(char *, size_t, int, char ***);
+char	       **cmd_copy_argv(int, char *const *);
+void		 cmd_free_argv(int, char **);
+struct cmd	*cmd_parse(int, char **, const char *, u_int, char **);
+size_t		 cmd_print(struct cmd *, char *, size_t);
+struct session	*cmd_current_session(struct cmd_q *, int);
+struct client	*cmd_current_client(struct cmd_q *);
+struct client	*cmd_find_client(struct cmd_q *, const char *, int);
+struct session	*cmd_find_session(struct cmd_q *, const char *, int);
+struct winlink	*cmd_find_window(struct cmd_q *, const char *,
+		     struct session **);
+int		 cmd_find_index(struct cmd_q *, const char *,
+		     struct session **);
+struct winlink	*cmd_find_pane(struct cmd_q *, const char *, struct session **,
+		     struct window_pane **);
+char		*cmd_template_replace(const char *, const char *, int);
+const char     	*cmd_get_default_path(struct cmd_q *, const char *);
+extern const struct cmd_entry *cmd_table[];
+extern const struct cmd_entry cmd_attach_session_entry;
+extern const struct cmd_entry cmd_bind_key_entry;
+extern const struct cmd_entry cmd_break_pane_entry;
+extern const struct cmd_entry cmd_capture_pane_entry;
+extern const struct cmd_entry cmd_choose_buffer_entry;
+extern const struct cmd_entry cmd_choose_client_entry;
+extern const struct cmd_entry cmd_choose_list_entry;
+extern const struct cmd_entry cmd_choose_session_entry;
+extern const struct cmd_entry cmd_choose_tree_entry;
+extern const struct cmd_entry cmd_choose_window_entry;
+extern const struct cmd_entry cmd_clear_history_entry;
+extern const struct cmd_entry cmd_clock_mode_entry;
+extern const struct cmd_entry cmd_command_prompt_entry;
+extern const struct cmd_entry cmd_confirm_before_entry;
+extern const struct cmd_entry cmd_copy_mode_entry;
+extern const struct cmd_entry cmd_delete_buffer_entry;
+extern const struct cmd_entry cmd_detach_client_entry;
+extern const struct cmd_entry cmd_display_message_entry;
+extern const struct cmd_entry cmd_display_panes_entry;
+extern const struct cmd_entry cmd_down_pane_entry;
+extern const struct cmd_entry cmd_find_window_entry;
+extern const struct cmd_entry cmd_has_session_entry;
+extern const struct cmd_entry cmd_if_shell_entry;
+extern const struct cmd_entry cmd_join_pane_entry;
+extern const struct cmd_entry cmd_kill_pane_entry;
+extern const struct cmd_entry cmd_kill_server_entry;
+extern const struct cmd_entry cmd_kill_session_entry;
+extern const struct cmd_entry cmd_kill_window_entry;
+extern const struct cmd_entry cmd_last_pane_entry;
+extern const struct cmd_entry cmd_last_window_entry;
+extern const struct cmd_entry cmd_link_window_entry;
+extern const struct cmd_entry cmd_list_buffers_entry;
+extern const struct cmd_entry cmd_list_clients_entry;
+extern const struct cmd_entry cmd_list_commands_entry;
+extern const struct cmd_entry cmd_list_keys_entry;
+extern const struct cmd_entry cmd_list_panes_entry;
+extern const struct cmd_entry cmd_list_sessions_entry;
+extern const struct cmd_entry cmd_list_windows_entry;
+extern const struct cmd_entry cmd_load_buffer_entry;
+extern const struct cmd_entry cmd_lock_client_entry;
+extern const struct cmd_entry cmd_lock_server_entry;
+extern const struct cmd_entry cmd_lock_session_entry;
+extern const struct cmd_entry cmd_move_pane_entry;
+extern const struct cmd_entry cmd_move_window_entry;
+extern const struct cmd_entry cmd_new_session_entry;
+extern const struct cmd_entry cmd_new_window_entry;
+extern const struct cmd_entry cmd_next_layout_entry;
+extern const struct cmd_entry cmd_next_window_entry;
+extern const struct cmd_entry cmd_paste_buffer_entry;
+extern const struct cmd_entry cmd_pipe_pane_entry;
+extern const struct cmd_entry cmd_previous_layout_entry;
+extern const struct cmd_entry cmd_previous_window_entry;
+extern const struct cmd_entry cmd_refresh_client_entry;
+extern const struct cmd_entry cmd_rename_session_entry;
+extern const struct cmd_entry cmd_rename_window_entry;
+extern const struct cmd_entry cmd_resize_pane_entry;
+extern const struct cmd_entry cmd_respawn_pane_entry;
+extern const struct cmd_entry cmd_respawn_window_entry;
+extern const struct cmd_entry cmd_rotate_window_entry;
+extern const struct cmd_entry cmd_run_shell_entry;
+extern const struct cmd_entry cmd_save_buffer_entry;
+extern const struct cmd_entry cmd_select_layout_entry;
+extern const struct cmd_entry cmd_select_pane_entry;
+extern const struct cmd_entry cmd_select_window_entry;
+extern const struct cmd_entry cmd_send_keys_entry;
+extern const struct cmd_entry cmd_send_prefix_entry;
+extern const struct cmd_entry cmd_server_info_entry;
+extern const struct cmd_entry cmd_set_buffer_entry;
+extern const struct cmd_entry cmd_set_environment_entry;
+extern const struct cmd_entry cmd_set_option_entry;
+extern const struct cmd_entry cmd_set_window_option_entry;
+extern const struct cmd_entry cmd_show_buffer_entry;
+extern const struct cmd_entry cmd_show_environment_entry;
+extern const struct cmd_entry cmd_show_messages_entry;
+extern const struct cmd_entry cmd_show_options_entry;
+extern const struct cmd_entry cmd_show_window_options_entry;
+extern const struct cmd_entry cmd_source_file_entry;
+extern const struct cmd_entry cmd_split_window_entry;
+extern const struct cmd_entry cmd_start_server_entry;
+extern const struct cmd_entry cmd_suspend_client_entry;
+extern const struct cmd_entry cmd_swap_pane_entry;
+extern const struct cmd_entry cmd_swap_window_entry;
+extern const struct cmd_entry cmd_switch_client_entry;
+extern const struct cmd_entry cmd_unbind_key_entry;
+extern const struct cmd_entry cmd_unlink_window_entry;
+extern const struct cmd_entry cmd_up_pane_entry;
+extern const struct cmd_entry cmd_wait_for_entry;
+
+/* cmd-attach-session.c */
+enum cmd_retval	 cmd_attach_session(struct cmd_q *, const char*, int, int);
+
+/* cmd-list.c */
+struct cmd_list	*cmd_list_parse(int, char **, const char *, u_int, char **);
+void		 cmd_list_free(struct cmd_list *);
+size_t		 cmd_list_print(struct cmd_list *, char *, size_t);
+
+/* cmd-queue.c */
+struct cmd_q	*cmdq_new(struct client *);
+int		 cmdq_free(struct cmd_q *);
+void printflike2 cmdq_print(struct cmd_q *, const char *, ...);
+void printflike2 cmdq_info(struct cmd_q *, const char *, ...);
+void printflike2 cmdq_error(struct cmd_q *, const char *, ...);
+int		 cmdq_guard(struct cmd_q *, const char *);
+void		 cmdq_run(struct cmd_q *, struct cmd_list *);
+void		 cmdq_append(struct cmd_q *, struct cmd_list *);
+int		 cmdq_continue(struct cmd_q *);
+void		 cmdq_flush(struct cmd_q *);
+
+/* cmd-string.c */
+int	cmd_string_parse(const char *, struct cmd_list **, const char *,
+	    u_int, char **);
+
+/* client.c */
+int	client_main(int, char **, int);
+
+/* key-bindings.c */
+extern struct key_bindings key_bindings;
+int	 key_bindings_cmp(struct key_binding *, struct key_binding *);
+RB_PROTOTYPE(key_bindings, key_binding, entry, key_bindings_cmp);
+struct key_binding *key_bindings_lookup(int);
+void	 key_bindings_add(int, int, struct cmd_list *);
+void	 key_bindings_remove(int);
+void	 key_bindings_clean(void);
+void	 key_bindings_init(void);
+void	 key_bindings_dispatch(struct key_binding *, struct client *);
+
+/* key-string.c */
+int	 key_string_lookup_string(const char *);
+const char *key_string_lookup_key(int);
+
+/* server.c */
+extern struct clients clients;
+extern struct clients dead_clients;
+extern struct paste_stack global_buffers;
+int	 server_start(int, char *);
+void	 server_update_socket(void);
+void	 server_add_accept(int);
+
+/* server-client.c */
+void	 server_client_handle_key(struct client *, int);
+void	 server_client_create(int);
+int      server_client_open(struct client *, struct session *, char **);
+void	 server_client_lost(struct client *);
+void	 server_client_callback(int, short, void *);
+void	 server_client_status_timer(void);
+void	 server_client_loop(void);
+
+/* server-window.c */
+void	 server_window_loop(void);
+
+/* server-fn.c */
+void	 server_fill_environ(struct session *, struct environ *);
+void	 server_write_ready(struct client *);
+int	 server_write_client(
+	     struct client *, enum msgtype, const void *, size_t);
+void	 server_write_session(
+	     struct session *, enum msgtype, const void *, size_t);
+void	 server_redraw_client(struct client *);
+void	 server_status_client(struct client *);
+void	 server_redraw_session(struct session *);
+void	 server_redraw_session_group(struct session *);
+void	 server_status_session(struct session *);
+void	 server_status_session_group(struct session *);
+void	 server_redraw_window(struct window *);
+void	 server_redraw_window_borders(struct window *);
+void	 server_status_window(struct window *);
+void	 server_lock(void);
+void	 server_lock_session(struct session *);
+void	 server_lock_client(struct client *);
+int	 server_unlock(const char *);
+void	 server_kill_window(struct window *);
+int	 server_link_window(struct session *,
+	     struct winlink *, struct session *, int, int, int, char **);
+void	 server_unlink_window(struct session *, struct winlink *);
+void	 server_destroy_pane(struct window_pane *);
+void	 server_destroy_session_group(struct session *);
+void	 server_destroy_session(struct session *);
+void	 server_check_unattached(void);
+void	 server_set_identify(struct client *);
+void	 server_clear_identify(struct client *);
+void	 server_update_event(struct client *);
+void	 server_push_stdout(struct client *);
+void	 server_push_stderr(struct client *);
+int	 server_set_stdin_callback(struct client *, void (*)(struct client *,
+	     int, void *), void *, char **);
+void	 server_unzoom_window(struct window *);
+
+/* status.c */
+int	 status_out_cmp(struct status_out *, struct status_out *);
+RB_PROTOTYPE(status_out_tree, status_out, entry, status_out_cmp);
+int	 status_at_line(struct client *);
+void	 status_free_jobs(struct status_out_tree *);
+void	 status_update_jobs(struct client *);
+void	 status_set_window_at(struct client *, u_int);
+int	 status_redraw(struct client *);
+char	*status_replace(struct client *, struct session *,
+	     struct winlink *, struct window_pane *, const char *, time_t, int);
+void printflike2 status_message_set(struct client *, const char *, ...);
+void	 status_message_clear(struct client *);
+int	 status_message_redraw(struct client *);
+void	 status_prompt_set(struct client *, const char *, const char *,
+	     int (*)(void *, const char *), void (*)(void *), void *, int);
+void	 status_prompt_clear(struct client *);
+int	 status_prompt_redraw(struct client *);
+void	 status_prompt_key(struct client *, int);
+void	 status_prompt_update(struct client *, const char *, const char *);
+
+/* resize.c */
+void	 recalculate_sizes(void);
+
+/* input.c */
+void	 input_init(struct window_pane *);
+void	 input_free(struct window_pane *);
+void	 input_parse(struct window_pane *);
+
+/* input-key.c */
+void	 input_key(struct window_pane *, int);
+void	 input_mouse(struct window_pane *, struct session *,
+	     struct mouse_event *);
+
+/* xterm-keys.c */
+char	*xterm_keys_lookup(int);
+int	 xterm_keys_find(const char *, size_t, size_t *, int *);
+
+/* colour.c */
+void	 colour_set_fg(struct grid_cell *, int);
+void	 colour_set_bg(struct grid_cell *, int);
+const char *colour_tostring(int);
+int	 colour_fromstring(const char *);
+u_char	 colour_256to16(u_char);
+
+/* attributes.c */
+const char *attributes_tostring(u_char);
+int	 attributes_fromstring(const char *);
+
+/* grid.c */
+extern const struct grid_cell grid_default_cell;
+extern const struct grid_cell grid_marker_cell;
+struct grid *grid_create(u_int, u_int, u_int);
+void	 grid_destroy(struct grid *);
+int	 grid_compare(struct grid *, struct grid *);
+void	 grid_collect_history(struct grid *);
+void	 grid_scroll_history(struct grid *);
+void	 grid_scroll_history_region(struct grid *, u_int, u_int);
+void	 grid_expand_line(struct grid *, u_int, u_int);
+const struct grid_cell *grid_peek_cell(struct grid *, u_int, u_int);
+const struct grid_line *grid_peek_line(struct grid *, u_int);
+struct grid_cell *grid_get_cell(struct grid *, u_int, u_int);
+void	 grid_set_cell(struct grid *, u_int, u_int, const struct grid_cell *);
+void	 grid_clear(struct grid *, u_int, u_int, u_int, u_int);
+void	 grid_clear_lines(struct grid *, u_int, u_int);
+void	 grid_move_lines(struct grid *, u_int, u_int, u_int);
+void	 grid_move_cells(struct grid *, u_int, u_int, u_int, u_int);
+char	*grid_string_cells(struct grid *, u_int, u_int, u_int,
+	     struct grid_cell **, int, int, int);
+void	 grid_duplicate_lines(
+	     struct grid *, u_int, struct grid *, u_int, u_int);
+u_int	 grid_reflow(struct grid *, struct grid *, u_int);
+
+/* grid-cell.c */
+u_int	 grid_cell_width(const struct grid_cell *);
+void	 grid_cell_get(const struct grid_cell *, struct utf8_data *);
+void	 grid_cell_set(struct grid_cell *, const struct utf8_data *);
+void	 grid_cell_one(struct grid_cell *, u_char);
+
+/* grid-view.c */
+const struct grid_cell *grid_view_peek_cell(struct grid *, u_int, u_int);
+struct grid_cell *grid_view_get_cell(struct grid *, u_int, u_int);
+void	 grid_view_set_cell(
+	     struct grid *, u_int, u_int, const struct grid_cell *);
+void	 grid_view_clear_history(struct grid *);
+void	 grid_view_clear(struct grid *, u_int, u_int, u_int, u_int);
+void	 grid_view_scroll_region_up(struct grid *, u_int, u_int);
+void	 grid_view_scroll_region_down(struct grid *, u_int, u_int);
+void	 grid_view_insert_lines(struct grid *, u_int, u_int);
+void	 grid_view_insert_lines_region(struct grid *, u_int, u_int, u_int);
+void	 grid_view_delete_lines(struct grid *, u_int, u_int);
+void	 grid_view_delete_lines_region(struct grid *, u_int, u_int, u_int);
+void	 grid_view_insert_cells(struct grid *, u_int, u_int, u_int);
+void	 grid_view_delete_cells(struct grid *, u_int, u_int, u_int);
+char	*grid_view_string_cells(struct grid *, u_int, u_int, u_int);
+
+/* screen-write.c */
+void	 screen_write_start(
+	     struct screen_write_ctx *, struct window_pane *, struct screen *);
+void	 screen_write_stop(struct screen_write_ctx *);
+void	 screen_write_reset(struct screen_write_ctx *);
+size_t printflike2 screen_write_cstrlen(int, const char *, ...);
+void printflike5 screen_write_cnputs(struct screen_write_ctx *,
+	     ssize_t, struct grid_cell *, int, const char *, ...);
+size_t printflike2 screen_write_strlen(int, const char *, ...);
+void printflike3 screen_write_puts(struct screen_write_ctx *,
+	     struct grid_cell *, const char *, ...);
+void printflike5 screen_write_nputs(struct screen_write_ctx *,
+	     ssize_t, struct grid_cell *, int, const char *, ...);
+void	 screen_write_vnputs(struct screen_write_ctx *,
+	     ssize_t, struct grid_cell *, int, const char *, va_list);
+void	 screen_write_parsestyle(
+	     struct grid_cell *, struct grid_cell *, const char *);
+void	 screen_write_putc(
+	     struct screen_write_ctx *, struct grid_cell *, u_char);
+void	 screen_write_copy(struct screen_write_ctx *,
+	     struct screen *, u_int, u_int, u_int, u_int);
+void	 screen_write_backspace(struct screen_write_ctx *);
+void	 screen_write_mode_set(struct screen_write_ctx *, int);
+void	 screen_write_mode_clear(struct screen_write_ctx *, int);
+void	 screen_write_cursorup(struct screen_write_ctx *, u_int);
+void	 screen_write_cursordown(struct screen_write_ctx *, u_int);
+void	 screen_write_cursorright(struct screen_write_ctx *, u_int);
+void	 screen_write_cursorleft(struct screen_write_ctx *, u_int);
+void	 screen_write_alignmenttest(struct screen_write_ctx *);
+void	 screen_write_insertcharacter(struct screen_write_ctx *, u_int);
+void	 screen_write_deletecharacter(struct screen_write_ctx *, u_int);
+void	 screen_write_clearcharacter(struct screen_write_ctx *, u_int);
+void	 screen_write_insertline(struct screen_write_ctx *, u_int);
+void	 screen_write_deleteline(struct screen_write_ctx *, u_int);
+void	 screen_write_clearline(struct screen_write_ctx *);
+void	 screen_write_clearendofline(struct screen_write_ctx *);
+void	 screen_write_clearstartofline(struct screen_write_ctx *);
+void	 screen_write_cursormove(struct screen_write_ctx *, u_int, u_int);
+void	 screen_write_reverseindex(struct screen_write_ctx *);
+void	 screen_write_scrollregion(struct screen_write_ctx *, u_int, u_int);
+void	 screen_write_linefeed(struct screen_write_ctx *, int);
+void	 screen_write_linefeedscreen(struct screen_write_ctx *, int);
+void	 screen_write_carriagereturn(struct screen_write_ctx *);
+void	 screen_write_clearendofscreen(struct screen_write_ctx *);
+void	 screen_write_clearstartofscreen(struct screen_write_ctx *);
+void	 screen_write_clearscreen(struct screen_write_ctx *);
+void	 screen_write_clearhistory(struct screen_write_ctx *);
+void	 screen_write_cell(struct screen_write_ctx *, const struct grid_cell *);
+void	 screen_write_setselection(struct screen_write_ctx *, u_char *, u_int);
+void	 screen_write_rawstring(struct screen_write_ctx *, u_char *, u_int);
+
+/* screen-redraw.c */
+void	 screen_redraw_screen(struct client *, int, int);
+void	 screen_redraw_pane(struct client *, struct window_pane *);
+
+/* screen.c */
+void	 screen_init(struct screen *, u_int, u_int, u_int);
+void	 screen_reinit(struct screen *);
+void	 screen_free(struct screen *);
+void	 screen_reset_tabs(struct screen *);
+void	 screen_set_cursor_style(struct screen *, u_int);
+void	 screen_set_cursor_colour(struct screen *, const char *);
+void	 screen_set_title(struct screen *, const char *);
+void	 screen_resize(struct screen *, u_int, u_int, int);
+void	 screen_set_selection(struct screen *,
+	     u_int, u_int, u_int, u_int, u_int, struct grid_cell *);
+void	 screen_clear_selection(struct screen *);
+int	 screen_check_selection(struct screen *, u_int, u_int);
+void	 screen_reflow(struct screen *, u_int);
+
+/* window.c */
+extern struct windows windows;
+extern struct window_pane_tree all_window_panes;
+int		 winlink_cmp(struct winlink *, struct winlink *);
+RB_PROTOTYPE(winlinks, winlink, entry, winlink_cmp);
+int		 window_pane_cmp(struct window_pane *, struct window_pane *);
+RB_PROTOTYPE(window_pane_tree, window_pane, tree_entry, window_pane_cmp);
+struct winlink	*winlink_find_by_index(struct winlinks *, int);
+struct winlink	*winlink_find_by_window(struct winlinks *, struct window *);
+struct winlink	*winlink_find_by_window_id(struct winlinks *, u_int);
+int		 winlink_next_index(struct winlinks *, int);
+u_int		 winlink_count(struct winlinks *);
+struct winlink	*winlink_add(struct winlinks *, int);
+void		 winlink_set_window(struct winlink *, struct window *);
+void		 winlink_remove(struct winlinks *, struct winlink *);
+struct winlink	*winlink_next(struct winlink *);
+struct winlink	*winlink_previous(struct winlink *);
+struct winlink	*winlink_next_by_number(struct winlink *, struct session *,
+		     int);
+struct winlink	*winlink_previous_by_number(struct winlink *, struct session *,
+		     int);
+void		 winlink_stack_push(struct winlink_stack *, struct winlink *);
+void		 winlink_stack_remove(struct winlink_stack *, struct winlink *);
+int		 window_index(struct window *, u_int *);
+struct window	*window_find_by_id(u_int);
+struct window	*window_create1(u_int, u_int);
+struct window	*window_create(const char *, const char *, const char *,
+		     const char *, struct environ *, struct termios *,
+		     u_int, u_int, u_int, char **);
+void		 window_destroy(struct window *);
+struct window_pane *window_get_active_at(struct window *, u_int, u_int);
+void		 window_set_active_at(struct window *, u_int, u_int);
+struct window_pane *window_find_string(struct window *, const char *);
+void		 window_set_active_pane(struct window *, struct window_pane *);
+struct window_pane *window_add_pane(struct window *, u_int);
+void		 window_resize(struct window *, u_int, u_int);
+int		 window_zoom(struct window_pane *);
+int		 window_unzoom(struct window *);
+void		 window_remove_pane(struct window *, struct window_pane *);
+struct window_pane *window_pane_at_index(struct window *, u_int);
+struct window_pane *window_pane_next_by_number(struct window *,
+		        struct window_pane *, u_int);
+struct window_pane *window_pane_previous_by_number(struct window *,
+		        struct window_pane *, u_int);
+int		 window_pane_index(struct window_pane *, u_int *);
+u_int		 window_count_panes(struct window *);
+void		 window_destroy_panes(struct window *);
+struct window_pane *window_pane_find_by_id(u_int);
+struct window_pane *window_pane_create(struct window *, u_int, u_int, u_int);
+void		 window_pane_destroy(struct window_pane *);
+void		 window_pane_timer_start(struct window_pane *);
+int		 window_pane_spawn(struct window_pane *, const char *,
+		     const char *, const char *, struct environ *,
+		     struct termios *, char **);
+void		 window_pane_resize(struct window_pane *, u_int, u_int);
+void		 window_pane_alternate_on(struct window_pane *,
+		     struct grid_cell *, int);
+void		 window_pane_alternate_off(struct window_pane *,
+		     struct grid_cell *, int);
+int		 window_pane_set_mode(
+		     struct window_pane *, const struct window_mode *);
+void		 window_pane_reset_mode(struct window_pane *);
+void		 window_pane_key(struct window_pane *, struct session *, int);
+void		 window_pane_mouse(struct window_pane *,
+		     struct session *, struct mouse_event *);
+int		 window_pane_visible(struct window_pane *);
+char		*window_pane_search(
+		     struct window_pane *, const char *, u_int *);
+char		*window_printable_flags(struct session *, struct winlink *);
+struct window_pane *window_pane_find_up(struct window_pane *);
+struct window_pane *window_pane_find_down(struct window_pane *);
+struct window_pane *window_pane_find_left(struct window_pane *);
+struct window_pane *window_pane_find_right(struct window_pane *);
+void		 window_set_name(struct window *, const char *);
+void		 window_remove_ref(struct window *);
+void		 winlink_clear_flags(struct winlink *);
+void		 window_mode_attrs(struct grid_cell *, struct options *);
+
+/* layout.c */
+u_int		 layout_count_cells(struct layout_cell *);
+struct layout_cell *layout_create_cell(struct layout_cell *);
+void		 layout_free_cell(struct layout_cell *);
+void		 layout_print_cell(struct layout_cell *, const char *, u_int);
+void		 layout_destroy_cell(struct layout_cell *, struct layout_cell **);
+void		 layout_set_size(
+		     struct layout_cell *, u_int, u_int, u_int, u_int);
+void		 layout_make_leaf(
+		     struct layout_cell *, struct window_pane *);
+void		 layout_make_node(struct layout_cell *, enum layout_type);
+void		 layout_fix_offsets(struct layout_cell *);
+void		 layout_fix_panes(struct window *, u_int, u_int);
+u_int		 layout_resize_check(struct layout_cell *, enum layout_type);
+void		 layout_resize_adjust(
+		     struct layout_cell *, enum layout_type, int);
+void		 layout_init(struct window *, struct window_pane *);
+void		 layout_free(struct window *);
+void		 layout_resize(struct window *, u_int, u_int);
+void		 layout_resize_pane(struct window_pane *, enum layout_type,
+		     int);
+void		 layout_resize_pane_to(struct window_pane *, enum layout_type,
+		     u_int);
+void		 layout_resize_pane_mouse(struct client *);
+void		 layout_assign_pane(struct layout_cell *, struct window_pane *);
+struct layout_cell *layout_split_pane(
+		     struct window_pane *, enum layout_type, int, int);
+void		 layout_close_pane(struct window_pane *);
+
+/* layout-custom.c */
+char		*layout_dump(struct window *);
+int		 layout_parse(struct window *, const char *);
+
+/* layout-set.c */
+const char	*layout_set_name(u_int);
+int		 layout_set_lookup(const char *);
+u_int		 layout_set_select(struct window *, u_int);
+u_int		 layout_set_next(struct window *);
+u_int		 layout_set_previous(struct window *);
+void		 layout_set_active_changed(struct window *);
+
+/* window-clock.c */
+extern const struct window_mode window_clock_mode;
+
+/* window-copy.c */
+extern const struct window_mode window_copy_mode;
+void		 window_copy_init_from_pane(struct window_pane *);
+void		 window_copy_init_for_output(struct window_pane *);
+void printflike2 window_copy_add(struct window_pane *, const char *, ...);
+void		 window_copy_vadd(struct window_pane *, const char *, va_list);
+void		 window_copy_pageup(struct window_pane *);
+
+/* window-choose.c */
+extern const struct window_mode window_choose_mode;
+void		 window_choose_add(struct window_pane *,
+			 struct window_choose_data *);
+void		 window_choose_ready(struct window_pane *,
+		     u_int, void (*)(struct window_choose_data *));
+struct window_choose_data	*window_choose_data_create (int,
+		     struct client *, struct session *);
+void	window_choose_data_free(struct window_choose_data *);
+void	window_choose_data_run(struct window_choose_data *);
+struct window_choose_data	*window_choose_add_window(struct window_pane *,
+			struct client *, struct session *, struct winlink *,
+			const char *, const char *, u_int);
+struct window_choose_data	*window_choose_add_session(struct window_pane *,
+			struct client *, struct session *, const char *,
+			const char *, u_int);
+struct window_choose_data	*window_choose_add_item(struct window_pane *,
+			struct client *, struct winlink *, const char *,
+			const char *, u_int);
+void	window_choose_expand_all(struct window_pane *);
+
+/* names.c */
+void		 queue_window_name(struct window *);
+char		*default_window_name(struct window *);
+
+/* signal.c */
+void	set_signals(void(*)(int, short, void *));
+void	clear_signals(int);
+
+/* control.c */
+void	control_callback(struct client *, int, void*);
+void printflike2 control_write(struct client *, const char *, ...);
+void	control_write_buffer(struct client *, struct evbuffer *);
+
+/* control-notify.c */
+void	control_notify_input(struct client *, struct window_pane *,
+	    struct evbuffer *);
+void	control_notify_window_layout_changed(struct window *);
+void	control_notify_window_unlinked(struct session *, struct window *);
+void	control_notify_window_linked(struct session *, struct window *);
+void	control_notify_window_renamed(struct window *);
+void	control_notify_attached_session_changed(struct client *);
+void	control_notify_session_renamed(struct session *);
+void	control_notify_session_created(struct session *);
+void	control_notify_session_close(struct session *);
+
+/* session.c */
+extern struct sessions sessions;
+extern struct sessions dead_sessions;
+extern struct session_groups session_groups;
+int	session_cmp(struct session *, struct session *);
+RB_PROTOTYPE(sessions, session, entry, session_cmp);
+int		 session_alive(struct session *);
+struct session	*session_find(const char *);
+struct session	*session_find_by_id(u_int);
+struct session	*session_create(const char *, const char *, const char *,
+		     struct environ *, struct termios *, int, u_int, u_int,
+		     char **);
+void		 session_destroy(struct session *);
+int		 session_check_name(const char *);
+void		 session_update_activity(struct session *);
+struct session	*session_next_session(struct session *);
+struct session	*session_previous_session(struct session *);
+struct winlink	*session_new(struct session *,
+		     const char *, const char *, const char *, int, char **);
+struct winlink	*session_attach(
+		     struct session *, struct window *, int, char **);
+int		 session_detach(struct session *, struct winlink *);
+struct winlink*	 session_has(struct session *, struct window *);
+int		 session_next(struct session *, int);
+int		 session_previous(struct session *, int);
+int		 session_select(struct session *, int);
+int		 session_last(struct session *);
+int		 session_set_current(struct session *, struct winlink *);
+struct session_group *session_group_find(struct session *);
+u_int		 session_group_index(struct session_group *);
+void		 session_group_add(struct session *, struct session *);
+void		 session_group_remove(struct session *);
+void		 session_group_synchronize_to(struct session *);
+void		 session_group_synchronize_from(struct session *);
+void		 session_group_synchronize1(struct session *, struct session *);
+void		 session_renumber_windows(struct session *);
+
+/* utf8.c */
+void	utf8_build(void);
+int	utf8_open(struct utf8_data *, u_char);
+int	utf8_append(struct utf8_data *, u_char);
+u_int	utf8_combine(const struct utf8_data *);
+u_int	utf8_split2(u_int, u_char *);
+
+/* osdep-*.c */
+char		*osdep_get_name(int, char *);
+char		*osdep_get_cwd(int);
+struct event_base *osdep_event_init(void);
+
+/* log.c */
+void		 log_open(int, const char *);
+void		 log_close(void);
+void printflike1 log_warn(const char *, ...);
+void printflike1 log_warnx(const char *, ...);
+void printflike1 log_info(const char *, ...);
+void printflike1 log_debug(const char *, ...);
+void printflike1 log_debug2(const char *, ...);
+__dead void printflike1 log_fatal(const char *, ...);
+__dead void printflike1 log_fatalx(const char *, ...);
+
+/* xmalloc.c */
+char		*xstrdup(const char *);
+void		*xcalloc(size_t, size_t);
+void		*xmalloc(size_t);
+void		*xrealloc(void *, size_t, size_t);
+int printflike2	 xasprintf(char **, const char *, ...);
+int		 xvasprintf(char **, const char *, va_list);
+int printflike3	 xsnprintf(char *, size_t, const char *, ...);
+int		 xvsnprintf(char *, size_t, const char *, va_list);
+
+#endif /* TMUX_H */
-- 
1.8.1.4

