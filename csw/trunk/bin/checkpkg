#!/bin/ksh -p

# checkpkg 1.36 
# This script examines a package that has been put together
# for submittal to the CSW archive at blastwave.org
#
# It examines it for compliance with the packaging standards at
# http://www.blastwave.org/standards/
# It DOES NOT CATCH EVERYTHING. However, the package will be
# tested with this script before acceptance, so you may as well
# save yourself some time, and run the script yourself!
#
# Be sure to occasionally do a "pkg-get update cswutils" so that
# you know you are tracking the most current version.
# 


PATH=$PATH:/usr/sbin

LOCAL_ARCH=`uname -p`

while [[ $# -ne 0 ]]
do
      case $1 in
              -e) WARNING_ERROR=1;;
              *) break;;
      esac
      shift
done


for f in "$@"
do



if [[ ! -f $f ]] ; then
	print ERROR: $f does not exist
	exit 1
fi

print Examining $f

file $f |sed 's/^.*://' |grep gzip >/dev/null
if [ $? -eq 0 ] ; then
	TMPARCHIVE=/tmp/`basename $f`
	if [[ -f $TMPARCHIVE ]] ; then
		print ERROR: $TMPARCHIVE already exists
		
	fi
	gzcat $f >$TMPARCHIVE || exit 1
	f=$TMPARCHIVE
fi

pkgname=`nawk 'NR == 2 {print $1; exit;}' $f`

EXTRACTDIR=/tmp/dissect.$$

if [ -d $EXTRACTDIR ] ; then
	print ERROR: $EXTRACTDIR already exists
	exit 1
fi

mkdir $EXTRACTDIR

TMPFILE=$EXTRACTDIR/pkginfo

dd if=$f skip=1 | (cd $EXTRACTDIR; cpio -ivd $pkgname/pkginfo)
if [[ $? -ne 0 ]] ; then
	print ERROR: could not extract $f
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
fi

mv $EXTRACTDIR/$pkgname/pkginfo $EXTRACTDIR ; rmdir $EXTRACTDIR/$pkgname

software=`sed -n 's/^NAME=\([^ -]*\) -.*$/\1/p' $TMPFILE`
version=`sed -n 's/^VERSION=//p' $TMPFILE`
desc=`sed -n 's/^DESC=//p' $TMPFILE`
email=`sed -n 's/^EMAIL=//p' $TMPFILE`
maintname=`sed -n 's/^VENDOR=.*for CSW by //p' $TMPFILE`
source_url=`sed -n 's/^VENDOR= *\([^ ]*\) .*for CSW by.*/\1/p' $TMPFILE`
hotline=`sed -n 's/^HOTLINE=//p' $TMPFILE`
basedir=`sed -n 's/^BASEDIR=//p' $TMPFILE`
pkgarch=`sed -n 's/^ARCH=//p' $TMPFILE|head -1`

case $software in
     *[A-Z]*)
	echo ERROR: $software must be all lowercase
	exit 1
	;;
esac

case `basename $f` in
	${software}-${version}-*)
		# file name looks okay
	;;
	${software}-*)
		print ERROR: filename missing full version field $version
		rm -rf $EXTRACTDIR $TMPARCHIVE
		 exit 1
	;;
	*)
		print ERROR: filename  should start with $software-$version-
		rm -rf $EXTRACTDIR $TMPARCHIVE
		exit  1
esac


errquit() {
	rm -f $TMPARCHIVE
	print $@
	exit 1
}

if [ "$maintname" = "" ] ; then
	# the old format, in the DESC field
	maintname=`sed -n 's/^DESC=.*for CSW by //p' $TMPFILE`

	# Since the DESC field has been coopted, take
	# description from second half of NAME field now.
	desc=`sed -n 's/^NAME=[^ -]* - //p' $TMPFILE`
else
	if [ "$desc" = "" ] ; then
		desc=`sed -n 's/^NAME=[^ -]* - //p' $TMPFILE`
	fi
fi

rm $TMPFILE

# strip out '' chars, because it interferes with mysql
desc=`print $desc | sed "s/'//g"`


print Info for pkg $pkgname

print software= "'$software'"
print arch= "'$pkgarch'"
print desc="'$desc'"
print pkgname="'$pkgname'"
print version="'$version'"
print maintainer name="'$maintname'"
print maint email="'$email'"
print hotline="'$hotline'"
if [ "$basedir" != "" ] ; then
	print basedir="'$basedir'"
fi

if [[ ${#software} -gt 20 ]] ; then errquit ERROR in $f: software name too long ; fi
if [[ ${#pkgname} -gt 20 ]] ; then errquit ERROR in $f: software name too long ; fi

if [ "$software" = "" ] ; then errquit ERROR in $f: software field not set properly in NAME ; fi
if [ "$pkgname" = "" ] ; then errquit ERROR in $f: pkgname field blank ; fi
if [ "$desc" = "" ] ; then errquit ERROR in $f: no description in either NAME or DESC field ; fi
if [ ${#desc} -gt 100 ] ; then errquit ERROR in $f: description too long ; fi
if [ "$version" = "" ] ; then errquit ERROR in $f: VERSION field blank ;  fi
if [ "$maintname" = "" ] ; then errquit ERROR in $f: maintainer name not detected. Fill out VENDOR field properly ; fi
if [ "$source_url" = "" ] ; then errquit ERROR in $f: source url not detected. Fill out VENDOR field properly ; fi
if [ "$email" = "" ] ; then errquit ERROR in $f: EMAIL field blank ; fi
if [ "$hotline" = "" ] ; then errquit ERROR in $f: HOTLINE field blank ; fi

# Verify if the source url is valid
print ""
print "Testing source url $source_url..."
wget -O /dev/null $source_url
if [[ $? -ne 0 ]]; then
	print "WARNING: $source_url is not a valid url or doesn't point to a valid page"
	if [[ "$WARNING_ERROR" -eq 1 ]]; then
		exit 1
	fi
fi


case $version in
	*-*)
		print ERROR: VERSION field not allowed to have '"-"' in it
		exit 1
	;;
esac

case $pkgarch in
	sparc|i386|all)
	;;
	sparc.*|i386.*)
	;;

	*)
	print ERROR: non-standard ARCH def in package: $pkgarch
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
esac

goodarch=yes
case $f in
	*${LOCAL_ARCH}*)
		
	;;
	*)
		print WARNING: pkg must be for arch $LOCAL_ARCH to check dynamic libs and prototype
                if [[ "$WARNING_ERROR" -eq 1 ]]; then
                                exit 1
		fi
		goodarch=no		
	;;
esac

# This is separated out, because we cant do a continue, in the case statement
if [ "$goodarch" = "no" ] ; then
	# neutral architechture. cant check libraries for it.
	print ""
	rm -rf $EXTRACTDIR $TMPARCHIVE
	continue
fi


# This function exists, because pkgtrans is BROKEN!!
# It leaves a directory in /var/tmp/aaXXXXXXX, even after clean quit
# SO, emulate pkgtrans behaviour, for "pkgtrans src destdir pkgname"
#   Except that we ignore pkgname arg, and just do first one we find.
#  and we are a bit hacky about how we do things.
pkgtrans(){
	if [[ ! -d $2 ]] ; then
		print ERROR: $2 is not a directory >/dev/fd/2
		return 1
	fi
	hdrblks=`(dd if=$1 skip=1 2>/dev/null| cpio -i -t  >/dev/null) 2>&1 |
		nawk '{print $1; exit;}'`

	## print initial hdrblks=$hdrblks

	hdrblks=$(($hdrblks + 1))
	mkdir $2/$3 || return 1

	dd if=$1 skip=$hdrblks 2>/dev/null | (cd $2/$3 ; cpio -ivdm)
	# on fail, SOMETIMES cpio returns 1, but sometimes it returns 0!!
	if [[ ! -d $2/$3/install ]] ; then
		print retrying extract with different archive offset...
		# no, I cant tell in advance why/when the prev fails
		hdrblks=$(($hdrblks + 1))
		dd if=$1 skip=$hdrblks 2>/dev/null| (cd $2/$3 ; cpio -ivdm)
	fi
}

print ""
print Extracing pkg for examination of files...
pkgtrans $f $EXTRACTDIR $pkgname


#############################################################
# We now have the package expanded, in "directory" form, in
# $EXTRACTDIR/$pkgname
# Now do some extended error checking on it.
# This is similar to Debians "Lintian" phase for packages.

/usr/sbin/pkgchk -d $EXTRACTDIR $pkgname || errquit "Package failed integrity check"

print "/usr/sbin/pkgchk passed."


########################################
# Check for some common errors
if [[ $pkgname != "CSWcommon" ]] ; then

	if [[ $LOGNAME != "root" ]] ; then
		nawk '$6 == "'$LOGNAME'" {print; exit 1}' $EXTRACTDIR/$pkgname/pkgmap
		if [[ $? -eq 1 ]] ; then
			print ERROR: files owned by $LOGNAME in prototype file
			rm -rf $EXTRACTDIR $TMPARCHIVE
			exit 1
		fi
	fi

	egrep 'd none /opt ' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print ERROR: You should not have an entry for /opt in your prototype file
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
	fi
	egrep 'd none [^ ]* 06' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print ERROR: You must have execute permission set on directories
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
	fi
	egrep '/opt/csw/man|d none man' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print ERROR: /opt/csw/man should not have a directory entry in prototype
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
	fi
	egrep '/opt/csw/doc|d none doc' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print ERROR: /opt/csw/doc should not have a directory entry in prototype
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
	fi
	egrep '/opt/csw/info|d none info' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print ERROR: /opt/csw/info should not have a directory entry in prototype
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
	fi
	egrep 'lib/charset.alias' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print WARNING: only CSWiconv should have lib/charset.alias in it
        if [[ "$WARNING_ERROR" -eq 1 ]]; then
        exit 1
	fi
	fi
	egrep 'share/locale/locale.alias' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print WARNING: only CSWcommon should have share/locale/locale.alias in it
        if [[ "$WARNING_ERROR" -eq 1 ]]; then
        exit 1
	fi
	fi
	# this is like "installed package info". It is acceptible
	# to update it in a postinstall script, but not have it
	# directly in the pkgmap. A "e" entry might be acceptible though.
	egrep ' f .*/perllocal.pod' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print ERROR: perllocal.pod should be removed from prototype file
	exit 1
	fi
fi
# special case. sigh.
if [[ $pkgname != "CSWtexinfo" ]] ; then
	egrep '/opt/csw/share/info/dir|none share/info/dir' $EXTRACTDIR/$pkgname/pkgmap
	if [[ $? -eq 0 ]] ; then
	print ERROR: /opt/csw/share/info/dir should only be in CSWtexinfo
	rm -rf $EXTRACTDIR $TMPARCHIVE
	exit 1
	fi
fi
#########################################
# find all executables and dynamic libs,and list their filenames.
listbinaries() {
	if [ ! -d $1 ] ; then
		print listbinaries: ERROR: $1 not a directory >/dev/fd/2
		rm -rf $EXTRACTDIR
		exit 1
	fi

	find $1 -print | xargs file |grep ELF |nawk -F: '{print $1}'
}



# man ld.so.1 for more info on this hack
export LD_NOAUXFLTR=1

listbinaries $EXTRACTDIR/$pkgname >$EXTRACTDIR/tmplist
# have to do this for ldd to work. arrg.
if [ -s "$EXTRACTDIR/tmplist" ] ; then
chmod 0755 `cat $EXTRACTDIR/tmplist`

#cat $EXTRACTDIR/tmplist| xargs ldd  2>/dev/null |fgrep  '.so' |
#              sed 's:^.*=>[^/]*::' | nawk '{print $1}' |sort -u >$EXTRACTDIR/liblist

cat $EXTRACTDIR/tmplist| xargs dump -Lv |nawk '$2=="NEEDED"{print $3}' |
		sort -u | egrep -v $EXTRACTDIR >$EXTRACTDIR/liblist

print libraries used are:
cat $EXTRACTDIR/liblist
else
	print no dynamic libraries in the package
fi

#Sometimes, these end up non-existant, which is Bad.
touch $EXTRACTDIR/liblist $EXTRACTDIR/libpkgs

if [[ -f $EXTRACTDIR/$pkgname/install/depend ]] ; then
	print 
	print "Examining dependancies in 'depend' file (May take a while)"
else
	# They may have forgotten to create/add in a depend file
	# remind people what the package depends on
	print "Analysing dynamic dependancies, if any"
	touch $EXTRACTDIR/$pkgname/install/depend
fi


	nawk '$1=="P" {print $2}'  $EXTRACTDIR/$pkgname/install/depend |sort >$EXTRACTDIR/deppkgs
	for dep in `cat $EXTRACTDIR/deppkgs`
	do
		pkginfo $dep || print "ERROR: invalid package $dep specified"
	done

	egrep -v 'SUNWbcp|SUNWowbcp|SUNWucb' /var/sadm/install/contents |
		fgrep -f $EXTRACTDIR/liblist >$EXTRACTDIR/shortcatalog



	for lib in `cat $EXTRACTDIR/liblist` ; do
		grep "[/=]$lib[ =]" $EXTRACTDIR/$pkgname/pkgmap
		if [[ $? -eq 0 ]] ; then
			echo $lib provided by package itself
			continue
		fi

		libpkg=`grep "^[^=]*/$lib[ =]" $EXTRACTDIR/shortcatalog |
		      sed 's/^.* \([^ ]*\)$/\1/' |sort -u`

		if [[ -z "$libpkg" ]] ; then
			print ERROR: cannot find package for $lib
		else
			print $lib $libpkg >>$EXTRACTDIR/libpkgs
		fi
	done
	sort -u $EXTRACTDIR/libpkgs >$EXTRACTDIR/libpkgs.x
	mv $EXTRACTDIR/libpkgs.x $EXTRACTDIR/libpkgs

	while read pkgs; do
		set -- $pkgs
		lib=$1; shift
		found="no"
		if echo $* | egrep "SUNW|SPRO" >/dev/null; then
			file="$EXTRACTDIR/sunpkgs"
		else
			file="$EXTRACTDIR/otherpkgs"
		fi

		for pkg in $*; do
			if grep -w $pkg $EXTRACTDIR/deppkgs >/dev/null; then
				found="yes"
				break;
			fi
		done

		if [[ "$found" != yes ]]; then
			echo "`echo $* | sed -e 's/ / or /g'` (provides $lib)" >> $file
		fi

	done < $EXTRACTDIR/libpkgs

	if [[ -f $EXTRACTDIR/sunpkgs ]]; then
		print
		print SUGGESTION: you may want to add some or all of the following Sun dependancies as depends:
		cat $EXTRACTDIR/sunpkgs
	fi

	if [[ -f $EXTRACTDIR/otherpkgs ]]; then
		print
		print WARNING: the following dependancies are missing in the $f depend file:
		cat $EXTRACTDIR/otherpkgs
                if [[ "$WARNING_ERROR" -eq 1 ]]; then
                                exit 1
		fi
	fi

#listbinaries /tmp/$pkgname

if [[ "$basedir" != "" ]] ; then
	print 
	print "Checking relocation ability..."
	xargs strings <$EXTRACTDIR/tmplist | grep /opt/csw
	if [[ $? -eq 0 ]] ; then
		print ERROR: package build as relocatable, but binaries have hardcoded /opt/csw paths in them
	else
		print trivial check passed
	fi
fi

rm -rf $EXTRACTDIR

if [[ $TMPARCHIVE != "" ]] ; then
	rm $TMPARCHIVE
fi

print ""

done
